#!/usr/bin/env bash
# trunk-ignore-all(shellcheck/SC2103)

# get a cleaned dirname, free from unnecessary fluff, e.g. [/../.] => [/]

function fs_dirname() (
	source "$DOROTHY/sources/bash.bash"

	# =====================================
	# Arguments

	function help {
		cat <<-EOF >&2
			ABOUT:
			Get the expanded cleaned parent path of a <path>.

			USAGE:
			fs-dirname [--] ...<path>

			COMPARISON:
			cd "$HOME"

			[dirname .]               outputs   [.]
			[fs-dirname -- .]         outputs   [/Users]

			[dirname ..]              outputs   [.]
			[fs-dirname -- ..]        outputs   [/]


			[dirname "$HOME"]         outputs   [/Users]
			[fs-dirname -- "$HOME"]   outputs   [/Users]

			fs-link --existing="$HOME" --symlink=./symlinked-directory
			[dirname ./symlinked-directory]     outputs [.]
			[fs-dirname -- ./symlinked-directory]   outputs [/Users]
		EOF
		if [[ $# -ne 0 ]]; then
			__print_error "$@"
		fi
		return 22 # EINVAL 22 Invalid argument
	}

	# process
	local item option_paths=()
	while [[ $# -ne 0 ]]; do
		item="$1"
		shift
		case "$item" in
		'--help' | '-h') help ;;
		'--path='*) option_paths+=("${item#*=}") ;;
		'--')
			option_paths+=("$@")
			shift $#
			break
			;;
		'--'*) help 'An unrecognised flag was provided: ' --variable-value={item} ;;
		*) option_paths+=("$item") ;;
		esac
	done

	# check
	if [[ ${#option_paths[@]} -eq 0 ]]; then
		help 'No <path>s provided.'
	fi

	# =====================================
	# Action

	# use () (...)  as we modify the pwd
	function do_dirname() (
		local path="$1" dirname
		if [[ -z $path || $path == '.' ]]; then
			# handles [fs-dirname] and [fs-dirname .]
			cd ..
			pwd
		elif [[ -d $path ]]; then
			# handles [fs-dirname ..] and [fs-dirname ./..]
			cd "$path"
			cd ..
			pwd
		else
			if [[ $path == */* ]]; then
				__replace --source={path} --target={dirname} --keep-before-last='/'
			else
				dirname='.'
			fi
			if [[ -z $dirname ]]; then
				# we have gone to the root, e.g. [fs-dirname /file]
				__print_lines '/'
			elif [[ -d $dirname ]]; then
				# the path is a file, so go into the parent, using the same technique as earlier methods
				cd "$dirname"
				pwd
			else
				# the path doesn't exist (could be a broken symlink), so just use the inference, if it differs
				if [[ $dirname != "$path" ]]; then
					__print_lines "$dirname"
				else
					# the path doesn't exist, and didn't have a directory component, just the file component
					# however, this should never occur, as we infer paths based on their relativity to the current directory
					__print_error 'Unable to determine the dirname directory for the non-existent path:' $'\n' --code="$path"
					return 1
				fi
			fi
		fi
	)

	local path dirname
	for path in "${option_paths[@]}"; do
		do_dirname "$path"
	done
)

# fire if invoked standalone
if [[ $0 == "${BASH_SOURCE[0]}" ]]; then
	fs_dirname "$@"
fi
