#!/usr/bin/env bash
# trunk-ignore-all(shellcheck/SC2103)

# get a cleaned dirname, free from unnecessary fluff, e.g. [/../.] => [/]

function fs_dirname() (
	source "$DOROTHY/sources/bash.bash"
	dorothy-warnings add --code='fs-dirname' --bold=' has been deprecated in favor of ' --code='fs-path --absolute --parents'

	# =====================================
	# Arguments

	function help {
		local parent_of_home
		parent_of_home="$(fs-path --parents --absolute -- "$HOME")"
		__print_help "$@" <<-EOF || return $?
			ABOUT:
			Get the expanded cleaned parent path of a <path>.

			USAGE:
			\`fs-dirname [--] ...<path>\`

			EXAMPLES:
			\`\`\`cd "$HOME"\`\`\`

			\`\`\`dirname .\`\`\`
			Outputs: \`.\`
			\`\`\`fs-path --parents -- .\`\`\`
			Outputs: \`.\`
			\`\`\`fs-dirname -- .\`\`\`
			Outputs: \`${parent_of_home}\`
			\`\`\`fs-path --absolute --parents -- .\`\`\`
			Outputs: \`${parent_of_home}\`

			\`\`\`dirname ..\`\`\`
			Outputs: \`.\`
			\`\`\`fs-path --parents -- ..\`\`\`
			Outputs: \`.\`
			\`\`\`fs-dirname -- ..\`\`\`
			Outputs: \`/\`
			\`\`\`fs-path --absolute --parents -- ..\`\`\`
			Outputs: \`/\`

			\`\`\`dirname "$HOME"\`\`\`
			Outputs: \`${parent_of_home}\`
			\`\`\`fs-dirname -- "$HOME"\`\`\`
			Outputs: \`${parent_of_home}\`
			\`\`\`fs-path --parents -- "$HOME"\`\`\`
			Outputs: \`${parent_of_home}\`

			\`\`\`cd "$HOME"; fs-link --existing="$HOME" --symlink=./symlinked-directory\`\`\`

			\`\`\`dirname ./symlinked-directory\`\`\`
			Outputs: \`.\`
			\`\`\`fs-dirname -- ./symlinked-directory\`\`\`
			Outputs: \`${parent_of_home}\`
			\`\`\`fs-path --parents -- ./symlinked-directory\`\`\`
			Outputs: \`.\`
			\`\`\`fs-path --parents --absolute -- ./symlinked-directory\`\`\`
			Outputs: \`${parent_of_home}/${USER}\`
			\`\`\`fs-path --parents --follow -- ./symlinked-directory\`\`\`
			Outputs: \`${parent_of_home}\`
		EOF
		return 22 # EINVAL 22 Invalid argument
	}

	# process
	local item option_paths=()
	while [[ $# -ne 0 ]]; do
		item="$1"
		shift
		case "$item" in
		'--help' | '-h') help ;;
		'--path='*) option_paths+=("${item#*=}") ;;
		'--')
			option_paths+=("$@")
			shift $#
			break
			;;
		'--'*) help 'An unrecognised flag was provided: ' --variable-value={item} ;;
		*) option_paths+=("$item") ;;
		esac
	done

	# check
	if [[ ${#option_paths[@]} -eq 0 ]]; then
		help --help='No <path>s provided.'
	fi

	# =====================================
	# Action

	# use () (...)  as we modify the pwd
	function do_dirname() (
		local path="$1" dirname
		if [[ -z $path || $path == '.' ]]; then
			# handles `fs-dirname` and `fs-dirname .`
			cd ..
			pwd
		elif [[ -d $path ]]; then
			# handles `fs-dirname ..` and `fs-dirname ./..`
			cd "$path"
			cd ..
			pwd
		else
			if [[ $path == */* ]]; then
				__replace --source={path} --target={dirname} --keep-before-last='/'
			else
				dirname='.'
			fi
			if [[ -z $dirname ]]; then
				# we have gone to the root, e.g. `fs-dirname /file`
				__print_lines '/'
			elif [[ -d $dirname ]]; then
				# the path is a file, so go into the parent, using the same technique as earlier methods
				cd "$dirname"
				pwd
			else
				# the path doesn't exist (could be a broken symlink), so just use the inference, if it differs
				if [[ $dirname != "$path" ]]; then
					__print_lines "$dirname"
				else
					# the path doesn't exist, and didn't have a directory component, just the file component
					# however, this should never occur, as we infer paths based on their relativity to the current directory
					__print_error 'Unable to determine the dirname directory for the non-existent path:' $'\n' --code="$path"
					return 1
				fi
			fi
		fi
	)

	local path dirname
	for path in "${option_paths[@]}"; do
		do_dirname "$path"
	done
)

# fire if invoked standalone
if [[ $0 == "${BASH_SOURCE[0]}" ]]; then
	fs_dirname "$@"
fi
