#!/usr/bin/env bash
# ^ using `bash` will cause `shfmt` to fail, as this is `bash` and `zsh` compatible but not compatible with `sh`
# `bash` and `zsh` run this natively, both support arrays, `zsh` does require $ prefix for var indexes

TITLE_START=$'\e]0;'
TITLE_END=$'\a'
NEWLINE=$'\n'
SHELL_START_INDEX=0 # zsh and bash have different start indexes

# NOTE THAT ANSI ESCAPE SEQUENCES MUST BE ESCAPED IF WITHIN PS1
# FURTHERMORE PS1 SUPPORTS SHORTCUTS
# https://www.gnu.org/software/bash/manual/bash.html#Controlling-the-Prompt
if [[ ${TERM-} == 'xterm-ghostty' ]]; then
	PROMPT_LINE_COLORS_SUPPORTED='yes'
else
	PROMPT_LINE_COLORS_SUPPORTED='no'
fi
__does_shell_support_prompt_line_colors() {
	local shell="$1"
	if [[ $PROMPT_LINE_COLORS_SUPPORTED != 'yes' ]]; then
		return 1
	fi
	if [[ $shell == 'bash' ]]; then
		return 0
	fi
	# zsh does not support
	return 1
}

if [[ -n ${BASH_VERSION-} ]]; then
	__command_exists() {
		type -P "$1" >/dev/null 2>&1 || return $?
	}
else
	__command_exists() {
		command -v "$1" >/dev/null 2>&1 || return $?
	}
fi
if __command_exists sudo; then
	__is_authenticated() {
		sudo --non-interactive -- true >/dev/null 2>&1 || return $?
	}
elif __command_exists doas; then
	__is_authenticated() {
		doas -n true >/dev/null 2>&1 || return $?
	}
else
	__is_authenticated() {
		return 1 # no sudo or doas, so we are not authenticated
	}
fi

# improve performance of time fetching on bash versions that support it, >=4.2
if [[ -n ${BASH_VERSION-} && ${BASH_VERSINFO[0]} -gt 4 || (${BASH_VERSINFO[0]} -eq 4 && ${BASH_VERSINFO[1]} -ge 2) ]]; then
	# this is instant
	__get_time() {
		printf '%(%H:%M:%S)T' || return $?
	}
else
	# this is slow
	__get_time() {
		date '+%H:%M:%S' || return $?
	}
fi

# theme
oztheme() {
	local shell="$1" last_command_exit_status="$2"

	# handle invisible characters in prompt
	local prompt_line_colors a z
	if __does_shell_support_prompt_line_colors "$shell"; then
		prompt_line_colors='yes'
		a='\['
		z='\]'
	else
		prompt_line_colors='no'
		a=''
		z=''
	fi

	# handle colors
	local reset="$a"$'\e[0m'"$z" italic="$a"$'\e[3m'"$z" red="$a"$'\e[31m'"$z" green="$a"$'\e[32m'"$z" yellow="$a"$'\e[33m'"$z" blue="$a"$'\e[34m'"$z" magenta="$a"$'\e[35m'"$z" cyan="$a"$'\e[36m'"$z" white="$a"$'\e[37m'"$z" intense_white="$a"$'\e[97m'"$z" background_red="$a"$'\e[41m'"$z"
	local separator="${white}:${reset}" prompt_segments=() prompt='' title_segments=() title='' yay_color_suffix nay_color_suffix suffix

	# LAST COMMAND EXIT STATUS
	if [[ $last_command_exit_status -ne 0 ]]; then
		prompt_segments+=("${red}[${last_command_exit_status}]")
	fi

	# AUTHENTICATION
	local authenticated=''
	if [[ -n ${SUDO_USER-} && $SUDO_USER != "$USER" ]]; then
		# after much experimentation, we don't actually care for adding the login user to the prompt, we only care about showing the active user
		# https://unix.stackexchange.com/a/362773
		nay_color_suffix="${USER} "
		if [[ $USER == 'root' ]]; then
			yay_color_suffix="${background_red}${intense_white}${USER}${reset} "
			authenticated='yes'
		else
			yay_color_suffix="${magenta}${italic}${USER}${reset} "
		fi
		title_segments+=("${USER}")
	fi
	if [[ $authenticated == 'yes' ]] || __is_authenticated; then
		yay_color_suffix+="${red}#${reset} "
		nay_color_suffix+="# "
	else
		yay_color_suffix+='$ '
		nay_color_suffix+='$ '
	fi
	if [[ $prompt_line_colors == 'yes' ]]; then
		suffix="$yay_color_suffix"
	else
		suffix="$nay_color_suffix"
	fi

	# TIME SEGMENT
	if [[ $shell == 'bash' ]]; then
		# https://www.gnu.org/software/bash/manual/bash.html#Controlling-the-Prompt
		prompt_segments+=("${green}\t")
	else
		local time
		time="$(__get_time || :)"
		if [[ -n $time ]]; then
			prompt_segments+=("${green}${time}")
		fi
	fi

	# SUDO, SSH, HOSTNAME
	if [[ -n ${SSH_CONNECTION-} || -n ${SSH_CLIENT-} || -n ${SSH_TTY-} ]]; then
		prompt_segments+=("${cyan}${SUDO_USER:-"$USER"}${blue}@${HOSTNAME}")
		title_segments+=("${SUDO_USER:-"$USER"}@${HOSTNAME}")
	fi

	# PATH SEGMENT
	local target="${PWD/HOME/~}"
	if [[ -n $target ]]; then
		prompt_segments+=("${yellow}${target}")
		title_segments+=("${target}")
	fi

	# GIT BRANCH
	# note that if you are running as another user, this will fail with: fatal: detected dubious ownership in repository at ...
	local git_branch
	git_branch="$(git rev-parse --abbrev-ref HEAD 2>/dev/null || :)"
	git_branch="${git_branch/* /}" # [* master] to [master]
	if [[ -n $git_branch ]]; then
		if git diff --quiet >/dev/null 2>&1; then
			prompt_segments+=("${cyan}${git_branch}")
		else
			prompt_segments+=("${red}${git_branch}")
		fi
	fi

	# compose the segments
	local i n
	for ((i = SHELL_START_INDEX, n = ${#prompt_segments[@]} + SHELL_START_INDEX; i < n; i++)); do
		prompt+="${separator}${prompt_segments[i]}${reset}"
	done
	for ((i = SHELL_START_INDEX, n = ${#title_segments[@]} + SHELL_START_INDEX; i < n; i++)); do
		title+=":${title_segments[i]}"
	done

	# removing separator prefix in a format compatible with bash, zsh, and shfmt
	prompt="${prompt#*"$separator"}"
	title="${title:1}"

	# adjust for shell
	if [[ $shell == 'bash' ]]; then
		# sourced, unsure why PS1 and title are separate
		PS1="${prompt}${NEWLINE}${suffix}"
		if [[ -n $title ]]; then
			printf '%s' "${TITLE_START}${title}${TITLE_END}"
		fi
	elif [[ $shell == 'zsh' ]]; then
		# sourced, and for some reason assigning PS1 here doesn't work
		local message="${prompt}${NEWLINE}${suffix}"
		if [[ -n $title ]]; then
			message+="${TITLE_START}${title}${TITLE_END}"
		fi
		printf '%s' "$message"
	else
		# run via command, unsure where there is no title
		printf '%s' "${prompt}${NEWLINE}${suffix}"
	fi
}

# fire if invoked standalone
if [[ $0 == "${BASH_SOURCE[0]}" ]]; then
	# invoked
	oztheme "$@"
elif [[ -n $BASH_VERSION ]]; then
	# sourced in bash
	PROMPT_COMMAND='oztheme bash $?'
elif [[ -n $ZSH_VERSION ]]; then
	# sourced in zsh
	SHELL_START_INDEX=1
	# trunk-ignore(shellcheck/SC2034)
	PS1='' PROMPT=''
	# @todo apparently `export DISABLE_AUTO_TITLE='true'` may be necessary with `oh-my-zsh` however I don't use it so I don't know
	precmd() {
		PS1="$(oztheme zsh "$?")"
	}
fi
