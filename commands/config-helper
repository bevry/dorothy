#!/usr/bin/env bash
source "$DOROTHY/sources/strict.bash"
source "$DOROTHY/sources/arrays.bash"
requires_array_support 'mapfile'

# test
if is-needle '--test' "$@"; then
	(
		# prepare
		echo-segment --h1="TEST: $0"
		echo
		file="$(mktemp)"

		# test invalid arguments fail
		eval-tester --ec=22 -- config-helper --file="$file"
		eval-tester --ec=22 -- config-helper --file="$file" --replace='one'
		eval-tester --ec=22 -- config-helper --file="$file" --find='one' --replace='one' --replace='two'
		eval-tester --ec=22 -- config-helper --file="$file" --find='one' --find='two' --replace='one'

		# test an empty file
		eval-tester -- config-helper --file="$file" \
			--find='commands.local/' --replace='commands.local/' \
			--find='config.local/' --replace='config.local/'
		eval-tester --stdout=$'commands.local/\nconfig.local/' -- cat "$file"

		# test a file that as results
		eval-tester -- config-helper --file="$file" \
			--find='commands.local/' --replace='commands.replaced/' \
			--find='config.local/' --replace='config.replaced/'
		eval-tester --stdout=$'##commands.local/\ncommands.replaced/\n##config.local/\nconfig.replaced/' -- cat "$file"

		# test find only, used by <sharebox> commandd
		# this is only for fetching config values, not for fetching lines, so the .gitignore style stuff isn't for this
		echo $'User=uu\nGroup=gg\n# Party=pp' >>"$file"
		eval-tester --stdout='uu' -- \
			config-helper --file="$file" --find='User=(.*)'
		eval-tester --stdout=$'uu\ngg' -- \
			config-helper --file="$file" --find='User=(.*)' --find='Group=(.*)'
		eval-tester --stdout=$'uu\ngg' -- \
			config-helper --file="$file" --find='User' --find='Group' --find='Party'

		# done
		echo-segment --g1="TEST: $0"
	)
	exit "$?"
fi

# dependencies
source "$DOROTHY/sources/ripgrep.bash"

# e.g.
# /etc/systemd/resolved.conf
# shell.sh
# .gitignore
file="$(get-flag-value file -- "$@")"

# e.g.
# Domains=
# DOROTHY_THEME=
# config.local/
mapfile -t find_array < <(get-flag-value find --multi -- "$@")
find_count="${#find_array[@]}"
if test "$find_count" -eq 0; then
	stderr echo-color \
		--error="$0 $*" $'\n' \
		--red="At least one [--find=...] argument must be provided."
	exit 22 # Invalid argument
fi

# e.g.
# Domains=~.
# DOROTHY_THEME=oz
# config.local/
mapfile -t replace_array < <(get-flag-value replace --multi -- "$@")
replace_count="${#replace_array[@]}"
if test "$replace_count" -eq 0; then
	# we are find only
	for find in "${find_array[@]}"; do
		pattern="^[ 	]*($find)=?(.*)$"
		# ^ with indentation but no comment (so we only get real values), and with value group so that $2 is consistent with overrides
		rg -o "$pattern" --replace '$2' "$file" || :
		# ^ don't fail on no results
	done
	exit
fi

# we are a replacement
# goal: replace all uncommented instances with a single set instance, after the first comment or at the end

# check we have the same finds as replaces
if test "$replace_count" -ne "$find_count"; then
	stderr echo-color \
		--error="$0 $*" $'\n' \
		--red="the amount of [--find=...] arguments must match the amount of [--replace=...] arguments."
	exit 22 # Invalid argument
fi

# prepare the file
touch "$file"
mapfile -t lines <"$file"

# cycle through each find and replace pair
for find_index in "${!find_array[@]}"; do
	# prepare
	find="${find_array[find_index]}"
	replace="${replace_array[find_index]}"
	pattern="^([ 	]*)[# 	]*($find)$" # with indentation, with comment
	found='no'
	stack=()
	results=()

	# cycle through the lines
	# `test ... && for ...` is for bash v3 compatibility
	test "${#lines[@]}" -ne 0 && for line in "${lines[@]}"; do
		# check if the lines matches the pattern
		if prefix="$(rg -qo "$pattern" --replace '$1' <<<"$line")"; then
			# if not found, add the replacement line to the stack, to be added when we get back to normal lines
			if test "$found" = 'no'; then
				stack+=(
					"${prefix}${replace}"
				)
				found='yes'
			fi

			# get existing line, minus comment prefix
			comment="$(rg -o "$pattern" --replace '$2' <<<"$line")"

			# only add the comment, if it is different from the result
			if test "$comment" != "${replace}"; then
				# use ## so it is easy to see where the replacements were
				results+=(
					"${prefix}##${comment}"
				)
			fi
		else
			# not a match, so ordinary line

			# empty the stack
			if test "${#stack[@]}" -ne 0; then
				results+=("${stack[@]}")
				stack=()
			fi

			# and append
			results+=("$line")
		fi
	done

	# empty the stack
	if test "${#stack[@]}" -ne 0; then
		results+=("${stack[@]}")
		stack=()
	fi

	# append replacement if it was never found
	if test "$found" = 'no'; then
		results+=("$replace")
	fi

	# replace the lines with the results, and move onto the next combo
	lines=("${results[@]}")
done

# write the updated file
echo-lines "${results[@]}" >"$file"
