#!/usr/bin/env bash

function fs_mv() (
	source "$DOROTHY/sources/bash.bash"

	# =====================================
	# Arguments

	# @todo this is getting too complicated, just do the features we need right now

	function help {
		cat <<-EOF >&2
			ABOUT:
			Relocate all <source>s to the <destination>.
			Unlike [mv] which is ambiguous as to whether it places at or within, [fs-mv] is configurable via options and will prompt if unconfigured.

			USAGE:
			fs-mv [...options] [--] [...<source>] <destination>

			OPTIONS:
			...<source>
			    The <source>s to relocate to or into or as the <destination>.
			<destination>
			    The <destination> to relocate the <source>s to or into or as.

			--within
			    If provided, place the <source> inside the <target>. Same as calling [fs-mv <source> <destination/source>].
				Implied if the <destination> has a trailing slash. If --no-within, a trailing slash will be discarded.
				Implied if there are multiple <sources>. If --no-within, only the last existing <source> will be used.
			    Not yet implemented.
			--merge=[shallow|deep]
			    If provided, if the <source> is a directory <source> it will have its contents placed inside <destination>, if <source> is a file, it will be moved inside the <destination>.
			    If the <destination> does not exist, it will be created as a directory.
			    If the <destination> is a file, unless [--replace] or [--rename] is provided, you will be prompted.
			    Not yet implemented.
			--overwrite
			    If provided, if a <destination> item already exists, it will be replaced by the incoming <source> item.
			    Cannot be used alongside [--rename].
			    Not yet implemented.
			--rename=[source|target]
			    If provided, if a <destination> item already exists, the incoming <source> item will be renamed (appending the current timestamp) to avoid conflicts.
			    Cannot be used alongside [--replace].
			    Not yet implemented.
			--amalgamate
			    If provided, discard a <source> item if it is equivalent to its <destination> item.
			    Not yet implemented.

			--symlink
			    If provided, each <source> will be persisted afterwards as a symlink to the <destination>.
			--absolute | --relative
			    If provided, forces the <source> symlinks to <destination> to be absolute or relative.
			    By default, this is determined by whether or not the <destination> was absolute or relative.
			--resolve
			    If provided, each and every <source> and <destination> symlink source and destination will be added as additional <source>s.
			--follow
			    If provided, the <destination> will become the <destination> symlink target if so.


			--elevated=<elevated>
			--elevate=<elevate>
			--user=<user>
			--group=<group>
			--reason=<reason>
			    Forwarded to [eval-helper].
		EOF
		if [[ $# -ne 0 ]]; then
			__print_error "$@"
		fi
		return 22 # EINVAL 22 Invalid argument
	}

	# process
	# option_within='' option_merge='' option_overwrite='' option_rename='' option_amalgamate=''
	local item option_quiet='' option_paths=() \
	option_symlink='' option_absolute='' option_resolve='' option_follow='' \
	option_elevated='' option_elevate='' option_user='' option_group='' option_reason=''
	while [[ $# -ne 0 ]]; do
		item="$1"
		shift
		case "$item" in
		'--help' | '-h') help ;;
		'--no-verbose'* | '--verbose'*) __flag --source={item} --target={option_quiet} --non-affirmative ;;
		'--no-quiet'* | '--quiet'*) __flag --source={item} --target={option_quiet} --affirmative ;;
		'--no-within'* | '--within'*) help 'The --within option is not yet implemented.' ;;
		'--no-merge'* | '--merge'*) help 'The --merge option is not yet implemented.' ;;
		'--no-overwrite'* | '--overwrite'*) help 'The --overwrite option is not yet implemented.' ;;
		'--no-rename'* | '--rename'*) help 'The --rename option is not yet implemented.' ;;
		'--no-amalgamate'* | '--amalgamate'*) help 'The --amalgamate option is not yet implemented.' ;;
		'--no-symlink'* | '--symlink'*)
			__flag --source={item} --target={option_symlink} --affirmative
			if [[ $option_symlink == 'all' ]]; then
				help 'The --symlink=all option is not yet implemented.'
			elif ! [[ -z $option_symlink || $option_symlink =~ ^(yes|no)$ ]]; then # bash 3.2 doesn't support ^(yes|no|)$
				help "An unrecognised value was provided for --symlink: $option_symlink"
			fi
			;;
		'--no-absolute'* | '--absolute'*) __flag --source={item} --target={option_absolute} --affirmative ;;
		'--no-relative'* | '--relative'*) __flag --source={item} --target={option_absolute} --non-affirmative ;;
		'--no-resolve'* | '--resolve'*) __flag --source={item} --target={option_resolve} --affirmative ;;
		'--no-follow'* | '--follow'*) __flag --source={item} --target={option_follow} --affirmative ;;
		# <elevate>
		'--elevated='*) option_elevated="${item#*=}" ;;
		'--no-elevate'* | '--elevate'*) __flag --source={item} --target={option_elevate} --affirmative ;;
		'--user='*) option_user="${item#*=}" ;;
		'--group='*) option_group="${item#*=}" ;;
		'--reason='*) option_reason="${item#*=}" ;;
		# </elevate>
		'--')
			option_paths+=("$@")
			shift $#
			break
			;;
		'--'*) help "An unrecognised flag was provided: $item" ;;
		*) option_paths+=("$item") ;;
		esac
	done

	# =====================================
	# Helpers

	local elevation_args=(--elevated="$option_elevated" --elevate="$option_elevate" --user="$option_user" --group="$option_group" --reason="$option_reason")

	function __wrap {
		eval-helper "${elevation_args[@]}" -- "$@" || return
	}

	# =====================================
	# Action

	# check
	if [[ ${#option_paths[@]} -lt 2 ]]; then
		help 'There must at least be a <source> and <destination> provided.'
	fi

	# determine the destination
	local destination
	__at --source={option_paths} --target={destination} -- -1

	# determine destination relative or absolute
	if [[ -z $option_absolute ]]; then
		if [[ $destination == /* ]]; then
			option_absolute=yes
		else
			option_absolute='no'
		fi
	fi

	# expand the destination?
	if [[ $option_follow == 'yes' ]]; then
		destination="$(fs-path "${elevation_args[@]}" --absolute --resolve --follow -- "$destination")"
	else
		destination="$(fs-path "${elevation_args[@]}" --absolute --no-resolve --no-follow -- "$destination")"
	fi

	# determine the sources
	local sources=() destination path
	if [[ $option_resolve == 'yes' ]]; then
		for path in "${option_paths[@]}"; do
			__affirm_value_is_defined "$path" '<path>' || return
			# add the path to the sources
			path="$(fs-path "${elevation_args[@]}" --absolute --no-resolve --no-follow -- "$path")"
			sources+=("$path")
			# resolve the path if it is a symlink
			while is-symlink "${elevation_args[@]}" -- "$path"; do
				path="$(fs-path "${elevation_args[@]}" --absolute --resolve --no-follow -- "$path")"
				# add the resolved symlink to the sources
				sources+=("$path")
			done
		done
	else
		for path in "${option_paths[@]}"; do
			__affirm_value_is_defined "$path" '<path>' || return
			# add the path to the sources
			path="$(fs-path "${elevation_args[@]}" --absolute --no-resolve --no-follow -- "$path")"
			sources+=("$path")
		done
	fi

	# ensure sources are unique, and do not contain the destination
	__unique --source+target={sources}
	__evict --source+target={sources} --every --optional -- "$destination"

	# if there are no sources remaining, then the sources were only the destination, which is a problem
	if [[ ${#sources[@]} -eq 0 ]]; then
		if [[ $option_quiet == 'no' ]]; then
			__print_style --stderr --notice='Nothing to move, as the <source>s were only the <destination>:' ' ' --path="$destination"
			return 0
		fi
	fi

	# move all sources to the destination
	local source
	function __fail {
		__print_style --stderr --notice='Something went wrong when relocating paths to their correct location. Please remove one of these to try again:' --newline --code="$source" --newline --code="$destination" || :
		return 17 # EEXIST 17 File exists
	}
	for source in "${sources[@]}"; do
		if [[ $option_symlink == 'yes' ]]; then
			fs-link "${elevation_args[@]}" --quiet="$option_quiet" --symlink="$source" --target="$destination" --absolute="$option_absolute"
		elif is-symlink "${elevation_args[@]}" -- "$source"; then
			fs-rm "${elevation_args[@]}" --quiet="$option_quiet" --no-confirm -- "$source"
		elif is-present "${elevation_args[@]}" -- "$source"; then
			# if the destination exists, trim both the source and destination to avoid merge failures
			# this is done for the destination here as prior moves could result in new trim-able destination contents
			if is-present "${elevation_args[@]}" -- "$destination"; then
				fs-trim "${elevation_args[@]}" --quiet="$option_quiet" --no-confirm --empty --cache -- "$source" "$destination"
				# if source doesn't exist anymore, we are done, as there is nothing left to relocate
				if is-missing "${elevation_args[@]}" -- "$source"; then
					continue
				fi
			else
				# nothing exists at the location, ensure its parent path at least exists
				__wrap mkdir -p -- "$(fs-path --parents -- "$destination")" >&2
			fi
			# merge the source into the destination
			if [[ $option_quiet == 'yes' ]]; then
				__wrap mv -f -- "$source" "$destination" || __fail
			else
				__wrap mv -fv -- "$source" "$destination" || __fail
			fi
		fi
	done
)

# fire if invoked standalone
if [[ $0 == "${BASH_SOURCE[0]}" ]]; then
	fs_mv "$@"
fi
