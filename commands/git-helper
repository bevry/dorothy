#!/usr/bin/env bash

function git_helper_test() (
	source "$DOROTHY/sources/bash.bash"

	# @todo add tests
	__print_style --notice='No tests have been implemented for git-helper yet.' || :
	return 0
)
function git_helper() (
	source "$DOROTHY/sources/bash.bash"

	# =====================================
	# Arguments
	function help {
		__print_help "$@" <<-EOF || return
			ABOUT:
			Helpers for working with git repositories.

			USAGE:
			\`git-helper [...options] <action> [--] [...args]\`

			OPTIONS:
			--path=<path> | --no-path
			    If <path> provided, use <path> for the repository.
			    If <path> omitted, use the current working directory for the repository.
			    If disabled, use a temporary directory for the git repository.
			--label=<label>
			    If <label> provided, refer to the repository as <label> in any messaging.

			ACTIONS:
			authors
			    Output all authors (contributors) within this git repository.
			emails
			    Output all author emails within this git repository.
			update-author --old=<old-email> --new=<new-email> --name=<new-name>
			    Update an author's name and email.

			branch [...arguments]
			    Select a branch from the repository.
			    --remote=<remote> | --[no-]remote
			    --branch=<branch> | --[no-]branch
			    --[no-]check
			    --[no-]verify
			    --[no-]active
			    --[no-]default
			    --[no-]local
			    --[no-]global
			    --[no-]env
			    --[no-]usual
			current-branch [...arguments]
			    Alias of \`branch\` action with arguments that fetch the current branch.
			default-branch [...arguments]
			    Alias of \`branch\` action with arguments that fetch the default branch.

			commit --hash=<hash>|--first [...arguments]
			    Select a commit from the repository.
			    --hash=<hash> | --first
			        If <hash> provided, select this commit hash.
			        If <first> provided, select the first commit.
			    --url
			        If enabled, output the commit URL.
			    --log
			        If enabled, output the commit log of the <hash>.
			first-commit-hash [...arguments]
			    Alias of \`commit --first --hash [...arguments]\`
			first-commit-url [...arguments]
			    Alias of \`commit --first --url [...arguments]\`

			file --file=<file> [...arguments]
			    Select a file from the repository.
			    --[no-]check
			    --[no-]local
			    --remote=<remote> | --[no-]remote
			    --branch=<branch> | --[no-]branch
			has-file [...arguments]
			    Alias for \`file [...arguments]\` action with arguments that check if the file exists.
			has-remote-file [...arguments]
			    Alias for \`file [...arguments]\` action with arguments that check if the remote file exists.
			get-remote-file [...arguments]
			    Alias for \`file [...arguments]\` action with arguments that fetch the remote file contents.

			is-dorothy [...arguments]
			    Alias for \`file [...arguments]\` action with arguments that check if the repository is a Dorothy repository.
			strongbox|get-strongbox [...arguments]
			    Alias for \`file [...arguments]\` action with arguments that fetch the strongbox configuration file if it exists.
			is-strongbox [...arguments]
			    Alias for \`file [...arguments]\` action with arguments that check if the repository contains configuration to encrypt files with Strongbox.

			protocol [...arguments]
			    Get or prompt the protocol to use for the repository.
			    --protocol=<protocol:ssh|https>
			        Get the <protocol> to use. If no <protocol> is provided, then prompt an available protocol.
			    --[no-]test
			        If enabled, only permit SSH if SSH can successfully connect to GitHub.

			remotes
			    Output each git remote on a newline, same as \`git remote\` but with verbose repository checks.

			remote [...arguments]
			    Get, apply, or check the <url> or <remote> in <protocol>.
			    If neither <url> and <remote> are provided, then <mode:get|apply|check> and prompt for the <remote>.
			    If only <url> is provided, then <mode:get> the <url> in the <protocol>.
			    If only <remote> is provided, then <mode:get|check|apply> and default <url> to the <remote>'s URL in <protocol>.
			    If both <url> and <remote> are provided, then <mode:get|check|apply> the <remote>'s URL against <url> in <protocol>.
			    --mode=<mode:get|apply|check> | --get|--apply|--check
			        The <mode> of operation. Defaults to <mode:get>.
			    --protocol=<protocol:ssh|https> | --[no-]protocol
			        The <protocol> to format the <url> in.
			        If no <protocol> is provided nor configured, then prompt from an available protocol.
			        If disabled, do not adjust <url> to the protocol.
			    --remote=<remote>
			        If provided with <url>, <mode:apply|check> the <remote>'s URL to <url>, or <mode:get> get <url> in <protocol> and ignore <remote>.
			        If provided without <url>, default <url> to the <remote>'s URL.
			    --url=<url>
			        If provided with <remote>, <mode:apply|check> the <remote>'s URL to <url>.
			        If provided with <mode:get>, then <url> in the <protocol>.
			    --result=<result:url|remote> | --[no-]result
			        What to return.
			        If not provided, then defaults to disabled with <mode:check>, otherwise defaults to <result:remote>.
			    --[no-]verify
			        If enabled, verify the applied <remote>'s URL matches the <url>.
			        Will default to enabled if <remote> and <url> is provided with <mode:apply|check>.
			    --[no-]test
			        If enabled, test the connection to <remote>.
			        Will default to enabled if <remote> and <url> is provided with <mode:apply>.
			url [...arguuments]
			    Alias for \`remote --result=url [...arguments]\`

			verify
			    Verify the <path> contains an initialised git repository.
			github-slug
			    Output the github slug for this repository.
			is-shallow
			    Is the repository a shallow clone?

			sync [...arguments]
			    Sync the git repository at <path> with its remote.
			    STDOUT will be either: \`failure\`, \`current\`, or \`updated\`.
			    --remote=<remote>
			        If provided, use this <remote> instead of the repository's or git's default.
			    --url=<url>
			        If provided, then configure and sync the remote to this <url>.
			    --branch=<branch>
			        If provided, sync with this branch, instead of the current branch, or if indeterminate, the default branch.
			    --[no-]new [...arguments]
			        If enabled, create the hosted repository if it doesn't exist.
			        --name=<name>
			            If provided, elect this <name> for the created repository.
			        --description=<description>
			            If provided, elect this <description> for the created repository.
			    --[no-]init
			        If enabled, initialise the repository if not already initialised.
			        If disabled or omitted, will not initialise.
			    --[no-]update|--update=optional
			        If enabled or omitted, then will update repository, and fail unable.
			        If \`optional\`, then will update the repository, but will ignore update failures.
			        If disabled, then will not update.
			new [...arguments]
			    Alias for \`sync --new --no-init --no-update [...arguments]\`
				Only creates the remote hosted repository, does not bind it locally.
			create [...arguments]
			    Alias for \`sync --new --init --update=optional [...arguments]\`
			    Creates the remote hosted repository, binds it locally.
			init [...arguments]
			    Alias for \`sync --no-new --init --no-update [...arguments]\`
			    Only initialize the <path> as a git repository.
			clone [...arguments]
			    Alias for \`sync --no-new --init --update [...arguments]\`
			    Ensure the <path> is a git repository and update it.
			fetch|pull|update [...arguments]
			    Alias for \`sync --no-new --no-init --update [...arguments]\`
			    Ensure an existing <path> repository is updated.

			review [...arguments]
			    Open the git repository in your desired git reviewer. Supports: \`GitFox\`, \`Tower\`
			    ...<argument>
			        Forwarded to the reviewer.
			unstage [...arguments]
			    Unstage the staged changes, without deleting or removing anything.
			    ...<argument>
			        Forwarded to \`git reset HEAD ...<argument>\`
			wipe
			    Wipe the current working directory to the state of the last commit. There will be a confirmation.
			umt | upstream-modification-times
			    Update the modification times of cloned files to that of their commits, rather than the time of cloning.
		EOF
		return 22 # EINVAL 22 Invalid argument
	}

	# process
	local item action='' option_path='' option_label='' option_args=() # option_quiet='no'
	while [[ $# -ne 0 ]]; do
		item="$1"
		shift
		case "$item" in
		--help | -h) help ;;
		--no-color* | --color*) __flag --source={item} --target={COLOR} --affirmative --export || return ;;
		# --no-verbose* | --verbose*) __flag --source={item} --target={option_quiet} --non-affirmative --coerce || return ;;
		# --no-quiet* | --quiet*) __flag --source={item} --target={option_quiet} --affirmative --coerce || return ;;
		--path=*) option_path="${item#*=}" ;;
		--no-path) option_path="$(fs-temp --cache --directory='dorothy' --directory='git-helper' --directory)" || return ;;
		--label=*) option_label="${item#*=}" ;;
		--)
			option_args+=("$@")
			shift "$#"
			break
			;;
		--*) option_args+=("$item") ;;
		*)
			if [[ -z $action ]]; then
				action="$item"
			else
				option_args+=("$item")
			fi
			;;
		esac
	done

	# label
	if [[ -z $option_label ]]; then
		option_label='repository'
	fi

	# check
	if [[ -z $action ]]; then
		help 'No ' --code='<action>' ' was provided.'
	fi

	# @todo use the eval-helper flow to auto-elevate and store if elevation is needed for use with the git calls
	# ensure path, and verify
	if [[ -z $option_path ]]; then
		option_path="$(pwd)" || return
	elif [[ $action == 'sync' ]] && is-missing -- "$option_path"; then
		fs-mkdir -- "$option_path" || return
	elif is-not-directory -- "$option_path"; then
		__print_error 'The path ' --path="$option_path" ' is not a git repository, because it is not a directory.' || :
		return 2 # ENOENT 2 No such file or directory
	fi

	# enter the path so that git commands work correctly
	cd "$option_path"

	# =====================================
	# Configuration

	source "$DOROTHY/sources/config.sh"

	# git.bash provides:
	local GIT_DEFAULT_BRANCH='main'
	local GIT_PROTOCOL='' # 'https', or 'ssh'
	load_dorothy_config 'git.bash'

	# =====================================
	# Authors

	# authors
	function __authors {
		__unrecognised_arguments "$@" || return
		git shortlog --summary --email | cut -f2- || return
	}

	# emails
	function __emails {
		__unrecognised_arguments "$@" || return
		git shortlog --summary --email | echo-regexp -ong --regexp='<(.+?)>' --replace='$1' || return
	}

	# author-update
	function __update_author {
		# process
		local item old_email='' new_email='' new_name=''
		while [[ $# -ne 0 ]]; do
			item="$1"
			shift
			case "$item" in
			--old=* | --old-email=*) old_email="${item#*=}" ;;
			--new=* | --new-email=*) new_email="${item#*=}" ;;
			--name=* | --new-name=*) new_name="${item#*=}" ;;
			*)
				if [[ -z $old_email ]]; then
					old_email="$item"
				elif [[ -z $new_email ]]; then
					new_email="$item"
				elif [[ -z $new_name ]]; then
					new_name="$item"
				else
					__unrecognised_argument "$item" || return
				fi
				;;
			esac
		done

		# validate and isolate old email
		local emails=()
		__split --target={emails} --no-zero-length --invoke -- \
			__emails
		old_email="$(
			choose --linger --required --no-confirm-solo \
				--question='Which email to update from the repository?' \
				--question="$option_path" \
				--default="$old_email" -- \
				"${emails[@]}"
		)"

		# ensure emails
		new_email="$(
			ask --linger --required \
				--question='What is the new email?' \
				--default="$new_email"
		)"
		new_name="$(
			ask --linger --required \
				--question='What is the new name?' \
				--default="$new_name"
		)"

		# apply
		fs-remove --quiet --no-confirm -- ./.git/refs/original
		git filter-branch --env-filter "
			OLD_EMAIL=\"$old_email\"
			CORRECT_EMAIL=\"$new_email\"
			CORRECT_NAME=\"$new_name\"
			if [ \"\$GIT_COMMITTER_EMAIL\" = \"\$OLD_EMAIL\" ]; then
				export GIT_COMMITTER_NAME=\"\$CORRECT_NAME\"
				export GIT_COMMITTER_EMAIL=\"\$CORRECT_EMAIL\"
			fi
			if [ \"\$GIT_AUTHOR_EMAIL\" = \"\$OLD_EMAIL\" ]; then
				export GIT_AUTHOR_NAME=\"\$CORRECT_NAME\"
				export GIT_AUTHOR_EMAIL=\"\$CORRECT_EMAIL\"
			fi
		" --tag-name-filter cat -- --branches --tags
	}

	# =====================================
	# Branches

	function __branch {
		# process
		local item check='no' remote='' branch='' head='' active='' default='' local='' global='' env='' usual='' verify=''
		while [[ $# -ne 0 ]]; do
			item="$1"
			shift
			case "$item" in
			--no-check* | --check*) __flag --source={item} --target={check} --affirmative --coerce || return ;;
			--no-remote* | --remote*) __flag --source={item} --target={remote} --affirmative --no-coerce || return ;;
			--no-branch* | --branch*) __flag --source={item} --target={branch} --affirmative --no-coerce || return ;;
			--no-head* | --head*) __flag --source={item} --target={head} --affirmative --coerce || return ;;
			--no-active* | --active*) __flag --source={item} --target={active} --affirmative --coerce || return ;;
			--no-default* | --default*) __flag --source={item} --target={default} --affirmative --coerce || return ;;
			--no-local* | --local*) __flag --source={item} --target={local} --affirmative --coerce || return ;;
			--no-global* | --global*) __flag --source={item} --target={global} --affirmative --coerce || return ;;
			--no-env* | --env*) __flag --source={item} --target={env} --affirmative --coerce || return ;;
			--no-usual* | --usual*) __flag --source={item} --target={usual} --affirmative --coerce || return ;;
			--no-verify* | --verify*) __flag --source={item} --target={verify} --affirmative --coerce || return ;;
			--*) __unrecognised_flag "$item" || return ;;
			*) __unrecognised_argument "$item" || return ;;
			esac
		done

		# adjustments
		if [[ $branch == 'yes' ]]; then
			branch=''
		fi
		if [[ $remote == 'yes' ]]; then
			remote=''
		fi

		# on a fresh init
		# `git rev-parse --abbrev-ref HEAD` will output HEAD but error
		# and `git branch -a` will output:
		# remotes/origin/HEAD -> origin/master
		# remotes/origin/master

		# branches
		local branches=() temp
		if [[ -n $branch && $branch != 'no' && $branch != 'yes' ]]; then
			branches+=("$branch")
		fi
		if [[ $active == 'yes' || ($active != 'no' && -z $branch) ]]; then
			temp="$(git rev-parse --abbrev-ref HEAD 2>/dev/null || :)"
			if [[ -n $temp ]]; then
				branches+=("$temp")
			fi
		fi
		if [[ $default == 'yes' || ($default != 'no' && -z $branch) ]]; then
			if [[ $local != 'no' ]]; then
				temp="$(git config --local init.defaultBranch 2>/dev/null || :)"
				if [[ -n $temp ]]; then
					branches+=("$temp")
				fi
			fi
			if [[ $global != 'no' ]]; then
				temp="$(git config --global init.defaultBranch 2>/dev/null || :)"
				if [[ -n $temp ]]; then
					branches+=("$temp")
				fi
			fi
		fi
		if [[ $env == 'yes' || ($env != 'no' && -z $branch) ]]; then
			if [[ -n $GIT_DEFAULT_BRANCH ]]; then
				branches+=("$GIT_DEFAULT_BRANCH")
			fi
		fi
		if [[ $usual == 'yes' || ($usual != 'no' && -z $branch) ]]; then
			branches+=(main master)
		fi

		# unique the branches
		__unique --source+target={branches} || return

		# evict head branches
		if [[ $head == 'no' ]]; then
			# as we have done unique, there will only be one
			__evict --source+target={branches} --first --optional --value='HEAD' || return
		fi

		# validate
		if [[ ${#branches[@]} -eq 0 ]]; then
			return 93 # ENOATTR 93 Attribute not found
		fi

		# if not verify, just do the first result
		if [[ $verify == 'no' ]]; then
			__print_lines "${branches[0]}"
			return 0
		fi

		# verify branch locally then remotely
		__affirm_length_defined "${#branches[@]}" '<branch>' || return
		local found=() fetched_remote='no'
		for branch in "${branches[@]}"; do
			# local
			if git rev-parse --verify --quiet "$branch" &>/dev/null; then
				found+=("$branch")
			# remote
			elif [[ $remote != 'no' ]]; then
				# remote and local branches, designed specially for this purpose:
				# git rev-parse --verify --quiet "$remote/$branch" &>/dev/null || return
				# remote and local branches:
				# git rev-parse --abbrev-ref "$remote/$branch" &>/dev/null || return
				if [[ $fetched_remote == 'no' ]]; then
					remote="$(__remote --remote="$remote")" || return
					fetched_remote='yes'
				fi
				if git rev-parse --verify --quiet "$remote/$branch" &>/dev/null || {
					# try fetch the git remote and try again
					git fetch "$remote" &>/dev/null && git rev-parse --verify --quiet "$remote/$branch" &>/dev/null
				}; then
					found+=("$branch")
				fi
			fi
		done

		# handle
		case "${#found[@]}" in
		0) return 93 ;; # ENOATTR 93 Attribute not found
		1) __print_lines "${found[0]}" ;;
		*) choose --linger --required --no-confirm-solo \
			--question="Which branch to select for the repository?" \
			--question="$option_path" \
			--default-exact="${found[0]}" \
			-- "${found[@]}" || return ;;
		esac

		# done
		return 0
	}

	# =====================================
	# Commits

	function __commit {
		# process
		local item first='no' hash='' url='' log=''
		while [[ $# -ne 0 ]]; do
			item="$1"
			shift
			case "$item" in
			--no-first* | --first*) __flag --source={item} --target={first} --affirmative --coerce || return ;;
			--no-hash* | --hash*) __flag --source={item} --target={hash} --affirmative --no-coerce || return ;;
			--no-url* | --url*) __flag --source={item} --target={url} --affirmative --no-coerce || return ;;
			--no-log* | --log*) __flag --source={item} --target={log} --affirmative --no-coerce || return ;;
			--*) __unrecognised_flag "$item" || return ;;
			*) __unrecognised_argument "$item" || return ;;
			esac
		done

		# first
		if [[ $first == 'yes' ]]; then
			hash="$(git log --reverse --oneline | echo-first-line | echo-regexp -o --regexp='(.+?) .+' --replace='$1' || :)"
		fi

		# verify
		__affirm_value_is_defined "$hash" '--hash=<commit-hash>' || return

		# action
		if [[ $url == 'yes' ]]; then
			slug="$(__get_github_slug)" || return
			__print_lines "https://github.com/$slug/commit/$hash" || return
		elif [[ $log == 'yes' ]]; then
			git log -1 "$hash" || return
		else
			__print_lines "$hash" || return
		fi
	}

	# =====================================
	# Files

	function __file {
		# process
		local item check='no' local='' remote='' branch='' file=''
		while [[ $# -ne 0 ]]; do
			item="$1"
			shift
			case "$item" in
			--no-check* | --check*) __flag --source={item} --target={check} --affirmative --coerce || return ;;
			--no-local* | --local*) __flag --source={item} --target={local} --affirmative --coerce || return ;;
			--no-remote* | --remote*) __flag --source={item} --target={remote} --affirmative --no-coerce || return ;;
			--no-branch* | --branch*) __flag --source={item} --target={branch} --affirmative --no-coerce || return ;;
			--file=* | --subpath=* | --path=*) file="${item#*=}" ;;
			--*) __unrecognised_flag "$item" || return ;;
			*) __unrecognised_argument "$item" || return ;;
			esac
		done

		# file
		__affirm_value_is_defined "$file" '--file=<file>' || return

		# local subpaths
		if [[ $local != 'no' && (-z $remote || $remote == 'no') ]]; then
			if [[ -z $branch || $branch == 'no' ]]; then
				# check
				if [[ $check == yes ]]; then
					if [[ -f $file ]]; then
						return 0
					fi
				else
					if cat "$file" 2>/dev/null; then
						return 0
					fi
				fi
			else
				local local_branch
				local_branch="$(__branch --no-remote --branch="$branch" --verify)" || return
				# check
				if [[ $check == yes ]]; then
					if git cat-file -e "$local_branch:$file" 2>/dev/null; then
						return 0
					fi
				else
					if git cat-file -p "$local_branch:$file" 2>/dev/null; then
						return 0
					fi
				fi
			fi
		fi

		# remote subpaths
		if [[ $remote != 'no' ]]; then
			remote="$(__remote --remote="$remote")" || return
			# remote requires branch, so ignore branch=no
			local remote_branch
			remote_branch="$(__branch --remote="$remote" --branch="$branch" --verify)" || return
			# check
			if [[ $check == yes ]]; then
				if git cat-file -e "$remote/$remote_branch:$file" 2>/dev/null; then
					return 0
				fi
			else
				if git cat-file -p "$remote/$remote_branch:$file" 2>/dev/null; then
					return 0
				fi
			fi
		fi

		# failure
		return 93 # ENOATTR 93 Attribute not found
	}

	# helper
	# trunk-ignore(shellcheck/SC2120)
	function __dorothy_grep {
		__unrecognised_arguments "$@" || return
		grep --quiet --fixed-strings \
			--regexp='Dorothy User Configuration' \
			--regexp='https://github.com/bevry/dorothy' \
			--regexp='https://dorothy.bevry.me' || return
	}

	# is-dorothy / has-dorothy-remote-file
	function __is_dorothy {
		# trunk-ignore(shellcheck/SC2119)
		__file "$@" --file='README.md' | __dorothy_grep || return
	}

	# strongbox / get-strongbox / is-strongbox
	function __strongbox {
		__file "$@" --file='.strongbox-keyid' || return
	}

	# =====================================
	# Protocols

	local PROTOCOLS=()

	# trunk-ignore(shellcheck/SC2120)
	function __load_protocols {
		__unrecognised_arguments "$@" || return
		if [[ ${#PROTOCOLS[@]} -eq 0 ]]; then
			# test a generic ssh connection to github
			# @todo it does support a url argument, for if we want to properly test a SSH remote
			if ssh-helper test &>/dev/null; then
				PROTOCOLS+=('ssh')
			fi
			PROTOCOLS+=('https')
		fi
	}

	function __protocol {
		# process
		local item protocol='' test='no'
		while [[ $# -ne 0 ]]; do
			item="$1"
			shift
			case "$item" in
			--protocol=*) protocol="${item#*=}" ;;
			--no-test* | --test*) __flag --source={item} --target={test} --affirmative --coerce || return ;;
			--*) __unrecognised_flag "$item" || return ;;
			*) __unrecognised_argument "$item" || return ;;
			esac
		done

		# use default
		if [[ -z $protocol ]]; then
			protocol="$GIT_PROTOCOL"
		fi
		# verify
		if [[ $protocol == 'http' ]]; then
			protocol='https'
		elif ! [[ $protocol =~ ^(ssh|https)$ ]]; then
			protocol=''
		fi
		# protocols
		local protocols
		if [[ $test == 'yes' ]]; then
			# trunk-ignore(shellcheck/SC2119)
			__load_protocols || return
			protocols=("${PROTOCOLS[@]}")
		else
			protocols=('https' 'ssh')
		fi
		# select
		if [[ -z $protocol || $test == 'yes' ]]; then
			# nice workaround for CI to select the first item, while still requiring a confirmation from a human
			local defaults=("$protocol" "$GIT_PROTOCOL")
			if [[ $IS_STDIN_OPENED_ON_TERMINAL == 'no' ]]; then
				defaults+=("${protocols[0]}")
			fi
			protocol="$(choose --required --no-confirm-default --no-confirm-solo \
				--question='Which git protocol to use on the repository?' \
				--question="$option_path" \
				--defaults-exact="$(__print_lines "${defaults[@]}")" -- "${protocols[@]}")" || return
		fi
		# result
		if [[ -n $protocol ]]; then
			__print_lines "$protocol" || return
		else
			return 42 # ENOPROTOOPT 42 Protocol not available
		fi
	}

	# =================================
	# Remotes

	function __remotes {
		__unrecognised_arguments "$@" || return
		# verify path, assumed verified for other actions
		local remote_status remote_output
		__do --redirect-status={remote_status} --redirect-output={remote_output} \
			-- git remote || return
		if [[ $remote_status -eq 128 ]]; then
			__print_error 'The directory ' --path="$option_path" ' is not a git repository.' || :
			if [[ -n $remote_output ]]; then
				__print_lines "$remote_output" >&2 || :
			fi
			return "$status" # makes more sense to continue inheriting the git exit status 128 than converting it to EFTYPE 79 Inappropriate file type or format
		elif [[ -z $remote_output ]]; then
			__print_error 'The directory ' --path="$option_path" ' is a git repository without any remotes.' || :
			return 91 # ENOMSG 91 No message of desired type
		elif [[ $remote_status -ne 0 ]]; then
			__print_error 'The directory ' --path="$option_path" ' failed with the exit exit status of ' --status="$git_status" ' when fetching its remotes.' || :
			if [[ -n $remote_output ]]; then
				__print_lines "$remote_output" >&2 || :
			fi
			return "$remote_status"
		else
			__print_lines "$remote_output" || return
		fi
	}

	# =================================
	# URLs

	function __format_url_to_protocol {
		# process
		local item protocol='' url=''
		while [[ $# -ne 0 ]]; do
			item="$1"
			shift
			case "$item" in
			--protocol=*) protocol="${item#*=}" ;;
			--url=*) url="${item#*=}" ;;
			--*) __unrecognised_flag "$item" || return ;;
			*) __unrecognised_argument "$item" || return ;;
			esac
		done

		# ensure
		__affirm_value_is_defined "$protocol" '<protocol>' || return
		if ! [[ $protocol =~ ^(https|ssh)$ ]]; then
			return 14 # EFAULT 14 Bad address
		fi

		# convert urns
		local where='' username='' project=''
		if [[ $url =~ ^(gh|github): ]]; then
			# github:username/project
			where='github'
			__replace --source={url} --keep-after-first=':' --keep-before-first='/' --target={username} || return
			__replace --source={url} --keep-after-last='/' --target={project} || return
		elif [[ $url =~ ^(gl|gitlab): ]]; then
			where='gitlab'
			__replace --source={url} --keep-after-first=':' --keep-before-first='/' --target={username} || return
			__replace --source={url} --keep-after-last='/' --target={project} || return
		elif [[ $url =~ ^[^:/]+/[^:/]+$ ]]; then
			# username/project, assume github
			where='github'
			__replace --source={url} --keep-before-first='/' --target={username} || return
			__replace --source={url} --keep-after-first='/' --target={project} || return
		fi
		if [[ -n $username && -n $project ]]; then
			if [[ $protocol == 'https' ]]; then
				__print_lines "https://$where.com/$username/$project.git" || return
			else
				__print_lines "git@$where.com:$username/$project.git" || return
			fi
			return 0
		fi

		# HTTPS urls:
		# https://github.com/balupton/dotfiles.git
		# SSH urls:
		# ssh://git@github.com/balupton/dotfiles.git
		# git@github.com:balupton/dotfiles.git

		# remove ssh prefix
		url="${url#*git@}"
		# remove url protocol prefix, e.g. https://
		url="${url#*://}"
		# remove .git suffix
		url="${url%.git*}"

		# fetch domain
		local domain
		domain="${url%:*}"
		if [[ -z $domain || $domain == "$url" ]]; then
			domain="${url%/*}"    # trims project
			domain="${domain%/*}" # trims user
		fi

		# fetch subpath
		local subpath
		subpath="${url#*:}"
		if [[ -z $subpath || $subpath == "$url" ]]; then
			subpath="${url#*/}"
		fi

		# format
		if [[ $protocol == 'https' ]]; then
			__print_lines "https://$domain/$subpath.git" || return
		else
			__print_lines "git@$domain:$subpath.git" || return
		fi
	}

	function __url {
		__remote --result=url "$@" || return
	}

	function __remote {
		# process
		local item mode='get' protocol='' remote='' url='' result='' verify='' test=''
		while [[ $# -ne 0 ]]; do
			item="$1"
			shift
			case "$item" in
			--mode=get | --mode=apply | --mode=check) mode="${item#*=}" ;;
			--get | --apply | --check) mode="${item#--}" ;;
			--no-protocol* | --protocol*) __flag --source={item} --target={protocol} --affirmative --no-coerce || return ;;
			--remote=*) remote="${item#*=}" ;;
			--no-remote* | --remote*) __flag --source={item} --target={remote} --affirmative --no-coerce || return ;;
			--url=*) url="${item#*=}" ;;
			--no-result* | --result*) __flag --source={item} --target={result} --affirmative --no-coerce || return ;;
			--no-verify* | --verify*) __flag --source={item} --target={verify} --affirmative --coerce || return ;;
			--no-test* | --test*) __flag --source={item} --target={test} --affirmative --coerce || return ;;
			--*) __unrecognised_flag "$item" || return ;;
			*) __unrecognised_argument "$item" || return ;;
			esac
		done

		# adjust verify and test
		if [[ -z $verify ]]; then
			if [[ $protocol == 'no' ]]; then
				verify='no'
			elif [[ -n $remote && -n $url && ($mode == 'apply' || $mode == 'check') ]]; then
				verify='yes'
			else
				verify='no'
			fi
		fi
		if [[ -z $test ]]; then
			if [[ -n $remote && -n $url && $mode == 'apply' ]]; then
				test='yes'
			else
				test='no'
			fi
		fi

		# adjust result
		if [[ -z $result ]]; then
			if [[ $mode == 'check' ]]; then
				result='no'
			else
				result='remote'
			fi
		fi
		if ! [[ $result =~ ^(url|remote|no)$ ]]; then
			__unrecognised_argument "--result=$result" || return
		fi

		# adjust protocol, no testing as we test via `git fetch` instead
		# if protocol is disabled, then it means no protocol adjustments
		if [[ $protocol != 'no' ]]; then
			if [[ $protocol == 'yes' ]]; then
				protocol=''
			fi
			protocol="$(__protocol --no-test --protocol="$protocol")"
		fi

		# adjust url, remote, and mode
		if [[ -n $url ]]; then
			# if url and remote, then this just means url with a remote fallback
			if [[ -z $remote || $mode == 'get' ]]; then
				# check for get
				# if non-get with url but no remote, then fail
				if [[ $mode != 'get' ]]; then
					help --code="$(echo-escape-command -- git-helper remote --mode="$mode" --url="$url")" ' without ' --code='--remote=<remote>' ' is pointless.' || return
				fi
				# now do format
				if [[ $protocol == 'no' ]]; then
					__print_lines "$url" || return
				else
					__format_url_to_protocol --url="$url" --protocol="$protocol" || return
				fi
				return
			fi
		fi

		# if no remote, then prompt for remote
		if [[ -z $remote ]]; then
			local remotes=()
			__split --target={remotes} --no-zero-length --invoke -- \
				__remotes || return
			remote="$(choose --required --no-confirm-default --no-confirm-solo \
				--question="Which git remote to select for the repository?" \
				--question="$option_path" \
				--default-exact="$remote" -- "${remotes[@]}")" || return
		fi

		# if no url, get the url from the specified/prompted remote
		if [[ -z $url ]]; then
			url="$(git remote get-url "$remote")" || return
		fi

		# process
		local https_url ssh_url protocol_url=''
		https_url="$(__format_url_to_protocol --url="$url" --protocol=https)" || return
		ssh_url="$(__format_url_to_protocol --url="$url" --protocol=ssh)" || return
		if [[ $protocol == 'no' ]]; then
			protocol_url="$url"
		else
			protocol_url="$(__format_url_to_protocol --url="$url" --protocol="$protocol")" || return
		fi
		function __set_remote_url {
			local custom_url="$1" result_url
			# if it exists, just update the url, so fetching is partial thus quicker
			if git remote get-url "$remote" &>/dev/null; then
				git remote set-url "$remote" "$custom_url" || return
			else
				# add if it doesn't exist
				git remote add "$remote" "$custom_url" || return
			fi
			# if not verifying, already done
			if [[ $verify == 'no' ]]; then
				return 0
			fi
			# check it has applied correctly
			result_url="$(git remote get-url "$remote")" || return
			if [[ $result_url != "$custom_url" ]]; then
				# output details
				__print_error 'The remote ' --variable-value={remote} ' resulted in ' --url="$result_url" ' instead of the desired ' --url="$custom_url" || :

				# and check to see if it was git config rewrite rules to blame
				local global_lines='' local_lines=''
				global_lines="$(git config --global --list | grep --fixed-strings --regexp='.insteadof=')" || :
				if [[ -n $global_lines ]]; then
					__print_style --stderr --bold='These rules of your global git config could be to blame:' --newline --code="$global_lines" || :
				fi
				local_lines="$(git config --list | grep --fixed-strings --regexp='.insteadof=')"
				if [[ -n $local_lines ]]; then
					__print_style --stderr --bold='These rules of your global git config could be to blame:' --newline --code="$local_lines" || :
				fi
				if [[ -n $local_lines || -n $local_lines ]]; then
					__print_style --stderr --notice='Remove them running the following:' || :
					echo-regexp -gomn '^(.+)=.*$' 'git config --global --unset $1' -- "$local_lines" >&2 || :
					echo-regexp -gomn '^(.+)=.*$' 'git config --unset $1' -- "$local_lines" >&2 || :
				fi

				# note the failure
				return 100 # EPROTO 100 Protocol error
			fi
		}

		# apply difference if necessary
		if [[ $protocol_url != "$url" ]]; then
			# if apply, then apply
			if [[ $mode == 'apply' ]]; then
				__set_remote_url "$protocol_url" || return
			elif [[ $mode == 'check' ]]; then
				return 93 # ENOATTR 93 Attribute not found
			fi
		fi

		# test application
		function __test {
			local remote_url pending success failure status
			# trunk-ignore(shellcheck/SC2034)
			remote_url="$(git remote get-url "$remote")" || return
			pending="$(__print_style --bold='Testing ' --variable={remote} ' on ' --variable={option_path} ' to ' --variable={remote_url})" || return
			success="$(__print_style --success='Using ' --variable={remote} ' on ' --variable={option_path} ' to ' --variable={remote_url})" || return
			failure="$(__print_style --error='Failed ' --variable={remote} ' on ' --variable={option_path} ' to ' --variable={remote_url})" || return
			eval-helper --quiet --pending="$pending" --success="$success" --failure="$failure" \
				-- git fetch --dry-run "$remote"
		}
		function __test_with_fallback {
			if __test; then
				return 0
			fi
			# @todo once `choose` supports `--inline` then change to `choose` instead of this `confirm` seesaw
			if [[ $protocol == 'ssh' ]]; then
				if confirm --positive --ppid=$$ -- "Protocol [$protocol] failed, try HTTPS?"; then
					protocol='https'
					__set_remote_url "$https_url" || return
					__test_with_fallback || return
				else
					return 1
				fi
			else
				if confirm --positive --ppid=$$ -- "Protocol [$protocol] failed, try SSH?"; then
					protocol='ssh'
					__set_remote_url "$ssh_url" || return
					__test_with_fallback || return
				else
					return 1
				fi
			fi
		}
		if [[ $test == 'yes' ]]; then
			__test_with_fallback
		fi

		# result
		case "$result" in
		url) git remote get-url "$remote" || return ;;
		remote) __print_lines "$remote" || return ;;
		*) __unrecognised_flag "--result=$result" || return ;;
		esac

		# done
		return 0
	}

	# =====================================
	# Repository Properties

	function __is_shallow_clone {
		__unrecognised_arguments "$@" || return
		[[ "$(git rev-parse --is-shallow-repository || :)" != 'false' ]] || return
	}

	function __get_github_slug {
		__unrecognised_arguments "$@" || return
		git remote -v | echo-regexp -o --regexp='.+?github[.]com[:/](.+?)[.]git.+' --replace='$1' || return
	}

	# verify repository
	function __verify {
		__unrecognised_arguments "$@" || return
		local git_status git_output
		__do --redirect-status={git_status} --redirect-output={git_output} -- git status || return
		if [[ $git_status -eq 128 ]]; then
			__print_error 'The directory ' --path="$option_path" ' is not a git repository.' || :
			if [[ -n $git_output ]]; then
				__print_lines "$git_output" >&2 || :
			fi
			return "$git_status" # makes more sense to continue inheriting the git exit status 128 than converting it to EFTYPE 79 Inappropriate file type or format
		elif [[ $git_status -ne 0 ]]; then
			__print_error 'The directory ' --path="$option_path" ' failed with the git exit status of ' --status="$git_status" ' when fetching its status via ' --code='git status' || :
			if [[ -n $git_output ]]; then
				__print_lines "$git_output" >&2 || :
			fi
			return "$git_status"
		fi
		return 0
	}

	# =====================================
	# Repository

	function __sync {
		# process
		local item remote='origin' url='' branch='' protocol='' project='' description='' homepage='' new='' init='' update=''
		while [[ $# -ne 0 ]]; do
			item="$1"
			shift
			case "$item" in
			--remote=*) remote="${item#*=}" ;;
			--url=*) url="${item#*=}" ;;
			--branch=*) branch="${item#*=}" ;;
			--no-protocol* | --protocol*) __flag --source={item} --target={protocol} --affirmative --no-coerce || return ;;
			--project=*) project="${item#*=}" ;;
			--description=*) description="${item#*=}" ;;
			--homepage=*) homepage="${item#*=}" ;;
			--no-new* | --new*) __flag --source={item} --target={new} --affirmative --no-coerce || return ;;
			--no-init* | --init*) __flag --source={item} --target={init} --affirmative --no-coerce || return ;;
			--no-update* | --update*) __flag --source={item} --target={update} --affirmative --no-coerce || return ;;
			--*) __unrecognised_flag "$item" || return ;;
			*) __unrecognised_argument "$item" || return ;;
			esac
		done

		# if we haven't initialised, then manually initialise
		if [[ ! -d .git ]]; then
			if [[ $init != 'no' ]]; then
				git init -q || return
			else
				# fail with nice error
				__verify || return
			fi
		fi

		if [[ $new == 'yes' ]]; then
			# url, where
			local where
			if [[ $url =~ ^(local|none)$ ]]; then
				where='local'
				url=''
			else
				# ignore failures, as it just means there wasn't a url and the repo doesn't have remotes
				# use https for now for consistent url passing, it'll be converted to the intended protocol later
				url="$(__url --remote="$remote" --url="$url" --protocol=https 2>/dev/null)" || :
			fi
			if [[ -n $url ]]; then
				if [[ $url == *github.com* ]]; then
					where='github'
				elif [[ $url == *gitlab.com* ]]; then
					where='gitlab'
				else
					where='custom'
				fi
			elif [[ $IS_STDIN_OPENED_ON_TERMINAL == 'yes' ]]; then
				where="$(
					choose --linger --required --label \
						--question='Where do you want to store your Dorothy user configuration?' -- \
						github 'Use a GitHub repository for your user configuration.' \
						gitlab 'Use a GitLab repository for your user configuration.' \
						custom 'Manually specify a repository URL for your user configuration.' \
						local "Don't use a repository for your user configuration, just store it locally for now."
				)"
			else
				__print_style --notice="Terminal isn't reactive, as such will default to local storage for user configuration."
				where='local'
			fi

			# handle remote repository setup
			if [[ $where =~ ^(github|gitlab|custom)$ ]]; then
				# validate
				local username='' default cli enter_or_confirm='Enter' repo_slug remote_slug conflict_choice
				if [[ -z $url ]]; then
					# prepare username default, and clear generic usernames
					if [[ -z $username ]]; then
						username="$(get-profile username || :)"
						if [[ -n $username ]] && is-generic -- "$username"; then
							username=''
						fi
					fi
				fi
				while :; do
					default='' cli='' repo_slug='' remote_slug=''
					if [[ $where != 'custom' ]]; then
						default+="$where:"
					fi
					if [[ -n $username ]]; then
						default+="$username/"
					fi
					default+="$project"
					url="$(
						ask --linger --default="$default" \
							"$enter_or_confirm the repository clone URL for your $option_label:" \
							'e.g. github:username/project' \
							'e.g. https://github.com/username/project.git' \
							'e.g. ssh://git@github.com/balupton/dotfiles.git' \
							'e.g. git@github.com:balupton/dotfiles.git'
					)"
					if [[ -z $url || $url == 'local' ]]; then
						url=''
						where='local'
						break
					fi
					url="$(__format_url_to_protocol --url="$url" --protocol=https)" || return
					if [[ -z $url || $url == 'local' ]]; then
						url=''
						where='local'
						break
					fi
					if [[ $url == *github.com* ]]; then
						where='github'
						setup-util-gh --confirm --optional
						if __command_exists -- gh; then
							cli='gh'
						fi
					elif [[ $url == *gitlab.com* ]]; then
						where='gitlab'
						setup-util-glab --confirm --optional
						if __command_exists -- glab; then
							cli='glab'
						fi
					else
						where='custom'
					fi

					# make the repo slug
					if [[ -n $cli ]]; then
						__replace --source={url} --keep-before-last='/' --keep-after-first='.com' --pattern='[/:]' --target={username} || return
						__replace --source={url} --keep-after-last='/' --keep-before-first='.git' --target={project} || return
						repo_slug="$username/$project"
					fi

					# validate existence
					if [[ $cli == 'gh' ]]; then
						remote_slug="$(gh repo view "$repo_slug" --json nameWithOwner | jq -r .nameWithOwner)" || :
						if [[ $remote_slug == "$repo_slug" ]]; then
							break
						else
							conflict_choice="$(
								choose --required --label --question="When verifying $repo_slug it redirected to $remote_slug. What do you want to do?" -- \
									create "Create a new repository at $repo_slug" \
									change "Use $remote_slug instead" \
									redirect "Use $repo_slug and have it redirect to $remote_slug for now" \
									rename "Rename $remote_slug to $repo_slug"
							)"
							case "$conflict_choice" in
							create) : ;;
							change)
								url="https://$where.com/$remote_slug.git"
								break
								;;
							redirect)
								break
								;;
							rename)
								gh repo rename "$remote_slug" "$repo_slug" || return
								break
								;;
							esac
						fi
					elif [[ $cli == 'glab' ]]; then
						if glab repo view "$repo_slug" >/dev/null; then
							break
						fi
					elif fetch --ok "$url"; then
						break
					elif confirm --linger --bool --ppid=$$ -- "Unable to validate the repository exists. Does it actually exist?" "Go to $url and verify it exists."; then
						break
					fi

					# if existence couldn't be validated, create it
					if [[ $cli == 'gh' ]]; then
						if gh repo create "$repo_slug" --description="$description" --homepage="$homepage" --public --confirm --enable-wiki=false; then
							break
						fi
					elif [[ $cli == 'glab' ]]; then
						# @todo untested
						if glab repo create "$repo_slug" --description "$description" --public; then
							break
						fi
					else
						if [[ $where == 'github' ]]; then
							open 'https://github.com/new' &>/dev/null || :
						elif [[ $where == 'gitlab' ]]; then
							open 'https://gitlab.com/projects/new#blank_project' &>/dev/null || :
						fi
						__print_style \
							--notice2="Create a $where repository for your $option_label using the following details:" --newline \
							--bold='Repository name: ' --code="$project" --newline \
							--bold='Description: ' --code="$description"
					fi
					enter_or_confirm='Confirm'
				done
			fi
		fi

		# avoid merge conflicts
		git config pull.ff only || return

		# exit early if no update
		if [[ $update == 'no' ]]; then
			return 0
		fi

		# wrap the update to handle optional
		function __do_update {
			# the verify and test will handle the update failure
			remote="$(__remote --apply --remote="$remote" --url="$url" --protocol="$protocol" --verify --test)" || return

			# fetch all origins, branches, and prune remote deleted branches
			local pending success failure
			pending="$(__print_style --bold='Fetching ' --bold='all remotes' ' on ' --variable={option_path})" || return
			success="$(__print_style --success='Fetched ' --bold='all remotes' ' on ' --variable={option_path})" || return
			failure="$(__print_style --error='Failed fetching ' --bold='all remotes' ' on ' --variable={option_path})" || return
			eval-helper --quiet --pending="$pending" --success="$success" --failure="$failure" \
				-- git fetch --all --prune || return

			# now that we have fetch, ensure the branch
			# if an init just happened, the active branch will be HEAD, which when cloned will use the default branch configuration, which may not actually be the remote branch name, this is easiest to workaround by just denying head branches
			branch="$(__branch --remote="$remote" --branch="$branch" --no-head --verify)" || return

			# if strongbox, ensure configured before pulling
			local strongbox_keyid
			strongbox_keyid="$(__strongbox --remote="$remote" --branch="$branch")" || :
			if [[ -n $strongbox_keyid ]]; then
				# it is strongbox, so install strongbox
				setup-util-strongbox || return
				# check strongbox configuration
				local local_strongbox_keyring
				local_strongbox_keyring="$HOME/.strongbox_keyring"
				function __check_keyring {
					grep --quiet --fixed-strings --regexp="$strongbox_keyid" -- "$local_strongbox_keyring" || return
				}
				if ! __check_keyring; then
					# strongbox is not configured
					__prepare_current_user || return
					local local_ip
					local_ip="$(what-is-my-ip local | echo-first-line --stdin || :)"
					__print_style \
						--notice2="Your Strongbox keyring on this machine is missing the Strongbox keyid for your specified $option_label:" --newline \
						--newline \
						"$option_label's local path: " --path="$option_path" --newline \
						"$option_label's Strongbox keyid: " --path="$strongbox_keyid" --newline \
						"This Machine's Strongbox keyring: " --path="$local_strongbox_keyring" --newline \
						"This Machine's User: " --code="$CURRENT_USER" --newline \
						"This Machine's Local IP: " --code="$local_ip" --newline \
						'Strongbox Documentation: ' --url='https://github.com/uw-labs/strongbox' --newline \
						--newline \
						'To manually edit your Strongbox keyring entry on this machine, run the following in a new terminal window attached to this machine:' --newline \
						--code="$(edit --dry "$local_strongbox_keyring" || :)" --newline \
						--newline \
						'If VNC is enabled on this machine, run the following on your primary machine to then manually copy the Strongbox keyring to this machine:' --newline \
						--code="$(echo-escape-command -- cat "$HOME/.strongbox_keyring" || :)" --newline \
						--code="$(echo-escape-command -- open "vnc://$local_ip" || :)" --newline \
						--newline \
						'If SSH is enabled on this machine, run the following on your primary machine to copy the Strongbox keyring to this machine:' --newline \
						--code="$(echo-escape-command -- fs-copy -- "$HOME/.strongbox_keyring" "${CURRENT_USER}@${local_ip}:${local_strongbox_keyring}" || :)" --newline \
						--newline \
						'To enable SSH on this machine:' --newline \
						'macOS via: ' --code='System Preferences > Sharing > Remote Login.' --newline \
						'Linux via: ' --code="$(echo-escape-command -- "$DOROTHY/commands/dorothy" run -- setup-util-ssh || :)" --newline \
						--newline \
						'Alternative methods to copy the Strongbox keyring to this machine include:' --newline \
						'Using Croc: ' --url='https://github.com/schollz/croc?tab=readme-ov-file#usage' --newline \
						--code="$(echo-escape-command -- "$DOROTHY/commands/dorothy" run -- setup-util-croc || :)" --newline \
						'Using Magic Wormhole: ' --url='https://magic-wormhole.readthedocs.io/en/latest/welcome.html#example' --newline \
						--code="$(echo-escape-command -- "$DOROTHY/commands/dorothy" run -- setup-util-magic-wormhole || :)" --newline \
						'Using Termscp: ' --url='https://termscp.veeso.dev/user-manual.html' --newline \
						--code="$(echo-escape-command -- "$DOROTHY/commands/dorothy" run -- setup-util-termscp || :)"

					# don't bother with any confirmations, such is unnecessary complexity for the UX
					while ! __check_keyring; do
						waiter --timeout=10 --message="$(__print_style --notice2="Waiting %s before checking again for the required Strongbox configuration...")"
					done

					# log now configured
					__print_style --good2='Your Strongbox keyring is now configured correctly, continuing with clone.'
				fi
			fi

			# do the pull, applying the remote changes to the local branch
			local pending success failure
			pending="$(__print_style --bold='Pulling ' --variable={branch} ' via ' --variable={remote} ' on ' --variable={option_path})" || return
			success="$(__print_style --success='Pulled ' --variable={branch} ' via ' --variable={remote} ' on ' --variable={option_path})" || return
			failure="$(__print_style --error='Failed pulling ' --variable={branch} ' via ' --variable={remote} ' on ' --variable={option_path})" || return
			eval-helper --quiet --pending="$pending" --success="$success" --failure="$failure" \
				-- git pull "$remote" "$branch" || return
		}

		# do the update handling optional
		if [[ $update == 'optional' ]]; then
			__do_update || :
		else
			__do_update || return
		fi
		return 0
	}

	function __review {
		# @todo make this configurable
		if __command_exists -- gf; then
			gf "$option_path" "$@" || return
		elif get-app --quiet -- 'Gitfox'; then
			open-app 'Gitfox' -- "$option_path" "$@" || return
		elif __command_exists -- tower; then
			tower "$option_path" "$@" || return
		elif get-app --quiet -- 'Tower'; then
			open-app 'Tower' -- "$option_path" "$@" || return
		else
			__print_error 'No supported git reviewers installed.' || :
			return 93 # ENOATTR 93 Attribute not found
		fi
	}

	function __unstage {
		# https://stackoverflow.com/a/6919257
		git reset HEAD "$@" || return
	}

	function __wipe {
		__unrecognised_arguments "$@" || return
		if confirm --positive --ppid=$$ -- "Are you sure you want to wipe [$option_path] to the last commit state, reverting all uncommitted files and changes?"; then
			git reset --hard || return
			git clean -f || return
		fi
	}

	function __umt {
		__unrecognised_arguments "$@" || return
		# https://serverfault.com/a/1031956
		# ^ all suggestions there have shortcomings, such as producing:
		# xargs: warning: options --max-args and --replace/-I/-i are mutually exclusive, ignoring previous --max-args value
		# this solves it:
		# git ls-tree -r --name-only HEAD -z | TZ=UTC xargs -0 -I_ git --no-pager log -1 --date=iso-local --format='%ad _' -- _ | echo-write | echo-regexp -gonm '^(.+?) \+0000 (.+)$' "TZ=UTC touch -md '\$1' '\$2'" | bash
		# however our below implementation is far easier, more understandable, just as quick, and supports paths with % and quotes:
		local subfiles=() subfile timestamp
		__split --target={subfiles} --no-zero-length --invoke -- \
			git ls-tree -r --name-only HEAD || return
		for subfile in "${subfiles[@]}"; do
			timestamp="$(TZ=UTC git --no-pager log -1 --date=iso-local --format='%ad' -- "$subfile")" || return
			# trim trailing +0000
			timestamp="${timestamp% +0000}"
			TZ=UTC touch -md "$timestamp" -- "$subfile" || return
		done
	}

	# =====================================
	# Action

	# perform the action
	case "$action" in
	# authors
	authors) __authors "${option_args[@]}" ;;
	emails) __emails "${option_args[@]}" ;;
	author | author-update | update-author) __update_author "${option_args[@]}" ;;
	# branches
	branch) __branch "${option_args[@]}" ;;
	active-branch | current-branch) __branch --active --no-default --no-env --no-usual --verify "${option_args[@]}" ;;
	default-branch) __branch --no-active --verify "${option_args[@]}" ;;
	# commits
	commit) __commit "${option_args[@]}" ;;
	first-commit-url) __commit --first --url "${option_args[@]}" ;;
	# files
	file) __file "${option_args[@]}" ;;
	has-file) __file --check "${option_args[@]}" ;;
	has-remote-file) __file --check --no-local "${option_args[@]}" ;;
	get-remote-file) __file --no-local "${option_args[@]}" ;;
	# special files
	is-dorothy) __is_dorothy "${option_args[@]}" ;;
	get-strongbox) __strongbox "${option_args[@]}" ;;
	is-strongbox) __strongbox --check "${option_args[@]}" ;;
	# protocol
	protocol) __protocol "${option_args[@]}" ;;
	# remotes
	remotes) __remotes "${option_args[@]}" ;;
	# url
	remote | protocol-format | format-protocol | protocol-update | update-protocol | remote-set | set-remote) __remote "${option_args[@]}" ;;
	url) __url "${option_args[@]}" ;;
	# repository properties
	verify) __verify "${option_args[@]}" ;;
	github-slug) __get_github_slug "${option_args[@]}" ;;
	is-shallow) __is_shallow_clone "${option_args[@]}" ;;
	# sync
	sync) __sync "${option_args[@]}" ;;
	new) __sync --new --no-init --no-update "${option_args[@]}" ;;
	create) __sync --new --init --update=optional "${option_args[@]}" ;;
	init) __sync --no-new --init --no-update "${option_args[@]}" ;;
	clone) __sync --no-new --init --update "${option_args[@]}" ;;
	fetch | pull | update) __sync --no-new --no-init --update "${option_args[@]}" ;;
	# repository
	review) __review "${option_args[@]}" ;;
	unstage) __unstage "${option_args[@]}" ;;
	wipe) __wipe "${option_args[@]}" ;;
	umt | upstream-modification-times) __umt "${option_args[@]}" ;;
	*) help 'An unrecognised <action> was provided: ' --variable-value={action} ;;
	esac
)

# fire if invoked standalone
if [[ $0 == "${BASH_SOURCE[0]}" ]]; then
	if [[ $* == '--test' ]]; then
		git_helper_test
	else
		git_helper "$@"
	fi
fi
