#!/usr/bin/env bash

# @todo add tests

function git_helper() (
	source "$DOROTHY/sources/bash.bash"

	# =====================================
	# Arguments

	function help {
		cat <<-EOF >&2
			ABOUT:
			Helpers for working with git repositories.

			USAGE:
			git-helper [...options] <action> [--] [...args]

			OPTIONS:
			--path=<path>
			    Instead of the current working directory, use this path as the git repository.
			--no-path
			    Use a temporary directory as the container for the git repository.
			--verify
			    Verify the <path> contains an initialised git repository before proceeding with the <action>.
			--quiet
			    If enabled, output less messaging.

			ACTIONS:
			authors
			    Output all authors (contributors) within this git repository.
			emails
				Output all author emails within this git repository.
			update-author --old=<old-email> --new=<new-email> --name=<new-name>
			    Update an author's name and email.

			branch [--has] [--verify] [--remote=<remote>] [--branch=<branch>] [--[no-]active] [--[no-]default] [--[no-]local] [--[no-]global] [--[no-]env] [--[no-]usual]
			    Select a branch from the repository.
			current-branch
			    Alias of [branch] with arguments that fetch the current branch.
			default-branch
			    Alias of [branch] with arguments that fetch the default branch.

			commit [<hash>] [--first] [--hash] [--url]
			    Select a commit from the repository.
			first-commit-hash
			    Alias of [commit] with arguments that fetch the first commit hash of the repository.
			first-commit-url
			    Alias of [commit] with arguments that fetch the first commit url of the repository.

			file --file=<file> [--has] [--local] [--remote=<remote>] [--branch=<branch>]
			    Select a file from the repository.
			has-file
			    Alias for [file] with arguments that check if the file exists.
			has-remote-file
			    Alias for [file] with arguments that check if the remote file exists.
			get-remote-file
			    Alias for [file] with arguments that fetch the remote file contents.

			is-dorothy
			    Alias for [file] with arguments that check if the repository is a Dorothy repository.
			strongbox | get-strongbox
			    Alias for [file] with arguments that fetch the strongbox configuration file if it exists.
			is-strongbox
			    Alias for [file] with arguments that check if the repository contains configuration to encrypt files with Strongbox.

			protocol [--protocol=<protocol> | ssh | http | https] [--verify]
			    Select the protocol to use for the repository.
			protocol-update -- <remote-name> [<protocol>]
			    Set the <remote-name> to use the <protocol>.
			    If no <protocol> is specified, the preferred protocol will be selected.
			protocol-format -- <url> [<protocol>]
			    Format the <url> to the specified <protocol>.
			    If no <protocol> is specified, the preferred protocol will be selected.

			remotes
			    Output each git remote on a newline, same as [git remote] but with verbose repository checks.

			verify
			    Verify the <path> contains an initialised git repository.
			github-slug
			    Output the github slug for this repository.
			is-shallow
			    Is the repository a shallow clone?

			update [--remote=<remote>] [--branch=<branch>] [--url=<remote-url>]
			    Update the git repository inside <path>.
			    STDOUT will be either either:
			        failure
			        current
			        updated
			review -- [...<args>]
			    Open the git repository in your desired git reviewer. Supports: GitFox, Tower. Forwards <args> to the reviewer.
			unstage -- [...<args>]
			    Unstage the staged changes, without deleting or removing anything. Forwards <args> to [git reset HEAD].
			wipe
			    Wipe the current working directory to the state of the last commit. There will be a confirmation.
			umt | upstream-modification-times
			    Update the modification times of cloned files to that of their commits, rather than the time of cloning.
		EOF
		if [[ $# -ne 0 ]]; then
			__print_error "$@"
		fi
		return 22 # EINVAL 22 Invalid argument
	}

	# process
	local item action='' option_quiet='no' option_path='' option_verify='no' option_args=()
	while [[ $# -ne 0 ]]; do
		item="$1"
		shift
		case "$item" in
		--help | -h) help ;;
		--no-color* | --color*) __flag --source={item} --target={COLOR} --affirmative --export || return ;;
		--no-verbose* | --verbose*) __flag --source={item} --target={option_quiet} --non-affirmative --coerce || return ;;
		--no-quiet* | --quiet*) __flag --source={item} --target={option_quiet} --affirmative --coerce || return ;;
		--path=*) option_path="${item#*=}" ;;
		--no-path) option_path="$(fs-temp --cache --directory='dorothy' --directory='git-helper' --directory)" || return ;;
		--no-verify* | --verify*) __flag --source={item} --target={option_verify} --affirmative --coerce || return ;;
		--)
			option_args+=("$@")
			shift "$#"
			break
			;;
		--*) option_args+=("$item") ;;
		*)
			if [[ -z $action ]]; then
				action="$item"
			else
				option_args+=("$item" "$@")
				shift "$#"
				break
			fi
			;;
		esac
	done

	# @todo use the eval-helper flow to auto-elevate and store if elevation is needed for use with the git calls
	# ensure path, and verify
	if [[ -z $option_path ]]; then
		option_path="$(pwd)" || return
	elif [[ ! -d $option_path ]]; then
		__print_error 'The path ' --path="$option_path" ' is not a git repository, because it is not a directory.' || :
		return 2 # ENOENT 2 No such file or directory
	fi

	# alias
	local repository="$option_path"

	# check
	if [[ -z $action ]]; then
		help 'No ' --code='<action>' ' was provided.'
	fi

	# =====================================
	# Configuration

	source "$DOROTHY/sources/config.sh"

	# git.bash provides:
	local GIT_DEFAULT_BRANCH='main'
	local GIT_PROTOCOL='' # 'https', or 'ssh'
	load_dorothy_config 'git.bash'

	# =====================================
	# Authors

	# authors
	function __authors {
		__unrecognised_arguments "$@" || return
		git shortlog --summary --email | cut -f2- || return
	}

	# emails
	function __emails {
		__unrecognised_arguments "$@" || return
		git shortlog --summary --email | echo-regexp -ong --regexp='<(.+?)>' --replace='$1' || return
	}

	# author-update
	function __update_author {
		# process
		local item old_email='' new_email='' new_name=''
		while [[ $# -ne 0 ]]; do
			item="$1"
			shift
			case "$item" in
			--old=* | --old-email=*) old_email="${item#*=}" ;;
			--new=* | --new-email=*) new_email="${item#*=}" ;;
			--name=* | --new-name=*) new_name="${item#*=}" ;;
			*)
				if [[ -z $old_email ]]; then
					old_email="$item"
				elif [[ -z $new_email ]]; then
					new_email="$item"
				elif [[ -z $new_name ]]; then
					new_name="$item"
				else
					__unrecognised_argument "$item" || return
				fi
				;;
			esac
		done

		# validate and isolate old email
		local emails=()
		__split --target={emails} --no-zero-length --invoke -- \
			__emails
		old_email="$(
			choose --linger --required --no-confirm-solo \
				--question='Which email to update from the repository?' \
				--question="$repository" \
				--default="$old_email" -- \
				"${emails[@]}"
		)"

		# ensure emails
		new_email="$(
			ask --linger --required \
				--question='What is the new email?' \
				--default="$new_email"
		)"
		new_name="$(
			ask --linger --required \
				--question='What is the new name?' \
				--default="$new_name"
		)"

		# apply
		fs-remove --quiet --no-confirm -- ./.git/refs/original
		git filter-branch --env-filter "
			OLD_EMAIL=\"$old_email\"
			CORRECT_EMAIL=\"$new_email\"
			CORRECT_NAME=\"$new_name\"
			if [ \"\$GIT_COMMITTER_EMAIL\" = \"\$OLD_EMAIL\" ]; then
				export GIT_COMMITTER_NAME=\"\$CORRECT_NAME\"
				export GIT_COMMITTER_EMAIL=\"\$CORRECT_EMAIL\"
			fi
			if [ \"\$GIT_AUTHOR_EMAIL\" = \"\$OLD_EMAIL\" ]; then
				export GIT_AUTHOR_NAME=\"\$CORRECT_NAME\"
				export GIT_AUTHOR_EMAIL=\"\$CORRECT_EMAIL\"
			fi
		" --tag-name-filter cat -- --branches --tags
	}

	# =====================================
	# Branches

	function __branch {
		# process
		local item has='no' remote='' branch='' active='' default='' local='' global='' env='' usual='' verify=''
		while [[ $# -ne 0 ]]; do
			item="$1"
			shift
			case "$item" in
			--no-has* | --has*) __flag --source={item} --target={has} --affirmative --coerce || return ;;
			--no-remote* | --remote*) __flag --source={item} --target={remote} --affirmative --no-coerce || return ;;
			--no-branch* | --branch*) __flag --source={item} --target={branch} --affirmative --no-coerce || return ;;
			--no-active* | --active*) __flag --source={item} --target={active} --affirmative --coerce || return ;;
			--no-default* | --default*) __flag --source={item} --target={default} --affirmative --coerce || return ;;
			--no-local* | --local*) __flag --source={item} --target={local} --affirmative --coerce || return ;;
			--no-global* | --global*) __flag --source={item} --target={global} --affirmative --coerce || return ;;
			--no-env* | --env*) __flag --source={item} --target={env} --affirmative --coerce || return ;;
			--no-usual* | --usual*) __flag --source={item} --target={usual} --affirmative --coerce || return ;;
			--no-verify* | --verify*) __flag --source={item} --target={verify} --affirmative --coerce || return ;;
			--*) __unrecognised_flag "$item" || return ;;
			*) __unrecognised_argument "$item" || return ;;
			esac
		done

		# branches
		local branches=() temp
		if [[ $branch == 'yes' ]]; then
			branch=''
		fi
		if [[ -n $branch && $branch != 'no' && $branch != 'yes' ]]; then
			branches+=("$branch")
		fi
		if [[ $active == 'yes' || ($active != 'no' && -z $branch) ]]; then
			temp="$(git rev-parse --abbrev-ref HEAD 2>/dev/null || :)"
			if [[ -n $temp ]]; then
				branches+=("$temp")
			fi
		fi
		if [[ $default == 'yes' || ($default != 'no' && -z $branch) ]]; then
			if [[ $local != 'no' ]]; then
				temp="$(git config --local init.defaultBranch 2>/dev/null || :)"
				if [[ -n $temp ]]; then
					branches+=("$temp")
				fi
			fi
			if [[ $global != 'no' ]]; then
				temp="$(git config --global init.defaultBranch 2>/dev/null || :)"
				if [[ -n $temp ]]; then
					branches+=("$temp")
				fi
			fi
		fi
		if [[ $env == 'yes' || ($env != 'no' && -z $branch) ]]; then
			if [[ -n $GIT_DEFAULT_BRANCH ]]; then
				branches+=("$GIT_DEFAULT_BRANCH")
			fi
		fi
		if [[ $usual == 'yes' || ($usual != 'no' && -z $branch) ]]; then
			branches+=(main master)
		fi

		# if not verify, just do the first result
		if [[ $verify == 'no' ]]; then
			__print_lines "${branches[0]}"
			return 0
		fi

		# verify local then remote for each branch
		local branch_reference verified_remote='no' found='no'
		for branch in "${branches[@]}"; do
			# local
			if git rev-parse --verify --quiet "$branch" &>/dev/null; then
				if [[ $has != 'yes' ]]; then
					__print_lines "$branch"
				fi
				return 0
			fi
			# remote
			if [[ $remote != 'no' ]]; then
				if [[ $verified_remote == 'no' ]]; then
					verified_remote='yes'
					set +x
					remote="$(__remote --remote="$remote" --verify="$verify")" || :
				fi
				if git rev-parse --verify --quiet "$remote/$branch" &>/dev/null; then
					if [[ $has != 'yes' ]]; then
						__print_lines "$branch"
					fi
					return 0
				fi
			fi
		done
		# remote and local branches, designed specially for this purpose:
		# git rev-parse --verify --quiet "$remote/$branch" &>/dev/null || return
		# remote and local branches:
		# git rev-parse --abbrev-ref "$remote/$branch" &>/dev/null || return

		# failure
		return 93 # ENOATTR 93 Attribute not found
	}

	# =====================================
	# Commits

	function __commit {
		# process
		local item first='no' hash='' url='' log=''
		while [[ $# -ne 0 ]]; do
			item="$1"
			shift
			case "$item" in
			--no-first* | --first*) __flag --source={item} --target={first} --affirmative --coerce || return ;;
			--no-hash* | --hash*) __flag --source={item} --target={hash} --affirmative --no-coerce || return ;;
			--no-url* | --url*) __flag --source={item} --target={url} --affirmative --no-coerce || return ;;
			--no-log* | --log*) __flag --source={item} --target={log} --affirmative --no-coerce || return ;;
			--*) __unrecognised_flag "$item" || return ;;
			*) __unrecognised_argument "$item" || return ;;
			esac
		done

		# first
		if [[ $first == 'yes' ]]; then
			hash="$(git log --reverse --oneline | echo-first-line | echo-regexp -o --regexp='(.+?) .+' --replace='$1' || :)"
		fi

		# verify
		__affirm_value_is_defined "$hash" '--hash=<commit-hash>' || return

		# action
		if [[ $url == 'yes' ]]; then
			slug="$(__get_github_slug)" || return
			__print_lines "https://github.com/$slug/commit/$hash" || return
		elif [[ $log == 'yes' ]]; then
			git log -1 "$hash" || return
		else
			__print_lines "$hash" || return
		fi
	}

	# =====================================
	# Files

	function __file {
		# process
		local item has='no' local='' remote='' branch='' file=''
		while [[ $# -ne 0 ]]; do
			item="$1"
			shift
			case "$item" in
			--no-has* | --has*) __flag --source={item} --target={has} --affirmative --coerce || return ;;
			--no-local* | --local*) __flag --source={item} --target={local} --affirmative --coerce || return ;;
			--no-remote* | --remote*) __flag --source={item} --target={remote} --affirmative --no-coerce || return ;;
			--no-branch* | --branch*) __flag --source={item} --target={branch} --affirmative --no-coerce || return ;;
			--file=* | --subpath=* | --path=*) file="${item#*=}" ;;
			--*) __unrecognised_flag "$item" || return ;;
			*) __unrecognised_argument "$item" || return ;;
			esac
		done

		# file
		__affirm_value_is_defined "$file" '--file=<file>' || return

		# local subpaths
		if [[ $local != 'no' && (-z $remote || $remote == 'no') ]]; then
			if [[ -z $branch || $branch == 'no' ]]; then
				# check
				if [[ $has == yes ]]; then
					if [[ -f $file ]]; then
						return 0
					fi
				else
					if cat "$file" 2>/dev/null; then
						return 0
					fi
				fi
			else
				local local_branch
				local_branch="$(__branch --no-remote --branch="$branch")" || return
				# check
				if [[ $has == yes ]]; then
					if git cat-file -e "$local_branch:$file" 2>/dev/null; then
						return 0
					fi
				else
					if git cat-file -p "$local_branch:$file" 2>/dev/null; then
						return 0
					fi
				fi
			fi
		fi

		# remote subpaths
		if [[ $remote != 'no' ]]; then
			remote="$(__remote --remote="$remote")" || return
			# remote requires branch, so ignore branch=no
			local remote_branch
			remote_branch="$(__branch --remote="$remote" --branch="$branch")" || return
			# check
			if [[ $has == yes ]]; then
				if git cat-file -e "$remote/$remote_branch:$file" 2>/dev/null; then
					return 0
				fi
			else
				if git cat-file -p "$remote/$remote_branch:$file" 2>/dev/null; then
					return 0
				fi
			fi
		fi

		# failure
		return 93 # ENOATTR 93 Attribute not found
	}

	# helper
	function __dorothy_grep {
		__unrecognised_arguments "$@" || return
		grep --quiet --fixed-strings \
			--regexp='Dorothy User Configuration' \
			--regexp='https://github.com/bevry/dorothy' \
			--regexp='https://dorothy.bevry.me' || return
	}

	# is-dorothy / has-dorothy-remote-file
	function __is_dorothy {
		__file "$@" --file='README.md' | __dorothy_grep || return
	}

	# strongbox / get-strongbox / is-strongbox
	function __strongbox {
		__file "$@" --file='.strongbox-keyid' || return
	}

	# =====================================
	# Protocols

	local PROTOCOLS=()
	function __load_protocols {
		__unrecognised_arguments "$@" || return
		if [[ ${#PROTOCOLS[@]} -eq 0 ]]; then
			if ssh-helper test &>/dev/null; then
				PROTOCOLS+=('ssh')
			fi
			PROTOCOLS+=('https')
		fi
	}

	function __get_protocol {
		# process
		local item protocol='' verify='no'
		while [[ $# -ne 0 ]]; do
			item="$1"
			shift
			case "$item" in
			--protocol=*) protocol="${item#*=}" ;;
			ssh | http | https) protocol="$item" ;;
			--no-verify* | --verify*) __flag --source={item} --target={verify} --affirmative --coerce || return ;;
			--*) __unrecognised_flag "$item" || return ;;
			*) __unrecognised_argument "$item" || return ;;
			esac
		done

		# fetch and verify
		if [[ -z $protocol ]]; then
			protocol="$GIT_PROTOCOL"
		fi
		if ! [[ $protocol =~ ^(ssh|http|https)$ ]]; then
			protocol=''
		fi
		if [[ -z $protocol || $verify != 'no' ]]; then
			__load_protocols || return
			protocol="$(choose --required --no-confirm-default --no-confirm-solo \
				--question='Which git protocol to use on the repository?' \
				--question="$repository" \
				--default-exact="$protocol" --default-exact="$GIT_PROTOCOL" -- "${PROTOCOLS[@]}")" || return
		fi

		# result
		if [[ -n $protocol ]]; then
			__print_lines "$protocol" || return
		else
			return 42 # ENOPROTOOPT 42 Protocol not available
		fi
	}

	function __format_protocol {
		# process
		local item protocol='' remote='' url=''
		while [[ $# -ne 0 ]]; do
			item="$1"
			shift
			case "$item" in
			--protocol=*) protocol="${item#*=}" ;;
			ssh | http | https) protocol="$item" ;;
			--url=* | --remote-url=*) url="${item#*=}" ;;
			--remote=* | --remote-name=* | --name=*) remote="${item#*=}" ;;
			--*) __unrecognised_flag "$item" || return ;;
			*) __unrecognised_argument "$item" || return ;;
			esac
		done

		# adjustments
		protocol="$(__get_protocol --protocol="$protocol")"
		if [[ -z $url ]]; then
			url="$(__remote --url --remote="$remote")" || return
		fi

		# remove ssh prefix
		url="${url#*git@}"
		# remove https prefix
		url="${url#*://}"
		# remove .git suffix
		url="${url%.git*}"

		# fetch domain
		local domain
		domain="${url%:*}"
		if [[ -z $domain || $domain == "$url" ]]; then
			domain="${url%/*}"    # trims repo
			domain="${domain%/*}" # trims user
		fi
		# __print_lines "domain=$domain"

		# fetch subpath
		local subpath
		subpath="${url#*:}"
		if [[ -z $subpath || $subpath == "$url" ]]; then
			subpath="${url#*/}"
		fi

		if [[ $protocol == 'https' ]]; then
			__print_lines "https://$domain/$subpath.git"
		elif [[ $protocol == 'ssh' ]]; then
			# ssh://git@github.com/balupton/dotfiles.git
			# and
			# git@github.com:balupton/dotfiles.git
			# are both SSH urls
			__print_lines "git@$domain:$subpath.git"
		else
			return 1
		fi
	}

	function __update_protocol {
		# process
		local item protocol='' remote='' url=''
		while [[ $# -ne 0 ]]; do
			item="$1"
			shift
			case "$item" in
			--protocol=*) protocol="${item#*=}" ;;
			ssh | http | https) protocol="$item" ;;
			--remote=* | --remote-name=* | --name=*) remote="${item#*=}" ;;
			--url=* | --remote-url=*) url="${item#*=}" ;;
			--*) __unrecognised_flag "$item" || return ;;
			*) __unrecognised_argument "$item" || return ;;
			esac
		done

		# adjust
		if [[ -z $remote ]]; then
			remote="$(__remote --remote="$remote")" || return
		fi
		if [[ -n $url ]]; then
			__remote --remote="$remote" --url="$proposed_url" || return
		fi
		if [[ -z $protocol ]]; then
			protocol="$(__get_protocol --verify --protocol="$protocol")" || return
		fi

		# process
		local original_url https_url ssh_url proposed_url=''
		original_url="$(__remote --url --remote="$remote" || :)"
		https_url="$(__format_protocol --url="$original_url" --protocol=https)" || return
		ssh_url="$(__format_protocol --url="$original_url" --protocol=ssh)" || return
		proposed_url="$(__format_protocol --url="$original_url" --protocol="$protocol")" || return

		# apply difference if necessary
		if [[ $proposed_url != "$original_url" ]]; then
			__remote --remote="$remote" --url="$proposed_url" || return # this will set a non-existent remote
		fi
		# @todo there is an [else] edge case here where the remote does not exist, in which the below will fail

		# test application
		function __test_with_fallback {
			local protocol="$1" url="$proposed_url" pending success failure status
			pending="$(__print_style --bold='Testing ' --variable={remote} ' on ' --variable={repository} ' to ' --variable={url} ' via ' --variable={protocol})" || return
			success="$(__print_style --success='Using ' --variable={remote} ' on ' --variable={repository} ' to ' --variable={url} ' via ' --variable={protocol})" || return
			failure="$(__print_style --error='Failed ' --variable={remote} ' on ' --variable={repository} ' to ' --variable={url} ' via ' --variable={protocol})" || return
			__try {status} -- \
				eval-helper --quiet --pending="$pending" --success="$success" --failure="$failure" \
				-- git-helper --path="$repository" has-remote --remote="$remote"
			if [[ $status -eq 0 ]]; then
				return 0
			else
				if [[ $protocol == 'ssh' ]]; then
					if confirm --positive --ppid=$$ -- "Protocol [$protocol] failed, try HTTPS?"; then
						__remote --remote="$remote" --url="$https_url" || return
						__test_with_fallback 'https' || return
					else
						return 1
					fi
				else
					if confirm --positive --ppid=$$ -- "Protocol [$protocol] failed, try SSH?"; then
						__remote --remote="$remote" --url="$ssh_url" || return
						__test_with_fallback 'ssh' || return
					else
						return 1
					fi
				fi
			fi
		}
		__test_with_fallback "$protocol"
	}

	# =================================
	# Remotes

	function __remotes {
		__unrecognised_arguments "$@" || return
		# verify path, assumed verified for other actions
		local remote_status remote_output
		__do --redirect-status={remote_status} --redirect-output={remote_output} \
			-- git remote || return
		if [[ $remote_status -eq 128 ]]; then
			__print_error 'The directory ' --path="$repository" ' is not a git repository.' || :
			if [[ -n $remote_output ]]; then
				__print_lines "$remote_output" >&2 || :
			fi
			return "$status" # makes more sense to continue inheriting the git exit status 128 than converting it to EFTYPE 79 Inappropriate file type or format
		elif [[ -z $remote_output ]]; then
			__print_error 'The directory ' --path="$repository" ' is a git repository without any remotes.' || :
			return 91 # ENOMSG 91 No message of desired type
		elif [[ $remote_status -ne 0 ]]; then
			__print_error 'The directory ' --path="$repository" ' failed with the exit exit status of ' --status="$git_status" ' when fetching its remotes.' || :
			if [[ -n $remote_output ]]; then
				__print_lines "$remote_output" >&2 || :
			fi
			return "$remote_status"
		else
			__print_lines "$remote_output" || return
		fi
	}

	function __remote {
		# process
		local item has='no' url='no' verify='no' remote=''
		while [[ $# -ne 0 ]]; do
			item="$1"
			shift
			case "$item" in
			--no-has* | --has*) __flag --source={item} --target={has} --affirmative --coerce || return ;;
			--no-url* | --url*) __flag --source={item} --target={url} --affirmative --no-coerce || return ;;
			--no-verify* | --verify*) __flag --source={item} --target={verify} --affirmative --coerce || return ;;
			--no-remote* | --remote*) __flag --source={item} --target={remote} --affirmative --no-coerce || return ;;
			--*) __unrecognised_flag "$item" || return ;;
			*) __unrecognised_argument "$item" || return ;;
			esac
		done

		# fetch and verify
		if [[ $remote == 'yes' ]]; then
			remote=''
		fi
		if [[ -z $remote || $verify != 'no' ]]; then
			local remotes=()
			__split --target={remotes} --no-zero-length --invoke -- \
				__remotes || return
			remote="$(choose --required --no-confirm-default --no-confirm-solo \
				--question="Which repository remote to select for the repository?" \
				--question="$repository" \
				--default-exact="$remote" -- "${remotes[@]}")" || return
		fi

		# has/get
		if [[ $has == 'yes' ]]; then
			return 0
		elif [[ $url == 'yes' ]]; then
			git remote get-url "$remote" || return
		elif [[ -n $url && $url != 'no' ]]; then
			# set the url

			# remove and add
			git remote remove "$remote" 2>/dev/null || : # don't care if doesn't exist, and remove to ensure desired URL is applied
			git remote add "$remote" "$url" || return

			# ensure it changed, as git rules may have prevented it
			local result_url
			result_url="$(git remote get-url "$remote")" || return
			if [[ $result_url != "$url" ]]; then
				# it did not change, failure condition

				# output details
				__print_error 'The remote ' --variable-value={remote} ' of ' --url="$url" ' resulted instead in ' --url="$result_url" ' this indicates you have a conflicting replacement rule.' || :

				# and check to see if it was git config rewrite rules to blame
				local global_lines='' local_lines=''
				global_lines="$(git config --global --list | grep --fixed-strings --regexp='.insteadof=')" || :
				if [[ -n $global_lines ]]; then
					__print_style --stderr --bold='These rules of your global git config could be to blame:' --newline --code="$global_lines" || :
				fi
				local_lines="$(git config --list | grep --fixed-strings --regexp='.insteadof=')"
				if [[ -n $local_lines ]]; then
					__print_style --stderr --bold='These rules of your global git config could be to blame:' --newline --code="$local_lines" || :
				fi
				if [[ -n $local_lines || -n $local_lines ]]; then
					__print_style --stderr --notice='Remove them running the following:' || :
					echo-regexp -gomn '^(.+)=.*$' 'git config --global --unset $1' -- "$local_lines" >&2 || :
					echo-regexp -gomn '^(.+)=.*$' 'git config --unset $1' -- "$local_lines" >&2 || :
				fi

				# note the failure
				return 100 # EPROTO 100 Protocol error
			fi
		else
			__print_lines "$remote" || return
		fi
		return 0
	}

	# =====================================
	# Repository Properties

	function __is_shallow_clone {
		__unrecognised_arguments "$@" || return
		[[ "$(git rev-parse --is-shallow-repository || :)" != 'false' ]] || return
	}

	function __get_github_slug {
		__unrecognised_arguments "$@" || return
		git remote -v | echo-regexp -o --regexp='.+?github[.]com[:/](.+?)[.]git.+' --replace='$1' || return
	}

	# verify repository
	function __verify {
		__unrecognised_arguments "$@" || return
		local git_status git_output
		__do --redirect-status={git_status} --redirect-output={git_output} -- git status || return
		if [[ $git_status -eq 128 ]]; then
			__print_error 'The directory ' --path="$repository" ' is not a git repository.' || :
			if [[ -n $git_output ]]; then
				__print_lines "$git_output" >&2 || :
			fi
			return "$git_status" # makes more sense to continue inheriting the git exit status 128 than converting it to EFTYPE 79 Inappropriate file type or format
		elif [[ $git_status -ne 0 ]]; then
			__print_error 'The directory ' --path="$repository" ' failed with the git exit status of ' --status="$git_status" ' when fetching its status via ' --code='git status' || :
			if [[ -n $git_output ]]; then
				__print_lines "$git_output" >&2 || :
			fi
			return "$git_status"
		fi
		return 0
	}

	# =====================================
	# Repository

	function __update {
		# process
		local item remote='' url='' branch=''
		while [[ $# -ne 0 ]]; do
			item="$1"
			shift
			case "$item" in
			--remote=* | --remote-name=*) remote="${item#*=}" ;;
			--branch=* | --branch-name=*) branch="${item#*=}" ;;
			--url=* | --remote-url=*) url="${item#*=}" ;;
			--*) __unrecognised_flag "$item" || return ;;
			*)
				if [[ -n $item && -z $remote ]]; then
					remote="$item"
				elif [[ -n $item && -z $url ]]; then
					url+="$url"
				else
					__unrecognised_argument "$item" || return
				fi
				;;
			esac
		done

		# ensure
		remote="$(__remote --remote="$remote")" || return

		# log
		local header="Updating $repository from $remote"
		__print_style --h2="$header" || return

		# helper
		local PULL_OUTPUT_FILE
		PULL_OUTPUT_FILE="$(fs-temp --directory='dorothy' --directory='git-helper' --file --suffix='.pull-output')"
		function __do_the_fetch {
			local pending success failure
			pending="$(__print_style --bold='Fetching ' --bold='all remotes' ' on ' --variable={repository})" || return
			success="$(__print_style --success='Fetched ' --bold='all remotes' ' on ' --variable={repository})" || return
			failure="$(__print_style --error='Failed fetching ' --bold='all remotes' ' on ' --variable={repository})" || return
			eval-helper --quiet --pending="$pending" --success="$success" --failure="$failure" \
				-- git fetch --all --prune || return
		}
		function __do_the_pull {
			local pending success failure
			pending="$(__print_style --bold='Pulling ' --variable={branch} ' via ' --variable={remote} ' on ' --variable={repository})" || return
			success="$(__print_style --success='Pulled ' --variable={branch} ' via ' --variable={remote} ' on ' --variable={repository})" || return
			failure="$(__print_style --error='Failed pulling ' --variable={branch} ' via ' --variable={remote} ' on ' --variable={repository})" || return
			eval-helper --quiet --pending="$pending" --success="$success" --failure="$failure" --copy-stdout="$PULL_OUTPUT_FILE" \
				-- git pull "$remote" "$branch" || return
		}
		function __do_the_update {
			# avoid merge conflicts
			git config pull.ff only || return
			# add/update the remote url if specified
			if [[ -n $url ]]; then
				__remote --remote="$remote" --url="$url" || return
			fi
			# now that we know the remote name should exist, ensure it is the preferred protocol
			__update_protocol --remote="$remote" || return
			# update all origins, branches, and prune remote deleted branches
			__do_the_fetch || return
			# now that we have fetch, ensure the branch
			branch="$(__branch --remote="$remote" --branch="$branch")" || return
			# apply the remote changes to the local branch
			__do_the_pull "$branch" || return
		}

		# write to PULL_OUTPUT_FILE so that already updated can be detected
		# write to stderr so that [__update] returns only [failure|current|updated]
		# @todo style this with eval-helper pending/success/failure
		local update_status
		__do --redirect-status={update_status} --redirect-stdout=STDERR -- __do_the_update || return
		if [[ $update_status -ne 0 ]]; then
			# update failed
			__print_style --stderr --error1='git failed with exit status: ' --status="$update_status" --newline \
				--stdout=$'failure\n' \
				--tty --e2="$header" || :
			return 1
		elif grep --quiet --fixed-strings --regexp='Already' -- "$PULL_OUTPUT_FILE"; then
			# already up to date
			__print_style \
				--stdout=$'current\n' \
				--tty --g2="$header" || return
		else
			# updated successfully
			__print_style \
				--stdout=$'current\n' \
				--tty --g2="$header" || return
		fi
	}

	function __review {
		# @todo make this configurable
		if __command_exists -- gf; then
			gf "$repository" "$@" || return
		elif get-app --quiet -- 'Gitfox'; then
			open-app 'Gitfox' -- "$repository" "$@" || return
		elif __command_exists -- tower; then
			tower "$repository" "$@" || return
		elif get-app --quiet -- 'Tower'; then
			open-app 'Tower' -- "$repository" "$@" || return
		else
			__print_error 'No supported git reviewers installed.' || :
			return 93 # ENOATTR 93 Attribute not found
		fi
	}

	function __unstage {
		# https://stackoverflow.com/a/6919257
		git reset HEAD "$@" || return
	}

	function __wipe {
		__unrecognised_arguments "$@" || return
		if confirm --positive --ppid=$$ -- "Are you sure you want to wipe [$repository] to the last commit state, reverting all uncommitted files and changes?"; then
			git reset --hard || return
			git clean -f || return
		fi
	}

	function __umt {
		__unrecognised_arguments "$@" || return
		# https://serverfault.com/a/1031956
		# ^ all suggestions there have shortcomings, such as producing:
		# xargs: warning: options --max-args and --replace/-I/-i are mutually exclusive, ignoring previous --max-args value
		# this solves it:
		# git ls-tree -r --name-only HEAD -z | TZ=UTC xargs -0 -I_ git --no-pager log -1 --date=iso-local --format='%ad _' -- _ | echo-write | echo-regexp -gonm '^(.+?) \+0000 (.+)$' "TZ=UTC touch -md '\$1' '\$2'" | bash
		# however our below implementation is far easier, more understandable, just as quick, and supports paths with % and quotes:
		local subfiles=() subfile timestamp
		__split --target={subfiles} --no-zero-length --invoke -- \
			git ls-tree -r --name-only HEAD || return
		for subfile in "${subfiles[@]}"; do
			timestamp="$(TZ=UTC git --no-pager log -1 --date=iso-local --format='%ad' -- "$subfile")" || return
			# trim trailing +0000
			timestamp="${timestamp% +0000}"
			TZ=UTC touch -md "$timestamp" -- "$subfile" || return
		done
	}

	# =====================================
	# Action

	# enter the path so that git commands work correctly
	cd "$option_path"

	# verify?
	if [[ $option_verify == 'yes' ]]; then
		__verify || return
	fi

	# perform the action
	case "$action" in
	# authors
	authors) __authors "${option_args[@]}" ;;
	emails) __emails "${option_args[@]}" ;;
	author | author-update | update-author) __update_author "${option_args[@]}" ;;
	# branches
	branch) __branch "${option_args[@]}" ;;
	active-branch | current-branch) __branch "${option_args[@]}" --active --no-default --no-env --no-usual --verify ;;
	default-branch) __branch "${option_args[@]}" --no-active --verify ;;
	# commits
	commit) __commit "${option_args[@]}" ;;
	first-commit-url) __commit "${option_args[@]}" --first --url ;;
	# files
	file) __file "${option_args[@]}" ;;
	has-file) __file "${option_args[@]}" --has ;;
	has-remote-file) __file "${option_args[@]}" --has --no-local ;;
	get-remote-file) __file "${option_args[@]}" --no-local ;;
	# special files
	is-dorothy) __is_dorothy "${option_args[@]}" ;;
	get-strongbox) __strongbox "${option_args[@]}" ;;
	is-strongbox) __strongbox "${option_args[@]}" --has ;;
	# protocol
	protocol) __get_protocol "${option_args[@]}" ;;
	protocol-update | update-protocol) __update_protocol "${option_args[@]}" ;;
	protocol-format | format-protocol) __format_protocol "${option_args[@]}" ;;
	# remotes
	remotes) __remotes "${option_args[@]}" ;;
	remote) __remote "${option_args[@]}" ;;
	has-remote | test-remote) __remote "${option_args[@]}" --has ;;
	set-remote | set-remote-url) __remote "${option_args[@]}" ;;
	# repository properties
	verify) __verify "${option_args[@]}" ;;
	github-slug) __get_github_slug "${option_args[@]}" ;;
	is-shallow) __is_shallow_clone "${option_args[@]}" ;;
	# repository
	update) __update "${option_args[@]}" ;;
	review) __review "${option_args[@]}" ;;
	unstage) __unstage "${option_args[@]}" ;;
	wipe) __wipe "${option_args[@]}" ;;
	umt | upstream-modification-times) __umt "${option_args[@]}" ;;
	*) help 'An unrecognised <action> was provided: ' --variable-value={action} ;;
	esac
)

# fire if invoked standalone
if [[ $0 == "${BASH_SOURCE[0]}" ]]; then
	git_helper "$@"
fi
