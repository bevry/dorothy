#!/usr/bin/env bash

function git_helper_test() (
	source "$DOROTHY/sources/bash.bash"
	eval-tester --ignore-stderr --status=22 -- git-helper --help

	# @todo add tests
	__print_style --notice='No tests have been implemented for git-helper yet.' || :
	return 0
)
function git_helper() (
	source "$DOROTHY/sources/bash.bash"

	# =====================================
	# Arguments

	function help {
		__print_help "$@" <<-EOF || return $?
			ABOUT:
			Helpers for working with git repositories.

			USAGE:
			\`git-helper [...options] <action> [--] [...args]\`

			OPTIONS:
			--path=<path> | --no-path
			    If <path> provided, use <path> for the repository.
			    If <path> omitted, use the current working directory for the repository.
			    If disabled, use a temporary directory for the git repository.
			--label=<label>
			    If <label> provided, refer to the repository as <label> in any messaging.

			ACTIONS:
			& authors
			    Output all authors (contributors) within this git repository.
			& emails
			    Output all author emails within this git repository.
			& update-author --old=<old-email> --new=<new-email> --name=<new-name>
			    Update an author's name and email.

			& branch [...arguments]
			    Select a branch from the repository.
			    --remote=<remote> | --[no-]remote
			    --branch=<branch> | --[no-]branch
			    --[no-]check
			    --[no-]verify
			    --[no-]active
			    --[no-]default
			    --[no-]local
			    --[no-]global
			    --[no-]env
			    --[no-]usual
			& current-branch [...arguments]
			    Alias of \`branch\` action with arguments that fetch the current branch.
			& default-branch [...arguments]
			    Alias of \`branch\` action with arguments that fetch the default branch.

			& commit --hash=<hash>|--first [...arguments]
			    Select a commit from the repository.
			    --hash=<hash> | --first
			        If <hash> provided, select this commit hash.
			        If <first> provided, select the first commit.
			    --url
			        If enabled, output the commit URL.
			    --log
			        If enabled, output the commit log of the <hash>.
			& first-commit [...arguments]
			    Alias of \`commit --first [...arguments]\`
			& first-commit-log|first-commit-entry [...arguments]
			    Alias of \`commit --first --log [...arguments]\`
			& first-commit-hash [...arguments]
			    Alias of \`commit --first --hash [...arguments]\`
			& first-commit-url [...arguments]
			    Alias of \`commit --first --url [...arguments]\`

			& file --file=<file> [...arguments]
			    Select a file from the repository.
			    --[no-]check
			    --[no-]local
			    --remote=<remote> | --[no-]remote
			    --branch=<branch> | --[no-]branch
			& has-file [...arguments]
			    Alias for \`file [...arguments]\` action with arguments that check if the file exists.
			& has-remote-file [...arguments]
			    Alias for \`file [...arguments]\` action with arguments that check if the remote file exists.
			& get-remote-file [...arguments]
			    Alias for \`file [...arguments]\` action with arguments that fetch the remote file contents.

			& is-dorothy [...arguments]
			    Alias for \`file [...arguments]\` action with arguments that check if the repository is a Dorothy repository.
			& strongbox|get-strongbox [...arguments]
			    Alias for \`file [...arguments]\` action with arguments that fetch the strongbox configuration file if it exists.
			& is-strongbox [...arguments]
			    Alias for \`file [...arguments]\` action with arguments that check if the repository contains configuration to encrypt files with Strongbox.

			& protocol [...arguments]
			    Get or prompt the protocol to use for the repository.
			    --protocol=<protocol:ssh|https>
			        Get the <protocol> to use. If no <protocol> is provided, then prompt an available protocol.
			    --[no-]test
			        If enabled, only permit SSH if SSH can successfully connect to GitHub.

			& remotes
			    Output each git remote on a newline, same as \`git remote\` but with verbose repository checks.

			& remote [...arguments]
			    Get, apply, or check the <url> or <remote> in <protocol>.
			    If neither <url> and <remote> are provided, then <mode:get|apply|check> and prompt for the <remote>.
			    If only <url> is provided, then <mode:get> the <url> in the <protocol>.
			    If only <remote> is provided, then <mode:get|check|apply> and default <url> to the <remote>'s URL in <protocol>.
			    If both <url> and <remote> are provided, then <mode:get|check|apply> the <remote>'s URL against <url> in <protocol>.
			    --mode=<mode:get|apply|check> | --get|--apply|--check
			        The <mode> of operation. Defaults to <mode:get>.
			    --protocol=<protocol:ssh|https> | --[no-]protocol
			        The <protocol> to format the <url> in.
			        If no <protocol> is provided nor configured, then prompt from an available protocol.
			        If disabled, do not adjust <url> to the protocol.
			    --remote=<remote>
			        If provided with <url>, <mode:apply|check> the <remote>'s URL to <url>, or <mode:get> get <url> in <protocol> and ignore <remote>.
			        If provided without <url>, default <url> to the <remote>'s URL.
			    --url=<url>
			        If provided with <remote>, <mode:apply|check> the <remote>'s URL to <url>.
			        If provided with <mode:get>, then <url> in the <protocol>.
			    --result=<result:url|remote> | --[no-]result
			        What to return.
			        If not provided, then defaults to disabled with <mode:check>, otherwise defaults to <result:remote>.
			    --[no-]verify
			        If enabled, verify the applied <remote>'s URL matches the <url>.
			        Will default to enabled if <remote> and <url> is provided with <mode:apply|check>.
			    --[no-]test
			        If enabled, test the connection to <remote>.
			        Will default to enabled if <remote> and <url> is provided with <mode:apply>.
			    --depth=<depth> | --unshallow
			        Prune the remote's fetched history to <depth> commits from tip.
			        If \`0\` or <unshallow>, then unshallow the history.
			        Only applicable with <test> enabled.
			& url [...arguments]
			    Alias for \`remote --result=url [...arguments]\`

			& verify
			    Verify the <path> contains an initialised git repository.
			& github-slug
			    Output the github slug for this repository.
			& is-shallow
			    Is the repository a shallow clone?

			& sync [...arguments]
			    Sync the git repository at <path> with its remote.
			    STDOUT will be either: \`failure\`, \`current\`, or \`updated\`.
			    --remote=<remote>
			        If provided, use this <remote> instead of the repository's or git's default.
			    --url=<url>
			        If provided, then configure and sync the remote to this <url>.
			    --branch=<branch>
			        If provided, sync with this branch, instead of the current branch, or if indeterminate, the default branch.
			    --depth=<depth> | --unshallow
			        If cloning or pulling, only fetch <depth> commits from tip.
			        If \`0\` or <unshallow>, then unshallow the history.
			    --[no-]rebase
			        If pulling, rebase our changes atop of the remote changes, useful to avoid diverging branch blocks.
			    --[no-]new [...arguments]
			        If enabled, create the hosted repository if it doesn't exist.
			        --name=<name>
			            If provided, elect this <name> for the created repository.
			        --description=<description>
			            If provided, elect this <description> for the created repository.
			    --[no-]init
			        If enabled, initialise the repository if not already initialised.
			        If disabled or omitted, will not initialise.
			    --[no-]update | --update=optional
			        If enabled or omitted, then will update repository, and fail unable.
			        If set to \`optional\`, then will update the repository, but will ignore update failures.
			        If disabled, then will not update.
			& new [...arguments]
			    Alias for \`sync --new --no-init --no-update [...arguments]\`
			    Only creates the remote hosted repository, does not bind it locally.
			& create [...arguments]
			    Alias for \`sync --new --init --update=optional [...arguments]\`
			    Creates the remote hosted repository, binds it locally.
			& init [...arguments]
			    Alias for \`sync --no-new --init --no-update [...arguments]\`
			    Only initialize the <path> as a git repository.
			& clone [...arguments]
			    Alias for \`sync --no-new --init --update [...arguments]\`
			    Ensure the <path> is a git repository and update it.
			& fetch|pull|update [...arguments]
			    Alias for \`sync --no-new --no-init --update [...arguments]\`
			    Ensure an existing <path> repository is updated.

			& review [...arguments]
			    Open the git repository in your desired git reviewer. Supports: \`GitFox\`, \`Tower\`
			    ...<argument>
			        Forwarded to the reviewer.
			& unstage [...arguments]
			    Unstage the staged changes, without deleting or removing anything.
			    ...<argument>
			        Forwarded to \`git reset HEAD ...<argument>\`
			& wipe
			    Wipe the current working directory to the state of the last commit. There will be a confirmation.
			& umt | upstream-modification-times
			    Update the modification times of cloned files to that of their commits, rather than the time of cloning.
		EOF
		return 22 # EINVAL 22 Invalid argument
	}

	# process
	local item action='' option_path='' option_label='' option_args=() # option_quiet='no'
	while [[ $# -ne 0 ]]; do
		item="$1"
		shift
		case "$item" in
		--help | -h) help ;;
		--no-color* | --color*) __flag --source={item} --target={COLOR} --affirmative --export || return $? ;;
		# --no-verbose* | --verbose*) __flag --source={item} --target={option_quiet} --non-affirmative --coerce || return $? ;;
		# --no-quiet* | --quiet*) __flag --source={item} --target={option_quiet} --affirmative --coerce || return $? ;;
		--path=*) option_path="${item#*=}" ;;
		--no-path) option_path="$(fs-temp --cache --directory='dorothy' --directory='git-helper' --directory)" || return $? ;;
		--label=*) option_label="${item#*=}" ;;
		--)
			option_args+=("$@")
			shift "$#"
			break
			;;
		--*) option_args+=("$item") ;;
		*)
			if [[ -z $action ]]; then
				action="$item"
			else
				option_args+=("$item")
			fi
			;;
		esac
	done

	# label
	if [[ -z $option_label ]]; then
		option_label='repository'
	fi

	# check
	if [[ -z $action ]]; then
		help 'No ' --code='<action>' ' was provided.'
	fi

	# @todo use the eval-helper flow to auto-elevate and store if elevation is needed for use with the git calls
	# ensure path, and verify
	if [[ -z $option_path ]]; then
		option_path="$(pwd)" || return $?
	elif [[ $action == 'sync' ]] && is-missing -- "$option_path"; then
		fs-mkdir -- "$option_path" || return $?
	elif is-not-directory -- "$option_path"; then
		__print_error 'The path ' --path="$option_path" ' is not a git repository, because it is not a directory.' || :
		return 2 # ENOENT 2 No such file or directory
	fi

	# enter the path so that git commands work correctly
	cd "$option_path"

	# =====================================
	# Configuration

	source "$DOROTHY/sources/config.sh"

	# git.bash provides:
	local GIT_DEFAULT_BRANCH='main'
	local GIT_PROTOCOL='' # 'https', or 'ssh'
	load_dorothy_config 'git.bash'

	# =====================================
	# Authors

	# authors
	function __authors {
		__unrecognised_arguments "$@" || return $?
		git shortlog --summary --email | cut -f2- || return $?
	}

	# emails
	function __emails {
		__unrecognised_arguments "$@" || return $?
		git shortlog --summary --email | echo-regexp -ong --regexp='<(.+?)>' --replace='$1' || return $?
	}

	# author-update
	function __update_author {
		# process
		local item old_email='' new_email='' new_name=''
		while [[ $# -ne 0 ]]; do
			item="$1"
			shift
			case "$item" in
			--old=* | --old-email=*) old_email="${item#*=}" ;;
			--new=* | --new-email=*) new_email="${item#*=}" ;;
			--name=* | --new-name=*) new_name="${item#*=}" ;;
			*)
				if [[ -z $old_email ]]; then
					old_email="$item"
				elif [[ -z $new_email ]]; then
					new_email="$item"
				elif [[ -z $new_name ]]; then
					new_name="$item"
				else
					__unrecognised_argument "$item" || return $?
				fi
				;;
			esac
		done

		# validate and isolate old email
		local emails=()
		__split --target={emails} --no-zero-length --invoke -- \
			__emails
		old_email="$(
			choose --linger --required --no-confirm-solo \
				--question='Which email to update from the repository?' \
				--question="$option_path" \
				--default="$old_email" -- \
				"${emails[@]}"
		)"

		# ensure emails
		new_email="$(
			ask --linger --required \
				--question='What is the new email?' \
				--default="$new_email"
		)"
		new_name="$(
			ask --linger --required \
				--question='What is the new name?' \
				--default="$new_name"
		)"

		# apply
		fs-remove --quiet --no-confirm -- ./.git/refs/original
		git filter-branch --env-filter "
			OLD_EMAIL=\"$old_email\"
			CORRECT_EMAIL=\"$new_email\"
			CORRECT_NAME=\"$new_name\"
			if [ \"\$GIT_COMMITTER_EMAIL\" = \"\$OLD_EMAIL\" ]; then
				export GIT_COMMITTER_NAME=\"\$CORRECT_NAME\"
				export GIT_COMMITTER_EMAIL=\"\$CORRECT_EMAIL\"
			fi
			if [ \"\$GIT_AUTHOR_EMAIL\" = \"\$OLD_EMAIL\" ]; then
				export GIT_AUTHOR_NAME=\"\$CORRECT_NAME\"
				export GIT_AUTHOR_EMAIL=\"\$CORRECT_EMAIL\"
			fi
		" --tag-name-filter cat -- --branches --tags
	}

	# =====================================
	# Branches

	function __branch {
		# process
		local item check='no' remote='' branch='' head='' active='' default='' local='' usual='' verify=''
		while [[ $# -ne 0 ]]; do
			item="$1"
			shift
			case "$item" in
			--no-check* | --check*) __flag --source={item} --target={check} --affirmative --coerce || return $? ;;
			--no-branch* | --branch*) __flag --source={item} --target={branch} --affirmative --no-coerce || return $? ;;
			--no-active* | --active*) __flag --source={item} --target={active} --affirmative --coerce || return $? ;;
			--no-head* | --head*) __flag --source={item} --target={head} --affirmative --coerce || return $? ;;
			--no-local* | --local*) __flag --source={item} --target={local} --affirmative --coerce || return $? ;;
			--no-remote* | --remote*) __flag --source={item} --target={remote} --affirmative --no-coerce || return $? ;;
			--no-default* | --default*) __flag --source={item} --target={default} --affirmative --coerce || return $? ;;
			--no-usual* | --usual*) __flag --source={item} --target={usual} --affirmative --coerce || return $? ;;
			--no-verify* | --verify*) __flag --source={item} --target={verify} --affirmative --coerce || return $? ;;
			--*) __unrecognised_flag "$item" || return $? ;;
			*) __unrecognised_argument "$item" || return $? ;;
			esac
		done

		# on a fresh init
		# `git rev-parse --abbrev-ref HEAD` will output HEAD but error
		# and `git branch -a` will output:
		# remotes/origin/HEAD -> origin/master
		# remotes/origin/master

		# adjustments for user error due to common conventions
		if [[ $branch =~ ^(yes|no)$ ]]; then
			branch=''
		fi

		# compile the branches
		local branches=() defaults=() skips=() local_branches=() remote_branches=() temp_list=() temp

		# add the argument branch to defaults
		if [[ -n $branch ]]; then
			defaults+=("$branch")
			skips+=("$branch")
		fi

		# add active branch
		if [[ $active != 'no' ]]; then
			temp="$(git rev-parse --abbrev-ref HEAD 2>/dev/null || :)"
			if [[ -n $temp ]]; then
				branches+=("$temp")
				defaults+=("$temp")
				if [[ $active == 'yes' ]]; then
					skips+=("$temp")
				fi
			fi
		fi

		# add local branches
		__split --target={local_branches} --overwrite --no-zero-length --invoke -- \
			git branch --list --format='%(refname:short)'
		if [[ $local != 'no' ]]; then
			branches+=("${local_branches[@]}")
		fi

		# add remote branches, and prep filter
		__split --target={temp_list} --overwrite --no-zero-length --invoke -- \
			git branch --list --remotes --format='%(refname)'
		if [[ -n $remote && $remote != 'no' && $remote != 'yes' ]]; then
			for temp in "${temp_list[@]}"; do
				if [[ $temp == "refs/remotes/$remote/"* ]]; then
					remote_branches+=("${temp#refs/remotes/*/}")
				fi
			done
			if [[ ${#remote_branches[@]} -eq 0 ]]; then
				__print_error 'The desired remote of ' --value="$remote" ' has no branches in the repository at ' --path="$option_path" '. Perhaps you need to fetch first.' || return $?
				return 93 # ENOATTR 93 Attribute not found
			fi
		else
			remote_branches+=("${temp_list[@]#refs/remotes/*/}")
		fi
		if [[ $remote != 'no' ]]; then
			branches+=("${remote_branches[@]}")
		fi

		# add default branches
		if [[ $default != 'no' ]]; then
			temp="$(git config --local init.defaultBranch 2>/dev/null || :)"
			if [[ -n $temp ]]; then
				defaults+=("$temp")
				if [[ $default == 'yes' ]]; then
					skips+=("$temp")
				fi
			fi
			if [[ -n $GIT_DEFAULT_BRANCH ]]; then
				defaults+=("$GIT_DEFAULT_BRANCH")
				if [[ $default == 'yes' ]]; then
					skips+=("$GIT_DEFAULT_BRANCH")
				fi
			fi
			temp="$(git config --global init.defaultBranch 2>/dev/null || :)"
			if [[ -n $temp ]]; then
				defaults+=("$temp")
				if [[ $default == 'yes' ]]; then
					skips+=("$temp")
				fi
			fi
		fi

		# add usual
		if [[ $usual != 'no' ]]; then
			defaults+=(main master)
		fi

		# unique the branches
		__unique --source+target={branches} || return $?
		__unique --source+target={defaults} || return $?
		__unique --source+target={skips} || return $?

		# evict head branches
		if [[ $head == 'no' ]]; then
			# as we have done unique, there will only be one
			__evict --source+target={branches} --first --optional --value='HEAD' || return $?
			__evict --source+target={defaults} --first --optional --value='HEAD' || return $?
			__evict --source+target={skips} --first --optional --value='HEAD' || return $?
		fi

		# if we are filtering, then filter
		local filtered
		if [[ $local == 'no' ]]; then
			# evict branches that are only local
			filtered=()
			for temp in "${branches[@]}"; do
				if ! __has --source={local_branches} -- "$temp" || __has --source={remote_branches} -- "$temp"; then
					filtered+=("$temp")
				fi
			done
			branches=("${filtered[@]}")
		fi
		if [[ $remote == 'no' ]]; then
			# evict branches that are only remote
			filtered=()
			for temp in "${branches[@]}"; do
				if ! __has --source={remote_branches} -- "$temp" || __has --source={local_branches} -- "$temp"; then
					filtered+=("$temp")
				fi
			done
			branches=("${filtered[@]}")
		fi

		# validate
		if [[ ${#branches[@]} -eq 0 ]]; then
			__print_error 'No branches at ' --path="$option_path" ' matched the requirements.' || return $?
			return 93 # ENOATTR 93 Attribute not found
		fi

		# skip now if the skip branch branch actually exists
		# if not verifying, then just make it the first preference
		# @todo this may be a mistake, and if not verifying, we may just want to return the first skip? but that seems strange
		# maybe if not verifying, it should be the first skip that exists, otherwise the first skip that doesn't exist, otherwise the first default that exists, otherwise the first default that doesn't exist, ... but who knows
		# need a use case that challenges this
		for temp in "${skips[@]}"; do
			if __has --source={branches} -- "$temp"; then
				__print_lines "$temp" || return $?
				return 0
			fi
		done

		# handle verify vs no verify
		if [[ $verify == 'no' ]]; then
			# not verify, so we don't care if branches exist, so just prepend skips and defaults to branches
			branches+=("${skips[@]}" "${defaults[@]}")
			__unique --source+target={branches} || return $?
		else
			# redo branches in preferred order
			temp_list=()
			for temp in "${skips[@]}" "${defaults[@]}"; do
				if __has --source={branches} -- "$temp"; then
					temp_list+=("$temp")
				fi
			done
			branches=("${temp_list[@]}")
			__unique --source+target={branches} || return $?
		fi

		# if solo, then skip confirm which lingers
		if [[ ${#branches[@]} -eq 1 ]]; then
			__print_lines "${branches[0]}" || return $?
			return 0
		fi

		# select
		choose --linger --required --no-confirm-solo \
			--question="Which branch to select for the repository?" \
			--question="$option_path" \
			--defaults-exact="$(__print_lines "${skips[@]}" "${defaults[@]}")" -- \
			"${branches[@]}" || return $?

		# done
		return 0
	}

	# =====================================
	# Commits

	function __commit {
		# process
		local item first='no' hash='' url='' log=''
		while [[ $# -ne 0 ]]; do
			item="$1"
			shift
			case "$item" in
			--no-first* | --first*) __flag --source={item} --target={first} --affirmative --coerce || return $? ;;
			--no-hash* | --hash*) __flag --source={item} --target={hash} --affirmative --no-coerce || return $? ;;
			--no-url* | --url*) __flag --source={item} --target={url} --affirmative --no-coerce || return $? ;;
			--no-log* | --log*) __flag --source={item} --target={log} --affirmative --no-coerce || return $? ;;
			--*) __unrecognised_flag "$item" || return $? ;;
			*) __unrecognised_argument "$item" || return $? ;;
			esac
		done

		# first
		if [[ $first == 'yes' ]]; then
			hash="$(git log --reverse --oneline | echo-first-line | echo-regexp -o --regexp='(.+?) .+' --replace='$1' || :)"
		fi

		# verify
		__affirm_value_is_defined "$hash" '--hash=<commit-hash>' || return $?

		# action
		if [[ $url == 'yes' ]]; then
			slug="$(__get_github_slug)" || return $?
			__print_lines "https://github.com/$slug/commit/$hash" || return $?
		elif [[ $log == 'yes' ]]; then
			git log -1 "$hash" || return $?
		else
			__print_lines "$hash" || return $?
		fi
	}

	# =====================================
	# Files

	function __file {
		# process
		local item check='no' local='' remote='' branch='' file=''
		while [[ $# -ne 0 ]]; do
			item="$1"
			shift
			case "$item" in
			--no-check* | --check*) __flag --source={item} --target={check} --affirmative --coerce || return $? ;;
			--no-local* | --local*) __flag --source={item} --target={local} --affirmative --coerce || return $? ;;
			--no-remote* | --remote*) __flag --source={item} --target={remote} --affirmative --no-coerce || return $? ;;
			--no-branch* | --branch*) __flag --source={item} --target={branch} --affirmative --no-coerce || return $? ;;
			--file=* | --subpath=* | --path=*) file="${item#*=}" ;;
			--*) __unrecognised_flag "$item" || return $? ;;
			*) __unrecognised_argument "$item" || return $? ;;
			esac
		done

		# file
		__affirm_value_is_defined "$file" '--file=<file>' || return $?

		# local subpaths
		if [[ $local != 'no' && (-z $remote || $remote == 'no') ]]; then
			if [[ -z $branch || $branch == 'no' ]]; then
				# check
				if [[ $check == yes ]]; then
					if [[ -f $file ]]; then
						return 0
					fi
				else
					if cat "$file" 2>/dev/null; then
						return 0
					fi
				fi
			else
				local local_branch
				local_branch="$(__branch --no-remote --branch="$branch" --verify)" || return $?
				# check
				if [[ $check == yes ]]; then
					if git cat-file -e "$local_branch:$file" 2>/dev/null; then
						return 0
					fi
				else
					if git cat-file -p "$local_branch:$file" 2>/dev/null; then
						return 0
					fi
				fi
			fi
		fi

		# remote subpaths
		if [[ $remote != 'no' ]]; then
			remote="$(__remote --remote="$remote")" || return $?
			# remote requires branch, so ignore branch=no
			local remote_branch
			remote_branch="$(__branch --remote="$remote" --branch="$branch" --verify)" || return $?
			# check
			if [[ $check == yes ]]; then
				if git cat-file -e "$remote/$remote_branch:$file" 2>/dev/null; then
					return 0
				fi
			else
				if git cat-file -p "$remote/$remote_branch:$file" 2>/dev/null; then
					return 0
				fi
			fi
		fi

		# failure
		return 93 # ENOATTR 93 Attribute not found
	}

	# helper
	function __dorothy_grep {
		__unrecognised_arguments "$@" || return $?
		grep --quiet --fixed-strings \
			--regexp='Dorothy User Configuration' \
			--regexp='https://github.com/bevry/dorothy' \
			--regexp='https://dorothy.bevry.me' || return $?
	}

	# is-dorothy / has-dorothy-remote-file
	function __is_dorothy {
		__file "$@" --file='README.md' | __dorothy_grep || return $?
	}

	# strongbox / get-strongbox / is-strongbox
	function __strongbox {
		__file "$@" --file='.strongbox-keyid' || return $?
	}

	# =====================================
	# Protocols

	local PROTOCOLS=()

	function __load_protocols {
		__unrecognised_arguments "$@" || return $?
		if [[ ${#PROTOCOLS[@]} -eq 0 ]]; then
			# test a generic ssh connection to github
			# @todo it does support a url argument, for if we want to properly test a SSH remote
			if ssh-helper test &>/dev/null; then
				PROTOCOLS+=('ssh')
			fi
			PROTOCOLS+=('https')
		fi
	}

	function __get_validated_protocol {
		local protocol="$1"
		if [[ -z $protocol ]]; then
			return 0
		elif [[ $protocol == 'http' ]]; then
			__print_lines 'https' || return $?
		elif [[ $protocol =~ ^(ssh|https)$ ]]; then
			__print_lines "$protocol" || return $?
		else
			__print_error 'The protocol ' --value="$protocol" ' is not supported. Supported protocols are: ' --code='https' ' and ' --value='ssh' || :
			return 22 # EINVAL 22 Invalid argument
		fi
	}

	function __protocol {
		# process
		local item protocol='' test='no'
		while [[ $# -ne 0 ]]; do
			item="$1"
			shift
			case "$item" in
			--protocol=*) protocol="$(__get_validated_protocol "${item#*=}")" ;;
			--no-test* | --test*) __flag --source={item} --target={test} --affirmative --coerce || return $? ;;
			--*) __unrecognised_flag "$item" || return $? ;;
			*) __unrecognised_argument "$item" || return $? ;;
			esac
		done

		# protocols
		local protocols
		if [[ $test == 'yes' ]]; then
			__load_protocols || return $?
			protocols=("${PROTOCOLS[@]}")
		else
			protocols=('https' 'ssh')
		fi

		# prepare defaults
		# @todo do this same technique for preferred branch
		local defaults=() update_repo_config='no'
		if [[ -z $protocol ]]; then
			update_repo_config='yes'
			defaults=(
				"$protocol"
				"$(git config --local git.protocol 2>/dev/null || :)"
				"$GIT_PROTOCOL"
				"$(git config --global git.protocol 2>/dev/null || :)"
			)
			if [[ $IS_STDIN_OPENED_ON_TERMINAL == 'no' ]]; then
				defaults+=("${protocols[0]}")
			fi
			__unique --source+target={defaults} || return $?
			__evict --source+target={defaults} --optional --first --value='' || return $?
		fi
		# __dump {protocol} {protocols} {defaults} {mode} {GIT_PROTOCOL} >&2 || return $?

		# this choose selects but also filters to tested protocols
		# @todo update `__load_protocols` to test `remotes` instead of generic protocol testing
		if [[ -z $protocol || $test == 'yes' ]]; then
			protocol="$(choose --required --no-confirm-default --no-confirm-solo \
				--question='Which git protocol to use on the repository?' \
				--question="$option_path" \
				--defaults-exact="$(__print_lines "${defaults[@]}")" -- "${protocols[@]}")" || return $?
			if [[ -n $protocol && $update_repo_config == 'yes' ]]; then
				# this could fail if it isn't already init'd
				# however, it is the best option, as it persists regardless of subshell
				git config --local git.protocol "$protocol" 2>/dev/null || :
				# do this, but it won't have an effect due to it not escaping the subshell
				if [[ -z $GIT_PROTOCOL ]]; then
					GIT_PROTOCOL="$protocol"
				fi
			fi
		fi

		# result
		if [[ -n $protocol ]]; then
			__print_lines "$protocol" || return $?
		elif [[ ${#defaults[@]} -ge 1 ]]; then
			__get_validated_protocol "${defaults[0]}" || return $?
		else
			return 42 # ENOPROTOOPT 42 Protocol not available
		fi
	}

	# =================================
	# Remotes

	function __remotes {
		__unrecognised_arguments "$@" || return $?
		# verify path, assumed verified for other actions
		local remote_status remote_output
		__do --redirect-status={remote_status} --redirect-output={remote_output} -- \
			git remote || return $?
		if [[ $remote_status -eq 128 ]]; then
			__print_error 'The directory ' --path="$option_path" ' is not a git repository.' || :
			if [[ -n $remote_output ]]; then
				__print_lines "$remote_output" >&2 || :
			fi
			return "$status" # makes more sense to continue inheriting the git exit status 128 than converting it to EFTYPE 79 Inappropriate file type or format
		elif [[ -z $remote_output ]]; then
			__print_error 'The directory ' --path="$option_path" ' is a git repository without any remotes.' || :
			return 91 # ENOMSG 91 No message of desired type
		elif [[ $remote_status -ne 0 ]]; then
			__print_error 'The directory ' --path="$option_path" ' failed with the exit exit status of ' --status="$git_status" ' when fetching its remotes.' || :
			if [[ -n $remote_output ]]; then
				__print_lines "$remote_output" >&2 || :
			fi
			return "$remote_status"
		else
			__print_lines "$remote_output" || return $?
		fi
	}

	# =================================
	# URLs

	function __get_username_fallback {
		local username
		username="$(get-profile username || :)"
		if [[ -z $username ]]; then
			return 93 # ENOATTR 93 Attribute not found
		fi
		if is-generic -- "$username"; then
			return 93 # ENOATTR 93 Attribute not found
		fi
		__print_lines "$username" || return $?
	}

	function __format_url_to_protocol {
		# process
		local item protocol='' url=''
		while [[ $# -ne 0 ]]; do
			item="$1"
			shift
			case "$item" in
			--protocol=*) protocol="${item#*=}" ;;
			--url=*) url="${item#*=}" ;;
			--*) __unrecognised_flag "$item" || return $? ;;
			*) __unrecognised_argument "$item" || return $? ;;
			esac
		done

		# ensure
		local original_url="$url"
		__affirm_value_is_defined "$protocol" '<protocol>' || return $?
		if ! [[ $protocol =~ ^(https|ssh)$ ]]; then
			return 14 # EFAULT 14 Bad address
		fi

		# convert urns
		local where='' slug=''
		if [[ $url =~ ^(gh|github): ]]; then
			# github:<project>
			# github:<username>/<project>
			where='github'
			__replace --source={url} --keep-after-first=':' --target={slug} || return $?
		elif [[ $url =~ ^(gl|gitlab): ]]; then
			# gitlab:<project>
			# gitlab:<username>/<project>
			where='gitlab'
			__replace --source={url} --keep-after-first=':' --target={slug} || return $?
		elif [[ $url =~ ^[^:/]+/[^:/]+$ ]]; then
			# <project>
			# <username>/<project>
			# assume github
			where='github'
			slug="$url"
		fi
		if [[ -n $slug ]]; then
			local username='' project=''
			if [[ $slug == */* ]]; then
				__replace --source={slug} --keep-before-first='/' --target={username} || return $?
				__replace --source={slug} --keep-after-first='/' --target={project} || return $?
				if [[ $project == */* ]]; then
					__print_error 'The URL ' --value="$original_url" ' is invalid as the project name contains a slash.' || :
					return 22 # EINVAL 22 Invalid argument
				fi
			else
				project="$slug"
			fi
			if [[ -z $project ]]; then
				__print_error 'The URL ' --value="$original_url" ' is invalid as it does not contain a project name.' || :
				return 22 # EINVAL 22 Invalid argument
			fi
			if [[ -z $username ]]; then
				username="$(__get_username_fallback)" || :
			fi
			if [[ -z $username ]]; then
				__print_error 'The URL ' --value="$original_url" ' is did not contain a username, and one could not be inferred.' || :
				return 22 # EINVAL 22 Invalid argument
			fi
			if [[ $protocol == 'https' ]]; then
				__print_lines "https://$where.com/$username/$project.git" || return $?
			else
				__print_lines "git@$where.com:$username/$project.git" || return $?
			fi
			return 0
		fi

		# HTTPS urls:
		# https://github.com/balupton/dotfiles.git
		# SSH urls:
		# ssh://git@github.com/balupton/dotfiles.git
		# git@github.com:balupton/dotfiles.git

		# remove ssh prefix
		url="${url#*git@}"
		# remove url protocol prefix, e.g. https://
		url="${url#*://}"
		# remove .git suffix
		url="${url%.git*}"

		# fetch domain
		local domain
		domain="${url%:*}"
		if [[ -z $domain || $domain == "$url" ]]; then
			domain="${url%/*}"    # trims project
			domain="${domain%/*}" # trims user
		fi

		# fetch subpath
		local subpath
		subpath="${url#*:}"
		if [[ -z $subpath || $subpath == "$url" ]]; then
			subpath="${url#*/}"
		fi

		# validate
		if [[ -z $domain || -z $subpath ]]; then
			__print_error 'The URL ' --value="$original_url" ' was malformed, could not determine its domain and subpath.' || :
			return 22 # EINVAL 22 Invalid argument
		fi

		# format
		if [[ $protocol == 'https' ]]; then
			__print_lines "https://$domain/$subpath.git" || return $?
		else
			__print_lines "git@$domain:$subpath.git" || return $?
		fi
	}

	function __url {
		__remote --result=url "$@" || return $?
	}

	function __remote {
		# process
		local item mode='get' protocol='' remote='' url='' result='' verify='' test='' depth=''
		while [[ $# -ne 0 ]]; do
			item="$1"
			shift
			case "$item" in
			--mode=get | --mode=apply | --mode=check) mode="${item#*=}" ;;
			--get | --apply | --check) mode="${item#--}" ;;
			--no-protocol* | --protocol*) __flag --source={item} --target={protocol} --affirmative --no-coerce || return $? ;;
			--remote=*) remote="${item#*=}" ;;
			--no-remote* | --remote*) __flag --source={item} --target={remote} --affirmative --no-coerce || return $? ;;
			--url=*) url="${item#*=}" ;;
			--no-result* | --result*) __flag --source={item} --target={result} --affirmative --no-coerce || return $? ;;
			--no-verify* | --verify*) __flag --source={item} --target={verify} --affirmative --coerce || return $? ;;
			--no-test* | --test*) __flag --source={item} --target={test} --affirmative --coerce || return $? ;;
			--depth=*) depth="${item#*=}" ;;
			--no-unshallow* | --unshallow*)
				__flag --source+target={item} --affirmative --coerce || return $?
				if [[ $item == 'yes' ]]; then
					depth=0
				fi
				;;
			--*) __unrecognised_flag "$item" || return $? ;;
			*) __unrecognised_argument "$item" || return $? ;;
			esac
		done

		# adjust verify and test
		if [[ -z $verify ]]; then
			if [[ $protocol == 'no' ]]; then
				verify='no'
			elif [[ -n $remote && -n $url && ($mode == 'apply' || $mode == 'check') ]]; then
				verify='yes'
			else
				verify='no'
			fi
		fi
		if [[ -z $test ]]; then
			if [[ -n $remote && -n $url && $mode == 'apply' ]]; then
				test='yes'
			else
				test='no'
			fi
		fi

		# adjust result
		if [[ -z $result ]]; then
			if [[ $mode == 'check' ]]; then
				result='no'
			else
				result='remote'
			fi
		fi
		if ! [[ $result =~ ^(url|remote|no)$ ]]; then
			__unrecognised_argument "--result=$result" || return $?
		fi

		# adjust protocol, no testing as we test via `git fetch` instead
		# if protocol is disabled, then it means no protocol adjustments
		if [[ $protocol != 'no' ]]; then
			if [[ $protocol == 'yes' ]]; then
				protocol=''
			fi
			protocol="$(__protocol --no-test --protocol="$protocol")"
		fi

		# adjust url, remote, and mode
		if [[ -n $url ]]; then
			# if url and remote, then this just means url with a remote fallback
			if [[ -z $remote || $mode == 'get' ]]; then
				# check for get
				# if non-get with url but no remote, then fail
				if [[ $mode != 'get' ]]; then
					help --code="$(echo-escape-command -- git-helper remote --mode="$mode" --url="$url")" ' without ' --code='--remote=<remote>' ' is pointless.' || return $?
				fi
				# now do format
				if [[ $protocol == 'no' ]]; then
					__print_lines "$url" || return $?
				else
					__format_url_to_protocol --url="$url" --protocol="$protocol" || return $?
				fi
				return $?
			fi
		fi

		# if no remote, then prompt for remote
		if [[ -z $remote ]]; then
			local remotes=()
			__split --target={remotes} --no-zero-length --invoke -- \
				__remotes || return $?
			remote="$(choose --required --no-confirm-default --no-confirm-solo \
				--question="Which git remote to select for the repository?" \
				--question="$option_path" \
				--default-exact="$remote" -- "${remotes[@]}")" || return $?
		fi

		# fetch the remote url for check or if no url
		local remote_url=''
		if [[ -z $url || $mode == 'check' ]]; then
			remote_url="$(git remote get-url "$remote" 2>/dev/null)" || return $?
			if [[ -z $remote_url ]]; then
				__print_error 'The remote ' --variable-value={remote} ' does not exist on the repository at ' --path="$option_path" ' so unable to fetch its URL.' || :
				return 93 # ENOATTR 93 Attribute not found
			fi
			if [[ -z $url ]]; then
				url="$remote_url"
			fi
		fi

		# process
		local https_url ssh_url protocol_url=''
		https_url="$(__format_url_to_protocol --url="$url" --protocol=https)" || return $?
		ssh_url="$(__format_url_to_protocol --url="$url" --protocol=ssh)" || return $?
		if [[ $protocol == 'no' ]]; then
			protocol_url="$url"
		else
			protocol_url="$(__format_url_to_protocol --url="$url" --protocol="$protocol")" || return $?
		fi
		function __set_remote_url {
			local custom_url="$1" result_url
			# if it exists, just update the url, so fetching is partial thus quicker
			if git remote get-url "$remote" &>/dev/null; then
				git remote set-url "$remote" "$custom_url" || return $?
			else
				# add if it doesn't exist
				git remote add "$remote" "$custom_url" || return $?
			fi
			# if not verifying, already done
			if [[ $verify == 'no' ]]; then
				return 0
			fi
			# check it has applied correctly
			result_url="$(git remote get-url "$remote")" || return $?
			if [[ $result_url != "$custom_url" ]]; then
				# output details
				__print_error 'The remote ' --variable-value={remote} ' resulted in ' --url="$result_url" ' instead of the desired ' --url="$custom_url" || :

				# and check to see if it was git config rewrite rules to blame
				local local_lines global_lines
				local_lines="$(git config --local --list | grep --fixed-strings --regexp='.insteadof=' || :)"
				if [[ -n $local_lines ]]; then
					__print_style --stderr --bold='These rules of your local git config could be to blame:' --newline --code="$local_lines" || :
				fi
				global_lines="$(git config --global --list | grep --fixed-strings --regexp='.insteadof=' || :)"
				if [[ -n $global_lines ]]; then
					__print_style --stderr --bold='These rules of your global git config could be to blame:' --newline --code="$global_lines" || :
				fi
				if [[ -n $local_lines || -n $local_lines ]]; then
					__print_style --stderr --notice='Remove them running the following:' || :
					echo-regexp -gomn '^(.+)=.*$' 'git config --local --unset $1' -- "$local_lines" >&2 || :
					echo-regexp -gomn '^(.+)=.*$' 'git config --global --unset $1' -- "$local_lines" >&2 || :
				fi

				# note the failure
				return 100 # EPROTO 100 Protocol error
			fi
		}

		# if check, then check the url matches
		if [[ $mode == 'check' && $remote_url != "$protocol_url" ]]; then
			return 93 # ENOATTR 93 Attribute not found
		fi

		# if apply, then apply, so the remote can be updated or even created
		if [[ $mode == 'apply' ]]; then
			__set_remote_url "$protocol_url" || return $?
		fi

		# test application
		function __test_with_fallback {
			# before this was `--dry-run --depth=1`, however specifying `--depth=<depth>` disregards `--dry-run` which then requires `git fetch --unshallow` to repair the `grafted` and diverged (diverged only in perception) commit history
			# there is `---negotiate-only` which seems like it would work, but it isn't
			# however, without any other args, it seems it will just do what was previously configured, however, this is called in `sync` before our initial fetch/pull, so respect the depth if one was provided, and file a bug with git that depth discards dry-run
			local depth_args=()
			# if our depth is 0, and if it is shallow
			if [[ -n $depth ]]; then
				if [[ $depth -ge 1 ]]; then
					# make shallow
					depth_args+=("--depth=$depth")
				elif [[ -e .git/shallow ]]; then
					# make unshallow
					depth_args+=('--unshallow')
				fi # else already unshallow
			fi
			# perform the fetch
			if eval-helper --quiet --wrap -- git fetch --dry-run "${depth_args[@]}" "$remote"; then
				return 0
			fi
			# it failed, handle fallback
			local tested_url
			tested_url="$(git remote get-url "$remote")" || return $?
			# @todo once `choose` supports `--inline` then change to `choose` instead of this `confirm` seesaw
			if [[ $protocol == 'ssh' ]]; then
				if confirm --positive --ppid=$$ -- "Testing $option_path remote $remote to $tested_url via $protocol failed, try HTTPS?"; then
					protocol='https'
					__set_remote_url "$https_url" || return $?
					__test_with_fallback || return $?
				else
					return 1
				fi
			else
				if confirm --positive --ppid=$$ -- "Testing $option_path remote $remote to $tested_url via $protocol failed, try SSH?"; then
					protocol='ssh'
					__set_remote_url "$ssh_url" || return $?
					__test_with_fallback || return $?
				else
					return 1
				fi
			fi
		}
		if [[ $test == 'yes' ]]; then
			__test_with_fallback
		fi

		# result
		case "$result" in
		url) git remote get-url "$remote" || return $? ;;
		remote) __print_lines "$remote" || return $? ;;
		no) : ;;
		*) __unrecognised_flag "--result=$result" || return $? ;;
		esac

		# done
		return 0
	}

	# =====================================
	# Repository Properties

	function __is_shallow_clone {
		__unrecognised_arguments "$@" || return $?
		[[ "$(git rev-parse --is-shallow-repository || :)" != 'false' ]] || return $?
	}

	function __get_github_slug {
		__unrecognised_arguments "$@" || return $?
		git remote -v | echo-regexp -o --regexp='.+?github[.]com[:/](.+?)[.]git.+' --replace='$1' || return $?
	}

	# verify repository
	function __verify {
		__unrecognised_arguments "$@" || return $?
		local git_status git_output
		__do --redirect-status={git_status} --redirect-output={git_output} -- git status || return $?
		if [[ $git_status -eq 128 ]]; then
			__print_error 'The directory ' --path="$option_path" ' is not a git repository.' || :
			if [[ -n $git_output ]]; then
				__print_lines "$git_output" >&2 || :
			fi
			return "$git_status" # makes more sense to continue inheriting the git exit status 128 than converting it to EFTYPE 79 Inappropriate file type or format
		elif [[ $git_status -ne 0 ]]; then
			__print_error 'The directory ' --path="$option_path" ' failed with the git exit status of ' --status="$git_status" ' when fetching its status via ' --code='git status' || :
			if [[ -n $git_output ]]; then
				__print_lines "$git_output" >&2 || :
			fi
			return "$git_status"
		fi
		return 0
	}

	# =====================================
	# Repository

	function __sync {
		# process
		local item remote='origin' url='' branch='' depth='' protocol='' project='' description='' homepage='' rebase='' new='' init='' update=''
		while [[ $# -ne 0 ]]; do
			item="$1"
			shift
			case "$item" in
			--remote=*) remote="${item#*=}" ;;
			--url=*) url="${item#*=}" ;;
			--branch=*) branch="${item#*=}" ;;
			--depth=*) depth="${item#*=}" ;;
			--no-unshallow* | --unshallow*)
				__flag --source+target={item} --affirmative --coerce || return $?
				if [[ $item == 'yes' ]]; then
					depth=0
				fi
				;;
			--no-protocol* | --protocol*) __flag --source={item} --target={protocol} --affirmative --no-coerce || return $? ;;
			--project=*) project="${item#*=}" ;;
			--description=*) description="${item#*=}" ;;
			--homepage=*) homepage="${item#*=}" ;;
			--no-rebase* | --rebase*) __flag --source={item} --target={rebase} --affirmative --coerce || return $? ;;
			--no-new* | --new*) __flag --source={item} --target={new} --affirmative --no-coerce || return $? ;;
			--no-init* | --init*) __flag --source={item} --target={init} --affirmative --no-coerce || return $? ;;
			--no-update* | --update*) __flag --source={item} --target={update} --affirmative --no-coerce || return $? ;;
			--*) __unrecognised_flag "$item" || return $? ;;
			*) __unrecognised_argument "$item" || return $? ;;
			esac
		done

		# rebase
		local rebase_args=()
		if [[ $rebase == 'yes' ]]; then
			rebase_args+=("--rebase=$rebase")
		fi

		# if we haven't initialised, then manually initialise
		if [[ ! -d .git ]]; then
			if [[ $init != 'no' ]]; then
				git init -q || return $?
				# don't mangle line endings
				git config core.autocrlf input || return $?
			else
				# fail with nice error
				__verify || return $?
			fi
		fi

		# if new and no remotes
		if [[ $new == 'yes' && -z "$(git remote 2>/dev/null || :)" ]]; then
			# url, where
			local where
			if [[ $url =~ ^(local|none)$ ]]; then
				where='local'
				url=''
			else
				# ignore failures, as it just means there wasn't a url and the repo doesn't have remotes
				# use https for now for consistent url passing, it'll be converted to the intended protocol later
				url="$(__url --remote="$remote" --url="$url" --protocol=https 2>/dev/null || :)"
			fi
			if [[ -n $url ]]; then
				if [[ $url == *github.com* ]]; then
					where='github'
				elif [[ $url == *gitlab.com* ]]; then
					where='gitlab'
				else
					where='custom'
				fi
			elif [[ $IS_STDIN_OPENED_ON_TERMINAL == 'yes' ]]; then
				where="$(
					choose --linger --required --label \
						--question='Where do you want to store your Dorothy user configuration?' -- \
						github 'Use a GitHub repository for your user configuration.' \
						gitlab 'Use a GitLab repository for your user configuration.' \
						custom 'Manually specify a repository URL for your user configuration.' \
						local "Don't use a repository for your user configuration, just store it locally for now."
				)"
			else
				__print_style --notice="Terminal isn't reactive, as such will default to local storage for user configuration."
				where='local'
			fi

			# handle remote repository setup
			if [[ $where =~ ^(github|gitlab|custom)$ ]]; then
				# validate
				local username='' default cli enter_or_confirm='Enter' repo_slug remote_slug remote_slug__styled conflict_options conflict_choice web_url
				while :; do
					default='' cli='' repo_slug='' remote_slug=''
					if [[ $where != 'custom' ]]; then
						default+="$where:"
					fi
					if [[ -n $username ]]; then
						# for subsequent loops, prefill username on next loops
						# it isn't needed, hence why we don't prefill it for the first loop
						default+="$username/"
					fi
					default+="$project"
					url="$(
						ask --linger --default="$default" \
							"$enter_or_confirm the repository clone URL for your $option_label:" \
							'e.g. github:<project>' \
							'e.g. github:<username>/<project>' \
							'e.g. https://github.com/<username>/<project>.git' \
							'e.g. ssh://git@github.com/<username>/<project>.git' \
							'e.g. git@github.com:<username>/<project>.git'
					)"
					if [[ -z $url || $url == 'local' ]]; then
						url=''
						where='local'
						break
					fi
					url="$(__format_url_to_protocol --url="$url" --protocol=https || :)"
					if [[ -z $url ]]; then
						url=''
						where='local'
						break
					fi
					web_url="${url%.git}"
					if [[ $url == *github.com* ]]; then
						where='github'
						setup-util-gh --confirm --optional
						# can only use the gh CLI if it is authenticated
						if __command_exists -- gh && gh auth status &>/dev/null; then
							cli='gh'
						fi
					elif [[ $url == *gitlab.com* ]]; then
						where='gitlab'
						setup-util-glab --confirm --optional
						if __command_exists -- glab; then
							cli='glab'
						fi
					else
						where='custom'
					fi

					# make the repo slug
					if [[ -n $cli ]]; then
						# update vars for next loops and for debugging
						__replace --source={url} --keep-before-last='/' --keep-after-first='.com' --pattern='[/:]' --target={username} || return $?
						__replace --source={url} --keep-after-last='/' --keep-before-first='.git' --target={project} || return $?
						repo_slug="$username/$project"
					fi

					# validate existence
					if [[ $cli == 'gh' ]]; then
						remote_slug="$(gh repo view "$repo_slug" --json nameWithOwner | __jq -r .nameWithOwner || :)"
						if [[ $remote_slug == "$repo_slug" ]]; then
							break
						else
							remote_slug__styled="$(__dump --value="$remote_slug" || :)"
							if [[ -n $remote_slug ]]; then
								conflict_options=(
									create "Create a new repository at $repo_slug"
									change "Use $remote_slug instead"
									ignore "Use $repo_slug and have it redirect to $remote_slug for now"
									rename "Rename $remote_slug to $repo_slug"
								)
							else
								conflict_options=(
									create "Create a new repository at $repo_slug"
									ignore "Use $repo_slug and ignore the verification failure"
								)
							fi
							conflict_choice="$(choose --required --label --question="When verifying $repo_slug it redirected to $remote_slug__styled. What do you want to do?" -- "${conflict_options[@]}")"
							case "$conflict_choice" in
							create) : ;;
							change)
								url="https://$where.com/$remote_slug.git"
								break
								;;
							ignore)
								break
								;;
							rename)
								gh repo rename "$remote_slug" "$repo_slug" || return $?
								break
								;;
							esac
						fi
					elif [[ $cli == 'glab' ]]; then
						if glab repo view "$repo_slug" >/dev/null; then
							break
						fi
					elif fetch --ok "$web_url"; then
						break
					elif confirm --linger --bool --ppid=$$ -- "Unable to validate the repository exists. Does it actually exist?" "Go to $web_url and verify it exists."; then
						break
					fi

					# if existence couldn't be validated, create it
					if [[ $cli == 'gh' ]]; then
						if gh repo create "$repo_slug" --description="$description" --homepage="$homepage" --public --confirm --enable-wiki=false; then
							break
						fi
					elif [[ $cli == 'glab' ]]; then
						# @todo untested
						if glab repo create "$repo_slug" --description "$description" --public; then
							break
						fi
					else
						if [[ $where == 'github' ]]; then
							open 'https://github.com/new' &>/dev/null || :
						elif [[ $where == 'gitlab' ]]; then
							open 'https://gitlab.com/projects/new#blank_project' &>/dev/null || :
						fi
						__print_style \
							--notice2="Create a $where repository for your $option_label using the following details:" --newline \
							--bold='Repository name: ' --code="$project" --newline \
							--bold='Description: ' --code="$description"
					fi
					enter_or_confirm='Confirm'
				done
			fi
		fi

		# exit early if no update
		if [[ $update == 'no' ]]; then
			# ensure the remote is desired, only testing if new
			if [[ -n $url || -n $protocol ]]; then
				__remote --no-result --apply --remote="$remote" --url="$url" --protocol="$protocol" --verify --test="$new" || return $?
			fi
			# done
			return 0
		fi

		# prepare depth
		local depth_args=()
		function __prepare_depth {
			depth_args=()
			# if our depth is 0, and if it is shallow
			if [[ -n $depth ]]; then
				if [[ $depth -ge 1 ]]; then
					# make shallow
					depth_args+=("--depth=$depth")
				elif [[ -e .git/shallow ]]; then
					# make unshallow
					depth_args+=('--unshallow')
				fi # else already unshallow
			fi
		}

		# wrap the update to handle optional
		function __do_update {
			# avoid merge conflicts
			# this prevents the need for doing a `git status &>/dev/null` check. to make sure the HEAD is fresh
			# although, doing the status check is a better idea perhaps
			git config --local pull.ff only || return $?

			# ensure and fetch the remote, testing it
			remote="$(__remote --apply --remote="$remote" --url="$url" --protocol="$protocol" --verify --test --depth="$depth")" || return $?

			# fetch all origins, branches, and prune remote deleted branches
			local pending success failure
			__prepare_depth
			pending="$(__print_style --bold='Fetching' ' ' --path="$option_path" ' ' --variable={remote})" || return $?
			success="$(__print_style --success='Fetched' ' ' --path="$option_path" ' ' --variable={remote})" || return $?
			failure="$(__print_style --error='Failed to fetch' ' ' --path="$option_path" ' ' --variable={remote})" || return $?
			eval-helper --quiet --wrap --pending="$pending" --success="$success" --failure="$failure" -- \
				git fetch --prune "${depth_args[@]}" "$remote" || return $?

			# if we pull on HEAD then it will pull from the desired branch, but it will not pull TO the desired branch, instead it will pull to the DEFAULT branch, which causes `bevry/dorothy-fixtures` to go from `master` to `main` which is then not linked back to `origin/master`
			# as such, check if there are any local branches, and if not, then do a checkout of the branch instead of a direct pull
			# this is here, as we need the branch for strongbox
			local operation
			if [[ -z "$(git branch --list 2>/dev/null || :)" ]]; then
				# no local branches, so checkout later
				operation='checkout'
			else
				# has local branches, so pull later
				operation='pull'
			fi

			# if no branch, use the current branch, and filter to remote branches only
			if [[ -z $branch ]]; then
				branch="$(git rev-parse --abbrev-ref HEAD 2>/dev/null || :)"
			fi
			branch="$(__branch --remote="$remote" --branch="$branch" --no-head --no-local --verify)" || return $?

			# if strongbox, ensure configured before pulling
			local strongbox_keyid
			strongbox_keyid="$(__strongbox --remote="$remote" --branch="$branch" || :)"
			if [[ -n $strongbox_keyid ]]; then
				# it is strongbox, so install strongbox
				setup-util-strongbox || return $?
				# check strongbox configuration
				local local_strongbox_keyring
				local_strongbox_keyring="$HOME/.strongbox_keyring"
				function __check_keyring {
					# ignore stderr if keyring doesn't exist yet
					grep --quiet --fixed-strings --regexp="$strongbox_keyid" -- "$local_strongbox_keyring" 2>/dev/null || return $?
				}
				if ! __check_keyring; then
					# strongbox is not configured
					__prepare_current_user || return $?
					local local_ip
					local_ip="$(what-is-my-ip local | echo-first-line --stdin || :)"
					# trunk-ignore-all(shellcheck/SC2088)
					__print_style \
						--notice2="Your Strongbox keyring on this machine is missing the Strongbox keyid for your specified $option_label:" --newline \
						--newline \
						"$option_label's local path: " --path="$option_path" --newline \
						"$option_label's Strongbox keyid: " --path="$strongbox_keyid" --newline \
						"This Machine's Strongbox keyring: " --path="$local_strongbox_keyring" --newline \
						"This Machine's User: " --code="$CURRENT_USER" --newline \
						"This Machine's Local IP: " --code="$local_ip" --newline \
						'Strongbox Documentation: ' --url='https://github.com/uw-labs/strongbox' --newline \
						--newline \
						'To manually edit your Strongbox keyring entry on this machine, run the following in a new terminal window attached to this machine:' --newline \
						--code="$(edit --dry "$local_strongbox_keyring" || :)" --newline \
						--newline \
						'If VNC is enabled on this machine, run the following on your primary machine to then manually copy the Strongbox keyring to this machine:' --newline \
						--code="$(echo-escape-command --persist="~" -- cat "~/.strongbox_keyring" || :)" --newline \
						--code="$(echo-escape-command -- open "vnc://$local_ip" || :)" --newline \
						--newline \
						'If SSH is enabled on this machine, run the following on your primary machine to copy the Strongbox keyring to this machine:' --newline \
						--code="$(echo-escape-command --persist="~" -- fs-copy -- "~/.strongbox_keyring" "${CURRENT_USER}@${local_ip}:${local_strongbox_keyring}" || :)" --newline \
						--newline \
						'To enable SSH on this machine:' --newline \
						'macOS via: ' --code='System Preferences > Sharing > Remote Login.' --newline \
						'Linux via: ' --code="$(echo-escape-command -- "$DOROTHY/commands/dorothy" run -- setup-util-ssh || :)" --newline \
						--newline \
						'Alternative methods to copy the Strongbox keyring to this machine include:' --newline \
						'Using Croc: ' --url='https://github.com/schollz/croc?tab=readme-ov-file#usage' --newline \
						--code="$(echo-escape-command -- "$DOROTHY/commands/dorothy" run -- setup-util-croc || :)" --newline \
						'Using Magic Wormhole: ' --url='https://magic-wormhole.readthedocs.io/en/latest/welcome.html#example' --newline \
						--code="$(echo-escape-command -- "$DOROTHY/commands/dorothy" run -- setup-util-magic-wormhole || :)" --newline \
						'Using Termscp: ' --url='https://termscp.veeso.dev/user-manual.html' --newline \
						--code="$(echo-escape-command -- "$DOROTHY/commands/dorothy" run -- setup-util-termscp || :)"

					# don't bother with any confirmations, such is unnecessary complexity for the UX
					while ! __check_keyring; do
						waiter --timeout=10 --message="$(__print_style --notice2="Waiting %s before checking again for the required Strongbox configuration...")"
					done

					# log now configured
					__print_style --good2='Your Strongbox keyring is now configured correctly, continuing with clone.'
				fi
			fi

			# checkout or pull
			if [[ $operation == 'checkout' ]]; then
				pending="$(__print_style --bold='Checking out' ' ' --path="$option_path" ' ' --variable={remote} ' ' --variable={branch})" || return $?
				success="$(__print_style --success='Checked out' ' ' --path="$option_path" ' ' --variable={remote} ' ' --variable={branch})" || return $?
				failure="$(__print_style --error='Failed to checkout' ' ' --path="$option_path" ' ' --variable={remote} ' ' --variable={branch})" || return $?
				eval-helper --quiet --wrap --pending="$pending" --success="$success" --failure="$failure" -- \
					git checkout --track "$remote/$branch" || return $?
			else
				__prepare_depth
				pending="$(__print_style --bold='Pulling' ' ' --path="$option_path" ' ' --variable={remote} ' ' --variable={branch})" || return $?
				success="$(__print_style --success='Pulled' ' ' --path="$option_path" ' ' --variable={remote} ' ' --variable={branch})" || return $?
				failure="$(__print_style --error='Failed to pull' ' ' --path="$option_path" ' ' --variable={remote} ' ' --variable={branch})" || return $?
				eval-helper --quiet --wrap --pending="$pending" --success="$success" --failure="$failure" -- \
					git pull "${rebase_args[@]}" "${depth_args[@]}" "$remote" "$branch" || return $?
			fi
		}

		# do the update handling optional
		if [[ $update == 'optional' ]]; then
			__do_update || :
		else
			__do_update || return $?
		fi
		return 0
	}

	function __review {
		# @todo make this configurable
		if get-app --quiet --app='Gitfox'; then
			get-app --invoke --app='Gitfox' -- "$option_path" "$@" || return $?
		elif get-app --quiet --app='Tower'; then
			get-app --invoke --app='Tower' -- "$option_path" "$@" || return $?
		else
			__print_error 'No supported git reviewers installed.' || :
			return 93 # ENOATTR 93 Attribute not found
		fi
	}

	function __unstage {
		# https://stackoverflow.com/a/6919257
		git reset HEAD "$@" || return $?
	}

	function __wipe {
		__unrecognised_arguments "$@" || return $?
		if confirm --positive --ppid=$$ -- "Are you sure you want to wipe [$option_path] to the last commit state, reverting all uncommitted files and changes?"; then
			git reset --hard || return $?
			git clean -f || return $?
		fi
	}

	function __umt {
		__unrecognised_arguments "$@" || return $?
		# https://serverfault.com/a/1031956
		# ^ all suggestions there have shortcomings, such as producing:
		# xargs: warning: options --max-args and --replace/-I/-i are mutually exclusive, ignoring previous --max-args value
		# this solves it:
		# git ls-tree -r --name-only HEAD -z | TZ=UTC xargs -0 -I_ git --no-pager log -1 --date=iso-local --format='%ad _' -- _ | echo-write | echo-regexp -gonm '^(.+?) \+0000 (.+)$' "TZ=UTC touch -md '\$1' '\$2'" | bash
		# however our below implementation is far easier, more understandable, just as quick, and supports paths with % and quotes:
		local subfiles=() subfile timestamp
		__split --target={subfiles} --no-zero-length --invoke -- \
			git ls-tree -r --name-only HEAD || return $?
		for subfile in "${subfiles[@]}"; do
			timestamp="$(TZ=UTC git --no-pager log -1 --date=iso-local --format='%ad' -- "$subfile")" || return $?
			# trim trailing +0000
			timestamp="${timestamp% +0000}"
			TZ=UTC touch -md "$timestamp" -- "$subfile" || return $?
		done
	}

	# =====================================
	# Action

	# perform the action
	case "$action" in
	# authors
	authors) __authors "${option_args[@]}" ;;
	emails) __emails "${option_args[@]}" ;;
	author | author-update | update-author) __update_author "${option_args[@]}" ;;
	# branches
	branch) __branch "${option_args[@]}" ;;
	active-branch | current-branch) __branch --active --verify "${option_args[@]}" ;;
	default-branch) __branch --default --verify "${option_args[@]}" ;;
	# commits
	commit) __commit "${option_args[@]}" ;;
	first-commit) __commit --first "${option_args[@]}" ;;
	first-commit-entry | first-commit-log) __commit --first --log "${option_args[@]}" ;;
	first-commit-hash) __commit --first --hash "${option_args[@]}" ;;
	first-commit-url) __commit --first --url "${option_args[@]}" ;;
	# files
	file) __file "${option_args[@]}" ;;
	has-file) __file --check "${option_args[@]}" ;;
	has-remote-file) __file --check --no-local "${option_args[@]}" ;;
	get-remote-file) __file --no-local "${option_args[@]}" ;;
	# special files
	is-dorothy) __is_dorothy "${option_args[@]}" ;;
	get-strongbox) __strongbox "${option_args[@]}" ;;
	is-strongbox) __strongbox --check "${option_args[@]}" ;;
	# protocol
	protocol) __protocol "${option_args[@]}" ;;
	# remotes
	remotes) __remotes "${option_args[@]}" ;;
	# url
	remote | protocol-format | format-protocol | protocol-update | update-protocol | remote-set | set-remote) __remote "${option_args[@]}" ;;
	url) __url "${option_args[@]}" ;;
	# repository properties
	verify) __verify "${option_args[@]}" ;;
	github-slug) __get_github_slug "${option_args[@]}" ;;
	is-shallow) __is_shallow_clone "${option_args[@]}" ;;
	# sync
	sync) __sync "${option_args[@]}" ;;
	new) __sync --new --no-init --no-update "${option_args[@]}" ;;
	create) __sync --new --init --update=optional "${option_args[@]}" ;;
	init) __sync --no-new --init --no-update "${option_args[@]}" ;;
	clone) __sync --no-new --init --update "${option_args[@]}" ;;
	fetch | pull | update) __sync --no-new --no-init --update "${option_args[@]}" ;;
	# repository
	review) __review "${option_args[@]}" ;;
	unstage) __unstage "${option_args[@]}" ;;
	wipe) __wipe "${option_args[@]}" ;;
	umt | upstream-modification-times) __umt "${option_args[@]}" ;;
	*) help --help='An unrecognised <action> was provided: ' --variable-value={action} ;;
	esac
)

# fire if invoked standalone
if [[ $0 == "${BASH_SOURCE[0]}" ]]; then
	if [[ $* == '--test' ]]; then
		git_helper_test
	else
		git_helper "$@"
	fi
fi
