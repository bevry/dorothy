#!/usr/bin/env bash

function get_terminal_tty_support_test() (
	source "$DOROTHY/sources/bash.bash"
	source "$(type -P eval-tester)"
	echo-style --h1="TEST: $0"

	function __do_test {
		__print_lines "\$- = $-"

		# alpine doesn't support the [-p] argument
		if ! is-apk && __command_exists -- ps; then
			__print_lines 'tty:'
			ps -p "$$" -o tty= || :
		fi

		# https://stackoverflow.com/a/54668834/130638
		if ls /proc/$$/fdinfo/* >/dev/null 2>&1 || grep -q 'flags:    00$' /proc/$$/fdinfo/0; then
			echo proc_pass
		else
			echo proc_fail
		fi

		( (tty -s && echo tty_s_pass) || echo tty_s_fail) || :

		( (test -t 0 && echo test_t_stdin_pass) || echo test_t_stdin_fail) || :
		( (test -t 1 && echo test_t_stdout_pass) || echo test_t_stdout_fail) || :
		( (test -t 2 && echo test_t_stderr_pass) || echo test_t_stderr_fail) || :

		( (test -p /dev/stdin && echo test_p_stdin_pass) || echo test_p_stdin_fail) || :
		( (test -p /dev/stdout && echo test_p_stdout_pass) || echo test_p_stdout_fail) || :
		( (test -p /dev/stderr && echo test_p_stderr_pass) || echo test_p_stderr_fail) || :
		( (test -p /dev/tty && echo test_p_tty_pass) || echo test_p_tty_fail) || :

		( (test -c /dev/stdin && echo test_c_stdin_pass) || echo test_c_stdin_fail) || :
		( (test -c /dev/stdout && echo test_c_stdout_pass) || echo test_c_stdout_fail) || :
		( (test -c /dev/stderr && echo test_c_stderr_pass) || echo test_c_stderr_fail) || :
		( (test -c /dev/tty && echo test_c_tty_pass) || echo test_c_tty_fail) || :

		# check if reading is even possible (If TIMEOUT is 0, read returns immediately, without trying to read any data, returning success only if input is available on the specified file descriptor.)
		( (read -t 0 && echo read_default_pass) || echo read_default_fail) || :
		( (read -t 0 </dev/stdin && echo read_stdin_pass) || echo read_stdin_fail) || :
		( (read -t 0 </dev/stdout && echo read_stdout_pass) || echo read_stdout_fail) || :
		( (read -t 0 </dev/stderr && echo read_stderr_pass) || echo read_stderr_fail) || :
		( (read -t 0 </dev/tty && echo read_tty_pass) || echo read_tty_fail) || :

		# don't use exec, don't use printf, they interefered with the read-key tests, as read-key would read [exec]
		# : is the same check but it is superior because it is a proper noop, unlike exec and printf

		( (: </dev/stdin && echo noop_from_stdin_pass) || echo noop_from_stdin_fail) || :
		( (: </dev/stdout && echo noop_from_stdout_pass) || echo noop_from_stdout_fail) || :
		( (: </dev/stderr && echo noop_from_stderr_pass) || echo noop_from_stderr_fail) || :
		( (: </dev/tty && echo noop_from_tty_pass) || echo noop_from_tty_fail) || :

		( (: >/dev/stdin && echo noop_to_stdin_pass) || echo noop_to_stdin_fail) || :
		( (: >/dev/stdout && echo noop_to_stdout_pass) || echo noop_to_stdout_fail) || :
		( (: >/dev/stderr && echo noop_to_stderr_pass) || echo noop_to_stderr_fail) || :
		( (: >/dev/tty && echo noop_to_tty_pass) || echo noop_to_tty_fail) || :

		( (: </dev/stdin >/dev/stdin && echo noop_bidirectonal_stdin_pass) || echo noop_bidirectonal_stdin_fail) || :
		( (: </dev/stdout >/dev/stdout && echo noop_bidirectonal_stdout_pass) || echo noop_bidirectonal_stdout_fail) || :
		( (: </dev/stderr >/dev/stderr && echo noop_bidirectonal_stderr_pass) || echo noop_bidirectonal_stderr_fail) || :
		( (: </dev/tty >/dev/tty && echo noop_bidirectonal_tty_pass) || echo noop_bidirectonal_tty_fail) || :
	}

	local stdout stderr

	__do_test

	__print_lines '' '### testing pipe ###'
	__print_lines 'testing pipe' | __do_test

	__print_lines '' '### testing delayed pipe ###'
	{
		sleep 3
		__print_line
	} | __do_test || : # this is necessary, as otherwise the pipe fails with 141

	__print_lines '' '### testing <<< ###'
	__do_test <<<'testing <<<'

	__print_lines '' '### testing < <(...) ###'
	__do_test < <(__print_lines 'testing <<<')

	__print_lines '' '### testing background ###'
	__do_test &
	wait $!

	__print_lines '' '### --stdoutvar ###'
	stdout=''
	stderr=''
	eval_capture --stdoutvar=stdout -- __do_test
	__print_lines 'stdout ='
	echo-lines --indent='    ' --stdin <<<"$stdout"
	__print_lines 'stderr ='
	echo-lines --indent='    ' --stdin <<<"$stderr"

	__print_lines '' '### --stderrvar ###'
	stdout=''
	stderr=''
	eval_capture --stderrvar=stderr -- __do_test
	__print_lines 'stdout ='
	echo-lines --indent='    ' --stdin <<<"$stdout"
	__print_lines 'stderr ='
	echo-lines --indent='    ' --stdin <<<"$stderr"

	__print_lines '' '### --stdoutvar --stderrvar ###'
	stdout=''
	stderr=''
	eval_capture --stdoutvar=stdout --stderrvar=stderr -- __do_test
	__print_lines 'stdout ='
	echo-lines --indent='    ' --stdin <<<"$stdout"
	__print_lines 'stderr ='
	echo-lines --indent='    ' --stdin <<<"$stderr"

	echo-style --g1="TEST: $0"
	return 0
)
function get_terminal_tty_support() (
	source "$DOROTHY/sources/bash.bash"

	# =====================================
	# Arguments

	function help {
		cat <<-EOF >/dev/stderr
			ABOUT:
			Get whether the terminal supports the [/dev/tty] device file, outputting [yes] if so, otherwise [no].

			USAGE:
			get-terminal-tty-support [...options]

			OPTIONS:
			--quiet
			    Instead outputting [yes] or [no], return an exit status of [0] if so, otherwise [1].
		EOF
		if test "$#" -ne 0; then
			printf '%s\n' '' 'ERROR:' "$@" # don't get echo-style, as echo-style uses this
		fi
		return 22 # EINVAL 22 Invalid argument
	}

	# process
	local item option_quiet=''
	while test "$#" -ne 0; do
		item="$1"
		shift
		case "$item" in
		'--help' | '-h') help ;;
		'--no-verbose'* | '--verbose'*)
			option_quiet="$(get-flag-value --non-affirmative --fallback="$option_quiet" -- "$item")"
			;;
		'--no-quiet'* | '--quiet'*)
			option_quiet="$(get-flag-value --affirmative --fallback="$option_quiet" -- "$item")"
			;;
		'--'*) help "An unrecognised flag was provided: $item" ;;
		*) help "An unrecognised argument was provided: $item" ;;
		esac
	done

	# =====================================
	# Action

	if test "$option_quiet" = 'yes'; then
		(: </dev/tty >/dev/tty) &>/dev/null
		return
	elif (: </dev/tty >/dev/tty) &>/dev/null; then
		__print_lines 'yes'
	else
		__print_lines 'no'
	fi
)

# fire if invoked standalone
if test "$0" = "${BASH_SOURCE[0]}"; then
	if test "$*" = '--test'; then
		get_terminal_tty_support_test
	else
		get_terminal_tty_support "$@"
	fi
fi
