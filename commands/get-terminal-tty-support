#!/usr/bin/env bash

function get_terminal_tty_support_test() (
	source "$DOROTHY/sources/bash.bash"
	source "$(type -P eval-tester)"
	echo-style --h1="TEST: $0"

	function __do_test {
		__print_lines "\$- = $-"

		# alpine doesn't support the [-p] argument
		if ! is-apk && __command_exists -- ps; then
			__print_lines '' 'tty:'
			ps -p "$$" -o tty= || :
		fi

		if __command_exists -- lsof; then
			__print_lines '' 'lsof:'
			lsof -p $$ || :
		fi

		__print_lines '' '/dev/fd/*:'
		ls -l /dev/fd/* || :
		file /dev/fd/* || :

		if test -e /dev/pts; then
			__print_lines '' '/dev/pts/*:'
			ls -l /dev/pts/* || :
			file /dev/pts/* || :
		fi

		__print_lines '' 'realpath /dev/fd/*:'
		fs-realpath -- /dev/fd/* || :

		# https://stackoverflow.com/a/54668834/130638
		if ls /proc/$$/fdinfo/* >/dev/null 2>&1 || grep -q 'flags:    00$' /proc/$$/fdinfo/0; then
			__print_lines '' proc_pass
		else
			__print_lines '' proc_fail
		fi

		# attempts at detection

		# -c /dev/stdin to handle background in ssh -T
		# note that if everything is captured, such as eval_capture with stdin modification, then this appears true
		( ([[ (-p /dev/stdin || -c /dev/stdin) && -p /dev/stdout && -p /dev/stderr ]] && ! (: >/dev/stdin) && __print_lines is_ssh_T_or_all_custom) || __print_lines is_neither_ssh_T_or_all_custom) || :
		( (! [[ -c /dev/stdin ]] && (: >/dev/stdin) && __print_lines is_CI) || __print_lines is_not_CI) || :

		( (tty -s && __print_lines tty_s_pass) || __print_lines tty_s_fail) || :

		( (test -t 0 && __print_lines test_t_stdin_pass) || __print_lines test_t_stdin_fail) || :
		( (test -t 1 && __print_lines test_t_stdout_pass) || __print_lines test_t_stdout_fail) || :
		( (test -t 2 && __print_lines test_t_stderr_pass) || __print_lines test_t_stderr_fail) || :

		( (test -p /dev/stdin && __print_lines test_p_stdin_pass) || __print_lines test_p_stdin_fail) || :
		( (test -p /dev/stdout && __print_lines test_p_stdout_pass) || __print_lines test_p_stdout_fail) || :
		( (test -p /dev/stderr && __print_lines test_p_stderr_pass) || __print_lines test_p_stderr_fail) || :
		( (test -p /dev/tty && __print_lines test_p_tty_pass) || __print_lines test_p_tty_fail) || :

		( (test -c /dev/stdin && __print_lines test_c_stdin_pass) || __print_lines test_c_stdin_fail) || :
		( (test -c /dev/stdout && __print_lines test_c_stdout_pass) || __print_lines test_c_stdout_fail) || :
		( (test -c /dev/stderr && __print_lines test_c_stderr_pass) || __print_lines test_c_stderr_fail) || :
		( (test -c /dev/tty && __print_lines test_c_tty_pass) || __print_lines test_c_tty_fail) || :

		# check if reading is even possible (If TIMEOUT is 0, read returns immediately, without trying to read any data, returning success only if input is available on the specified file descriptor.)
		( (read -t 0 && __print_lines read_default_pass) || __print_lines read_default_fail) || :
		( (read -t 0 </dev/stdin && __print_lines read_stdin_pass) || __print_lines read_stdin_fail) || :
		( (read -t 0 </dev/stdout && __print_lines read_stdout_pass) || __print_lines read_stdout_fail) || :
		( (read -t 0 </dev/stderr && __print_lines read_stderr_pass) || __print_lines read_stderr_fail) || :
		( (read -t 0 </dev/tty && __print_lines read_tty_pass) || __print_lines read_tty_fail) || :

		# don't use exec, don't use printf, they interefered with the read-key tests, as read-key would read [exec]
		# : is the same check but it is superior because it is a proper noop, unlike exec and printf

		( (: </dev/stdin && __print_lines noop_from_stdin_pass) || __print_lines noop_from_stdin_fail) || :
		( (: </dev/stdout && __print_lines noop_from_stdout_pass) || __print_lines noop_from_stdout_fail) || :
		( (: </dev/stderr && __print_lines noop_from_stderr_pass) || __print_lines noop_from_stderr_fail) || :
		( (: </dev/tty && __print_lines noop_from_tty_pass) || __print_lines noop_from_tty_fail) || :

		( (: >/dev/stdin && __print_lines noop_to_stdin_pass) || __print_lines noop_to_stdin_fail) || :
		( (: >/dev/stdout && __print_lines noop_to_stdout_pass) || __print_lines noop_to_stdout_fail) || :
		( (: >/dev/stderr && __print_lines noop_to_stderr_pass) || __print_lines noop_to_stderr_fail) || :
		( (: >/dev/tty && __print_lines noop_to_tty_pass) || __print_lines noop_to_tty_fail) || :

		( (: </dev/stdin >/dev/stdin && __print_lines noop_bidirectonal_stdin_pass) || __print_lines noop_bidirectonal_stdin_fail) || :
		( (: </dev/stdout >/dev/stdout && __print_lines noop_bidirectonal_stdout_pass) || __print_lines noop_bidirectonal_stdout_fail) || :
		( (: </dev/stderr >/dev/stderr && __print_lines noop_bidirectonal_stderr_pass) || __print_lines noop_bidirectonal_stderr_fail) || :
		( (: </dev/tty >/dev/tty && __print_lines noop_bidirectonal_tty_pass) || __print_lines noop_bidirectonal_tty_fail) || :
	}

	local stdout stderr

	__do_test

	__print_lines '' '' '### testing pipe ###'
	__print_lines 'testing pipe' | __do_test

	__print_lines '' '' '### testing delayed pipe ###'
	{
		sleep 3
		__print_line
	} | __do_test || : # this is necessary, as otherwise the pipe fails with 141

	__print_lines '' '' '### testing <<< ###'
	__do_test <<<'testing <<<'

	__print_lines '' '' '### testing < <(...) ###'
	__do_test < <(__print_lines 'testing <<<')

	__print_lines '' '' '### testing background ###'
	__do_test &
	wait $!

	__print_lines '' '' '### --stdoutvar ###'
	stdout=''
	stderr=''
	eval_capture --stdoutvar=stdout -- __do_test
	__print_lines 'stdout ='
	echo-lines --indent='    ' --stdin <<<"$stdout"
	__print_lines 'stderr ='
	echo-lines --indent='    ' --stdin <<<"$stderr"

	__print_lines '' '' '### --stderrvar ###'
	stdout=''
	stderr=''
	eval_capture --stderrvar=stderr -- __do_test
	__print_lines 'stdout ='
	echo-lines --indent='    ' --stdin <<<"$stdout"
	__print_lines 'stderr ='
	echo-lines --indent='    ' --stdin <<<"$stderr"

	__print_lines '' '' '### --stdoutvar --stderrvar ###'
	stdout=''
	stderr=''
	eval_capture --stdoutvar=stdout --stderrvar=stderr -- __do_test
	__print_lines 'stdout ='
	echo-lines --indent='    ' --stdin <<<"$stdout"
	__print_lines 'stderr ='
	echo-lines --indent='    ' --stdin <<<"$stderr"

	__print_lines '' '' '### pipe to --stdoutvar --stderrvar ###'
	stdout=''
	stderr=''
	__print_lines 'testing pipe' | eval_capture --stdoutvar=stdout --stderrvar=stderr -- __do_test
	__print_lines 'stdout ='
	echo-lines --indent='    ' --stdin <<<"$stdout"
	__print_lines 'stderr ='
	echo-lines --indent='    ' --stdin <<<"$stderr"

	__print_lines '' '' '### delayed pipe to --stdoutvar --stderrvar ###'
	stdout=''
	stderr=''
	{
		sleep 3
		__print_line
	} | eval_capture --stdoutvar=stdout --stderrvar=stderr -- __do_test || :
	__print_lines 'stdout ='
	echo-lines --indent='    ' --stdin <<<"$stdout"
	__print_lines 'stderr ='
	echo-lines --indent='    ' --stdin <<<"$stderr"

	__print_lines '' '' '###  <<< to --stdoutvar --stderrvar ###'
	stdout=''
	stderr=''
	eval_capture --stdoutvar=stdout --stderrvar=stderr -- __do_test <<<'testing <<<'
	__print_lines 'stdout ='
	echo-lines --indent='    ' --stdin <<<"$stdout"
	__print_lines 'stderr ='
	echo-lines --indent='    ' --stdin <<<"$stderr"

	__print_lines '' '' '###  < <(...) to --stdoutvar --stderrvar ###'
	stdout=''
	stderr=''
	eval_capture --stdoutvar=stdout --stderrvar=stderr -- __do_test < <(__print_lines 'testing <<<')
	__print_lines 'stdout ='
	echo-lines --indent='    ' --stdin <<<"$stdout"
	__print_lines 'stderr ='
	echo-lines --indent='    ' --stdin <<<"$stderr"

	echo-style --g1="TEST: $0"
	return 0
)
function get_terminal_tty_support() (
	source "$DOROTHY/sources/bash.bash"

	# =====================================
	# Arguments

	function help {
		cat <<-EOF >/dev/stderr
			ABOUT:
			Get whether the terminal supports the [/dev/tty] device file, outputting [yes] if so, otherwise [no].

			USAGE:
			get-terminal-tty-support [...options]

			OPTIONS:
			--quiet
			    Instead outputting [yes] or [no], return an exit status of [0] if so, otherwise [1].
		EOF
		if test "$#" -ne 0; then
			printf '%s\n' '' 'ERROR:' "$@" # don't get echo-style, as echo-style uses this
		fi
		return 22 # EINVAL 22 Invalid argument
	}

	# process
	local item option_quiet=''
	while test "$#" -ne 0; do
		item="$1"
		shift
		case "$item" in
		'--help' | '-h') help ;;
		'--no-verbose'* | '--verbose'*)
			option_quiet="$(get-flag-value --non-affirmative --fallback="$option_quiet" -- "$item")"
			;;
		'--no-quiet'* | '--quiet'*)
			option_quiet="$(get-flag-value --affirmative --fallback="$option_quiet" -- "$item")"
			;;
		'--'*) help "An unrecognised flag was provided: $item" ;;
		*) help "An unrecognised argument was provided: $item" ;;
		esac
	done

	# =====================================
	# Action

	if test "$option_quiet" = 'yes'; then
		(: </dev/tty >/dev/tty) &>/dev/null
		return
	elif (: </dev/tty >/dev/tty) &>/dev/null; then
		__print_lines 'yes'
	else
		__print_lines 'no'
	fi
)

# fire if invoked standalone
if test "$0" = "${BASH_SOURCE[0]}"; then
	if test "$*" = '--test'; then
		get_terminal_tty_support_test
	else
		get_terminal_tty_support "$@"
	fi
fi
