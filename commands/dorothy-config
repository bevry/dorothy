#!/usr/bin/env bash

# @todo merge with [config-edit], [config-helper], are all doubling up on this

function dorothy_config_test() (
	source "$DOROTHY/sources/bash.bash"
	source "$(type -P eval-tester)"

	# prepare
	local PLACEHOLDER__CONTEXT expected_stdout expected_stderr expected_first_result expected_final_result invented_packages \
		file_name='setup.bash' \
		file_path="$DOROTHY/user/config/setup.bash" \
		backup_path="$DOROTHY/user/config/setup.bash.backup" \
		local_file_path="$DOROTHY/user/config.local/setup.bash" \
		local_backup_path="$DOROTHY/user/config.local/setup.bash.backup" \
		util_packages=(
			curl
			ripgrep
			sd
		)
	# define
	PLACEHOLDER__CONTEXT="$RANDOM"
	invented_packages=(
		# 0 and 1 prefixes for sorting consistency
		"dorothy-config-testing-value-0-$PLACEHOLDER__CONTEXT"
		"dorothy-config-testing-value-1-$PLACEHOLDER__CONTEXT"
	)
	expected_stderr="Updated configuration file: $file_path"
	expected_stdout="$(__print_lines "${invented_packages[@]}")"
	expected_first_result="$(
		sed -e "s/\\\$PLACEHOLDER__CONTEXT/$PLACEHOLDER__CONTEXT/" \
			"$DOROTHY/fixtures/dorothy-config.after-addition.expected.txt"
	)"
	expected_final_result="$(
		sed -e "s/\\\$PLACEHOLDER__CONTEXT/$PLACEHOLDER__CONTEXT/" \
			"$DOROTHY/fixtures/dorothy-config.after-removal.expected.txt"
	)"

	# move original file to backup if a backup doesn't already exit
	local can_restore_backup='no'
	if is-missing -- "$backup_path" && is-present -- "$file_path"; then
		mv -- "$file_path" "$backup_path"
		can_restore_backup='yes'
	fi
	if is-missing -- "$local_backup_path" && is-present -- "$local_file_path"; then
		mv -- "$local_file_path" "$local_backup_path"
		can_restore_backup='yes'
	fi
	if [[ $can_restore_backup == 'yes' ]]; then
		function __restore_backup {
			if is-present -- "$backup_path"; then
				mv -f -- "$backup_path" "$file_path" || return $?
			fi
			if is-present -- "$local_backup_path"; then
				mv -f -- "$local_backup_path" "$local_file_path" || return $?
			fi
		}
		trap __restore_backup EXIT
	fi

	# ensure the file has been moved
	eval_tester -- is-missing -- "$file_path"

	# eval_tester --stderr="$expected_stderr" -- \
	# 	dorothy-config \
	# 	setup.bash \
	# 	--prefer=public \
	# 	-- \
	# 	--field=DOROTHY_CONFIG_TESTING_LIST $'--array=dorothy-config-testing-value-06589\ndorothy-config-testing-value-122058' \
	# 	--field=SETUP_UTILS $'--array=curl\nnano\nripgrep\nsd\nvim'
	# echo-file -- "$file_path" || :

	# eval_tester --debug -- \
	# 	config-helper \
	# 	--file=/home/balupton/.local/share/dorothy/user/config/setup.bash \
	# 	--multiple=warn-skip
	# 	-- \
	# 	--field=DOROTHY_CONFIG_TESTING_LIST $'--array=dorothy-config-testing-value-06589\ndorothy-config-testing-value-122058' \
	# 	--field=SETUP_UTILS $'--array=curl\nnano\nripgrep\nsd\nvim'

	# output the configuration file, so we can track its progress, in case something goes wrong, which on CI it might
	# echo-file -- "$file_path" || :

	# add DOROTHY_CONFIG_TESTING_LIST, ignore stderr as it will vary based on whether choose was used or not
	eval_tester --name='add and remove packages' --stdout="$expected_stdout" --ignore-stderr -- \
		eval-no-color -- dorothy-config --packages-var='DOROTHY_CONFIG_TESTING_LIST' --prefer=public -- "${invented_packages[@]}" "${util_packages[@]}"

	# output the configuration file, so we can track its progress, in case something goes wrong, which on CI it might
	# echo-file -- "$file_path" || :

	# ensure it had the before lines, loader lines, and after lines
	eval_tester --stdout="$expected_first_result" -- cat "$file_path"

	# read DOROTHY_CONFIG_TESTING_LIST
	expected_stdout=$'(\n'"$(echo-lines --quote=bash --indent=$'\t' -- "${invented_packages[@]}")"$'\n)'
	eval_tester --name='read packages' --stdout="$expected_stdout" --ignore-stderr -- \
		eval-no-color -- config-helper --file="$file_path" -- --field='DOROTHY_CONFIG_TESTING_LIST'

	# output the configuration file, so we can track its progress, in case something goes wrong, which on CI it might
	# echo-file -- "$file_path" || :

	# remove DOROTHY_CONFIG_TESTING_LIST
	eval_tester --name='remove config' --stderr="$expected_stderr" -- \
		eval-no-color -- dorothy-config "$file_name" --prefer=public -- --field='DOROTHY_CONFIG_TESTING_LIST' --replace=

	# ensure it removed what it was meant to
	eval_tester --stdout="$expected_final_result" -- cat "$file_path"

	# output the configuration file, so we can track its progress, in case something goes wrong, which on CI it might
	# echo-file -- "$file_path" || :

	# `__restore_backup` occurs on exit, so it doesn't need to be called here

	return 0
)
function dorothy_config() (
	source "$DOROTHY/sources/bash.bash"
	source "$DOROTHY/sources/config.sh"

	# =================================
	# Arguments

	function help {
		cat <<-EOF >&2
			USAGE:
			dorothy-config [...options] --packages-var=<variable> -- ...<package>

			    # removes all setup-util-... packages from APK_INSTALL in <setup.bash>
			    __split --target={APK_INSTALL} --no-zero-length --invoke=try -- dorothy-config  --packages-var='APK_INSTALL' -- "\${APK_INSTALL[@]}"

			dorothy-config [...options] -- ...[options passed to config-helper]

			    dorothy-config 'git.bash' --prefer=local  -- \\
			        --field='GIT_DEFAULT_BRANCH' --value="\$GIT_DEFAULT_BRANCH"

			OPTIONS:
			<filename>
			    The filename of the configuration file to find or create, then update.

			--prefer=<local|public>
			    If <local> prefer <user/config.local>, if <public> prefer <user/config>.
			    If there are multiple config files, prompt the user which one to use.

			--reason=<reason>
			    The reason for the change, displays in prompts and whatnot.
		EOF
		if [[ $# -ne 0 ]]; then
			__print_error "$@"
		fi
		return 22 # EINVAL 22 Invalid argument
	}

	# process
	local item option_packages_var='' option_filename='' option_reason='' option_prefer='' option_args=()
	while [[ $# -ne 0 ]]; do
		item="$1"
		shift
		case "$item" in
		'--help' | '-h') help ;;
		'--packages-var='*) option_packages_var="${item#*=}" ;;
		'--file='*) option_filename="${item#*=}" ;;
		'--reason='*) option_reason="${item#*=}" ;;
		'--prefer=local' | '--prefer=public' | '--prefer=') option_prefer="${item#*=}" ;;
		'--')
			option_args+=("$@")
			shift $#
			break
			;;
		'--'*) help 'An unrecognised flag was provided: ' --variable-value={item} ;;
		*)
			if [[ -z $option_filename ]]; then
				option_filename="$item"
			else
				help 'An unrecognised argument was provided: ' --variable-value={item}
			fi
			;;
		esac
	done

	# ensure filename
	if [[ -z $option_filename ]]; then
		if [[ -n $option_packages_var ]]; then
			option_filename='setup.bash'
		else
			help 'A filename must be provided.'
		fi
	fi

	# check extension
	local extension # this is used later too
	extension="$(fs-path --extension -- "$option_filename" || :)"
	if ! [[ $extension =~ ^(bash|zsh|sh|fish|nu)$ ]]; then
		help 'The file extension of ' --code="$option_filename" ' is not yet supported.'
	fi

	# =================================
	# Action

	function prune_utilities_from_packages {
		local item reconfigure='no' revised_items=() installer util reason=''

		# SETUP_UTILS should have already been loaded, but let's create and load it if it hasn't
		# we need to do it this way, otherwise we would wipe pre-existing custom configuration
		if [[ -z ${SETUP_UTILS-} ]]; then
			SETUP_UTILS=()
			load_dorothy_config 'setup.bash'
		fi
		if [[ -z $option_filename ]]; then
			option_filename='setup.bash'
		fi

		# remove inputs with dedicated installers
		for item in "${option_args[@]}"; do
			installer="$(get-installer --quiet -- "$item" || :)"
			if [[ -n $installer ]]; then
				if [[ $installer == 'setup-util-'* ]]; then
					util="${installer#*setup-util-}"
					reason+="$(
						__print_style --reset --notice1='Relocate ' --code-notice1="$item" --notice1=' from ' --code-notice1="$option_packages_var" --notice1=' to ' --code-notice1="$util" --notice1=' in ' --code-notice1='SETUP_UTILS'
					)"$'\n'
					SETUP_UTILS+=("$util")
					reconfigure='yes'
				else
					reason+="$(
						__print_style --reset --notice1='Remove ' --code-notice1="$item" --notice1=' from ' --code-notice1="$option_packages_var" --notice1=' as it should be installed via ' --code-notice1="$installer"
					)"$'\n'
					reconfigure='yes'
				fi
				continue
			else
				revised_items+=("$item")
			fi
		done

		# update configuration if necessary
		if [[ $reconfigure == 'yes' ]]; then
			dorothy-config "$option_filename" --prefer="$option_prefer" --reason="$reason" -- \
				--field="$option_packages_var" --array="$(echo-unique --ignore-case -- "${revised_items[@]}")" \
				--field='SETUP_UTILS' --array="$(echo-unique --ignore-case -- "${SETUP_UTILS[@]}")"
		fi

		# output the revised items, so that the caller has them
		__print_lines "${revised_items[@]}"
	}

	function update_configuration {
		# prep
		local user_filepath='' temp_filepath='' displayed_reason='no' \
			source_filepath="\$DOROTHY/config/$option_filename" \
			default_filepath="$DOROTHY/config/$option_filename" \
			local_filepath="$DOROTHY/user/config.local/$option_filename" \
			public_filepath="$DOROTHY/user/config/$option_filename"

		# which location is preferred (the default option)
		if [[ $option_prefer == 'local' ]]; then
			user_filepath="$local_filepath"
		elif [[ $option_prefer == 'public' ]]; then
			user_filepath="$public_filepath"
		fi

		# enforce location to verified preference
		if [[ -f $local_filepath && -f $public_filepath ]]; then
			user_filepath="$(
				choose --linger --required \
					--question="$(__print_style --notice1='The configuration file ' --code-notice1="$option_filename" --notice1=' is pending updates. Select the specific configuration file to update.')"$'\n'"$option_reason" \
					--default="$user_filepath" -- "$public_filepath" "$local_filepath"
			)"
			displayed_reason='yes'
		elif [[ -f $local_filepath ]]; then
			user_filepath="$local_filepath"
		elif [[ -f $public_filepath ]]; then
			user_filepath="$public_filepath"
		else
			user_filepath="$public_filepath"
		fi

		# show the reason
		if [[ -n $option_reason && $displayed_reason == 'no' ]]; then
			__print_style --stderr \
				--notice1='The configuration file ' --code-notice1="$user_filepath" --notice1=' will be updated to:' --newline \
				"$option_reason"
		fi

		# ensure filepath can be written
		__mkdirp "$(dirname -- "$user_filepath")"

		# check if we have to make the filepath
		if [[ ! -f $user_filepath ]]; then
			temp_filepath="$(fs-temp --directory='dorothy' --directory='config-helper' --file --touch)"
			if [[ -f $default_filepath ]]; then
				# start with the header of the default configuration file
				echo-lines-before --needle='' --stdin <"$default_filepath" >>"$temp_filepath" # >> because https://github.com/bevry/dorothy/issues/283
				__print_line >>"$temp_filepath"

				# inject the sourcing of the default configuration file
				if [[ $extension == 'nu' ]]; then
					# nu doesn't support dynamic sourcing, so use default_filepath instead of source_filepath
					cat <<-EOF >>"$temp_filepath"
						# load the default configuration
						source '$default_filepath'

					EOF
				elif [[ $extension == 'sh' ]]; then
					# sh uses [.] instead of [source]
					cat <<-EOF >>"$temp_filepath"
						# load the default configuration
						. "$source_filepath"

					EOF
				else
					# fish, zsh, bash
					cat <<-EOF >>"$temp_filepath"
						# load the default configuration
						source "$source_filepath"

					EOF
				fi

				# append the body of the default configuration file
				# @note unless bash.bash:eval_capture removes [>/dev/stdout] or does [>>/dev/stdout] this will still overwrite instead of append
				echo-lines-after --needle='' --stdin <"$default_filepath" >>"$temp_filepath"
			else
				# even the dorothy default is missing
				cat <<-EOF >"$temp_filepath"
					#!/usr/bin/env $extension

				EOF
			fi

			# add the new file to the paths
			mv -- "$temp_filepath" "$user_filepath"
		fi

		# now that the file definitely exists, update it if we have values to update it
		if [[ ${#option_args[@]} -ne 0 ]]; then
			config-helper --file="$user_filepath" --multiple=warn-skip -- \
				"${option_args[@]}"
		fi
	}

	# perform the correct action
	if [[ -z $option_packages_var ]]; then
		update_configuration
	else
		prune_utilities_from_packages
	fi
)

# fire if invoked standalone
if [[ $0 == "${BASH_SOURCE[0]}" ]]; then
	if [[ $* == '--test' ]]; then
		dorothy_config_test
	else
		dorothy_config "$@"
	fi
fi
