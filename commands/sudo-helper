#!/usr/bin/env bash

function sudo_helper() (
	source "$DOROTHY/sources/bash.bash"

	# =====================================
	# Arguments

	function help {
		cat <<-EOF >&2
			ABOUT:
			Run the command with privilege elevation, be it via sudo or doas, or neither if not needed.

			USAGE:
			sudo-helper [...options] -- <command> [...args]

			OPTIONS:

		EOF
		if [[ $# -ne 0 ]]; then
			echo-error "$@"
		fi
		return 22 # EINVAL 22 Invalid argument
	}


	# ensure sudo is a valid value
	local elevate='' elevate_on_statuses=()
	if [[ -n $option_user || -n $option_group ]]; then
		# validate user and group, user is important, as otherwise we will be creating directories for users that don't exist
		if [[ -n $option_user ]] && ! is-user -- "$option_user"; then
			echo-style --stderr --error1='Cannot elevate privileges to a non-existent user: ' --code-error1="$option_user"
			return 2 # ENOENT 2 No such file or directory
		fi
		if [[ -n $option_group ]] && ! is-group -- "$option_group"; then
			echo-style --stderr --error1='Cannot elevate privileges to a non-existent group: ' --code-error1="$option_group"
			return 2 # ENOENT 2 No such file or directory
		fi
		elevate='yes'
	elif [[ ${#option_elevate[@]} -eq 0 ]]; then
		elevate='yes'
	elif [[ -z ${option_elevate[*]} ]]; then
		elevate='no'
	else
		elevate='no'
		for item in "${option_elevate[@]}"; do
			case "$item" in
			'') : ;; # discard, it's already served its purpose in now defaulting to disabled
			'yes')
				elevate='yes'
				elevate_on_statuses=()
				;;
			'no')
				elevate='no'
				elevate_on_statuses=()
				;;
			'failure')
				elevate='failure'
				elevate_on_statuses=()
				;;
			[0-9]*)
				if ! is-integer -- "$item"; then
					help "An unrecognised value was provided for --sudo: $item"
				fi
				elevate='status'
				elevate_on_statuses+=("$item")
				;;
			*)
				help "An unrecognised value was provided for --sudo: $item"
				;;
			esac
		done
	fi

	# =====================================
	# Action

	# try without sudo
	if [[ $elevate == 'no' || $elevate_technique == 'none' ]]; then
		__wrap "${option_cmd[@]}"
		return
	elif [[ $elevate == 'failure' ]]; then
		if __wrap "${option_cmd[@]}"; then
			return 0
		fi
	elif [[ $elevate == 'status' ]]; then
		local status=0
		__wrap "${option_cmd[@]}" || status=$?
		for item in "${elevate_on_statuses[@]}"; do
			if [[ $status -eq $item ]]; then
				elevate='yes'
				break
			fi
		done
		if [[ $elevate != 'yes' ]]; then
			return "$status"
		fi
	fi

	# if desired, note that it needed elevation
	if [[ -n $option_elevated ]]; then
		__do --redirect-stdout="$option_elevated" -- __print_lines 'yes'
	fi

	# prep sudo execution
	command_style='sudo'
	local sudo_cmd=() home=''
	if [[ $elevate_technique == 'sudo' ]]; then
		sudo_cmd+=('sudo')

		# if no-tty, then use the builtin sudo workaround which is the same as Dorothy's
		# if ! __has_tty_support; then
		# 	sudo_cmd+=('--stdin') # note tha this outputs what they are typing unconcealed to terminal
		# 	# alternative is this insecure option: export SUDO_ASKPASS=...; sudo_cmd+=('--askpass')
		# 	# as this is an edge case in what is meant to be non-interactive environments, this is fine
		# fi
		# ^ don't enable this yet, until someone requests it, I don't know the implications

		# add the things specific to attestation, while prepping home
		# don't use is-directory, is-missing, __elevate_mkdirp, as they will cause infinite recursion
		if [[ -n $option_user ]]; then
			sudo_cmd+=("--user=$option_user")
			# should coincide with setup-environment-commands
			if [[ -d /Users ]]; then
				home="/Users/$option_user"
			elif [[ -d '/home' ]]; then
				home="/home/$option_user"
			elif [[ -d "/$option_user" ]]; then
				HOME="/$option_user"
			fi
		elif [[ -n $HOME ]]; then
			home="$HOME"
		fi
		if [[ -n $option_group ]]; then
			sudo_cmd+=("--group=$option_group")
		fi

		# check if password is required
		# [sudo --validate] doesn't work on multipass, so just use [true] as a no-op
		if ! "${sudo_cmd[@]}" --non-interactive -- true &>/dev/null; then
			# password is required, let the user know what they are being prompted for
			# [--code=*] better than [echo-style --element/="$(echo-escape-command -- "${sudo_cmd[@]}" | echo-join ' ' --stdin)"] as that is too verbose
			# use [--tty] to ensure the prompt is not hidden when otherwise hiding sudo output, such as in [command-working]
			# while it would be nice to clear lines, we cannot know how many lines to clear as they could require multiple attempts to enter the password
			if [[ -n $option_reason ]]; then
				echo-style --tty --notice="$option_reason"
			else
				echo-style --tty --notice='Your password is required to momentarily grant privileges to execute the command:'
			fi
			option_wrap='yes'
		fi

		# add the things specific to the command
		if [[ -n $home ]]; then
			if [[ ! -e $home && ! -L $home ]]; then
				sudo mkdir -p -- "$home" # don't use __elevate_mkdirp as that calls __elevate which calls this
				fs-own --quiet --user="$option_user" --group="$option_group" --no-recursive -- "$home"
			fi
			sudo_cmd+=('--set-home')
		fi

		# sudo supports passing environment variables
		if [[ $option_inherit == 'yes' ]]; then
			sudo_cmd+=(
				'--preserve-env'
				"PATH=$PATH"
				--
			)
			# if it is linux, [sudo PATH=$PATH] doesn't seem to work, but [env PATH=$PATH] does, so just duplicate it
			if is-linux; then
				sudo_cmd+=(
					'env'
					"PATH=$PATH"
				)
			fi
		else
			sudo_cmd+=(--)
		fi
	elif [[ $elevate_technique == 'doas' ]]; then
		# https://man.archlinux.org/man/doas.1.en
		sudo_cmd+=('doas')
		if [[ -n $option_user ]]; then
			sudo_cmd+=(
				'-u'
				"$option_user"
			)
		fi
		if [[ -n $option_group ]]; then
			help 'doas does not support --group'
		fi
		# doas doesn't support ENVVAR=value, nor --
		if [[ $option_inherit == 'yes' ]]; then
			sudo_cmd+=(
				'env'
				"DOROTHY=$DOROTHY"
				"PATH=$PATH"
			)
		fi
	fi

	# run with sudo
	__wrap "${sudo_cmd[@]}" "${option_cmd[@]}"
)

# fire if invoked standalone
if [[ $0 == "${BASH_SOURCE[0]}" ]]; then
	sudo_helper "$@"
fi
