#!/usr/bin/env bash

function sudo_helper() (
	source "$DOROTHY/sources/bash.bash"

	# =====================================
	# Arguments

	# NOTE:

	# [sudo] and [doas] asks for your own password, not the target users password
	# [su] asks for the target user password
	# [sudo] and [doas] can be configured via their configuration files to target other users, not just [root]

	# EXAMPLE:

	# with this sudoers configuration file
	# developer ALL=(root,webuser) /a-special-echo arg1 arg2

	# and with /a-special-echo only being executable to [root] and [webuser]:
	# sudo chown root:webuser /a-special-echo
	# sudo chmod 750 /a-special-echo

	# if you are [webuser], you can run this without escalation (not because of sudoers, but because of the file-system permissions):
	# /a-special-echo arg1 arg2

	# if you are [someuser], you will be denied ability to run this (not because of sudoers, but because of the file-system permissions):
	# /a-special-echo arg1 arg2
	# and if that was the only configuration in sudoers, you would also be denied escalation to [root] or [webuser]

	# if you are [developer], you will be denied ability to run this (not because of sudoers, but because of the file-system permissions):
	# /a-special-echo arg1 arg2
	# however, sudoers will allow [developer] to escalate to [root] or [webuser]:
	# sudo /a-special-echo arg1 arg2
	# sudo -u webuser /a-special-echo arg1 arg2

	# TERMINOLOGY

	# "privilege escalation" is a bad thing: https://en.wikipedia.org/wiki/Privilege_escalation
	# use elevation/grant/authorise when it is good thing: https://en.wikipedia.org/wiki/Privilege_elevation

	function help {
		cat <<-EOF >&2
			ABOUT:
			Run the command with privilege elevation, be it via sudo or doas, or neither if not needed.

			USAGE:
			sudo-helper [...options] -- <command> [...args]
			sudo-helper --local

			OPTIONS:
			--elevated=<file|device-file|fd>
			    If specified, append [yes] to this target if the command required elevation.
			--elevate=<YES|no|''|failure|<exit-status>> | --sudo=<...>
			    If specified as yes, then the command will be elevated.
			    If <user> or <group> is specified, the remaining alternatives are discarded:
			    If specified as no, then the command will be run without elevation.
			    If specified as failure, then the command will be run without elevation, and if it fails, it will be run with elevation.
			    If specified as an integer, then the command will be run without elevation, and if it fails with that exit status, it will be run with elevation.
			    This can be specified multiple times, in which a [yes] or [no] value will reset prior values.
			    It can be [\n\t ,|] separated.
			    If this is not specified at all, it will default to [yes].
			    If this is specified as an empty string, it will default to [no].
			--user=<user>
			    Specify a user to run the command as. Forces --sudo=yes
			--group=<group>
			    Specify a group to run the command as. Forces --sudo=yes
			--reason=<reason>
			    If a prompt is required to momentarily grant privileges, this reason will be used to explain why elevation was required.

			--inherit
			    If enabled, inherit environment variables include PATH.

			--wrap
			    If enabled, [eval-helper] will be used to wrap the output of the command
			--quiet
			    If enabled, [eval-helper] will be used to silence the output of the command
			--confirm
			    If enabled, [eval-helper] will be used to confirm the execution of the command

			--local
			    Update sudo configuration to enable access to /usr/local paths

		EOF
		if [[ $# -ne 0 ]]; then
			echo-error "$@"
		fi
		return 22 # EINVAL 22 Invalid argument
	}

	# process
	# option_quiet='no' is an important default to ensure our call to eval-helper can still be interpolated
	local item option_cmd=() option_quiet='no' option_elevated='' option_elevate=() option_user='' option_group='' option_reason='' option_confirm='no' option_wrap='no' option_inherit='no' option_local=''
	function parse_sudo_arg_value {
		local sudo_arg="$1" sudo_args=()
		if [[ -z $sudo_arg ]]; then
			option_elevate+=('')
		else
			mapfile -t sudo_args < <(echo-split --characters=$'\n\t ,|' -- "$sudo_arg")
			option_elevate+=("${sudo_args[@]}")
		fi
	}
	while [[ $# -ne 0 ]]; do
		item="$1"
		shift
		case "$item" in
		'--help' | '-h') help ;;
		'--no-verbose'* | '--verbose'*)
			option_quiet="$(get-flag-value --non-affirmative --fallback="$option_quiet" -- "$item")"
			;;
		'--no-quiet'* | '--quiet'*)
			option_quiet="$(get-flag-value --affirmative --fallback="$option_quiet" -- "$item")"
			;;
		'--elevated='*) option_elevated="${item#*=}" ;;
		'--no-elevate'* | '--elevate'* | '--no-sudo'* | '--sudo'*) parse_sudo_arg_value "$(get-flag-value --affirmative -- "$item")" ;;
		'--user='*) option_user="${item#*=}" ;;
		'--group='*) option_group="${item#*=}" ;;
		'--reason='*) option_reason="${item#*=}" ;;
		'--no-inherit'* | '--inherit'*)
			option_inherit="$(get-flag-value --affirmative --fallback="$option_inherit" -- "$item")"
			;;
		'--no-wrap'* | '--wrap'*)
			option_wrap="$(get-flag-value --affirmative --fallback="$option_wrap" -- "$item")"
			;;
		'--no-confirm'* | '--confirm'*)
			option_confirm="$(get-flag-value --affirmative --fallback="$option_confirm" -- "$item")"
			;;
		'--no-local'* | '--local'*)
			option_local="$(get-flag-value --affirmative --fallback="$option_local" -- "$item")"
			;;
		'--')
			option_cmd+=("$@")
			shift "$#"
			break
			;;
		'--'*) help "An unrecognised flag was provided: $item" ;;
		*) help "An unrecognised argument was provided: $item" ;;
		esac
	done

	# local
	if [[ -n $option_local ]]; then
		# trim problematic paths
		local system_paths sudoers_line cron_system_line cron_user_line ignore_args=(
			# these are not needed for [dorothy run] to bootstrap itself
			--regexp="$HOME"
			--regexp='/Applications/'
		)
		if [[ -n ${HOMEBREW_PREFIX-} ]]; then
			# these are not needed for [dorothy run] to bootstrap itself
			# and they confuse cron as it thinks they have minutes due to version numbers
			ignore_args+=(
				--regexp="$HOMEBREW_PREFIX/Cellar"
				--regexp="$HOMEBREW_PREFIX/lib"
				--regexp="$HOMEBREW_PREFIX/opt"
			)
		fi
		system_paths="$(echo-split ':' --stdin <<<"$PATH" | grep --invert-match --fixed-strings "${ignore_args[@]}" | echo-join ':' --stdin)"

		sudoers_line="Defaults	secure_path=\"$system_paths\"" # $HOME paths do not make sense for root operation
		cron_system_line="PATH=\"$system_paths\""             # $HOME paths do not make sense for root operation
		cron_user_line="PATH=\"$system_paths\""               # $HOME paths fails to apply

		# sudoers
		config-edit --sudoers --line="$sudoers_line" --needle='secure_path' --add="$option_local"

		# cron
		config-edit --cron-system --line="$cron_system_line" --needle='PATH=' --add="$option_local"
		config-edit --cron-user --line="$cron_user_line" --needle='PATH=' --add="$option_local"

		# done
		return 0
	fi

	# check
	if [[ ${#option_cmd[@]} -eq 0 ]]; then
		help 'No <command> was provided.'
	fi

	# ensure sudo is a valid value
	local elevate='' elevate_on_statuses=()
	if [[ -n $option_user || -n $option_group ]]; then
		# validate user and group, user is important, as otherwise we will be creating directories for users that don't exist
		if [[ -n $option_user ]] && ! is-user -- "$option_user"; then
			echo-style --stderr --error1='Cannot elevate privileges to a non-existent user: ' --code-error1="$option_user"
			return 2 # ENOENT 2 No such file or directory
		fi
		if [[ -n $option_group ]] && ! is-group -- "$option_group"; then
			echo-style --stderr --error1='Cannot elevate privileges to a non-existent group: ' --code-error1="$option_group"
			return 2 # ENOENT 2 No such file or directory
		fi
		elevate='yes'
	elif [[ ${#option_elevate[@]} -eq 0 ]]; then
		elevate='yes'
	elif [[ -z ${option_elevate[*]} ]]; then
		elevate='no'
	else
		elevate='no'
		for item in "${option_elevate[@]}"; do
			case "$item" in
			'') : ;; # discard, it's already served its purpose in now defaulting to disabled
			'yes')
				elevate='yes'
				elevate_on_statuses=()
				;;
			'no')
				elevate='no'
				elevate_on_statuses=()
				;;
			'failure')
				elevate='failure'
				elevate_on_statuses=()
				;;
			[0-9]*)
				if ! is-integer -- "$item"; then
					help "An unrecognised value was provided for --sudo: $item"
				fi
				elevate='status'
				elevate_on_statuses+=("$item")
				;;
			*)
				help "An unrecognised value was provided for --sudo: $item"
				;;
			esac
		done
	fi

	# =====================================
	# Action

	# https://man.openbsd.org/doas
	# https://man.archlinux.org/man/doas.1.en

	# sudo
	# https://manpages.ubuntu.com/manpages/xenial/man8/sudo.8.html
	# -E, --preserve-env
	#    preserve user environment when running command
	# -H, --set-home
	#    set HOME variable to target user's home dir
	# -i, --login
	#    Run the shell specified by the target user's password database entry as a login shell.

	local command_style='code'
	function __wrap {
		if [[ $option_wrap == 'yes' || $option_confirm == 'yes' || $option_quiet == 'yes' ]]; then
			eval-helper --command="$(echo-style --"$command_style"="$(echo-escape-command -- "${option_cmd[@]}")")" --wrap="$option_wrap" --quiet="$option_quiet" --confirm="$option_confirm" -- "$@"
			return
		else
			"$@" # eval
			return
		fi
	}

	# determine technique
	local technique
	if __command_exists -- sudo; then
		technique='sudo'
	elif __command_exists -- doas; then
		technique='doas'
	else
		technique='none'
	fi

	# try without sudo
	if [[ $elevate == 'no' || $technique == 'none' ]]; then
		__wrap "${option_cmd[@]}"
		return
	elif [[ $elevate == 'failure' ]]; then
		if __wrap "${option_cmd[@]}"; then
			return 0
		fi
	elif [[ $elevate == 'status' ]]; then
		local status=0
		__wrap "${option_cmd[@]}" || status=$?
		for item in "${elevate_on_statuses[@]}"; do
			if [[ $status -eq $item ]]; then
				elevate='yes'
				break
			fi
		done
		if [[ $elevate != 'yes' ]]; then
			return "$status"
		fi
	fi

	# if desired, note that it needed elevation
	if [[ -n $option_elevated ]]; then
		__do --redirect-stdout="$option_elevated" -- __print_lines 'yes'
	fi

	# prep sudo execution
	command_style='sudo'
	local sudo_cmd=() home=''
	if [[ $technique == 'sudo' ]]; then
		sudo_cmd+=('sudo')

		# if no-tty, then use the builtin sudo workaround which is the same as Dorothy's
		# if ! __has_tty_support; then
		# 	sudo_cmd+=('--stdin') # note tha this outputs what they are typing unconcealed to terminal
		# 	# alternative is this insecure option: export SUDO_ASKPASS=...; sudo_cmd+=('--askpass')
		# 	# as this is an edge case in what is meant to be non-interactive environments, this is fine
		# fi
		# ^ don't enable this yet, until someone requests it, I don't know the implications

		# add the things specific to attestation, while prepping home
		# don't use is-directory, is-missing, __sudo_mkdirp, as they will cause infinite recursion
		if [[ -n $option_user ]]; then
			sudo_cmd+=("--user=$option_user")
			# should coincide with setup-environment-commands
			if [[ -d /Users ]]; then
				home="/Users/$option_user"
			elif [[ -d '/home' ]]; then
				home="/home/$option_user"
			elif [[ -d "/$option_user" ]]; then
				HOME="/$option_user"
			fi
		elif [[ -n $HOME ]]; then
			home="$HOME"
		fi
		if [[ -n $option_group ]]; then
			sudo_cmd+=("--group=$option_group")
		fi

		# check if password is required
		# [sudo --validate] doesn't work on multipass, so just use [true] as a no-op
		if ! "${sudo_cmd[@]}" --non-interactive -- true &>/dev/null; then
			# password is required, let the user know what they are being prompted for
			# [--code=*] better than [echo-style --element/="$(echo-escape-command -- "${sudo_cmd[@]}" | echo-join ' ' --stdin)"] as that is too verbose
			# use [--tty] to ensure the prompt is not hidden when otherwise hiding sudo output, such as in [command-working]
			# while it would be nice to clear lines, we cannot know how many lines to clear as they could require multiple attempts to enter the password
			if [[ -n $option_reason ]]; then
				echo-style --tty --notice="$option_reason"
			else
				echo-style --tty --notice='Your password is required to momentarily grant privileges to execute the command:'
			fi
			option_wrap='yes'
		fi

		# add the things specific to the command
		if [[ -n $home ]]; then
			if [[ ! -e $home && ! -L $home ]]; then
				sudo mkdir -p -- "$home" # don't use __sudo_mkdirp as that calls __try_sudo which calls this
				fs-own --quiet --user="$option_user" --group="$option_group" --no-recursive -- "$home"
			fi
			sudo_cmd+=('--set-home')
		fi

		# sudo supports passing environment variables
		if [[ $option_inherit == 'yes' ]]; then
			sudo_cmd+=(
				'--preserve-env'
				"PATH=$PATH"
				--
			)
			# if it is linux, [sudo PATH=$PATH] doesn't seem to work, but [env PATH=$PATH] does, so just duplicate it
			if is-linux; then
				sudo_cmd+=(
					'env'
					"PATH=$PATH"
				)
			fi
		else
			sudo_cmd+=(--)
		fi
	elif [[ $technique == 'doas' ]]; then
		# https://man.archlinux.org/man/doas.1.en
		sudo_cmd+=('doas')
		if [[ -n $option_user ]]; then
			sudo_cmd+=(
				'-u'
				"$option_user"
			)
		fi
		if [[ -n $option_group ]]; then
			help 'doas does not support --group'
		fi
		# doas doesn't support ENVVAR=value, nor --
		if [[ $option_inherit == 'yes' ]]; then
			sudo_cmd+=(
				'env'
				"DOROTHY=$DOROTHY"
				"PATH=$PATH"
			)
		fi
	fi

	# run with sudo
	__wrap "${sudo_cmd[@]}" "${option_cmd[@]}"
	return
)

# fire if invoked standalone
if [[ $0 == "${BASH_SOURCE[0]}" ]]; then
	sudo_helper "$@"
fi
