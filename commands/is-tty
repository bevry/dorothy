#!/usr/bin/env bash

function is_tty_test() (
	source "$DOROTHY/sources/bash.bash"
	source "$(type -P eval-tester)"
	echo-segment --h1="TEST: $0"

	function do_test { # üëç /docs/bash/errors: robust exit status, everything is ignored
		print_line "\$- = $-"

		# alpine doesn't support the [-p] argument
		if ! is-apk; then
			print_line 'tty:'
			ps -p "$$" -o tty= || :
		fi

		( (tty -s && echo tty_s_pass) || echo tty_s_fail) || :

		( (test -t 0 && echo test_t_stdin_pass) || echo test_t_stdin_fail) || :
		( (test -t 1 && echo test_t_stdout_pass) || echo test_t_stdout_fail) || :
		( (test -t 2 && echo test_t_stderr_pass) || echo test_t_stderr_fail) || :

		( (test -c /dev/stdin && echo test_c_stdin_pass) || echo test_c_stdin_fail) || :
		( (test -c /dev/stdout && echo test_c_stdout_pass) || echo test_c_stdout_fail) || :
		( (test -c /dev/stderr && echo test_c_stderr_pass) || echo test_c_stderr_fail) || :
		( (test -c /dev/tty && echo test_c_tty_pass) || echo test_c_tty_fail) || :

		# check if reading is even possible (If TIMEOUT is 0, read returns immediately, without trying to read any data, returning success only if input is available on the specified file descriptor.)
		( (read -t 0 && echo read_default_pass) || echo read_default_fail) || :
		( (read -t 0 </dev/stdin && echo read_stdin_pass) || echo read_stdin_fail) || :
		( (read -t 0 </dev/stdout && echo read_stdout_pass) || echo read_stdout_fail) || :
		( (read -t 0 </dev/stderr && echo read_stderr_pass) || echo read_stderr_fail) || :
		( (read -t 0 </dev/tty && echo read_tty_pass) || echo read_tty_fail) || :

		# don't use exec, don't use printf, they interefered with the read-key tests, as read-key would read [exec]
		# : is the same check but it is superior because it is a proper noop, unlike exec and printf

		( (: </dev/stdin && echo noop_from_stdin_pass) || echo noop_from_stdin_fail) || :
		( (: </dev/stdout && echo noop_from_stdout_pass) || echo noop_from_stdout_fail) || :
		( (: </dev/stderr && echo noop_from_stderr_pass) || echo noop_from_stderr_fail) || :
		( (: </dev/tty && echo noop_from_tty_pass) || echo noop_from_tty_fail) || :

		( (: >/dev/stdin && echo noop_to_stdin_pass) || echo noop_to_stdin_fail) || :
		( (: >/dev/stdout && echo noop_to_stdout_pass) || echo noop_to_stdout_fail) || :
		( (: >/dev/stderr && echo noop_to_stderr_pass) || echo noop_to_stderr_fail) || :
		( (: >/dev/tty && echo noop_to_tty_pass) || echo noop_to_tty_fail) || :

		( (: </dev/stdin >/dev/stdin && echo noop_bidirectonal_stdin_pass) || echo noop_bidirectonal_stdin_fail) || :
		( (: </dev/stdout >/dev/stdout && echo noop_bidirectonal_stdout_pass) || echo noop_bidirectonal_stdout_fail) || :
		( (: </dev/stderr >/dev/stderr && echo noop_bidirectonal_stderr_pass) || echo noop_bidirectonal_stderr_fail) || :
		( (: </dev/tty >/dev/tty && echo noop_bidirectonal_tty_pass) || echo noop_bidirectonal_tty_fail) || :
	}

	local stdout stderr

	do_test

	echo
	print_line '### testing pipe ###'
	print_line 'testing pipe' | do_test

	echo
	print_line '### testing delayed pipe ###'
	{
		sleep 1
		echo
	} | do_test || : # this is necessary, as otherwise the pipe fails with 141

	echo
	print_line '### testing <<< ###'
	do_test <<<'testing <<<'

	echo
	print_line '### testing < <(...) ###'
	do_test < <(print_line 'testing <<<')

	echo
	print_line '### --stdoutvar ###'
	stdout=''
	stderr=''
	eval_capture --stdoutvar=stdout -- do_test
	print_line 'stdout ='
	echo-lines --indent='    ' <<<"$stdout"
	print_line 'stderr ='
	echo-lines --indent='    ' <<<"$stderr"

	echo
	print_line '### --stderrvar ###'
	stdout=''
	stderr=''
	eval_capture --stderrvar=stderr -- do_test
	print_line 'stdout ='
	echo-lines --indent='    ' <<<"$stdout"
	print_line 'stderr ='
	echo-lines --indent='    ' <<<"$stderr"

	echo
	print_line '### --stdoutvar --stderrvar ###'
	stdout=''
	stderr=''
	eval_capture --stdoutvar=stdout --stderrvar=stderr -- do_test
	print_line 'stdout ='
	echo-lines --indent='    ' <<<"$stdout"
	print_line 'stderr ='
	echo-lines --indent='    ' <<<"$stderr"

	echo-segment --g1="TEST: $0"
	return 0
)
function is_tty() (
	source "$DOROTHY/sources/bash.bash"

	# =====================================
	# Arguments

	function help {
		cat <<-EOF >/dev/stderr
			ABOUT:
			Checks if the environment actually has a TTY available.
			This is important, as otherwise calls to [tty] will result in "not a tty" being output.

			USAGE:
			is-tty [..options]

			OPTIONS:
			--fallback
			    Output /dev/tty if available, otherwise output /dev/stderr. Always return success status.
		EOF
		if test "$#" -ne 0; then
			echo-error "$@"
		fi
		return 22 # EINVAL 22 Invalid argument
	}

	# process
	local item option_fallback='no'
	while test "$#" -ne 0; do
		item="$1"
		shift
		case "$item" in
		'--help' | '-h') help ;;
		'--no-fallback'* | '--fallback'*)
			option_fallback="$(get-flag-value fallback --missing="$option_fallback" -- "$item" | echo-affirmative)"
			;;
		'--'*) help "An unrecognised flag was provided: $item" ;;
		*) help "An unrecognised argument was provided: $item" ;;
		esac
	done

	# =====================================
	# Action

	# correctly, safely, and without side-effects, determine if the TTY is attached, readable, and writable
	# note that &>/dev/null is only possible for checking TTY (checking stdout/stderr that way will affect stdout/stderr, it is an observer effect)
	if test "$option_fallback" = 'yes'; then
		if (: </dev/tty >/dev/tty) &>/dev/null; then
			print_line '/dev/tty'
		else
			print_line '/dev/stderr'
		fi
		return 0
	else
		(: </dev/tty >/dev/tty) &>/dev/null
		return
	fi
)

# fire if invoked standalone
if test "$0" = "${BASH_SOURCE[0]}"; then
	if test "$*" = '--test'; then
		is_tty_test
	else
		is_tty "$@"
	fi
fi
