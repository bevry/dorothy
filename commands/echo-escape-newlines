#!/usr/bin/env bash

function echo_escape_newlines_test() (
	source "$DOROTHY/sources/bash.bash"

	eval-tester --name='using arguments' --stdout='a\nb' -- \
		echo-escape-newlines -- $'a\nb'

	{
		printf '%s' $'a\nb'
	} | eval-tester --name='using stdin' --stdout='a\nb' -- \
		echo-escape-newlines --stdin

	return 0
)
function echo_escape_newlines() (
	source "$DOROTHY/sources/stdinargs.bash"

	# =====================================
	# Arguments

	function help {
		__print_help "$@" <<-EOF || return $?
			ABOUT:
			For each <input>, escape its newlines into \`\\n\`.

			USAGE:
			\`echo-escape-newlines [...options] [--] ...<input>\`
			\`echo-lines ...<input> | echo-escape-newlines [...options]\`

			OPTIONS:
			$(__stdinargs__help_options --)

			EXAMPLES:
			\`echo-escape-newlines -- $'a\\nb'\`
			Outputs: \`a\\nb\`
			Returns: [0]

			\`printf '%s' \$'a\\nb' | echo-escape-newlines --stdin\`
			Outputs: \`a\\nb\`
			Returns: [0]

			\`printf '%s\\n' a b | echo-escape-newlines --stdin\`
			Outputs: \`a\\nb\\n\`
			Returns: [0]
		EOF
		return 22 # EINVAL 22 Invalid argument
	}

	# =====================================
	# Action

	function on_arg {
		local value="$1"
		value="${value//$'\n'/\\n}"
		__print_lines "$value"
	}
	function on_line {
		__print_string "$1\n"
	}
	function on_inline {
		__print_string "$1"
	}

	stdinargs "$@"
)

# fire if invoked standalone
if [[ $0 == "${BASH_SOURCE[0]}" ]]; then
	if [[ $* == '--test' ]]; then
		echo_escape_newlines_test
	else
		echo_escape_newlines "$@"
	fi
fi
