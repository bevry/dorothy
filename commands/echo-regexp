#!/usr/bin/env bash

function echo_regexp() (
	source "$DOROTHY/sources/stdinargs.bash"

	# =====================================
	# Arguments

	function help {
		cat <<-EOF >/dev/stderr
			ABOUT:
			Run a Regular Expression against the entire input, be it STDIN xor each argument.

			USAGE:
			echo-regexp [...options] [--] ...<input>
			echo-lines ...<input> | echo-regexp [...options]

			OPTIONS:
			--search=<search> | <search>
			    The regular expression to search for.

			--replace=<replace> | <replace>
			    The string to replace the search with.

			--flags=<flags> | <flags>
			    Regular expression flags, e.g. 'i' for case-insensitive.

			EXAMPLE:

			echo-lines a b c d | echo-regexp '([bc])' '{\$1}'

			    a
			    {b}
			    c
			    d

			echo-lines a b c d | echo-regexp '([bc])' '{\$1}' 'g'

			    a
			    {b}
			    {c}
			    d

			echo-lines a b c d | echo-regexp '(.+)' '{\$1}'

			    {a}
			    b
			    c
			    d

			echo-lines a b c d | echo-regexp '(.+)' '{\$1}' 'g'

			    {a}
			    {b}
			    {c}
			    {d}

			echo-lines a b c d | echo-regexp '(.+)' '{\$1}' 's'

			    {a
			    b
			    c
			    d
			    }

			echo-lines a b c d | echo-regexp '(?s:.+)' '{\$1}'

			    {a
			    b
			    c
			    d
			    }

			echo-lines a b c d | echo-regexp '(?s:(.+))' '{\$1}'

			    {a
			    b
			    c
			    d
			    }

			echo-lines a b c d | echo-regexp '([bc])' '{\$1}'

			    a
			    {b}
			    {c}
			    d

			echo-lines a b c d | echo-regexp '([bc])'\n '{\$1}'\n ''

			    a
			    {b}
			    d
		EOF
		if test "$#" -ne 0; then
			echo-error "$@"
		fi
		return 22 # EINVAL 22 Invalid argument
	}

	# args
	local item option_flags='' option_args=() option_inputs=()
	while test "$#" -ne 0; do
		item="$1"
		shift
		case "$item" in
		'--help' | '-h') help ;;
		'--flags='*) option_flags="${item#*=}" ;;
		-[gimsuyconqvf]*) option_flags+="${item#-}" ;;
		'--global') option_flags+='g' ;;
		'--ignore-case') option_flags+='i' ;;
		'--multiline') option_flags+='m' ;;
		'--dotall' | '--multiline-dotall') option_flags+='s' ;;
		'--unicode') option_flags+='u' ;;
		'--sticky') option_flags+='y' ;;
		'--count') option_flags+='c' ;;
		'--only' | '--only-matching') option_flags+='o' ;;
		'--newline' | '--newlines') option_flags+='n' ;;
		'--quiet') option_flags+='q' ;;
		'--verbose') option_flags+='v' ;;
		'--fail') option_flags+='f' ;;
		'--find='* | '--search='* | '--regexp='*)
			if test "${#option_args[@]}" -ne 0; then
				help "<search> must come before <...replacement>"
			else
				option_args+=("${item#*=}")
			fi
			;;
		'--replace='* | '--replacement='*)
			if test "${#option_args[@]}" -eq 0; then
				help "<replacement> must come after <search>"
			else
				option_args+=("${item#*=}")
			fi
			;;
		'--')
			option_inputs+=("$@")
			shift $#
			break
			;;
		*) option_args+=("$item") ;;
		esac
	done

	# check for search pattern
	if test "${#option_args[@]}" -eq 0; then
		help 'No <search> pattern provided.'
	fi

	# =====================================
	# Action

	# prep
	local deno_script
	deno_script="$(type -P 'echo-regexp.ts')"
	if command-missing -- deno; then # performance
		setup-util-deno --quiet
	fi

	function do_regexp {
		"$deno_script" "$option_flags" "${option_args[@]}"
	}

	if test "${#option_inputs[@]}" -eq 0; then
		do_regexp
	else
		local input
		for input in "${option_inputs[@]}"; do
			__print_lines "$input" | do_regexp
		done
	fi
)

# fire if invoked standalone
if test "$0" = "${BASH_SOURCE[0]}"; then
	echo_regexp "$@"
fi
