#!/usr/bin/env bash

function echo_regexp_test() (
	source "$DOROTHY/sources/bash.bash"
	eval-tester --ignore-stderr --status=22 -- echo-regexp --help

	# --------

	eval-tester --name='match works' --stdout='a  haystack' -- \
		echo-regexp 'a +haystack ?' -- 'a  haystack'

	eval-tester --name='match works' --stdout='b' -- \
		echo-regexp -i 'Z|B' -- 'abc'

	eval-tester --name='no match works' -- \
		echo-regexp 'Z|Y' -- 'abc'

	eval-tester --name='no match fails with -q' --status=1 -- \
		echo-regexp -q 'Z|Y' -- 'abc'

	# --------

	eval-tester --name='wrap [bc] with squigglies' --stdout='a{b}cd' -- \
		echo-regexp '([bc])' '{$1}' -- 'abcd'

	eval-tester --name='wrap [bc] with squigglies' --stdout=$'a\n{b}\nc\nd' -- \
		echo-regexp '([bc])' '{$1}' -- $'a\nb\nc\nd'

	eval-tester --name='wrap [bc] with squigglies, -g' --stdout='a{b}{c}d' -- \
		echo-regexp -g '([bc])' '{$1}' -- 'abcd'

	eval-tester --name='wrap [bc] with squigglies, -g' --stdout=$'a\n{b}\n{c}\nd' -- \
		echo-regexp -g '([bc])' '{$1}' -- $'a\nb\nc\nd'

	eval-tester --name='wrap [bc] with squigglies, -go' --stdout='{b}{c}' -- \
		echo-regexp -go '([bc])' '{$1}' -- 'abcd'

	eval-tester --name='wrap [bc] with squigglies, -go' --stdout='{b}{c}' -- \
		echo-regexp -go '([bc])' '{$1}' -- $'a\nb\nc\nd'

	eval-tester --name='wrap [bc] with squigglies, -gon' --stdout=$'{b}\n{c}' -- \
		echo-regexp -gon '([bc])' '{$1}' -- 'abcd'

	eval-tester --name='wrap [bc] with squigglies, -gon' --stdout=$'{b}\n{c}' -- \
		echo-regexp -gon '([bc])' '{$1}' -- $'a\nb\nc\nd'

	# --------

	eval-tester --name='wrap any with squigglies' --stdout=$'{a}\nb\nc\nd' -- \
		echo-regexp '(.+)' '{$1}' -- $'a\nb\nc\nd'

	eval-tester --name='wrap any with squigglies, -g' --stdout=$'{a}\n{b}\n{c}\n{d}' -- \
		echo-regexp -g '(.+)' '{$1}' -- $'a\nb\nc\nd'

	eval-tester --name='wrap any with squigglies, -s' --stdout=$'{a\nb\nc\nd}' -- \
		echo-regexp -s '(.+)' '{$1}' -- $'a\nb\nc\nd'

	if ! is-system --alpine; then
		eval-tester --name='wrap any with squigglies, -s via group' --stdout=$'{a\nb\nc\nd}' -- \
			echo-regexp '(?s:(.+))' '{$1}' -- $'a\nb\nc\nd'
	fi

	# --------

	eval-tester --name='count [bc], -c' --stdout='1' -- \
		echo-regexp -c '([bc])' -- 'abcd'

	eval-tester --name='count [bc], -cg' --stdout='2' -- \
		echo-regexp -cg '([bc])' -- 'abcd'

	eval-tester --name='count [bc], -cv' --stdout=$'a{b}cd\n1' -- \
		echo-regexp -cv '([bc])' '{$1}' -- 'abcd'

	eval-tester --name='count [bc], -cvg' --stdout=$'a{b}{c}d\n2' -- \
		echo-regexp -cvg '([bc])' '{$1}' -- 'abcd'

	eval-tester --name='count [bc], -cvon' --stdout=$'{b}\n1' -- \
		echo-regexp -cvon '([bc])' '{$1}' -- 'abcd'

	eval-tester --name='count [bc], -cvong' --stdout=$'{b}\n{c}\n2' -- \
		echo-regexp -cvong '([bc])' '{$1}' -- 'abcd'

	# --------

	eval-tester --name='-f [bc]' --stdout=$'a{b}cd' -- \
		echo-regexp -f '([bc])' '{$1}' -- 'abcd'

	eval-tester --name='-f [xyz]' --status=1 -- \
		echo-regexp -f '([xyz])' '{$1}' -- 'abcd'

	# --------

	eval-tester --name='character classes [[:XXX:]]' -- \
		echo-regexp -q '^[[:digit:]]+$' -- '012'

	eval-tester --name='character classes [[:XXX:][:YYY:]]' -- \
		echo-regexp -q '^[[:digit:][:lower:]]+$' -- 'z0'

	# --------

	return 0
)
function echo_regexp() (
	source "$DOROTHY/sources/bash.bash"

	# =====================================
	# Arguments

	function help {
		__print_help "$@" <<-EOF || return $?
			ABOUT:
			Run a Regular Expression against the entire input, be it STDIN xor each argument.

			USAGE:
			\`echo-regexp [...options] [--] ...<input>\`
			\`echo-lines ...<input> | echo-regexp [...options]\`

			OPTIONS:
			--search=<search> | <search>
			    The regular expression to search for.

			--replace=<replace> | <replace>
			    The string to replace the search with.

			--flags=<flags> | <flags>
			    Regular expression flags, e.g. \`i\` for case-insensitive.

			FLAGS:
			-g | --global
			    Search for all matches in the input.
			-i | --ignore-case
			    Ignore case when matching.
			-m | --multiline
			    Have ^ and $ match the start/end of each line.
			-s | --dotall | --multiline-dotall
			    Have . match newlines.
			-u | --unicode
			    Enable Unicode mode.
			-y | --sticky
			    Only match from the index indicated by the lastIndex property of this regular expression in the target string.
			-c | --count
			    Count the number of matches.
			-o | --only | --only-matching
			    Only return the matches, not the full string.
			-n | --newline | --newlines
			    Separate matches with newlines.
			-q | --quiet
			    Do not output anything, returning failure exit status if no matches. Implied \`--fail\`.
			-v | --verbose
			    When counting, output matches.
			-f | --fail
			    Return failure exit status if no matches. Output as normal.

			EXAMPLES:
			\`\`\`
			echo-lines -- a b c d | echo-regexp '(.+)' '{\$1}'
			\`\`\`
			Outputs:
			\`\`\`
			{a}
			b
			c
			d
			\`\`\`
			Returns: [0]

			\`\`\`
			echo-lines -- a b c d | echo-regexp -g '(.+)' '{\$1}'
			\`\`\`
			Outputs:
			\`\`\`
			{a}
			{b}
			{c}
			{d}
			\`\`\`
			Returns: [0]

			Using dotall via regular expression flag:
			<https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Regular_expressions#regex_flags>
			Then using dotall via regular expression modifier:
			<https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Regular_expressions/Modifier>
			\`\`\`
			echo-lines -- a b c d | echo-regexp -s '(.+)' '{\$1}'
			echo-lines -- a b c d | echo-regexp '(?s:(.+))' '{\$1}'
			\`\`\`
			Outputs:
			\`\`\`
			{a
			b
			c
			d
			}
			\`\`\`
			Returns: [0]

			Using dotall without the trailing newline:
			\`\`\`
			echo-lines --no-trail -- a b c d | echo-regexp -s '(.+)' '{\$1}'
			echo-lines --no-trail -- a b c d | echo-regexp '(?s:(.+))' '{\$1}'
			\`\`\`
			Outputs:
			\`\`\`
			{a
			b
			c
			d}
			\`\`\`
			Returns: [0]
		EOF
		return 22 # EINVAL 22 Invalid argument
	}

	# args
	local item option_flags='' option_args=() option_inputs=()
	while [[ $# -ne 0 ]]; do
		item="$1"
		shift
		case "$item" in
		'--help' | '-h') help ;;
		'--flags='*) option_flags="${item#*=}" ;;
		-[gimsuyconqvf]*) option_flags+="${item#-}" ;;
		'--global') option_flags+='g' ;;
		'--ignore-case') option_flags+='i' ;;
		'--multiline') option_flags+='m' ;;
		'--dotall' | '--multiline-dotall') option_flags+='s' ;;
		'--unicode') option_flags+='u' ;;
		'--sticky') option_flags+='y' ;;
		'--count') option_flags+='c' ;;
		'--only' | '--only-matching') option_flags+='o' ;;
		'--newline' | '--newlines') option_flags+='n' ;;
		'--quiet') option_flags+='q' ;;
		'--verbose') option_flags+='v' ;;
		'--fail') option_flags+='f' ;;
		'--find='* | '--search='* | '--regexp='*)
			if [[ ${#option_args[@]} -ne 0 ]]; then
				help '<search> must come before <...replacement>'
			else
				option_args+=("${item#*=}")
			fi
			;;
		'--replace='* | '--replacement='*)
			if [[ ${#option_args[@]} -eq 0 ]]; then
				help '<replacement> must come after <search>'
			else
				option_args+=("${item#*=}")
			fi
			;;
		'--')
			option_inputs+=("$@")
			shift $#
			break
			;;
		*) option_args+=("$item") ;;
		esac
	done

	# check for search pattern
	if [[ ${#option_args[@]} -eq 0 ]]; then
		help 'No <search> pattern provided.'
	fi

	# =====================================
	# Action

	local deno_script
	deno_script="$(type -P 'echo-regexp.ts')"
	__command_required -- 'deno'

	function __do_regexp {
		"$deno_script" "$option_flags" "${option_args[@]}"
	}

	if [[ ${#option_inputs[@]} -eq 0 ]]; then
		__do_regexp
	else
		local input
		for input in "${option_inputs[@]}"; do
			__print_string "$input" | __do_regexp
		done
	fi
)

# fire if invoked standalone
if [[ $0 == "${BASH_SOURCE[0]}" ]]; then
	if [[ $* == '--test' ]]; then
		echo_regexp_test
	else
		echo_regexp "$@"
	fi
fi
