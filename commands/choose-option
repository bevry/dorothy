#!/usr/bin/env bash
source "$DOROTHY/sources/strict.bash"
source "$DOROTHY/sources/shims.bash"
source "$DOROTHY/sources/arrays.bash"
may_require_array_support 'mapfile' 'empty'

# validate
if is-help-separator "$@"; then
	stderr cat <<-EOF
		ABOUT:
		Prompt the user to select a value from a list of values, in a clean and robust way.

		USAGE:
		choose-option \\
			[--question=question] \\
			[--filter=filter] \\
			[--label[=first]] \\
			[--return='\$label'] \\
			[--visual='\$label [\$value]'] \\
			[--required] \\
			[--multi] \\
			[--confirm] \\
			-- <[value]...> <value> <value>

		If you wish to show a question above the menu:
		--question=question -- <...>

		If you wish to filter the value and/or labels, use:
		--filter=filter -- <...>

		If you wish to prevent using the escape key to provide no selection, use:
		--required -- <...>

		If you wish to allow multiple selections:
		--multi -- <...>

		If you wish to confirm the selection with the user:
		--confirm -- <...>

		If you wish to pass values and labels, use:
		--label -- <[value, label]...> <value> <label> <value> <label>

		If you wish to pass label then value, use:
		--label=first -- <[label, value]...> <label> <value> <label> <value>

		By default, if the label and value differ, both will be displayed,
		 and if they are the same, then only the value will be displayed.

		If you wish to customise what is displayed:
		--label --visual='\$label [\$value]' -- <[value, label]...>
		^ the value is eval'd

		If you wish to return the label use:
		--label --return='\$label' -- <[value, label]...>
		^ the value is eval'd

		If you wish to return the visual use:
		--label --return='\$visual' -- <[value, label]...>
		^ the value is eval'd
	EOF
	exit 22 # Invalid argument
fi

# fetch options in a way that works with multi-line values
options=()
while [ $# -gt 0 ]; do
	if [ "$1" = '--' ]; then
		shift
		break
	fi
	options+=("$1")
	shift
done
option_question="$(get-flag-value question -- "${options[@]}")"
option_filter="$(get-flag-value filter -- "${options[@]}")"
option_timeout="$(get-flag-value timeout -- "${options[@]}")"
option_multi="$(get-flag-value multi --missing=no -- "${options[@]}" | echo-affirmative)"
option_confirm="$(get-flag-value confirm --missing=no -- "${options[@]}" | echo-affirmative)"
option_required="$(get-flag-value required --missing=no -- "${options[@]}" | echo-affirmative)"
option_label="$(get-flag-value label --missing=no -- "${options[@]}")" # can also be =first
option_visual="$(get-flag-value visual -- "${options[@]}")"
# shellcheck disable=SC2016
option_return="$(get-flag-value 'return' --missing='$value' -- "${options[@]}")"

# prepare items
items=("$@")
values=()
labels=()
visuals=()

# calculate item step size
items_step=1
if test "$option_label" != 'no'; then
	items_step=2
fi

# check user configuration has no mistakes
if test "${#items[@]}" -eq 0; then
	# ^ bash v3 compat
	{
		echo-color --error="No options were provided. See [$0 --help] for usage."
	} >/dev/stderr
	sleep 10
	exit 22 # Invalid argument
elif is-array-partial "${items[@]}"; then
	{
		echo-color --error="Empty options were provided. See [$0 --help] for usage."
	} >/dev/stderr
	echo-verbose "${items[@]}" >/dev/stderr
	sleep 10
	exit 22 # Invalid argument
fi
if test "$option_label" != 'no' && is-odd "${#items[@]}"; then
	{
		echo-color --error="The amount of labels must match the amount of options. See [$0 --help] for usage."
		echo-color --bold="Make the below provide an even amount of items, to ensure there is a label for each option."
		echo-verbose "${items[@]}"
	} >/dev/stderr
	sleep 10
	exit 22 # Invalid argument
fi

# iterate our items
for ((i = 0; i < ${#items[@]}; i = i + items_step)); do
	# order of
	if test "$option_label" = 'no'; then
		value="${items[$i]}"
		label="${items[$i]}"
	elif test "$option_label" = 'yes'; then
		value="${items[$i]}"
		label="${items[$i + 1]}"
	elif test "$option_label" = 'first'; then
		value="${items[$i + 1]}"
		label="${items[$i]}"
	else
		stderr echo "bad configuration: the --label value is invalid: [$option_label]"
		sleep 10
		exit 1
	fi

	# check both exist
	if test -z "$label" -o -z "$value"; then
		stderr echo "bad configuration: both label [$label] and value [$value] must exist"
		sleep 10
		exit 1
	fi

	# add to the list
	if test -n "$option_visual"; then
		eval "visual=\"$option_visual\""
	else
		visual="$label"
	fi

	# add to the list
	visuals+=("$visual")
	labels+=("$label")
	values+=("$value")
done

# sanity checks
if test "${#labels[@]}" -ne "${#values[@]}" -o "${#values[@]}" -ne "${#visuals[@]}"; then
	stderr echo "bad state: there must be the same amount of values, labels, and visuals"
	sleep 10
	exit 1
fi
if is-array-empty-or-partial "${labels[@]}"; then
	stderr echo "bad configuration: empty labels were provided:"
	stderr echo-verbose "${labels[@]}"
	sleep 10
	exit 1
fi
if is-array-empty-or-partial "${values[@]}"; then
	stderr echo "bad configuration: empty values were provided"
	stderr echo-verbose "${values[@]}"
	sleep 10
	exit 1
fi
if is-array-empty-or-partial "${visuals[@]}"; then
	stderr echo "bad configuration: empty visuals were provided"
	stderr echo-verbose "${values[@]}"
	sleep 10
	exit 1
fi

# helpers
final_results=()
function send_result() {
	local value="$1"
	local label="$2"
	local visual="$3"
	local result=''
	eval "result=\"$option_return\""
	final_results+=("$result")
}
function act() {
	local ec value label visual results confirm_value
	local filtered_values=()
	local filtered_labels=()
	local filtered_visuals=()
	final_results=() # not local, @todo find out why

	for i in "${!values[@]}"; do
		value="${values[$i]}"
		label="${labels[$i]}"
		visual="${visuals[$i]}"
		if test -n "$option_filter"; then
			# if we have a value, then constrain selection
			# compare their lowercase forms
			if [[ "$(lc "$label")" = *"$(lc "$option_filter")"* ]] || [[ "$(lc "$value")" = *"$(lc "$option_filter")"* ]]; then
				filtered_values+=("$value")
				filtered_labels+=("$label")
				filtered_visuals+=("$visual")
			fi
		else
			filtered_values+=("$value")
			filtered_labels+=("$label")
			filtered_visuals+=("$visual")
		fi
	done

	# todo, have this reprompt
	if is-array-empty-or-partial "${filtered_values[@]}"; then
		echo "Filter [$option_filter] returned no results, providing you all the results to select from." >/dev/tty
		option_filter=''
		act
		exit "$?" # exit with the above on success and failure
	fi

	# if we have only one option, then use that
	if test "${#filtered_values[@]}" -eq 1; then
		send_result "${filtered_values[0]}" "${filtered_labels[0]}" "${filtered_visuals[0]}"
	else
		# ask
		ec=0 && results="$(choose-menu \
			--question="$option_question" \
			--multi="$option_multi" \
			--required="$option_required" \
			--timeout="$option_timeout" \
			-- "${filtered_visuals[@]}")" || ec="$?"

		# check
		if test "$ec" -eq 62; then
			echo "Menu timed out [$ec]." >/dev/stderr
			sleep 10
			exit "$ec"
		elif test "$ec" -ne 0; then
			echo "Menu failed [$ec]." >/dev/stderr
			# some other failure
			sleep 10
			exit "$ec"
		elif test -z "$results"; then
			# no option
			if test "$option_required" = 'no'; then
				exit 0
			else
				echo "No input returned, despite required." >/dev/stderr
				sleep 10
				exit 5 # Input/output error
			fi
		fi

		# results
		mapfile -t results <<<"$results"
		test "${#results[@]}" -ne 0 && for i in "${results[@]}"; do
			send_result "${filtered_values[$i]}" "${filtered_labels[$i]}" "${filtered_visuals[$i]}"
		done
	fi

	# confirm if necessary if more than one possible value]
	if test "${#values[@]}" -gt 1 -a "$option_confirm" = 'yes'; then
		# timeout of one minute for confirms of existing values
		confirm_value="$(echo -n "${final_results[@]}")"
		ec=0 && confirmed="$(choose-option \
			--timeout=60 \
			--question="$option_question" \
			--required="$option_required" \
			--label \
			-- \
			yes "Use: $confirm_value" \
			no "Select something else.")" || ec="$?"

		# check
		if test "$ec" -ne 0; then
			echo "Timed out, using fallback value: $confirm_value" >/dev/stderr
			sleep 10
		fi

		# results
		if test "$confirmed" = 'no'; then
			option_filter=''
			act
			exit "$?" # exit with the above on success and failure
		fi
	fi

	# return the results
	echo-lines "${final_results[@]}"
}

# do the action
act
exit "$?" # exit with the above on success and failure
