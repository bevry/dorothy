#!/usr/bin/env bash

# @todos
# - [ ] config-helper sudo escalation
# - [ ] find out why xonsh is not getting installed
# - [ ] find out why all the shells aren't be configured correctly
# - [ ] save configuration updates

function setup_shell() (
	source "$DOROTHY/sources/bash.bash"
	source "$DOROTHY/sources/environment.sh" # ensure new installations are detected
	source "$DOROTHY/sources/styles.bash"

	# used by these helpers
	local option_brew='' option_exclusions=()
	local all_installable_basenames_of_shells=(
		# in order of usage
		bash
		zsh
		fish
		nu
		xonsh
		elvish
		dash
		ksh
	)
	local all_configurable_basenames_of_shells=("${all_installable_basenames_of_shells[@]}") # maybe one day this will be different
	local all_allowable_basenames_of_shells=("${all_installable_basenames_of_shells[@]}")    # maybe one day this will be different, and note that this needs to be merged with active system login shells

	function get_name_of_basename_of_shell {
		local shell="$1"
		case "$shell" in
		'bash') __print_lines 'Bash' ;;
		'zsh') __print_lines 'Zsh' ;;
		'fish') __print_lines 'Fish' ;;
		'nu') __print_lines 'Nu' ;;
		'xonsh') __print_lines 'Xonsh' ;;
		'elvish') __print_lines 'Elvish' ;;
		'dash') __print_lines 'Dash' ;;
		'ksh') __print_lines 'KSH' ;; # http://kornshell.com/doc/faq.html KornShell is the language, KSH-93 is the most recent version of the language, ksh is the program, so do KSH as a middle-ground
		*) __print_lines "$shell" ;;
		esac
	}

	function get_url_of_basename_of_shell {
		local shell="$1"
		case "$shell" in
		'bash') __print_lines 'https://en.wikipedia.org/wiki/Bash_(Unix_shell)' ;;
		'zsh') __print_lines 'https://en.wikipedia.org/wiki/Z_shell' ;;
		'fish') __print_lines 'https://en.wikipedia.org/wiki/Fish_(Unix_shell)' ;;
		'nu') __print_lines 'https://www.nushell.sh' ;;
		'xonsh') __print_lines 'https://xon.sh' ;;
		'elvish') __print_lines 'https://en.wikipedia.org/wiki/Fish_(Unix_shell)' ;;
		'dash') __print_lines 'https://en.wikipedia.org/wiki/Almquist_shell#Dash' ;;
		'ksh') __print_lines 'https://en.wikipedia.org/wiki/KornShell' ;;
		esac
	}

	function get_url_label_of_basename_of_shell {
		local shell="$1" name url
		name="$(get_name_of_basename_of_shell "$shell")"
		url="$(get_url_of_basename_of_shell "$shell")"
		if [[ -n $url ]]; then
			__print_style --bold="$name: " --dim="$url"
		else
			__print_style --bold="$name"
		fi
	}

	function gets_url_label_of_basenames_of_shells {
		local shells=("$@") shell
		for shell in "${shells[@]}"; do
			get_url_label_of_basename_of_shell "$shell"
		done
	}

	function get_version_of_path_of_shell {
		local path="$1" shell
		shell="$(basename -- "$path")"
		case "$shell" in
		'bash') command "$path" -c "printf '%s\n' \"\$BASH_VERSION\"" ;; # eval
		'zsh') command "$path" -c "printf '%s\n' \"\$ZSH_VERSION\"" ;;   # eval
		'fish') command "$path" -c "printf '%s\n' \"\$FISH_VERSION\"" ;; # eval
		'nu') command "$path" -c "printf '%s\n' \$env.NU_VERSION" ;;     # eval
		'elvish') command "$path" --version ;;                           # eval
		*) : ;;
		# go on the safe side, any don't do versions for anything we can't guarantee handling of
		#'dash' | 'ksh') : ;;  # these don't support [<shell> --version]
		# the bellow works for everything so far except nu, which [nu --version] just outputs the version
		#*) command "$path" --version | echo-regexp -on --search='version ([^( ]+)' --replace="\$1" ;;
		esac
	}

	function get_path_label_of_path_of_shell {
		local path="$1" shell name version args=()
		shell="$(basename -- "$path")"
		name="$(get_name_of_basename_of_shell "$shell")"
		version="$(get_version_of_path_of_shell "$path")"
		if [[ -n $version ]]; then
			args=(--bold="$name" ' ' --blue="$version" ' ' --dim="$path")
		else
			args=(--bold="$name" ' ' --dim="$path")
		fi
		__print_style "${args[@]}"
	}

	function __is_permitted_shell {
		local shell="$1" basename
		if [[ $option_brew != 'no' && ${#option_exclusions[@]} -eq 0 ]]; then
			return 0
		fi
		basename="$(basename -- "$shell")"
		if [[ $shell == "$basename" ]]; then
			# shell is basename, just check basename
			if __has --source={option_exclusions} -- "$shell"; then
				return 1
			fi
		else
			# shell is path, check both path and basename, and brew
			if [[ $option_brew == 'no' && -n ${HOMEBREW_PREFIX-} && $shell == "$HOMEBREW_PREFIX"* ]] || __has --source={option_exclusions} --cursor --first -- "$shell" "$basename"; then
				return 1
			fi
		fi
		return 0
	}

	function get_unique_and_permitted_shells {
		local shell permitted_shells=()
		for shell in "$@"; do
			if __is_permitted_shell "$shell"; then
				permitted_shells+=("$shell")
			fi
		done
		if [[ ${#permitted_shells[@]} -eq 0 ]]; then
			return
		fi
		echo-unique -- "${permitted_shells[@]}"
	}

	function get_unique_and_permitted_paths_of_shells {
		local shell all=()
		for shell in "$@"; do
			# returns all matching paths, or no paths, of the shell path or basename
			# which -a "$basename_or_path"
			# type -pa "$basename_or_path"
			# type -Pa "$basename_or_path" || : # suppress failure status if no results
			local paths=() path
			__split --target={paths} --no-zero-length --invoke=try -- \
				type -Pa "$shell"
			if [[ ${#paths[@]} -ne 0 ]]; then
				__split --target={paths} --no-zero-length --invoke -- \
					get_unique_and_permitted_shells "${paths[@]}"
				all+=("${paths[@]}")
			fi
		done
		if [[ ${#all[@]} -ne 0 ]]; then
			echo-unique -- "${all[@]}"
		fi
	}

	function get_unique_and_permitted_paths_of_allowed_shells {
		local paths=()
		__split --target={paths} --no-zero-length --invoke=try -- \
			echo-regexp -onm '^(/[^#]+).*$' '$1' </etc/shells
		if [[ ${#paths[@]} -ne 0 ]]; then
			get_unique_and_permitted_shells "${paths[@]}"
		fi
	}

	function get_unique_and_permitted_basenames_of_shells {
		local shell basenames=()
		for shell in "$@"; do
			if __is_permitted_shell "$shell"; then
				basenames+=("$(basename -- "$shell")")
			fi
		done
		# de-dup
		echo-unique -- "${basenames[@]}"
	}

	function get_unique_and_permitted_basenames_of_shells_with_labels {
		local basenames=() basename shell results=() label
		__split --target={basenames} --no-zero-length --invoke -- \
			get_unique_and_permitted_basenames_of_shells "$@"
		if [[ ${#basenames[@]} -eq 0 ]]; then
			return
		fi
		for basename in "${basenames[@]}"; do
			label="$(get_url_label_of_basename_of_shell "$basename")"
			results+=("$basename" "$label")
		done
		__print_lines "${results[@]}"
	}

	function get_unique_and_permitted_paths_of_shells_with_labels {
		local paths=() results=() label
		__split --target={paths} --no-zero-length --invoke -- \
			get_unique_and_permitted_paths_of_shells "$@"
		if [[ ${#paths[@]} -eq 0 ]]; then
			return
		fi
		for path in "${paths[@]}"; do
			label="$(get_path_label_of_path_of_shell "$path")"
			results+=("$path" "$label")
		done
		__print_lines "${results[@]}"
	}

	function get_unique_and_permitted_installed_shells {
		local shells=() shell results=()
		__split --target={shells} --no-zero-length --invoke -- \
			get_unique_and_permitted_shells "$@"
		if [[ ${#shells[@]} -eq 0 ]]; then
			return
		fi
		for shell in "${shells[@]}"; do
			if __command_exists -- "$shell"; then
				results+=("$shell")
			fi
		done
		if [[ ${#results[@]} -eq 0 ]]; then
			return
		fi
		__print_lines "${results[@]}"
	}

	function get_unique_and_permitted_configured_basenames_of_shells {
		local basenames=() basename fn results=()
		__split --target={basenames} --no-zero-length --invoke -- \
			get_unique_and_permitted_basenames_of_shells "$@"
		if [[ ${#basenames[@]} -eq 0 ]]; then
			return
		fi
		for basename in "${basenames[@]}"; do
			fn="__is_configured_$basename"
			if "$fn"; then
				results+=("$basename")
			fi
		done
		__print_lines "${results[@]}"
	}

	function get_unique_and_permitted_configured_paths_of_shells {
		local basenames=()
		__split --target={basenames} --no-zero-length --invoke -- \
			get_unique_and_permitted_configured_basenames_of_shells "$@"
		if [[ ${#basenames[@]} -eq 0 ]]; then
			return
		fi
		get_unique_and_permitted_paths_of_shells "${basenames[@]}"
	}

	function allow_login_shell_path {
		local login_shell_path="$1"
		config-helper --file=/etc/shells -- \
			--string-find="$login_shell_path" --replace="$login_shell_path"
	}
	function disallow_login_shell_path {
		local login_shell_path="$1"
		config-helper --file=/etc/shells -- \
			--string-find="$login_shell_path" --replace=''
	}

	local apply_login_shell_method='none'
	if is-ci; then
		if [[ -f /etc/passwd ]]; then
			apply_login_shell_method='passwd'
		fi
	elif __command_exists -- chpass; then
		apply_login_shell_method='chpass'
	elif __command_exists -- chsh; then
		apply_login_shell_method='chsh'
	elif __command_exists -- usermod; then
		apply_login_shell_method='usermod'
	elif __command_exists -- lchsh; then
		apply_login_shell_method='lchsh'
	elif [[ -f /etc/passwd ]]; then
		apply_login_shell_method='passwd'
	fi
	case "$apply_login_shell_method" in
	chpass)
		function apply_login_shell_path {
			local login_shell_path="$1" __chpass_status
			# [chpass] only give you one password attempt, so do it in a loop
			while :; do
				__chpass_status=0
				chpass -s "$login_shell_path" -u "$USER" || __chpass_status=$?
				if [[ $__chpass_status -eq 0 ]]; then
					# successfully updated
					__print_style --tty --dim='You can ignore [chpass: no changes made] warnings.' || return
					break
				elif [[ $__chpass_status -eq 1 ]]; then
					# incorrect password
					continue # try again
				elif [[ $__chpass_status -eq 130 ]]; then
					# 130 = SIGINT = ctrl+c = abort
					__print_style --stderr --error="Updating the login shell failed because [chpass] was aborted with exit status [$__chpass_status]." || return
					return 125 # ECANCELED 125 Operation cancelled
				else
					__print_style --stderr --error="Updating the login shell failed because [chpass] failed with exit status [$__chpass_status]." || return
					return "$__chpass_status"
				fi
			done
		}
		;;
	chsh)
		# ubuntu
		function apply_login_shell_path {
			local login_shell_path="$1"
			chsh -s "$login_shell_path" "$USER"
			return
		}
		;;
	usermod)
		# fedora
		function apply_login_shell_path {
			local login_shell_path="$1"
			eval-helper --elevate -- usermod --shell "$login_shell_path" "$USER"
			return
		}
		;;
	lchsh)
		# fedora
		function apply_login_shell_path {
			local login_shell_path="$1"
			__print_lines "$login_shell_path" | eval-helper --elevate -- lchsh "$USER" >/dev/null # output is confusing
			return
		}
		;;
	passwd)
		# everything else, including alpine
		function apply_login_shell_path {
			local login_shell_path="$1" bin_gsed_or_sed
			# @todo rewrite this with config-helper
			bin_gsed_or_sed="$(echo-gnu-command --install -- gsed || :)"
			if [[ -z $bin_gsed_or_sed ]]; then
				return 1
			fi
			# @todo replace with `echo-regexp` and `echo-write`
			eval-helper --elevate --inherit -- \
				"$bin_gsed_or_sed" --in-place --regexp-extended \
				--expression="s#^($USER:.+:).+?\$#\1$login_shell_path#" \
				/etc/passwd
			return
		}
		;;
	esac

	# bash
	function __is_configured_bash {
		# @todo don't implement these potential alternatives, as the implemented one is the best
		# echo-regexp --quiet --search='.+? # Dorothy' --any --file="$HOME/.bash_profile" --file="$HOME/.bashrc"
		# echo-regexp -q '.+? # Dorothy' --any -- "$HOME/.bash_profile" "$HOME/.bashrc"
		# echo-file --raw --optional -- "$HOME/.bash_profile" "$HOME/.bashrc" | echo-regexp -q '.+? # Dorothy'
		echo-if-present -- "$HOME/.bash_profile" "$HOME/.bashrc" "$HOME/.profile" | echo-file --raw --stdin | echo-regexp -q '.+?(init.sh).*? # Dorothy'
		return
	}
	function configure_bash {
		# mac and raspi ubuntu
		config-helper --file="$HOME/.bash_profile" -- \
			--find='.+? # Dorothy' --replace="source \"$DOROTHY/init.sh\" # Dorothy"

		# vm ubuntu
		config-helper --file="$HOME/.bashrc" -- \
			--find='.+? # Dorothy' --replace="source \"$DOROTHY/init.sh\" # Dorothy"
	}
	function deconfigure_bash {
		config-helper --file="$HOME/.bash_profile" -- \
			--find='.+? # Dorothy' --replace=''
		config-helper --file="$HOME/.bashrc" -- \
			--find='.+? # Dorothy' --replace=''
		config-helper --file="$HOME/.profile" -- \
			--find='.+?(init.sh).*? # Dorothy' --replace=''
	}

	# dash
	function __is_configured_dash {
		echo-if-present -- "$HOME/.profile" | echo-file --raw --stdin | echo-regexp -q '.+?(init.sh|init.dash).*? # Dorothy'
		return
	}
	function configure_dash {
		config-helper --file="$HOME/.profile" -- \
			--find='.+?(init.sh|init.dash).*? # Dorothy' --replace=". \"$DOROTHY/init.dash\" # Dorothy"
	}
	function deconfigure_dash {
		config-helper --file="$HOME/.profile" -- \
			--find='.+?(init.sh|init.dash).*? # Dorothy' --replace=''
	}

	# ksh
	function __is_configured_ksh {
		echo-if-present -- "$HOME/.profile" | echo-file --raw --stdin | echo-regexp -q '.+?(init.sh|init.ksh).*? # Dorothy'
		return
	}
	function configure_ksh {
		config-helper --file="$HOME/.profile" -- \
			--find='.+?(init.sh|init.ksh).*? # Dorothy' --replace=". \"$DOROTHY/init.ksh\" # Dorothy"
	}
	function deconfigure_ksh {
		config-helper --file="$HOME/.profile" -- \
			--find='.+?(init.sh|init.ksh).*? # Dorothy' --replace=''
	}

	# zsh
	function __is_configured_zsh {
		echo-if-present -- "$HOME/.zshrc" "$ZDOTDIR/.zprofile" | echo-file --raw --stdin | echo-regexp -q '.+? # Dorothy'
		return
	}
	function configure_zsh {
		setup-util-zsh --configure
		config-helper --file="$ZDOTDIR/.zshrc" -- \
			--find='.+? # Dorothy' --replace="source '$DOROTHY/init.sh' # Dorothy"
		config-helper --file="$ZDOTDIR/.zprofile" -- \
			--find='.+? # Dorothy' --replace="source '$DOROTHY/init.sh' # Dorothy"
	}
	function deconfigure_zsh {
		if [[ -d $ZDOTDIR ]]; then
			config-helper --file="$ZDOTDIR/.zshrc" -- \
				--find='.+? # Dorothy' --replace=''
			config-helper --file="$ZDOTDIR/.zprofile" -- \
				--find='.+? # Dorothy' --replace=''
		fi
	}

	# fish
	local fish_config_home="$XDG_CONFIG_HOME/fish"
	function __is_configured_fish {
		echo-if-present -- "$fish_config_home/config.fish" | echo-file --raw --stdin | echo-regexp -q '.+? # Dorothy'
	}
	function configure_fish {
		__mkdirp "$fish_config_home"
		config-helper --file="$fish_config_home/config.fish" -- \
			--find='.+? # Dorothy' --replace="source '$DOROTHY/init.fish' # Dorothy"
	}
	function deconfigure_fish {
		if [[ -d $fish_config_home ]]; then
			config-helper --file="$fish_config_home/config.fish" -- \
				--find='.+? # Dorothy' --replace=''
		fi
	}

	# nu
	function __is_configured_nu {
		local nu_config_path
		if __command_exists -- nu; then
			nu_config_path="$(nu -c 'echo $nu.loginshell-path')"
			echo-if-present -- "$nu_config_path" | echo-file --raw --stdin | echo-regexp -q '.+? # Dorothy'
			return
		else
			return 1
		fi
	}
	function configure_nu {
		local nu_config_path
		if __command_exists -- nu; then
			setup-util-nu --configure
			nu_config_path="$(nu -c 'echo $nu.loginshell-path')"
			config-helper --file="$nu_config_path" -- \
				--find='.+? # Dorothy' --replace="source '$DOROTHY/init.nu' # Dorothy"
		fi
	}
	function deconfigure_nu {
		local nu_config_path
		if __command_exists -- nu; then
			nu_config_path="$(nu -c 'echo $nu.loginshell-path')"
			config-helper --file="$nu_config_path" -- \
				--find='.+? # Dorothy' --replace=''
		fi
	}

	# xonsh
	local xonsh_config_home="$XDG_CONFIG_HOME/xonsh"
	function __is_configured_xonsh {
		echo-if-present -- "$xonsh_config_home/rc.xsh" | echo-file --raw --stdin | echo-regexp -q '.+? # Dorothy'
		return
	}
	function configure_xonsh {
		__mkdirp "$xonsh_config_home/rc.d"
		config-helper --file="$xonsh_config_home/rc.xsh" -- \
			--find='.+? # Dorothy' --replace="execx(compilex(open('$DOROTHY/init.xsh').read())) # Dorothy"
	}
	function deconfigure_xonsh {
		if [[ -d $xonsh_config_home ]]; then
			config-helper --file="$xonsh_config_home/rc.xsh" -- \
				--find='.+? # Dorothy' --replace=''
		fi
	}

	# elvish
	# https://elv.sh/ref/command.html#rc-file
	# https://elv.sh/ref/runtime.html
	# https://github.com/elves/elvish/issues/1726
	local elvish_config_home="$XDG_CONFIG_HOME/elvish"
	function __is_configured_elvish {
		echo-if-present -- "$elvish_config_home/rc.elv" | echo-file --raw --stdin | echo-regexp -q '.+? # Dorothy'
		return
	}
	function configure_elvish {
		__mkdirp "$elvish_config_home"
		config-helper --file="$elvish_config_home/rc.elv" -- \
			--find='.+? # Dorothy' --replace="eval (cat -- '$DOROTHY/init.elv' | slurp) # Dorothy"
	}
	function deconfigure_elvish {
		if [[ -d $elvish_config_home ]]; then
			config-helper --file="$elvish_config_home/rc.elv" -- \
				--find='.+? # Dorothy' --replace=''
		fi
	}

	# =====================================
	# Arguments

	# deprecate USER_SHELLS shells.bash
	# INSTALL_SHELLS not needed as that is just SETUP_UTILS
	# DOROTHY_SHELLS setup.bash
	# LOGIN_SHELLS setup.bash
	# if [setup-shells --configure] then do uninstalls and deconfigures
	# if [setup-shells bash zsh] install bash and zsh, configure bash and zsh, selects bash, but do not uninstall or deconfigure others
	# ^ problem with that, is where it should update configuration, in which others will be trimmed for next run if so
	# ^ if args provided, it does not reconfigure, unless --configure is provided
	# ^ if config provided, it does not reconfigure, unless --configure is provided

	function help {
		cat <<-EOF >&2
			ABOUT:
			Setup your desired shells. Installs/uninstalls them. Configures/deconfigures them for Dorothy. allows and applies your login shell.

			USAGE:
			setup-shell [...options] [--] ...<shell>
			If no <shell> preferences are provided, then [USER_SHELLS] from your [shell.bash] user configuration file will be used.

			SHELLS CONFIGURABLE FOR DOROTHY:
			$(gets_url_label_of_basenames_of_shells "${all_configurable_basenames_of_shells[@]}")

			OPTIONS:
			--setup
			    Reconfigure everything.

			[--] ...<shell>
			    A <shell> to perform one of the below actions on. If no action is provided, defaults to install, configure, allow, and login.
			--install
			    Install the specified <shell>s.
			--uninstall
			    Uninstall the specified <shell>s.
			--configure
			    Configure the specified <shell>s for dorothy.
			--deconfigure
			    Deconfigure the specified <shell>s for dorothy.
			--allow
			    Enable the specified <shell>s to be used as login shells.
			--disallow
			    Disable the specified <shell>s from being used as login shells.
			--login
			    Set the specified <shell>s as your login shell.

			--clean
			    Remove the current shell configuration files, leaving only the configurations that load Dorothy. Useful if you have already migrated to Dorothy.
			--no-brew
			    Exclude <shell> paths that were installed via Homebrew. Useful when uninstalling Homebrew.

			QUIRKS:
			You can use a command name, such as [bash] to select the preferred variation of the shell.
			You can use a full path, such as [/bin/bash] to select a specific variation of the shell.
		EOF
		if [[ $# -ne 0 ]]; then
			__print_error "$@"
		fi
		return 22 # EINVAL 22 Invalid argument
	}

	# process
	local item option_setup='' option_install='' option_uninstall='' option_configure='' option_deconfigure='' option_allow='' option_disallow='' option_login='' option_clean='' option_shells=()
	# option_brew='' option_exclusions=()
	while [[ $# -ne 0 ]]; do
		item="$1"
		shift
		case "$item" in
		'--help' | '-h') help ;;
		'--no-setup'* | '--setup'*) __flag --source={item} --target={option_setup} --affirmative ;;
		'--no-install'* | '--install'*) __flag --source={item} --target={option_install} --affirmative ;;
		'--no-uninstall'* | '--uninstall'*) __flag --source={item} --target={option_uninstall} --affirmative ;;
		'--no-configure'* | '--configure'*) __flag --source={item} --target={option_configure} --affirmative ;;
		'--no-deconfigure'* | '--deconfigure'*) __flag --source={item} --target={option_deconfigure} --affirmative ;;
		'--no-allow'* | '--allow'*) __flag --source={item} --target={option_allow} --affirmative ;;
		'--no-disallow'* | '--disallow'*) __flag --source={item} --target={option_disallow} --affirmative ;;
		'--no-login'* | '--login'*) __flag --source={item} --target={option_login} --affirmative ;;
		'--no-clean'* | '--clean'*) __flag --source={item} --target={option_clean} --affirmative ;;
		'--no-brew'* | '--brew'*) __flag --source={item} --target={option_brew} --affirmative ;;
		'--exclude='*) option_exclusions+=("${item#*=}") ;;
		'--')
			option_shells+=("$@")
			shift "$#"
			break
			;;
		'--'*) help 'An unrecognised flag was provided: ' --variable-value={item} ;;
		*) option_shells+=("$item") ;;
		esac
	done

	# load configuration if argument shells provided
	local only_args='no'
	if [[ ${#option_shells[@]} -ne 0 ]]; then
		only_args='yes'
		if [[ -z $option_install && -z $option_uninstall && -z $option_configure && -z $option_deconfigure && -z $option_allow && -z $option_disallow && -z $option_login && -z $option_clean ]]; then
			option_install='yes'
			option_configure='yes'
			option_allow='yes'
			option_login='yes'
		fi
	else
		# load configuration
		source "$DOROTHY/sources/config.sh"
		USER_SHELLS=()
		load_dorothy_config 'shells.bash'
		option_shells=("${USER_SHELLS[@]}")
	fi

	# =====================================
	# Helpers

	function select_shells_for_install_or_uninstall {
		# check
		if [[ $option_install == 'no' && $option_uninstall == 'no' ]]; then
			return 0
		fi

		# handle args
		if [[ $only_args == 'yes' ]]; then
			if [[ $option_uninstall == 'yes' || $option_install == 'yes' ]]; then
				local arg_shells=() shell
				__split --target={arg_shells} --no-zero-length --invoke -- \
					get_unique_and_permitted_basenames_of_shells "${option_shells[@]}"
				for shell in "${arg_shells[@]}"; do
					if [[ $option_uninstall == 'yes' ]]; then
						command "setup-util-$shell" --uninstall --optional # eval
					fi
					if [[ $option_install == 'yes' ]]; then
						command "setup-util-$shell" --install --optional # eval
					fi
				done
			fi
			return
		fi

		# prepare
		local shell question details
		question='Which shells should be installed this system?'
		details='Shells will be installed or uninstalled automatically using the appropriate methods on this system.'
		details+=$'\nUnselected shells will be uninstalled.'

		# handle defaults
		# there will always be already installed shells, as bash is always installed, however continue with the logic, because of exclusions
		local installed_shells=() user_shells=() defaults=() defaults_string=''
		__split --target={installed_shells} --no-zero-length --invoke -- \
			get_unique_and_permitted_installed_shells "${all_installable_basenames_of_shells[@]}"
		if [[ ${#option_shells[@]} -ne 0 ]]; then
			__split --target={user_shells} --no-zero-length --invoke -- \
				get_unique_and_permitted_basenames_of_shells "${option_shells[@]}"
		fi
		if [[ ${#user_shells[@]} -ne 0 && ${#installed_shells[@]} -ne 0 ]]; then
			defaults=("${user_shells[@]}" "${installed_shells[@]}")
			details+=$'\nPreselected shells are your preferences, as well as the shells that are already installed on this system.'
		elif [[ ${#user_shells[@]} -ne 0 ]]; then
			defaults=("${user_shells[@]}")
			details+=$'\nPreselected shells are your preferences.'
		elif [[ ${#installed_shells[@]} -ne 0 ]]; then
			defaults=("${installed_shells[@]}")
			details+=$'\nPreselected shells are the shells that are already installed on this system.'
		fi
		if [[ ${#defaults[@]} -ne 0 ]]; then
			defaults_string="$(__print_lines "${defaults[@]}")"
		fi

		# select which shells to install and consequently which to also uninstall
		local choices=() selected_shells=() result status
		__split --target={choices} --no-zero-length --invoke -- \
			get_unique_and_permitted_basenames_of_shells_with_labels "${all_installable_basenames_of_shells[@]}"
		__do --redirect-stdout=TTY -- __print_line
		__do --redirect-status={status} --redirect-stdout={result} -- \
			choose --linger --multi "$question" "$details" --defaults="$defaults_string" --label -- "${choices[@]}"
		if [[ $status -eq 130 ]]; then
			__print_style --tty --notice='No changes to installed shells were desired.'
			return 0
		elif [[ $status -ne 0 ]]; then
			return "$status"
		fi
		if [[ -n $result ]]; then
			__split --source={result} --target={selected_shells} --no-zero-length
		fi

		# install or uninstall
		if [[ ${#selected_shells[@]} -eq 0 ]]; then
			# uninstall everything
			if [[ $option_uninstall != 'no' ]]; then
				for shell in "${all_installable_basenames_of_shells[@]}"; do
					command "setup-util-$shell" --uninstall --optional # eval
				done
			fi
		else
			local shell
			for shell in "${all_installable_basenames_of_shells[@]}"; do
				if __has --source={selected_shells} -- "$shell"; then
					if [[ $option_install != 'no' ]]; then
						command "setup-util-$shell" --install --optional # eval
					fi
				elif [[ $option_uninstall != 'no' ]]; then
					command "setup-util-$shell" --uninstall --optional # eval
				fi
			done
		fi
	}

	function select_shells_for_configure_or_deconfigure {
		# check
		if [[ $option_configure == 'no' && $option_deconfigure == 'no' ]]; then
			return 0
		fi

		# handle args
		if [[ $only_args == 'yes' ]]; then
			if [[ $option_deconfigure == 'yes' || $option_configure == 'yes' ]]; then
				local arg_shells=() shell
				__split --target={arg_shells} --no-zero-length --invoke -- \
					get_unique_and_permitted_basenames_of_shells "${option_shells[@]}"
				for shell in "${arg_shells[@]}"; do
					if [[ $option_deconfigure == 'yes' ]]; then
						"deconfigure_$shell" # eval
					fi
					if [[ $option_configure == 'yes' ]]; then
						"configure_$shell" # eval
					fi
				done
			fi
			return
		fi

		# prepare
		local shell question details
		question='Which shells should load Dorothy when they are used as login shells?'
		details='Shells that load Dorothy will gain automated configuration for what is available on your system, access the hundreds of Dorothy commands, and leverage your Dorothy User Configuration, empowering you with a cross-shell, cross-os, and cross-arch ecosystem.'
		details+=$'\nUnselected shells will be configured to not load Dorothy.'

		# handle defaults
		local configured_shells=() user_shells=() defaults=() defaults_string=''
		__split --target={configured_shells} --no-zero-length --invoke -- \
			\
			get_unique_and_permitted_configured_basenames_of_shells "${all_configurable_basenames_of_shells[@]}"
		if [[ ${#option_shells[@]} -ne 0 ]]; then
			__split --target={user_shells} --no-zero-length --invoke -- \
				\
				get_unique_and_permitted_basenames_of_shells "${option_shells[@]}"
		fi
		if [[ ${#user_shells[@]} -ne 0 && ${#configured_shells[@]} -ne 0 ]]; then
			defaults=("${user_shells[@]}" "${configured_shells[@]}")
			details+=$'\nPreselected shells are your preferences, as well as the shells that are already configured for Dorothy on this system.'
		elif [[ ${#user_shells[@]} -ne 0 ]]; then
			defaults=("${user_shells[@]}")
			details+=$'\nPreselected shells are your preferences.'
		elif [[ ${#configured_shells[@]} -ne 0 ]]; then
			defaults=("${configured_shells[@]}")
			details+=$'\nPreselected shells are the shells that are already configured for Dorothy on this system.'
		fi
		if [[ ${#defaults[@]} -ne 0 ]]; then
			defaults_string="$(__print_lines "${defaults[@]}")"
		fi

		# select which shells to configure and consequently which to also deconfigure
		local choices=() selected_shells=() result status
		__split --target={choices} --no-zero-length --invoke -- \
			get_unique_and_permitted_basenames_of_shells_with_labels "${all_configurable_basenames_of_shells[@]}"
		__do --redirect-stdout=TTY -- __print_line
		__do --redirect-status={status} --redirect-stdout={result} -- \
			choose --linger --multi "$question" "$details" --defaults="$defaults_string" --label -- "${choices[@]}"
		if [[ $status -eq 130 ]]; then
			__print_style --tty --notice='No changes to configured shells were desired.'
			return 0
		elif [[ $status -ne 0 ]]; then
			return "$status"
		fi
		if [[ -n $result ]]; then
			__split --source={result} --target={selected_shells} --no-zero-length
		fi

		# cleanup, @todo this should be a user configuration hook or something
		if [[ $option_clean == 'yes' ]]; then
			# note that for WSL, they include useful configurations that Dorothy does reimplement
			fs-remove --confirm --no-confirm-if-empty --reason='Once you have migrated all your configuration to Dorothy, these files can usually be safely removed.' -- \
				"$HOME/.profile" "$HOME/.bash_profile" "$HOME/.bashrc" "$XDG_CONFIG_HOME/fish/config.fish" "$ZDOTDIR/.zshrc" "$ZDOTDIR/.zprofile"
		fi

		# configure or deconfigure
		if [[ ${#selected_shells[@]} -eq 0 ]]; then
			# deconfigure everything
			if [[ $option_deconfigure != 'no' ]]; then
				for shell in "${all_configurable_basenames_of_shells[@]}"; do
					"deconfigure_$shell" # eval
				done
			fi
		else
			local shell
			for shell in "${all_configurable_basenames_of_shells[@]}"; do
				if __has --source={selected_shells} -- "$shell"; then
					if [[ $option_configure != 'no' ]]; then
						"configure_$shell" # eval
					fi
				elif [[ $option_deconfigure != 'no' ]]; then
					"deconfigure_$shell" # eval
				fi
			done
		fi
	}

	function get_login_choices_defaults_details {
		local allowed_shells=() user_shells=() configured_shells=() installed_shells=() # apply choices, defaults, and details to caller
		if [[ ${#option_shells[@]} -ne 0 ]]; then
			__split --target={user_shells} --no-zero-length --invoke -- \
				get_unique_and_permitted_paths_of_shells "${option_shells[@]}"
			choices+=("${user_shells[@]}")
		fi
		__split --target={allowed_shells} --no-zero-length --invoke -- \
			get_unique_and_permitted_paths_of_allowed_shells
		choices+=("${allowed_shells[@]}")
		__split --target={configured_shells} --no-zero-length --invoke -- \
			get_unique_and_permitted_configured_paths_of_shells "${all_configurable_basenames_of_shells[@]}"
		choices+=("${configured_shells[@]}")
		__split --target={installed_shells} --no-zero-length --invoke -- \
			get_unique_and_permitted_installed_shells "${all_allowable_basenames_of_shells[@]}"
		if [[ ${#installed_shells[@]} -ne 0 ]]; then
			__split --target={installed_shells} --no-zero-length --invoke -- \
				get_unique_and_permitted_paths_of_shells "${installed_shells[@]}"
			choices+=("${installed_shells[@]}")
		fi
		if [[ ${#user_shells[@]} -ne 0 && ${#allowed_shells[@]} -ne 0 ]]; then
			defaults=("${user_shells[@]}" "${allowed_shells[@]}")
			details+=$'\nPreselected shells are your preferences, as well as the shells that are already allowed as a login shell on this system.'
		elif [[ ${#user_shells[@]} -ne 0 ]]; then
			defaults=("${user_shells[@]}")
			details+=$'\nPreselected shells are your preferences.'
		elif [[ ${#configured_shells[@]} -ne 0 && ${#allowed_shells[@]} -ne 0 ]]; then
			defaults=("${user_shells[@]}" "${allowed_shells[@]}")
			details+=$'\nPreselected shells are the shells that are already configured for Dorothy on this system, as well as the shells that are already allowed as a login shell on this system.'
		elif [[ ${#configured_shells[@]} -ne 0 ]]; then
			defaults=("${configured_shells[@]}")
			details+=$'\nPreselected shells are the shells that are already configured for Dorothy on this system.'
		elif [[ ${#installed_shells[@]} -ne 0 && ${#allowed_shells[@]} -ne 0 ]]; then
			defaults=("${installed_shells[@]}" "${allowed_shells[@]}")
			details+=$'\nPreselected shells are the shells that are already installed on this system, as well as the shells that are already allowed as a login shell on this system.'
		elif [[ ${#installed_shells[@]} -ne 0 ]]; then
			defaults=("${installed_shells[@]}")
			details+=$'\nPreselected shells are the shells that are already installed on this system.'
		elif [[ ${#allowed_shells[@]} -ne 0 ]]; then
			defaults=("${allowed_shells[@]}")
			details+=$'\nPreselected shells are the shells that are already allowed as a login shell on this system.'
		fi
		if [[ ${#defaults[@]} -ne 0 ]]; then
			defaults_string="$(__print_lines "${defaults[@]}")"
		fi
	}

	function select_shells_for_allow_or_disallow {
		# check
		if [[ $option_allow == 'no' && $option_disallow == 'no' ]]; then
			return 0
		fi

		# handle args
		if [[ $only_args == 'yes' ]]; then
			if [[ $option_disallow == 'yes' || $option_allow == 'yes' ]]; then
				local arg_shells=() shell
				__split --target={arg_shells} --no-zero-length --invoke -- \
					get_unique_and_permitted_paths_of_shells "${option_shells[@]}"
				for shell in "${arg_shells[@]}"; do
					if [[ $option_disallow == 'yes' ]]; then
						disallow_login_shell_path "$shell"
					fi
					if [[ $option_allow == 'yes' ]]; then
						allow_login_shell_path "$shell"
					fi
				done
			fi
			return
		fi

		# prepare
		local question details choices=() defaults=() defaults_string=''
		question='Which shells to allow as system login shells?'
		details='Shells that are enabled to run as system login shells can be used by your system upon login to configure your environment, as well as by your terminal emulator as your default shell.'
		details+=$'\nYour selection will be allowed as a system login shell. Unselected shells will be disallowed as system login shells. Your password may be required to apply the changes.'
		get_login_choices_defaults_details # apply choices, defaults, defaults_string, and details

		# select which shells to allow and consequently which to also disallow
		local choices_with_labels=() selected_shells=() result status
		__split --target={choices_with_labels} --no-zero-length --invoke -- \
			get_unique_and_permitted_paths_of_shells_with_labels "${choices[@]}"
		__do --redirect-stdout=TTY -- __print_line
		__do --redirect-status={status} --redirect-stdout={result} -- \
			choose --linger --required --multi "$question" "$details" --defaults="$defaults_string" --label -- "${choices_with_labels[@]}"
		if [[ $status -eq 130 ]]; then
			__print_style --tty --notice='No changes to system login shells were desired.'
			return 0
		elif [[ $status -ne 0 ]]; then
			return "$status"
		fi
		if [[ -n $result ]]; then
			__split --target={selected_shells} --no-zero-length -- "$result"
		fi

		# allow or disallow
		if [[ ${#selected_shells[@]} -eq 0 ]]; then
			# disallow everything
			if [[ $option_disallow != 'no' ]]; then
				__print_style --tty --notice='Skipping disallowing all shells form being used as a login shell, as that is a mistake.'
				return 0
			fi
		else
			local shell
			for shell in "${choices[@]}"; do
				if __has --source={selected_shells} -- "$shell"; then
					if [[ $option_allow != 'no' ]]; then
						allow_login_shell_path "$shell"
					fi
				elif [[ $option_disallow != 'no' ]]; then
					disallow_login_shell_path "$shell"
				fi
			done
		fi
	}

	function select_shell_for_system_login_shell {
		# check
		if [[ $option_login == 'no' ]]; then
			return 0
		fi

		# check
		if [[ $apply_login_shell_method == 'none' ]]; then
			__print_style --tty --notice="Dorothy doesn't know how to set the login shell on this Operating System."
			return 0
			# return 19 # ENODEV 19 Operation not configurable by device
		fi

		# handle args
		if [[ $only_args == 'yes' ]]; then
			if [[ $option_login == 'yes' ]]; then
				local arg_shells=() shell
				__split --target={arg_shells} --no-zero-length --invoke -- \
					get_unique_and_permitted_paths_of_shells "${option_shells[@]}"
				for shell in "${arg_shells[@]}"; do
					allow_login_shell_path "$shell"
					apply_login_shell_path "$shell"
				done
			fi
			return
		fi

		# prepare
		local question details choices=() defaults=() defaults_string=''
		question='Which shell to use as your default login shell?'
		details='Your default login shell is your preferred default shell. For supported systems, it will setup your environment upon login. For supported terminal emulators, it will be used for new terminal sessions.'
		details+=$'\nYour selection will be allowed as a system login shell, and applied as your preferred login shell. Your password may be required to apply the changes.'
		get_login_choices_defaults_details # apply choices, defaults, defaults_string, and details

		# select which shell to use as login shell
		__do --redirect-stdout=TTY -- __print_line
		login_shell_path="$(
			choose --linger --no-multi "$question" "$details" --defaults="$defaults_string" --label -- "${choices[@]}" || :
		)"
		if [[ -z $login_shell_path ]]; then
			__print_style --tty --notice='No changes to the default login shell were desired.'
			return 0
		fi

		# allow
		allow_login_shell_path "$login_shell_path"
		apply_login_shell_path "$login_shell_path"
	}

	# =====================================
	# Action

	select_shells_for_install_or_uninstall
	select_shells_for_configure_or_deconfigure
	select_shells_for_allow_or_disallow
	select_shell_for_system_login_shell
)

# fire if invoked standalone
if [[ $0 == "${BASH_SOURCE[0]}" ]]; then
	setup_shell "$@"
fi
