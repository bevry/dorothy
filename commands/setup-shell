#!/usr/bin/env bash

# Understanding this command:
# Permitted shells are shells not excluded.
# Excluded shells are provided by command line args, to exclude shells, such as when a shell is about to be uninstalled, so must be trimmed from say allowed shells.
# Allowed shells are shells within `/etc/shells` that are able to be login shells.

# todo add configuration saving
# todo add DOROTHY_CONFIGURE_SHELLS
# todo test uninstallation

# todo add --clear-history option
# nu: history -c
# sh: history -c
# fish:
# function secure_history
# 	set action (choose --question='What do you want to delete?' --default=$argv[1] --label -- 'some' 'delete only the known risks' 'all' 'erase your entire history')
# 	if test "$action" = 'all'; then
# 		history -c
# 		printf '%s\n' 'Erased everything.'
# 	else
# 		printf '%s\n' 'all' | history delete --contains 'auth'
# 		printf '%s\n' 'all' | history delete --contains 'cookie'
# 		printf '%s\n' 'all' | history delete --contains 'env'
# 		printf '%s\n' 'all' | history delete --contains 'http -f POST'
# 		printf '%s\n' 'all' | history delete --contains 'http POST'
# 		printf '%s\n' 'all' | history delete --contains 'key'
# 		printf '%s\n' 'all' | history delete --contains 'op '
# 		printf '%s\n' 'all' | history delete --contains 'secret'
# 		printf '%s\n' 'all' | history delete --contains 'session'
# 		printf '%s\n' 'all' | history delete --contains 'token'
# 		printf '%s\n' 'all' | history delete --contains 'twurl'
# 		printf '%s\n' 'all' | history delete --contains 'vault'
# 		printf '%s\n' 'all' | history delete --contains 'youtube-dl'
# 		printf '%s\n' 'all' | history delete --contains 'coda register'
# 		printf '%s\n' 'Erased known risks.'
# 	end
# end

# for scripts and sources to remove a deprecated configuration file
# remove_dorothy_config  [--reason=<reason>] [--] ...<filename>
# this should become part of `config.bash` (as `config.sh` doesn't have arrays) or even better part of `dorothy-config`
remove_dorothy_config() {
	# process arguments
	REMOVE_DOROTHY_CONFIG__item='' REMOVE_DOROTHY_CONFIG__reason='' REMOVE_DOROTHY_CONFIG__filenames=()
	while [[ $# -ne 0 ]]; do
		REMOVE_DOROTHY_CONFIG__item="$1"
		shift
		case "$REMOVE_DOROTHY_CONFIG__item" in
		'--reason='*) REMOVE_DOROTHY_CONFIG__reason="${REMOVE_DOROTHY_CONFIG__item#*=}" ;;
		'--')
			REMOVE_DOROTHY_CONFIG__filenames+=("$@")
			shift $#
			break
			;;
		*) REMOVE_DOROTHY_CONFIG__filenames+=("$REMOVE_DOROTHY_CONFIG__item") ;;
		esac
	done

	# for each filename, try user/config.local otherwise user/config
	for REMOVE_DOROTHY_CONFIG__filename in "${REMOVE_DOROTHY_CONFIG__filenames[@]}"; do
		if [[ -f "$DOROTHY/user/config.local/$REMOVE_DOROTHY_CONFIG__filename" ]]; then
			# remove user/config.local/*
			fs-rm --reason="$REMOVE_DOROTHY_CONFIG__reason" -- "$DOROTHY/user/config.local/$REMOVE_DOROTHY_CONFIG__filename" || :
		fi
		if [[ -f "$DOROTHY/user/config/$REMOVE_DOROTHY_CONFIG__filename" ]]; then
			# remove user/config/*
			fs-rm --reason="$REMOVE_DOROTHY_CONFIG__reason" -- "$DOROTHY/user/config/$REMOVE_DOROTHY_CONFIG__filename" || :
		fi
	done
}

function setup_shell_test() (
	source "$DOROTHY/sources/bash.bash"
	eval-tester --ignore-stderr --status=22 -- setup-shell --help
)

function setup_shell() (
	source "$DOROTHY/sources/bash.bash"
	source "$DOROTHY/sources/environment.sh" # ensure new installations are detected

	# used by these helpers
	local option_brew='' option_exclusions=()
	local all_installable_basenames_of_shells=(
		# in order of usage
		bash
		zsh
		fish
		nu
		xonsh
		elvish
		dash
		ksh
	)
	local all_configurable_basenames_of_shells=(
		"${all_installable_basenames_of_shells[@]}"
	)
	local all_allowable_basenames_of_shells=(
		"${all_installable_basenames_of_shells[@]}"
		sh
	)

	function __get_name_of_basename_of_shell {
		local shell="$1"
		case "$shell" in
		'bash') __print_lines 'Bash' || return $? ;;
		'zsh') __print_lines 'Zsh' || return $? ;;
		'fish') __print_lines 'Fish' || return $? ;;
		'nu') __print_lines 'Nu' || return $? ;;
		'xonsh') __print_lines 'Xonsh' || return $? ;;
		'elvish') __print_lines 'Elvish' || return $? ;;
		'dash') __print_lines 'Dash' || return $? ;;
		'ksh') __print_lines 'KSH' || return $? ;; # http://kornshell.com/doc/faq.html KornShell is the language, KSH-93 is the most recent version of the language, ksh is the program, so do KSH as a middle-ground
		*) __print_lines "$shell" || return $? ;;
		esac
	}

	function __get_url_of_basename_of_shell {
		local shell="$1"
		case "$shell" in
		'bash') __print_lines 'https://en.wikipedia.org/wiki/Bash_(Unix_shell)' || return $? ;;
		'zsh') __print_lines 'https://en.wikipedia.org/wiki/Z_shell' || return $? ;;
		'fish') __print_lines 'https://en.wikipedia.org/wiki/Fish_(Unix_shell)' || return $? ;;
		'nu') __print_lines 'https://www.nushell.sh' || return $? ;;
		'xonsh') __print_lines 'https://xon.sh' || return $? ;;
		'elvish') __print_lines 'https://en.wikipedia.org/wiki/Fish_(Unix_shell)' || return $? ;;
		'dash') __print_lines 'https://en.wikipedia.org/wiki/Almquist_shell#Dash' || return $? ;;
		'ksh') __print_lines 'https://en.wikipedia.org/wiki/KornShell' || return $? ;;
		esac
	}

	function __get_url_label_of_basename_of_shell {
		local shell="$1" name url
		name="$(__get_name_of_basename_of_shell "$shell")" || return $?
		url="$(__get_url_of_basename_of_shell "$shell")" || return $?
		if [[ -n $url ]]; then
			__print_style --bold="$name: " --dim+url="$url" || return $?
		else
			__print_style --bold="$name" || return $?
		fi
	}

	function __gets_url_label_of_basenames_of_shells {
		local shells=("$@") shell
		for shell in "${shells[@]}"; do
			__get_url_label_of_basename_of_shell "$shell" || return $?
		done
	}

	function __get_basename_of_shell {
		local shell="$1"
		fs-path --no-parents --no-extensions -- "$shell" || return $?
	}

	function __get_version_of_path_of_shell {
		local path="$1" basename
		if [[ ! -x $path ]]; then
			# this can happen when fetching for shells in `/etc/shell` that do not exist
			return 2 # ENOENT 2 No such file or directory
		fi
		basename="$(__get_basename_of_shell "$path")" || return $?
		case "$basename" in
		'bash') command "$path" -c "printf '%s\n' \"\$BASH_VERSION\"" || return $? ;; # eval
		'zsh') command "$path" -c "printf '%s\n' \"\$ZSH_VERSION\"" || return $? ;;   # eval
		'fish') command "$path" -c "printf '%s\n' \"\$FISH_VERSION\"" || return $? ;; # eval
		'nu') command "$path" -c "printf '%s\n' \$env.NU_VERSION" || return $? ;;     # eval
		'elvish') command "$path" --version || return $? ;;                           # eval
		*) : ;;
		# go on the safe side, any don't do versions for anything we can't guarantee handling of
		#'dash' | 'ksh') : ;;  # these don't support `<shell> --version`
		# the bellow works for everything so far except nu, which `nu --version` just outputs the version
		#*) command "$path" --version | echo-regexp -on --search='version ([^( ]+)' --replace="\$1" ;;
		esac
	}

	function __get_path_label_of_path_of_shell {
		local path="$1" resolved basename name version args=()
		resolved="$(fs-path --resolve -- "$path")" || return $?
		basename="$(__get_basename_of_shell "$path")" || return $?
		name="$(__get_name_of_basename_of_shell "$basename")" || return $?
		args=(--bold="$name" ' ' --path="$path")
		if [[ $resolved != "$path" ]]; then
			args+=(--dim=' => ' --path="$resolved")
		fi
		if [[ -x $path ]]; then
			version="$(__get_version_of_path_of_shell "$path" || :)"
			if [[ -n $version ]]; then
				args+=(' ' --blue="$version")
			else
				args+=(' ' --blue+dim='unknown version')
			fi
		elif [[ -e $path ]]; then
			args+=(' ' --red='not executable')
		else
			args+=(' ' --red='missing')
		fi
		__print_style "${args[@]}" || return $?
	}

	function __is_permitted_shell {
		local shell="$1" basename
		if [[ $option_brew != 'no' && ${#option_exclusions[@]} -eq 0 ]]; then
			return 0
		fi
		basename="$(__get_basename_of_shell "$path")" || return $?
		if [[ $shell == "$basename" ]]; then
			# shell is basename, just check basename
			if __has --source={option_exclusions} -- "$shell"; then
				return 1
			fi
		else
			# shell is path, check both path and basename, and brew
			if [[ $option_brew == 'no' && -n ${HOMEBREW_PREFIX-} && $shell == "$HOMEBREW_PREFIX"* ]] || __has --source={option_exclusions} --any -- "$shell" "$basename"; then
				return 1
			fi
		fi
		return 0
	}

	function __get_unique_and_permitted_shells {
		local shell permitted_shells=()
		for shell in "$@"; do
			if __is_permitted_shell "$shell"; then
				permitted_shells+=("$shell")
			fi
		done
		if [[ ${#permitted_shells[@]} -eq 0 ]]; then
			return $?
		fi
		__unique --source+target={permitted_shells} || return $?
		__print_lines "${permitted_shells[@]}" || return $?
	}

	function __get_unique_and_permitted_paths_of_installed_shells {
		local shell all=()
		for shell in "$@"; do
			# returns all matching paths, or no paths, of the shell path or basename
			# which -a "$basename_or_path"
			# type -pa "$basename_or_path"
			# type -Pa "$basename_or_path" || : # suppress failure status if no results
			local paths=() path
			__split --target={paths} --no-zero-length --invoke=try -- \
				type -Pa "$shell" || return $?
			if [[ ${#paths[@]} -ne 0 ]]; then
				__split --target={paths} --no-zero-length --invoke -- \
					__get_unique_and_permitted_shells "${paths[@]}" || return $?
				all+=("${paths[@]}")
			fi
		done
		if [[ ${#all[@]} -ne 0 ]]; then
			__unique --source+target={all} || return $?
			__print_lines "${all[@]}" || return $?
		fi
	}

	function __get_unique_and_permitted_and_resolved_paths_of_installed_shells {
		local paths=()
		__split --target={paths} --no-zero-length --invoke=try -- \
			__get_unique_and_permitted_paths_of_installed_shells "$@" || return $?
		if [[ ${#paths[@]} -ne 0 ]]; then
			__split --target={paths} --overwrite --no-zero-length --invoke=try -- \
				fs-path --resolve -- "${paths[@]}" || return $?
			__unique --source+target={paths} || return $?
			__print_lines "${paths[@]}" || return $?
		fi
	}

	function __get_unique_and_permitted_paths_of_allowed_shells {
		local paths=()
		__split --target={paths} --no-zero-length --invoke=try -- \
			echo-regexp -onm '^(/[^#]+).*$' '$1' </etc/shells || return $?
		if [[ ${#paths[@]} -ne 0 ]]; then
			__get_unique_and_permitted_shells "${paths[@]}" || return $?
		fi
	}

	function __get_unique_and_permitted_and_allowed_paths_of_installed_or_allowed_shells {
		local list=() allowed=() shell paths=()
		__split --target={list} --no-zero-length --invoke=try -- \
			__get_unique_and_permitted_paths_of_installed_shells "$@" || return $?
		__split --target={allowed} --target={list} --append --no-zero-length --invoke=try -- \
			__get_unique_and_permitted_paths_of_allowed_shells || return $?
		__unique --source+target={list}
		for shell in "${list[@]}"; do
			if __has --source={allowed} -- "$shell"; then
				paths+=("$shell")
			fi
		done
		__print_lines "${paths[@]}" || return $?
	}

	function __get_unique_and_permitted_and_allowed_paths_of_installed_and_allowed_shells {
		local installed=() allowed=() shell paths=()
		__split --target={installed} --no-zero-length --invoke=try -- \
			__get_unique_and_permitted_paths_of_installed_shells "$@" || return $?
		__split --target={allowed} --no-zero-length --invoke=try -- \
			__get_unique_and_permitted_paths_of_allowed_shells || return $?
		for shell in "${installed[@]}"; do
			if __has --source={allowed} -- "$shell"; then
				paths+=("$shell")
			fi
		done
		for shell in "${allowed[@]}"; do
			if ! __has --source={installed} -- "$shell"; then
				paths+=("$shell")
			fi
		done
		__print_lines "${paths[@]}" || return $?
	}

	function __get_unique_and_permitted_basenames_of_shells {
		local shell basenames=()
		for shell in "$@"; do
			if __is_permitted_shell "$shell"; then
				basenames+=("$(fs-path --no-parents --no-extensions -- "$shell")") || return $?
			fi
		done
		# de-dup
		__unique --source+target={basenames} || return $?
		__print_lines "${basenames[@]}" || return $?
	}

	function __get_unique_and_permitted_installed_shells {
		local shells=() shell results=()
		__split --target={shells} --no-zero-length --invoke -- \
			__get_unique_and_permitted_shells "$@" || return $?
		if [[ ${#shells[@]} -eq 0 ]]; then
			return $?
		fi
		for shell in "${shells[@]}"; do
			if __command_exists -- "$shell"; then
				results+=("$shell")
			fi
		done
		if [[ ${#results[@]} -eq 0 ]]; then
			return $?
		fi
		__print_lines "${results[@]}" || return $?
	}

	function __get_unique_and_permitted_configured_basenames_of_shells {
		local basenames=() basename fn results=()
		__split --target={basenames} --no-zero-length --invoke -- \
			__get_unique_and_permitted_basenames_of_shells "$@" || return $?
		if [[ ${#basenames[@]} -eq 0 ]]; then
			return $?
		fi
		for basename in "${basenames[@]}"; do
			fn="__is_configured_$basename"
			if "$fn"; then
				results+=("$basename")
			fi
		done
		__print_lines "${results[@]}" || return $?
	}

	local apply_login_shell_method='none'
	if [[ -n $CI ]]; then
		if [[ -f /etc/passwd ]]; then
			apply_login_shell_method='passwd'
		fi
	elif __command_exists -- chpass; then
		apply_login_shell_method='chpass'
	elif __command_exists -- chsh; then
		apply_login_shell_method='chsh'
	elif __command_exists -- usermod; then
		apply_login_shell_method='usermod'
	elif __command_exists -- lchsh; then
		apply_login_shell_method='lchsh'
	elif [[ -f /etc/passwd ]]; then
		apply_login_shell_method='passwd'
	fi
	case "$apply_login_shell_method" in
	chpass)
		function __apply_login_shell_path {
			local login_shell_path="$1"
			local -i __chpass_status
			# [chpass] only give you one password attempt, so do it in a loop
			while :; do
				__chpass_status=0
				chpass -s "$login_shell_path" -u "$USER" 2> >(echo-regexp --regexp='chpass: no changes made' --replace='Already is your login shell.') || return $? || __chpass_status=$?
				if [[ $__chpass_status -eq 0 ]]; then
					# successfully updated
					break
				elif [[ $__chpass_status -eq 1 ]]; then
					# incorrect password
					continue # try again
				elif [[ $__chpass_status -eq 130 ]]; then
					# 130 = SIGINT = ctrl+c = abort
					__print_error 'Updating the login shell failed because ' --code='chpass' ' was aborted with exit status ' --status="$__chpass_status" || return $?
					return 125 # ECANCELED 125 Operation cancelled
				else
					__print_error 'Updating the login shell failed because ' --code='chpass' ' failed with exit status ' --status="$__chpass_status" || return $?
					return "$__chpass_status"
				fi
			done
		}
		;;
	chsh)
		# ubuntu, fedora
		function __apply_login_shell_path {
			local login_shell_path="$1"
			chsh -s "$login_shell_path" "$USER" 2> >(echo-regexp --regexp='chsh: Shell not changed.' --replace='Already is your login shell.') || return $?
		}
		;;
	usermod)
		# fedora
		function __apply_login_shell_path {
			local login_shell_path="$1"
			eval-helper --elevate -- usermod --shell "$login_shell_path" "$USER" || return $?
		}
		;;
	lchsh)
		# fedora
		function __apply_login_shell_path {
			local login_shell_path="$1"
			__print_lines "$login_shell_path" | eval-helper --elevate -- lchsh "$USER" >/dev/null || return $? # output is confusing
		}
		;;
	passwd)
		# everything else, including alpine
		function __apply_login_shell_path {
			local login_shell_path="$1" bin_gsed_or_sed
			# todo rewrite this with config-helper
			bin_gsed_or_sed="$(echo-gnu-command --install -- gsed || :)"
			if [[ -z $bin_gsed_or_sed ]]; then
				return 1
			fi
			# todo replace with `echo-regexp` and `echo-write`
			eval-helper --elevate --inherit -- \
				"$bin_gsed_or_sed" --in-place --regexp-extended --expression="s#^($USER:.+:).+?\$#\1$login_shell_path#" /etc/passwd || return $?
		}
		;;
	esac

	# bash
	function __is_configured_bash {
		# todo don't implement these potential alternatives, as the implemented one is the best
		# echo-regexp --quiet --search='.+? # Dorothy' --any --file="$HOME/.bash_profile" --file="$HOME/.bashrc"
		# echo-regexp -q '.+? # Dorothy' --any -- "$HOME/.bash_profile" "$HOME/.bashrc"
		# echo-file --raw --optional -- "$HOME/.bash_profile" "$HOME/.bashrc" | echo-regexp -q '.+? # Dorothy'
		echo-if-present -- "$HOME/.bash_profile" "$HOME/.bashrc" "$HOME/.profile" | echo-file --stdin-paths --raw | echo-regexp -q '.+?(init.sh).*? # Dorothy' || return $?
	}
	function __configure_bash {
		# mac and raspi ubuntu
		config-helper --file="$HOME/.bash_profile" -- \
			--find='.+? # Dorothy' --replace="source $(echo-quote -- "$DOROTHY/init.sh") # Dorothy" || return $?

		# vm ubuntu
		config-helper --file="$HOME/.bashrc" -- \
			--find='.+? # Dorothy' --replace="source $(echo-quote -- "$DOROTHY/init.sh") # Dorothy" || return $?
	}
	function __deconfigure_bash {
		config-helper --file="$HOME/.bash_profile" -- \
			--find='.+? # Dorothy' --replace='' || return $?
		config-helper --file="$HOME/.bashrc" -- \
			--find='.+? # Dorothy' --replace='' || return $?
		config-helper --file="$HOME/.profile" -- \
			--find='.+?(init.sh).*? # Dorothy' --replace='' || return $?
	}

	# dash
	function __is_configured_dash {
		echo-if-present -- "$HOME/.profile" | echo-file --stdin-paths --raw | echo-regexp -q '.+?(init.sh|init.dash).*? # Dorothy' || return $?
	}
	function __configure_dash {
		config-helper --file="$HOME/.profile" -- \
			--find='.+?(init.sh|init.dash).*? # Dorothy' --replace=". $(echo-quote -- "$DOROTHY/init.dash") # Dorothy" || return $?
	}
	function __deconfigure_dash {
		config-helper --file="$HOME/.profile" -- \
			--find='.+?(init.sh|init.dash).*? # Dorothy' --replace='' || return $?
	}

	# ksh
	function __is_configured_ksh {
		echo-if-present -- "$HOME/.profile" | echo-file --stdin-paths --raw | echo-regexp -q '.+?(init.sh|init.ksh).*? # Dorothy' || return $?
	}
	function __configure_ksh {
		config-helper --file="$HOME/.profile" -- \
			--find='.+?(init.sh|init.ksh).*? # Dorothy' --replace=". $(echo-quote -- "$DOROTHY/init.ksh") # Dorothy" || return $?
	}
	function __deconfigure_ksh {
		config-helper --file="$HOME/.profile" -- \
			--find='.+?(init.sh|init.ksh).*? # Dorothy' --replace='' || return $?
	}

	# zsh
	function __is_configured_zsh {
		echo-if-present -- "$HOME/.zshrc" "$ZDOTDIR/.zprofile" | echo-file --stdin-paths --raw | echo-regexp -q '.+? # Dorothy' || return $?
	}
	function __configure_zsh {
		setup-util-zsh "${slim_options[@]}" || return $?
		config-helper --file="$ZDOTDIR/.zshrc" -- \
			--find='.+? # Dorothy' --replace="source $(echo-quote -- "$DOROTHY/init.sh") # Dorothy" || return $?
		config-helper --file="$ZDOTDIR/.zprofile" -- \
			--find='.+? # Dorothy' --replace="source $(echo-quote -- "$DOROTHY/init.sh") # Dorothy" || return $?
	}
	function __deconfigure_zsh {
		if [[ -d $ZDOTDIR ]]; then
			config-helper --file="$ZDOTDIR/.zshrc" -- \
				--find='.+? # Dorothy' --replace='' || return $?
			config-helper --file="$ZDOTDIR/.zprofile" -- \
				--find='.+? # Dorothy' --replace='' || return $?
		fi
	}

	# fish
	local fish_config_home="$XDG_CONFIG_HOME/fish"
	function __is_configured_fish {
		echo-if-present -- "$fish_config_home/config.fish" | echo-file --stdin-paths --raw | echo-regexp -q '.+? # Dorothy' || return $?
	}
	function __configure_fish {
		__mkdirp "$fish_config_home"
		config-helper --file="$fish_config_home/config.fish" -- \
			--find='.+? # Dorothy' --replace="source $(echo-quote -- "$DOROTHY/init.fish") # Dorothy" || return $?
	}
	function __deconfigure_fish {
		if [[ -d $fish_config_home ]]; then
			config-helper --file="$fish_config_home/config.fish" -- \
				--find='.+? # Dorothy' --replace='' || return $?
		fi
	}

	# nu
	function __is_configured_nu {
		if __command_exists -- nu; then
			local nu_config_path
			nu_config_path="$(nu -c 'echo $nu.loginshell-path')" || return $?
			echo-if-present -- "$nu_config_path" | echo-file --stdin-paths --raw | echo-regexp -q '.+? # Dorothy' || return $?
		else
			return 1
		fi
	}
	function __configure_nu {
		if __command_exists -- nu; then
			local nu_config_path nu_config_home
			setup-util-nu "${slim_options[@]}" || return $?
			nu_config_path="$(nu -c 'echo $nu.loginshell-path')" || return $?
			# mkdir to fix https://github.com/bevry/dorothy/actions/runs/19061496789/job/54442019271#step:2:507
			nu_config_home="$(fs-path --parents -- "$nu_config_path")" || return $?
			__mkdirp "$nu_config_home" || return $?
			config-helper --file="$nu_config_path" -- \
				--find='.+? # Dorothy' --replace="source $(echo-quote -- "$DOROTHY/init.nu") # Dorothy" || return $?
		fi
	}
	function __deconfigure_nu {
		local nu_config_path nu_config_home
		if __command_exists -- nu; then
			nu_config_path="$(nu -c 'echo $nu.loginshell-path')" || return $?
			# mkdir to fix https://github.com/bevry/dorothy/actions/runs/19061496789/job/54442019271#step:2:507
			nu_config_home="$(fs-path --parents -- "$nu_config_path")" || return $?
			__mkdirp "$nu_config_home" || return $?
			config-helper --file="$nu_config_path" -- \
				--find='.+? # Dorothy' --replace='' || return $?
		fi
	}

	# xonsh
	local xonsh_config_home="$XDG_CONFIG_HOME/xonsh"
	function __is_configured_xonsh {
		echo-if-present -- "$xonsh_config_home/rc.xsh" | echo-file --stdin-paths --raw | echo-regexp -q '.+? # Dorothy' || return $?
	}
	function __configure_xonsh {
		__mkdirp "$xonsh_config_home/rc.d" || return $?
		config-helper --file="$xonsh_config_home/rc.xsh" -- \
			--find='.+? # Dorothy' --replace="execx(compilex(open($(echo-quote -- "$DOROTHY/init.xsh")).read())) # Dorothy" || return $?
	}
	function __deconfigure_xonsh {
		if [[ -d $xonsh_config_home ]]; then
			config-helper --file="$xonsh_config_home/rc.xsh" -- \
				--find='.+? # Dorothy' --replace='' || return $?
		fi
	}

	# elvish
	# https://elv.sh/ref/command.html#rc-file
	# https://elv.sh/ref/runtime.html
	# https://github.com/elves/elvish/issues/1726
	local elvish_config_home="$XDG_CONFIG_HOME/elvish"
	function __is_configured_elvish {
		echo-if-present -- "$elvish_config_home/rc.elv" | echo-file --stdin-paths --raw | echo-regexp -q '.+? # Dorothy' || return $?
	}
	function __configure_elvish {
		__mkdirp "$elvish_config_home" || return $?
		config-helper --file="$elvish_config_home/rc.elv" -- \
			--find='.+? # Dorothy' --replace="eval (cat -- $(echo-quote -- "$DOROTHY/init.elv") | slurp) # Dorothy" || return $?
	}
	function __deconfigure_elvish {
		if [[ -d $elvish_config_home ]]; then
			config-helper --file="$elvish_config_home/rc.elv" -- \
				--find='.+? # Dorothy' --replace='' || return $?
		fi
	}

	# =====================================
	# Arguments

	# deprecate `USER_SHELLS` `shells.bash`
	# `INSTALL_SHELLS` not needed as that is just `SETUP_UTILS`
	# `DOROTHY_SHELLS` `setup.bash`
	# `LOGIN_SHELLS` `setup.bash`
	# if `setup-shells --configure` then do uninstalls and deconfigures
	# if `setup-shells bash zsh` install bash and zsh, configure bash and zsh, selects bash, but do not uninstall or deconfigure others
	# ^ problem with that, is where it should update configuration, in which others will be trimmed for next run if so
	# ^ if args provided, it does not reconfigure, unless `--configure` is provided
	# ^ if config provided, it does not reconfigure, unless `--configure` is provided

	function __help {
		__print_help "$@" <<-EOF || return $?
			ABOUT:
			Setup your desired shells. Installs/uninstalls them. Configures/deconfigures them for Dorothy. Allows/disallows them as login shells. Sets the login shell.

			USAGE:
			\`setup-shell [...options] [--] ...<shell>\`
			If no <shell> preferences are provided, then \`USER_SHELLS\` from your \`shell.bash\` user configuration file will be used.

			SHELLS CONFIGURABLE FOR DOROTHY:
			$(__gets_url_label_of_basenames_of_shells "${all_configurable_basenames_of_shells[@]}" || :)

			OPTIONS:
			--[no-]reconfigure
			    Whether to re-prompt and re-save configuration settings. Defaults to enabled if custom action shells are not provided.
			--[no-]fallback
			    If disabled, prevents installation of fallbacks to install dependencies.
			--[no-]deps
			    If disabled, prevents installation of dependencies, such as gpg etc.
			--[no-]slim
			    If enabled, disables reconfiguration, fallbacks, and dependencies.

			ACTION OPTIONS:
			If a specific action is specified, unspecified actions will be disabled.

			--shell=...<shell> | [--] ...<shell>
			    The <shell>s to perform the actions on.
			    E.g. \`bash\`, \`/bin/bash\`, etc.
			--exclude=...<excluded-shell>
			    Exclude <excluded-shell> from prompts.
			--[no-]brew
			    If disabled, exclude <shell> paths that were installed via Homebrew. Useful when uninstalling Homebrew.

			--[no-]install[=...<install-shell>]
			    If disabled, do not install any shells and reset <install-shell>s.
			    If enabled, prompt from these <install-shell>s or <shell>s to install.
			    Selection will be from all supported shells, and will default to existing installed shells and those from \`setup.bash:SETUP_UTILS\`.
			    Result will become <installed-shell>s.
			--[no-]upgrade[=...<upgrade-shell>]
			    If disabled, do not upgrade any shells and reset <upgrade-shell>s.
			    If enabled, prompt from these <upgrade-shell>s or <shell>s to upgrade.
			    Selection will be from installed shells, and will default to none.
			    Result will become <upgraded-shell>s.
			--[no-]uninstall[=...<uninstall-shell>]
			    If disabled, do not uninstall any shells and reset <uninstall-shell>s.
			    If enabled, prompt from these <uninstall-shell>s or <shell>s to uninstall.
			    Selection will be from shells that were not in <installed-shell>s and <upgrade-shell>s, and will default to none.
			    Result will be <uninstalled-shell>s.

			--[no-]configure[=...<configure-shell>]
			    If disabled, do not configure any shells for Dorothy and reset <configure-shell>s.
			    If enabled, prompt from these <configure-shell>s or <shell>s to configure.
			    Selection will be from installed shells, and will default to all <installed-shell>s.
			    Result will be <configured-shell>s.
			--[no-]deconfigure[=...<deconfigure-shell>]
			    If disabled, do not deconfigure any shells for Dorothy and reset <deconfigure-shell>s.
			    If enabled, prompt from these <deconfigure-shell>s or <shell>s to deconfigure.
			    Selection will be from shells that were not in <configured-shell>s and <cleaned-shell>s, and will default to none.
			    Result will be <deconfigured-shell>s.

			--[no-]allow[=...<allow-shell>]
			    If disabled, do not allow any shells and reset <allow-shell>s.
			    If enabled, prompt from these <allow-shell>s or <shell>s to allow.
			    Selection will be from installed shells, and will default to <configured-shell>s.
			    Result will be <allowed-shell>s.
			--[no-]disallow[=...<disallow-shell>]
			    If disabled, do not disallow any shells and reset <disallow-shell>s.
			    If enabled, prompt from these <disallow-shell>s or <shell>s to disallow.
			    Selection will be from shells that wre not in <allowed-shell>, and will default to all missing allowed shells.
			    Result will be <disallowed-shell>s.
			--[no-]login[=...<login-shell>]
			    If disabled, disable changing the login shell, and reset <login-shell>s.
			    If enabled, prompt from these <login-shell>s or <shell>s as your login shell,
			    Selection will be from <allowed-shell>s. Order will be from \`setup.bash:DOROTHY_LOGIN_SHELLS\` (previously \`shells.bash:USER_SHELLS\`).
		EOF
		return 22 # EINVAL 22 Invalid argument
	}

	# process
	local item option_reconfigure='' option_fallback='' option_deps='' \
		option_shells=() option_exclusions=() option_brew='yes' \
		option_install='' option_install_shells=() \
		option_upgrade='' option_upgrade_shells=() \
		option_uninstall='' option_uninstall_shells=() \
		option_configure='' option_configure_shells=() \
		option_deconfigure='' option_deconfigure_shells=() \
		option_allow='' option_allow_shells=() \
		option_disallow='' option_disallow_shells=() \
		option_login='' option_login_shells=()
	local option_custom='no' available_actions=(install upgrade uninstall configure deconfigure allow disallow login)
	function __parse_action {
		local action="$1" value=''
		local action_var="option_$action" action_shells_var="option_${action}_shells"
		__flag --source={item} --target={value} --affirmative --no-coerce || return $?
		if [[ -n $value ]]; then
			if [[ $value == 'no' ]]; then
				eval "$action_var=no $action_shells_var=()" || return $?
			elif [[ $value == 'yes' ]]; then
				eval "$action_var=yes"
				option_custom='yes'
			else
				__split --source={value} --target={"$action_shells_var"} --append --no-zero-length --delimiters=$'\n\t ,|' --no-zero-length || return $?
				__unique --source+target={"$action_shells_var"} || return $?
				eval "$action_var=yes"
				option_custom='yes'
			fi
		fi
	}
	# option_brew='' option_exclusions=()
	while [[ $# -ne 0 ]]; do
		item="$1"
		shift
		case "$item" in
		'--help' | '-h') __help || return $? ;;
		# <shared options between many setup commands>
		'--no-reconfigure'* | '--reconfigure'*) __flag --source={item} --target={option_reconfigure} --affirmative --coerce ;;
		'--no-fallback'* | '--fallback'*) __flag --source={item} --target={option_fallback} --affirmative --coerce ;;
		'--no-deps'* | '--deps'*) __flag --source={item} --target={option_deps} --affirmative --coerce ;;
		'--no-slim'* | '--slim'*) __flag --source={item} --target={option_reconfigure} --target={option_fallback} --target={option_deps} --affirmative --coerce ;;
		# </shared options between many setup commands>
		'--no-brew'* | '--brew'*) __flag --source={item} --target={option_brew} --affirmative --coerce || return $? ;;
		'--exclude='* | '--exclusions='* | '--without='*) __split --target={option_exclusions} --append --no-zero-length --delimiters=$'\n\t ,|' --no-zero-length -- "${item#*=}" ;;
		'--shell='*) __split --target={option_shells} --append --no-zero-length --delimiters=$'\n\t ,|' --no-zero-length -- "${item#*=}" ;;
		'--no-install'* | '--install'*) __parse_action 'install' ;;
		'--no-upgrade'* | '--upgrade'*) __parse_action 'upgrade' ;;
		'--no-uninstall'* | '--uninstall'*) __parse_action 'uninstall' ;;
		'--no-configure'* | '--configure'*) __parse_action 'configure' ;;
		'--no-deconfigure'* | '--deconfigure'*) __parse_action 'deconfigure' ;;
		'--no-allow'* | '--allow'*) __parse_action 'allow' ;;
		'--no-disallow'* | '--disallow'*) __parse_action 'disallow' ;;
		'--no-login'* | '--login'*) __parse_action 'login' ;;
		'--')
			option_shells+=("$@")
			shift "$#"
			break
			;;
		'--'*) __help 'An unrecognised flag was provided: ' --variable-value={item} || return $? ;;
		*) option_shells+=("$item") ;;
		esac
	done
	__unique --source+target={option_shells} || return $?

	# slim options
	local slim_options=(
		--reconfigure="$option_reconfigure"
		--fallback="$option_fallback"
		--deps="$option_deps"
	)

	# handle action defaults
	# `option_custom` is enabled if any action is enabled
	local action_value action_default actions=()
	if [[ $option_custom == 'yes' ]]; then
		action_default='no'
	else
		action_default='yes'
	fi
	for action in "${available_actions[@]}"; do
		eval "action_value=\"\$option_$action"\"
		if [[ -z $action_value ]]; then
			eval "option_$action=$action_default"
		elif [[ $action_value == 'yes' ]]; then
			actions+=("$action")
		fi
	done

	# default configuration based on whether custom shells were provided
	if [[ -z $option_reconfigure ]]; then
		if [[ ${#option_shells[@]} -eq 0 && $option_custom == 'no' ]]; then
			option_reconfigure='yes'
		else
			option_reconfigure='no'
		fi
	fi

	# load configuration regardless, as it is important for the clarity prompts
	source "$DOROTHY/sources/config.sh"
	# trunk-ignore(shellcheck/SC2034)
	local SETUP_UTILS=() DOROTHY_LOGIN_SHELLS=() USER_SHELLS=()
	load_dorothy_config -- 'setup.bash'

	# `USER_SHELLS` replaced by `DOROTHY_LOGIN_SHELLS`
	load_dorothy_config --optional -- 'shells.bash' # deprecated
	if [[ ${#USER_SHELLS[@]} -ne 0 ]]; then
		DOROTHY_LOGIN_SHELLS=("${USER_SHELLS[@]}")
		dorothy-config 'setup.bash' -- \
			--field='DOROTHY_LOGIN_SHELLS' --array="$(echo-unique --ignore-case -- "${DOROTHY_LOGIN_SHELLS[@]}")"
	fi
	remove_dorothy_config --reason='The shells.bash:USER_SHELLS has been relocated to setup.bash:DOROTHY_LOGIN_SHELLS. Relocation already done.' -- 'shells.bash'

	# =====================================
	# Helpers

	# Actions can be skipped, so be careful about inheriting configuration from one action to the next.

	function __handle_shells {
		# trunk-ignore-begin(shellcheck/SC2034)
		local \
			configured_shells=() \
			allowed_shells=() \
			user_install_shells=() \
			user_upgrade_shells=() \
			user_uninstall_shells=() \
			user_configure_shells=() \
			user_deconfigure_shells=() \
			user_allow_shells=() \
			user_disallow_shells=() \
			user_login_shells=()
		# trunk-ignore-end(shellcheck/SC2034)

		# do the prompts
		local action list=() shell defaults=() multi question description action_enabled action_shells action_shells_or_generic_shells_applied action_shells_or_generic_shells=() action_result_var group=() group_message=''
		function __apply_action_shells_or_generic_shells {
			if [[ $action_shells_or_generic_shells_applied == 'no' ]]; then
				if [[ ${#action_shells[@]} -ne 0 ]]; then
					action_shells_or_generic_shells=("${action_shells[@]}")
				else
					action_shells_or_generic_shells=("${option_shells[@]}")
				fi
				action_shells_or_generic_shells_applied='yes'
			fi
		}
		hash -r || : # before we begin, reset the executable cache
		for action in "${available_actions[@]}" fin; do
			# groups
			action_shells_or_generic_shells_applied='no'
			case "$action" in
			configure | allow | login | fin)
				# a group has now completed, apply changes
				if [[ ${#group[@]} -ne 0 ]]; then
					group_message="$(__join --source={group} --between='/')" || return $?
					__print_style --tty --newline --notice="Applying $group_message modifications..." || return $?
					if [[ $option_custom == 'no' ]]; then
						waiter 3 || :
					fi
					group=()
				fi
				# process
				case "$action" in
				configure)
					# now that we are in configure, do install/upgrade/uninstall
					for shell in "${all_configurable_basenames_of_shells[@]}"; do
						if __has --source={user_uninstall_shells} -- "$shell"; then
							if [[ $shell == 'bash' ]]; then
								__print_style --tty --notice='Cannot uninstall Bash, as it is a dependency of Dorothy.' || return $?
							else
								command "setup-util-$shell" --uninstall --optional "${slim_options[@]}" || return $? # eval
							fi
						fi
						if __has --source={user_upgrade_shells} -- "$shell"; then
							command "setup-util-$shell" --upgrade --optional "${slim_options[@]}" || return $? # eval
						elif __has --source={user_install_shells} -- "$shell" || [[ $shell == 'bash' ]]; then
							command "setup-util-$shell" --install --optional "${slim_options[@]}" || return $? # eval
						fi
					done
					hash -r || : # now that install/upgrade/uninstall is done, refresh the executable cache
					;;
				allow)
					# now that we are in allow, do configure/deconfigure
					for shell in "${user_deconfigure_shells[@]}"; do
						"__deconfigure_$shell" || return $? # eval
					done
					for shell in "${user_configure_shells[@]}"; do
						"__configure_$shell" || return $? # eval
					done
					;;
				login)
					# now that we are in login, do allow/disallow as a group

					# This is encountering <https://github.com/bevry/dorothy/issues/333>
					# ```
					# local config_args=()
					# for shell in "${user_disallow_shells[@]}"; do
					# 	config_args+=(--string-find="$shell" --string-replace='')
					# done
					# for shell in "${user_allow_shells[@]}"; do
					# 	config_args+=(--string-find="$shell" --string-replace="$shell")
					# done
					# if [[ ${#config_args[@]} -ne 0 ]]; then
					# 	config-helper --path=/etc/shells -- "${config_args[@]}" # not yet supported: --regexp=$'\n\n+' --replace=$'\n'
					# 	echo-trim-empty-lines --stdin </etc/shells | echo-write --atomic --path=/etc/shells
					# fi
					# ```
					# So do it directly instead:
					if [[ ${#user_allow_shells[@]} -ne 0 || ${#user_disallow_shells[@]} -ne 0 ]]; then
						local config config_lines=("${user_allow_shells[@]}")
						# trunk-ignore(shellcheck/SC2034)
						config="$(</etc/shells)" || return $?
						__split --source={config} --target={config_lines} --append --no-zero-length || return $?
						if [[ ${#user_disallow_shells[@]} -ne 0 ]]; then
							__evict --source+target={config_lines} --every --optional -- "${user_disallow_shells[@]}" || return $?
						fi
						__unique --source+target={config_lines} || return $?
						__print_lines "${config_lines[@]}" | echo-write --path=/etc/shells || return $?
						__print_style --stderr --success='Updated configuration file:' ' ' --path=/etc/shells || return $?
					fi
					;;
				fin)
					# now that we are in done, do login
					# there should only be one in this array
					for shell in "${user_login_shells[@]}"; do
						__apply_login_shell_path "$shell" || return $?
						break
					done
					break
					;;
				esac
				;;
			esac

			# prepare action
			list=() defaults=() description='' multi='yes'
			case "$action" in
			install)
				__split --target={list} --overwrite --no-zero-length --invoke -- \
					__get_unique_and_permitted_basenames_of_shells "${all_installable_basenames_of_shells[@]}" || return $?
				defaults+=(bash)
				question='Which shells to install?'
				description='Bash will always be installed, regardless of your selection, as it is a dependency of Dorothy.'
				action_enabled="$option_install"
				action_shells=("${option_install_shells[@]}")
				action_result_var='user_install_shells'
				;;
			upgrade)
				list=("${user_install_shells[@]}")
				question='Which shells to upgrade?'
				description='Bash will always be upgraded iff it is out of date, regardless of your selection, as it is a dependency of Dorothy.'
				action_enabled="$option_upgrade"
				action_shells=("${option_upgrade_shells[@]}")
				action_result_var='user_upgrade_shells'
				;;
			uninstall)
				__split --target={list} --overwrite --no-zero-length --invoke -- \
					__get_unique_and_permitted_installed_shells "${all_installable_basenames_of_shells[@]}" || return $?
				__evict --source+target={list} --optional --every -- 'bash' "${user_install_shells[@]}" || return $?
				question='Which undesired installed shells to uninstall?'
				description='Bash will always remain installed, regardless of your selection, as it is a dependency of Dorothy.'
				action_enabled="$option_uninstall"
				action_shells=("${option_uninstall_shells[@]}")
				action_result_var='user_uninstall_shells'
				;;
			configure)
				# refresh installed shells
				__split --target={list} --overwrite --no-zero-length --invoke -- \
					__get_unique_and_permitted_installed_shells "${all_configurable_basenames_of_shells[@]}" || return $?
				__split --target={configured_shells} --overwrite --no-zero-length --invoke -- \
					__get_unique_and_permitted_configured_basenames_of_shells "${all_configurable_basenames_of_shells[@]}" || return $?
				question='Which installed shells to enable Dorothy?'
				description="$(__print_style --help='To learn more about Dorothy: <https://dorothy.bevry.me>' --newline --help='To learn more about login shells: <https://github.com/bevry/dorothy/blob/master/docs/dorothy/dorothy-not-loading.md>')"
				action_enabled="$option_configure"
				action_shells=("${option_configure_shells[@]}")
				action_result_var='user_configure_shells'
				;;
			deconfigure)
				list=("${configured_shells[@]}")
				if [[ ${#list[@]} -ne 0 && ${#user_configure_shells[@]} -ne 0 ]]; then
					__evict --source+target={list} --optional --every -- "${user_configure_shells[@]}" || return $?
				fi
				question='Which undesired configured shells to disable Dorothy?'
				action_enabled="$option_deconfigure"
				action_shells=("${option_deconfigure_shells[@]}")
				action_result_var='user_deconfigure_shells'
				;;
			allow)
				# defaults first as we want them first in the list
				__split --target={defaults} --target={list} --overwrite --no-zero-length --invoke -- \
					__get_unique_and_permitted_paths_of_installed_shells "${all_allowable_basenames_of_shells[@]}" || return $?
				# trunk-ignore(shellcheck/SC2034)
				allowed_shells=()
				__split --target={list} --target={allowed_shells} --append --no-zero-length --invoke -- \
					__get_unique_and_permitted_paths_of_allowed_shells || return $?
				__unique --source+target={list} || return $?
				question='Which shells to allow as system login shells?'
				description='Shells that are enabled to run as system login shells can be used by your system upon login to configure your environment, as well as by your terminal emulator as your default shell.'
				action_enabled="$option_allow"
				action_shells=("${option_allow_shells[@]}")
				action_result_var='user_allow_shells'
				;;
			disallow)
				__split --target={list} --overwrite --no-zero-length --invoke -- \
					__get_unique_and_permitted_and_allowed_paths_of_installed_or_allowed_shells "${all_allowable_basenames_of_shells[@]}" || return $?
				# evict selection from allowed
				if [[ ${#user_allow_shells[@]} -ne 0 ]]; then
					__evict --source+target={list} --optional --every -- "${user_allow_shells[@]}" || return $?
				fi
				__unique --source+target={list} || return $?
				question='Which undesired allowed shells to disallow as system login shells?'
				description='Shells that are no longer listed to run as system login shells will no longer be able to be used by your system upon login to configure your environment, nor by your terminal emulator as your default shell.'
				action_enabled="$option_disallow"
				action_shells=("${option_disallow_shells[@]}")
				action_result_var='user_disallow_shells'
				;;
			login)
				# don't use `user_allow_shells`, as we want to ensure the data is refreshed due to the disallows
				# make sure preferences are first
				__apply_action_shells_or_generic_shells
				__split --target={allowed_shells} --overwrite --no-zero-length --invoke -- \
					__get_unique_and_permitted_paths_of_allowed_shells || return $?
				__split --target={list} --overwrite --no-zero-length --invoke -- \
					__get_unique_and_permitted_and_allowed_paths_of_installed_and_allowed_shells "${action_shells_or_generic_shells[@]}" "${DOROTHY_LOGIN_SHELLS[@]}" "${all_allowable_basenames_of_shells[@]}" || return $?
				# defaults handled within loop
				multi='no'
				question='Which single allowed shell to use as your default login shell?'
				description='Your default login shell is your preferred default shell. For supported systems, it will setup your environment upon login. For supported terminal emulators, it will be used for new terminal sessions.'
				action_enabled="$option_login"
				action_shells=("${option_login_shells[@]}")
				action_result_var='user_login_shells'
				;;
			esac
			__apply_action_shells_or_generic_shells

			# check
			if [[ $action == 'login' && $apply_login_shell_method == 'none' ]]; then
				__print_style --tty --newline --notice="Dorothy doesn't know how to set the login shell on this Operating System." || return $?
				return 0
				# return 19 # ENODEV 19 Operation not configurable by device
			fi

			# skipped / custom
			if [[ $action_enabled == 'no' ]]; then
				continue
			elif [[ ${#list[@]} -eq 0 ]]; then
				__print_style --tty --newline --question-title-result="$question" --newline --commentary-nothing-available='' || return $?
				continue
			fi

			# only add to the group if we have things to do
			group+=("$action")

			# generate menu
			local basename has_args=() results=() label paths=() path default defaults=() details=() version preselections=() choices=() choices_standard=() choices_default=()
			for shell in "${list[@]}"; do
				has_args=("$shell") default='no'
				if [[ $shell == /* ]]; then
					# shell is path
					basename="$(__get_basename_of_shell "$shell")"
					label="$(__get_path_label_of_path_of_shell "$shell")"
					has_args+=("$basename")
				else
					# shell is basename
					label="$(__get_url_label_of_basename_of_shell "$shell")" || return $?
					__split --target={paths} --overwrite --no-zero-length --invoke -- \
						__get_unique_and_permitted_and_resolved_paths_of_installed_shells "$shell" || return $?
					if [[ ${#paths[@]} -ne 0 ]]; then
						if [[ $action == 'install' ]]; then
							default='yes'
						fi
						details=('Existing installation at ')
						for path in "${paths[@]}"; do
							version="$(__get_version_of_path_of_shell "$path")" || return $?
							details+=(--path="$path" ' ')
							if [[ -n $version ]]; then
								details+=(--blue="$version" ' ')
							fi
						done
						label+=$'\n'"$(__print_style "${details[@]}")" || return $?
					fi
				fi
				preselections=()
				if __has --source={action_shells} --any -- "${has_args[@]}"; then
					default='yes'
					preselections+=("--$action=<shell>")
				elif __has --source={option_shells} --any -- "${has_args[@]}"; then
					default='yes'
					preselections+=('--shell=<shell>')
				fi
				if [[ $action == 'install' || $action == 'upgrade' ]]; then
					if __has --source={SETUP_UTILS} --any -- "${has_args[@]}"; then
						if [[ $action == 'install' ]]; then
							default='yes'
						fi
						preselections+=('setup.bash:SETUP_UTILS')
					fi
				elif [[ $action == 'allow' || $action == 'disallow' || $action == 'login' ]]; then
					if [[ $action == 'allow' || $action == 'login' ]]; then
						if __has --source={DOROTHY_LOGIN_SHELLS} --any -- "${has_args[@]}"; then
							default='yes'
							preselections+=('setup.bash:DOROTHY_LOGIN_SHELLS')
						fi
					fi
					if __has --source={allowed_shells} --any -- "${has_args[@]}"; then
						default='yes'
						preselections+=('/etc/shells')
						# label+=$'\nExisting allowance from '"$(__print_style --code='/etc/shells')." || return $?
					fi
				fi
				if [[ ${#preselections[@]} -ne 0 ]]; then
					label+=$'\nExisting selection from '"$(__join --source={preselections} --between=', ' --style='code')."
				fi
				if [[ $action == 'configure' || $action == 'deconfigure' ]]; then
					if __has --source={configured_shells} --any -- "${has_args[@]}"; then
						default='yes'
						label+=$'\nExisting configuration for Dorothy.' || return $?
					fi
				fi
				if [[ $default == 'yes' ]]; then
					defaults+=("$shell")
					choices_default+=("$shell" "$label")
				else
					choices_standard+=("$shell" "$label")
				fi
			done
			choices=("${choices_default[@]}" "${choices_standard[@]}")
			__unique --source+target={defaults}

			local skip_default='no'
			if [[ $option_custom == 'yes' && ${#action_shells[@]} -ne 0 ]]; then
				skip_default='yes'
			fi

			# select which shells to install and consequently which to also uninstall
			local -i status=0
			__value_to_tty $'\n' || return $?
			__split --target={"$action_result_var"} --overwrite --no-zero-length --invoke -- \
				choose --linger --skip-default="$skip_default" --multi="$multi" "$question" "$description" --defaults="$(__print_lines "${defaults[@]}")" --label -- "${choices[@]}" || status=$?
			if [[ $status -eq 130 ]]; then
				# this shouldn't happen, as 130 will only be returned if `--required` and no selection were made, which is not the case here
				# but just continue anyway
				continue
			elif [[ $status -ne 0 ]]; then
				return "$status"
			fi
		done
	}

	# =====================================
	# Action

	__handle_shells || return $?
)

# fire if invoked standalone
if [[ $0 == "${BASH_SOURCE[0]}" ]]; then
	if [[ $* == '--test' ]]; then
		setup_shell_test
	else
		setup_shell "$@"
	fi
fi
