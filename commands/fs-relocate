#!/usr/bin/env bash

function fs_relocate() (
	source "$DOROTHY/sources/bash.bash"

	# =====================================
	# Arguments

	function help {
		cat <<-EOF >&2
			ABOUT:
			Relocate all <source>s into the <destination>.

			USAGE:
			fs-relocate [...options] [--] [...<source>] <destination>

			OPTIONS:
			--symlink
			    If provided, the <source> will be persisted afterwards as a symlink to the <destination>.

			--elevated=<elevated>
			--elevate=<elevate>
			--user=<user>
			--group=<group>
			--reason=<reason>
			    Forwarded to [eval-helper].

			QUIRKS:
			If any <source> or the <destination> is a symlink, its symlink will be removed and its target will be relocated to the <destination>.
		EOF
		if [[ $# -ne 0 ]]; then
			echo-error "$@"
		fi
		return 22 # EINVAL 22 Invalid argument
	}

	# process
	local item option_paths=() option_symlink='no' option_elevated='' option_elevate='' option_user='' option_group='' option_reason=''
	while [[ $# -ne 0 ]]; do
		item="$1"
		shift
		case "$item" in
		'--help' | '-h') help ;;
		'--no-symlink'* | '--symlink'*)
			option_symlink="$(get-flag-value --affirmative --fallback="$option_symlink" -- "$item")"
			;;
		# <elevate>
		'--elevated='*) option_elevated="${item#*=}" ;;
		'--no-elevate'* | '--elevate'*)
			option_elevate+="$(get-flag-value --affirmative --fallback-on-empty --fallback="$option_elevate" -- "$item")"
			;;
		'--user='*) option_user="${item#*=}" ;;
		'--group='*) option_group="${item#*=}" ;;
		'--reason='*) option_reason="${item#*=}" ;;
		# </elevate>
		'--')
			option_paths+=("$@")
			shift $#
			break
			;;
		'--'*) help "An unrecognised flag was provided: $item" ;;
		*) option_paths+=("$item") ;;
		esac
	done

	# check
	if [[ ${#option_paths[@]} -eq 0 ]]; then
		help 'No <destination> provided.'
	fi

	# split sources and destination
	local sources destination
	local -i count
	# this does not work in bash v3
	# destination="${option_paths[-1]}"
	# sources=("${option_paths[@]:0:${#option_paths[@]}-1}")
	# this does work in bash v3
	count=${#option_paths[@]}
	destination="${option_paths[count - 1]}"
	sources=("${option_paths[@]:0:count-1}")

	# =====================================
	# Action

	function __wrap {
		if [[ $1 == '--' ]]; then
			shift
		fi
		eval-helper --elevated="$option_elevated" --elevate="$option_elevate" --user="$option_user" --group="$option_group" --reason="$option_reason" -- "$@"
	}

	# if destination is a symlink, resolve it, move it, and remove it
	local redirected_destination
	# if destination is a symlink, resolve it, move it, and remove it
	if is-symlink --elevated="$option_elevated" --elevate="$option_elevate" --user="$option_user" --group="$option_group" --reason="$option_reason" -- "$destination"; then
		if is-exist --elevated="$option_elevated" --elevate="$option_elevate" --user="$option_user" --group="$option_group" --reason="$option_reason" -- "$destination"; then
			redirected_destination="$(fs-path --resolve --elevated="$option_elevated" --elevate="$option_elevate" --user="$option_user" --group="$option_group" --reason="$option_reason" -- "$destination")"
			# remove the destination symlink
			__wrap rm -f -- "$destination"
			# relocate the resolved destination to the destination
			__wrap mv -fv -- "$redirected_destination" "$destination"
		else
			# remove the broken destination symlink
			__wrap rm -f -- "$destination"
		fi
	fi

	# move all sources to the destination
	if [[ ${#sources[@]} -ne 0 ]]; then
		local source original_source symlink_accident
		function __fail {
			echo-style --stderr --notice='Something went wrong when relocating paths to their correct location. Please remove one of these to try again:' --newline --code="$source" --newline --code="$destination"
			return 17 # EEXIST 17 File exists
		}
		for source in "${sources[@]}"; do
			# if source is a symlink, resolve it and remove it
			if is-symlink --elevated="$option_elevated" --elevate="$option_elevate" --user="$option_user" --group="$option_group" --reason="$option_reason" -- "$source"; then
				# store the source symlink
				original_source="$source"
				# update the source with the resolved source target
				if is-exist --elevated="$option_elevated" --elevate="$option_elevate" --user="$option_user" --group="$option_group" --reason="$option_reason" -- "$source"; then
					# is not a broken symlink
					source="$(fs-path --resolve --elevated="$option_elevated" --elevate="$option_elevate" --user="$option_user" --group="$option_group" --reason="$option_reason" -- "$source")"
				fi
				# if the source target is the the destination, and we want to make a symlink, we are done
				if [[ $option_symlink == 'yes' && $source == "$destination" ]]; then
					return 0
				fi
				# the source target is not the destination, so remove the source symlink
				__wrap rm -f -- "$original_source"
			elif [[ $source == "$destination" ]]; then
				# sanity check, if the source is the same as the destination, nothing to do
				return 0
			fi

			# sanity check
			if is-symlink --elevated="$option_elevated" --elevate="$option_elevate" --user="$option_user" --group="$option_group" --reason="$option_reason" -- "$source"; then
				__fail
			fi

			# if the source exists, prep for merging it with the destination
			if is-present --elevated="$option_elevated" --elevate="$option_elevate" --user="$option_user" --group="$option_group" --reason="$option_reason" -- "$source"; then
				# if the destination exists, trim both the source and destination to avoid merge failures
				if is-present --elevated="$option_elevated" --elevate="$option_elevate" --user="$option_user" --group="$option_group" --reason="$option_reason" -- "$destination"; then
					# do the trim
					fs-trim --no-confirm --quiet --empty --cache --elevated="$option_elevated" --elevate="$option_elevate" --user="$option_user" --group="$option_group" --reason="$option_reason" -- "$source" "$destination"
					# if source doesn't exist anymore, we are done, as there is nothing left to relocate
					if is-missing --elevated="$option_elevated" --elevate="$option_elevate" --user="$option_user" --group="$option_group" --reason="$option_reason" -- "$source"; then
						return 0
					fi
				fi

				# merge the source into the destination
				__wrap mv -fv -- "$source" "$destination" || __fail
			fi

			# sanity check
			if is-present -elevated="$option_elevated" --elevate="$option_elevate" --user="$option_user" --group="$option_group" --reason="$option_reason" -- "$source"; then
				__fail
			fi

			# do we want to persist a symlink?
			if [[ $option_symlink == 'yes' ]]; then
				# now that source definitely doesn't exist, symlink the source to the destination
				# ln <target> <symlink>
				if is-busybox -- ln; then
					# alpine doesn't support -F, however the removals earlier should make it unnecessary
					__wrap ln -sf -- "$destination" "$source"
				else
					# -F: replace symlink if directory if needed
					# -f: unlink symlink path if needed
					# -s: symbolic link
					__wrap ln -sfF -- "$destination" "$source"
				fi

				# cleanup accidents
				symlink_accident="$source/$(fs-path --no-parents -- "$destination")"
				if is-symlink -elevated="$option_elevated" --elevate="$option_elevate" --user="$option_user" --group="$option_group" --reason="$option_reason" -- "$symlink_accident"; then
					__wrap rm -f -- "$symlink_accident"
				fi
			fi
		done
	fi
)

# fire if invoked standalone
if [[ $0 == "${BASH_SOURCE[0]}" ]]; then
	fs_relocate "$@"
fi
