#!/usr/bin/env bash

function echo_join_test() (
	source "$DOROTHY/sources/bash.bash"

	eval-tester --ignore-stderr --status=22 -- echo-join ', ' -- a b

	eval-tester --stdout='ab' -- echo-join -- a b
	eval-tester --stdout='a, b' -- echo-join --between=', ' -- a b
	eval-tester --stdout=$'a\n\tb' -- echo-join --between=$'\n\t' -- a b

	__print_lines a b | eval-tester --stdout='ab' -- echo-join --stdin
	__print_lines a b | eval-tester --stdout='a, b' -- echo-join --between=', ' --stdin
	__print_lines a b | eval-tester --stdout=$'a\n\tb' -- echo-join --between=$'\n\t' --stdin

	eval-tester --stdout=$'{\e[31m<\e[1ma\e[22m>\e[39m\e[2m|\e[22m\e[31m<\e[1mb\e[22m>\e[39m\e[2m|\e[22m\e[31m<\e[1mc\e[22m>\e[39m}' -- \
		echo-join --first='{' --last='}' --left='<' --right='>' --between='|' --style=bold --wrap-style=foreground_red --between-style=dim -- a b c

	return 0
)
function echo_join() (
	source "$DOROTHY/sources/stdinargs.bash"

	# =====================================
	# Arguments

	function help {
		__print_help "$@" <<-EOF || return $?
			ABOUT:
			Concatenate the inputs with the <join> between them.

			USAGE:
			\`echo-join [...options] -- ...<input>\`
			\`echo-lines ...<input> | echo-join [...options]\`

			OPTIONS:
			--first=<text>
			    Text to put before the first <input>.
			--last=<text>
			    Text to put after the last <input>.
			--between=<text> | --join=<text> | --delimiter=<text>
			    The delimiter to put between each <input>. If not provided, a space is used.
			--before=<text> | --prefix=<text> | --left=<text>
			    Text to put before each <input>.
			--after=<text> | --suffix=<text> | --right=<text>
			    Text to put after each <input>.
			--style=<style>
			    The style to apply to each <input>.
			--wrap-style=<style>
			    The style to apply to the entire output.
			--between-style=<style>
			    The style to apply to the <between> text.

			$(__stdinargs__help_options --)

			QUIRKS:
			Use \`--last=\$'\\n'\` to add a trailing newline.
		EOF
		return 22 # EINVAL 22 Invalid argument
	}

	# process our own arguments, delegate everything else to stdinargs
	local item option_first='' option_last='' option_between='' option_before='' option_after='' option_style='' option_wrap_style='' option_between_style=''
	while [[ $# -ne 0 ]]; do
		item="$1"
		shift
		case "$item" in
		'--help' | '-h') help ;;
		'--first='*) option_first="${item#*=}" ;;
		'--last='*) option_last="${item#*=}" ;;
		'--between='* | '--join='* | '--delimiter='*) option_between="${item#*=}" ;;
		'--before='* | '--prefix='* | '--left='*) option_before="${item#*=}" ;;
		'--after='* | '--suffix='* | '--right='*) option_after="${item#*=}" ;;
		'--style='*) option_style="${item#*=}" ;;
		'--wrap-style='*) option_wrap_style="${item#*=}" ;;
		'--between-style='*) option_between_style="${item#*=}" ;;
		# forward to stdinargs, however support mixing and matching of our options, with stdinargs options
		'--')
			option_args+=("$item" "$@")
			shift $#
			break
			;;
		'--'*) option_args+=("$item") ;;
		*) help 'An unrecognised argument was provided: ' --variable-value={item} ;;
		esac
	done

	# =================================
	# Action

	local pieces=()
	function __on_piece {
		pieces+=("$1")
	}
	function __on_finish {
		__join --source={pieces} --first="$option_first" --last="$option_last" --between="$option_between" --before="$option_before" --after="$option_after" --style="$option_style" --wrap-style="$option_wrap_style" --between-style="$option_between_style"
	}

	stdinargs "${option_args[@]}"
)

# fire if invoked standalone
if [[ $0 == "${BASH_SOURCE[0]}" ]]; then
	if [[ $* == '--test' ]]; then
		echo_join_test
	else
		echo_join "$@"
	fi
fi
