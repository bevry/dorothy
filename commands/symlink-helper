#!/usr/bin/env bash

# @todo currently this is only for creating, however we could make it also for listing/finding as well - probably a bad idea

# @todo update this for auto-elevation

function symlink_helper() (
	source "$DOROTHY/sources/bash.bash"

	# =====================================
	# Arguments

	function help {
		cat <<-EOF
			ABOUT:
			Create a symlink at a new location that points to an existing location.

			USAGE:
			symlink-helper [...options] --target=<target> --symlink=<symlink>

			OPTIONS:
			--target=<target> | --existing=<target>
			    The target of the symlink.
			--symlink=<symlink>
			    The location of the symlink to modify.

			--relative
			    Save the symlink target as a relative path instead of absolute.

			--quiet
			    When quiet, only output errors, do not output symlink creation.
			--verbose
			    When verbose, output even if symlink is already desired.

			--elevated=<elevated>
			--elevate=<elevate>
			--user=<user>
			--group=<group>
			--reason=<reason>
				Forwarded to [eval-helper].

			EXAMPLES:
			symlink-helper --target="$HOME" --symlink=./my-home-folder-symlink
		EOF
		if [[ $# -ne 0 ]]; then
			echo-error "$@"
		fi
		return 22 # EINVAL 22 Invalid argument
	}

	# process
	local item option_quiet='' option_targets=() option_symlinks=() option_relative='no' option_elevated='' option_elevate='' option_user='' option_group='' option_reason=''
	while [[ $# -ne 0 ]]; do
		item="$1"
		shift
		case "$item" in
		'--help' | '-h') help ;;
		'--no-verbose'* | '--verbose'*)
			option_quiet="$(get-flag-value --non-affirmative --fallback="$option_quiet" -- "$item")"
			;;
		'--no-quiet'* | '--quiet'*)
			option_quiet="$(get-flag-value --affirmative --fallback="$option_quiet" -- "$item")"
			;;
		'--target='* | '--existing='*) option_targets+=("${item#*=}") ;;
		'--symlink='*) option_symlinks+=("${item#*=}") ;;
		'--no-relative'* | '--relative'*)
			option_relative="$(get-flag-value --affirmative --fallback="$option_relative" -- "$item")"
			;;
		# <elevate>
		'--elevated='*) option_elevated="${item#*=}" ;;
		'--no-elevate'* | '--elevate'* | '--no-sudo'* | '--sudo'*)
			option_elevate+="$(get-flag-value --affirmative --fallback-on-empty --fallback="$option_elevate" -- "$item")"
			;;
		'--user='*) option_user="${item#*=}" ;;
		'--group='*) option_group="${item#*=}" ;;
		'--reason='*) option_reason="${item#*=}" ;;
		# </elevate>
		'--'*) help "An unrecognised flag was provided: $item" ;;
		*) help "An unrecognised argument was provided: $item" ;;
		esac
	done

	# ensure as many targets as symlinks
	if [[ ${#option_targets[@]} -ne ${#option_symlinks[@]} ]]; then
		help "The number of targets [${#option_targets[@]}] does not match the number of symlinks [${#option_symlinks[@]}]"
	elif [[ ${#option_targets[@]} -eq 0 ]]; then
		option_targets+=("$(
			ask --required \
				--question='What is the existing path that you want the symlink to target?'
		)")
		option_symlinks+=("$(
			ask --required \
				--question='What is the new path that you want to be the symlink that redirects?'
		)")
	fi

	# check
	function help_missing {
		echo-style --stderr \
			--error='FAILURE:' --newline \
			'The path to be symlinked ' --code="$option_target" " doesn't actually exist." --newline \
			'As such, we cannot create a symlink at ' --code="$option_symlink" ' pointing to it.' --newline \
			'Create the path at ' --code="$option_target" ' first, then try again.'
		return 2 # ENOENT 2 No such file or directory
	}
	function __wrap {
		eval-helper --elevated="$option_elevated" --elevate="$option_elevate" --user="$option_user" --group="$option_group" --reason="$option_reason" -- "$@"
	}
	# create the symlink
	# -F: replace symlink if directory if needed
	# -f: unlink symlink path if needed
	# -s: symbolic link
	if is-busybox -- ln; then
		function __ln {
			# alpine's ln doesn't support -F, however the above removals should make it unnecessary
			# https://github.com/bevry/dorothy/actions/runs/11323459946/job/31486170602#step:4:11
			__wrap ln -sf "$@"
		}
	else
		function __ln {
			__wrap ln -sfF "$@"
		}
	fi

	# =====================================
	# Act

	# ensure validity of target path
	local index target symlink original
	for index in "${!option_targets[@]}"; do
		target="${option_targets[$index]}"
		symlink="${option_symlinks[$index]}"
		# @todo is this while loop necessary?
		while :; do
			# ensure both paths are not relative paths, otherwise weird things will happen
			target="$(fs-path --absolute --elevated="$option_elevated" --elevate="$option_elevate" --user="$option_user" --group="$option_group" --reason="$option_reason" -- "$target")"
			symlink="$(fs-path --absolute --elevated="$option_elevated" --elevate="$option_elevate" --user="$option_user" --group="$option_group" --reason="$option_reason" -- "$symlink")"

			# double check the existence of the source, if it doesn't exist, there is no point
			if is-missing --elevated="$option_elevated" --elevate="$option_elevate" --user="$option_user" --group="$option_group" --reason="$option_reason" -- "$target"; then
				help_missing
			fi

			# check if the target path is a symlink
			# if it is, then use its target instead, and repeat the checks
			if is-symlink --elevated="$option_elevated" --elevate="$option_elevate" --user="$option_user" --group="$option_group" --reason="$option_reason" -- "$target"; then
				original="$target"
				target="$(fs-path --resolve --elevated="$option_elevated" --elevate="$option_elevate" --user="$option_user" --group="$option_group" --reason="$option_reason" -- "$target")"
				if [[ -z $option_quiet || $option_quiet == 'no' ]]; then
					echo-style --stderr --bold='üíÅ‚Äç‚ôÄÔ∏è Target ' --code="$original" --bold=' redirects to ' --code="$target" --bold=' üëâ using the redirection...'
				fi
				continue
			fi

			# all checks passed, break
			break
		done

		# determine the desired path
		if [[ $option_relative == 'yes' ]]; then
			target="$(fs-path --resolve --relative-to="$(fs-path --parents -- "$symlink")" --elevated="$option_elevated" --elevate="$option_elevate" --user="$option_user" --group="$option_group" --reason="$option_reason" -- "$target")"
		fi

		# check if the symlink is already desired
		# @todo this could be optimised by writing a symlink-helper.bash or by checking the exit status of the is-* commands
		if is-exist --elevated="$option_elevated" --elevate="$option_elevate" --user="$option_user" --group="$option_group" --reason="$option_reason" -- "$symlink"; then
			if is-symlink --elevated="$option_elevated" --elevate="$option_elevate" --user="$option_user" --group="$option_group" --reason="$option_reason" -- "$symlink"; then
				if [[ "$(fs-path --resolve --elevated="$option_elevated" --elevate="$option_elevate" --user="$option_user" --group="$option_group" --reason="$option_reason" -- "$symlink")" == "$target" ]]; then
					if [[ $option_quiet == 'no' ]]; then
						echo-style --stderr --bold='üëç Symlink already created at ' --code="$symlink" --bold=' targetting ' --code="$target"
					fi
					return 0
				fi
				if [[ -z $option_quiet || $option_quiet == 'no' ]]; then
					echo-style --stderr --bold='üíÅ‚Äç‚ôÄÔ∏è Symlink already exists at ' --code="$symlink" --bold=' üëâ recreating...'
				fi
				# is a symlink but a different target, drop it and recreate
				__wrap rm -f -- "$symlink" >&2
			else
				# not a symlink, confirm with the user what to do
				fs-rm --quiet="$option_quiet" --confirm --elevated="$option_elevated" --elevate="$option_elevate" --user="$option_user" --group="$option_group" --reason="$option_reason" -- "$symlink" >&2
			fi
		elif is-symlink --elevated="$option_elevated" --elevate="$option_elevate" --user="$option_user" --group="$option_group" --reason="$option_reason" -- "$symlink"; then
			# is a broken symlink, drop it and recreate
			__wrap rm -f -- "$symlink" >&2
		else
			# the symlink doesn't exist, ensure its parent path at least exists
			__wrap mkdir -p -- "$(fs-path --parents -- "$symlink")" >&2
		fi

		# create the symlink
		__ln -- "$target" "$symlink" >&2

		# log result to stderr
		if [[ -z $option_quiet || $option_quiet == 'no' ]]; then
			echo-style --stderr --success='üëç Symlink created at ' --code="$symlink" --bold=' targetting ' --code="$target"
		fi
	done
)

# fire if invoked standalone
if [[ $0 == "${BASH_SOURCE[0]}" ]]; then
	symlink_helper "$@"
fi
