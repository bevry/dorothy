#!/usr/bin/env bash

function ask_test() (
	source "$DOROTHY/sources/bash.bash"
	echo-segment --h1="TEST: $0"

	eval-tester --name='default response -confirm' --stdout='a default response' \
		-- ask --question='What is your response?' --default='a default response'

	{
		# confirm to enter a value
		sleep 3
		echo
	} | eval-tester --name='default response +confirm' --stdout='a default response' \
		-- ask --question='What is your response?' --default='a default response' --confirm

	{
		# confirm to enter a value
		sleep 3
		echo

		# enter the custom response
		sleep 3
		print_line 'a custom response'
	} | eval-tester --name='custom response -default -confirm' --stdout='a custom response' \
		-- ask --question='What is your response?'

	{
		# confirm to enter a value
		sleep 3
		echo

		# enter the custom response
		sleep 3
		print_line 'a custom response'

		# confirm the custom response
		sleep 3
		echo
	} | eval-tester --name='custom response -default +confirm' --stdout='a custom response' \
		-- ask --question='What is your response?' --confirm

	{
		# move down and select custom response
		sleep 3
		printf $'\eOB'
		sleep 3
		echo

		# enter the custom response
		sleep 3
		print_line 'a custom response'

		# confirm the custom response
		sleep 3
		echo
	} | eval-tester --name='custom response +default +confirm' --stdout='a custom response' \
		-- ask --question='What is your response?' --default='a default response' --confirm

	echo-segment --g1="TEST: $0"
	return 0
)
function ask_() (
	source "$DOROTHY/sources/bash.bash"
	source "$DOROTHY/sources/tty.bash"

	# =====================================
	# Arguments

	function help {
		cat <<-EOF >/dev/stderr
			ABOUT:
			Prompt the user for an input value in a clean and robust way.

			USAGE:
			ask [...options]

			OPTIONS:
			--question=<string>
			    Specifies the question that the prompt will be answering.

			--default=<value>
				Specifies the default value if no user specified value is entered.

			--confirm
			    Specifies that the prompt should confirm the value before continuing.

			--password
			    Specifies that the prompt should hide the value when entering by using password mode.

			--required
			    Specifies that the prompt should not continue until a value is provided.

			--timeout=<seconds>
			    Specifies a custom timeout value in seconds.
		EOF
		if test "$#" -ne 0; then
			echo-error "$@"
		fi
		return 22 # EINVAL 22 Invalid argument
	}

	# process
	local item args=() option_question='' option_default='' option_timeout='' option_password='no' option_required='no' option_linger='no' option_confirm_default='yes' option_confirm_input='no'
	while test "$#" -ne 0; do
		item="$1"
		shift
		case "$item" in
		'--help' | '-h') help ;;
		'--question='*) option_question="${item#*=}" ;;
		'--default='*) option_default="${item#*=}" ;;
		'--timeout='*) option_timeout="${item#*=}" ;;
		'--no-password'* | '--password'*)
			option_password="$(get-flag-value --affirmative --fallback="$option_password" -- "$item")"
			;;
		'--no-required'* | '--required'*)
			option_required="$(get-flag-value --affirmative --fallback="$option_required" -- "$item")"
			;;
		'--no-linger'* | '--linger'*)
			option_linger="$(get-flag-value --affirmative --fallback="$option_linger" -- "$item")"
			;;
		'--no-confirm-default'* | '--confirm-default'*)
			option_confirm_default="$(get-flag-value --affirmative --fallback="$option_confirm_default" -- "$item")"
			;;
		'--no-confirm-input'* | '--confirm-input'*)
			option_confirm_input="$(get-flag-value --affirmative --fallback="$option_confirm_input" -- "$item")"
			;;
		'--')
			args+=("$@")
			shift $#
			break
			;;
		'--'*) help "An unrecognised flag was provided: $item" ;;
		*) help "An unrecognised argument was provided: $item" ;;
		esac
	done

	# =====================================
	# Action

	# prepare
	# @todo implement cursor move fallback
	local tty_target
	tty_target="$(is-tty --fallback)"

	# adjust result
	local RESULT
	if test -n "$option_default"; then
		RESULT="$option_default"
	else
		RESULT=''
	fi

	# adjust timeout to one minute if we have a default value, or if optional
	if test -z "$option_timeout" && (is-value -- "$RESULT" || test "$option_required" = 'no'); then
		option_timeout=60
	fi

	# adjust question
	local question_render prompt
	prompt='> '
	question_render="$(echo-style --bold="$option_question")"

	# adjust tty
	local size_columns bin_gfold bin_gwc
	size_columns="$(tput cols)"
	if is-mac; then
		bin_gfold="$(type -P 'gfold' 2>/dev/null || :)"
		bin_gwc="$(type -P 'gwc' 2>/dev/null || :)"
	else
		bin_gfold="$(type -P 'fold' 2>/dev/null || :)"
		bin_gwc="$(type -P 'wc' 2>/dev/null || :)"
	fi

	# helpers
	local ASKED='no'
	function send_result {
		if test "$option_linger" = 'yes'; then
			print_line "$question_render"$'\n'"$RESULT" >"$tty_target"
		fi
		print_line "$RESULT"
	}
	function on_timeout {
		if is-value -- "$RESULT"; then
			echo-style --notice="Ask timed out. Using the fallback value: " --code="$RESULT" >/dev/stderr
			sleep 5
			send_result
			return 0
		elif test "$option_required" = 'no'; then
			echo-style --notice='Ask timed out. Had no fallback value, this is fine as the field was optional.' >/dev/stderr
			sleep 5
			return 0
		else
			echo-style --warning='Ask timed out. Had no fallback value... the field was required.' >/dev/stderr
			sleep 5
			return 60 # ETIMEDOUT 60 Operation timed out
		fi
	}
	function do_prompt { # has sideffects: RESULT, ASKED
		local __read_status render render_rows

		# tty_auto
		ASKED='yes' # not local
		if test -n "$question_render"; then
			print_line "$question_render" >"$tty_target"
		fi
		while true; do
			# -i requires -e
			__read_status=0 && read -r -t 300 -ei "$RESULT" -p "$prompt" RESULT || __read_status=$?

			# \n at the end to factor in the enter key
			render="$(echo-trim-colors -- "$question_render"$'\n'"$prompt$RESULT")"
			render="$("$bin_gfold" -w "$size_columns" <<<"$render")"
			render_rows="$("$bin_gwc" -l <<<"$render")"

			# move these lines up and erase
			printf '\e[%sF\e[G\e[J' "$render_rows" >"$tty_target"

			if test "$__read_status" -eq 142; then
				return 60 # ETIMEDOUT 60 Operation timed out
			fi
			if is-value -- "$RESULT"; then
				# we have a value, proceed
				break
			elif test "$option_required" = 'yes'; then
				# ask again
				continue
			else
				# no result, optional, set value to empty, and proceed
				RESULT=''
				break
			fi
		done
		do_validate
	}
	function do_validate {
		local choose_status prompt_status choice choices=()

		# have we prompted?
		if test "$ASKED" = 'no'; then
			# do we want to confirm the default value
			if is-value -- "$RESULT" && test "$option_confirm_default" = 'no'; then
				send_result
				return 0
			fi
		else
			# we have asked, do we want to confirm the input value
			if test "$option_confirm_input" = 'no'; then
				send_result
				return 0
			fi

			# redo choices, has to be redone each time due to result
			if test "$option_password" = 'yes'; then
				choices+=('existing' 'use the entered password')
			else
				choices+=('existing' "use the entered value: [$RESULT]")
			fi
			choices+=('custom' 'redo the entered value')
			if test "$option_required" = 'no'; then
				choices+=('none' 'use no value')
			fi

			# we want to confirm
			eval_capture --statusvar=choose_status --stdoutvar=choice -- \
				choose-option \
				--timeout="$option_timeout" \
				--question="$option_question" \
				--label -- "${choices[@]}"

			# check the confirmation
			if test "$choose_status" -eq 60; then
				echo-style --error="Choose timed out: $choose_status" >/dev/stderr
				on_timeout
				return
			elif test "$choose_status" -ne 0; then
				echo-style --error="Choose failed: $choose_status" >/dev/stderr
				sleep 3
				return "$choose_status"
			fi

			# proceess the confirmation
			if test "$choice" = 'existing'; then
				# done, sucess
				send_result
				return 0
			elif test "$choice" = 'custom'; then
				: # proceed with prompt
			elif test "$choice" = 'none'; then
				# done, sucess
				echo
				return 0
			else
				# unknown error
				echo-style --error="Invalid choice: $choice" >/dev/stderr
				sleep 3
				return 14 # EFAULT 14 Bad address
			fi
		fi

		# prompt
		eval_capture --statusvar=prompt_status -- do_prompt

		# check for failure
		if test "$prompt_status" -ne 0; then
			# timeout probably
			on_timeout
			return
		fi

		# done, success
		return 0
	}

	# act
	do_validate
)

# fire if invoked standalone
if test "$0" = "${BASH_SOURCE[0]}"; then
	if test "$*" = '--test'; then
		ask_test
	else
		ask_ "$@"
	fi
fi
