#!/usr/bin/env bash
export PATH="$DOROTHY_USER_HOME/commands.local:$DOROTHY_USER_HOME/commands:$DOROTHY/commands:$PATH"  # right to left is preference
source "$DOROTHY/sources/home.sh" # ensure env configured correctly
source "$DOROTHY/sources/strict.bash"
source "$DOROTHY/sources/splitlines.bash"
source "$DOROTHY/sources/config.sh"

# don't use `is-admin` here, as sudo does not necessarily load this
# so sudo should inherit standard config

# shell
login_shell="${1-}"

# helpers
function echo_var_del {
	if test "$login_shell" = "fish"; then
		echo "set --universal --erase $1;"
	else
		echo "export $1=\"\";"
	fi
}
function echo_var_add {
	local fish_flags=('--export' '--prepend') separator name value
	if test "$#" -eq 3; then
		separator="$1"
		name="$2"
		value="$3"
	else
		# windows uses semicolon for separator
		# unix uses colon for separator
		# we do not yet support windows
		fish_flags+=('--path')
		separator=':'
		name="$1"
		value="$2"
	fi
	if test "$login_shell" = "fish"; then
		# · -x or --export causes the specified shell variable to be exported to child processes (making it an "environment variable")
		# · --path causes the specified variable to be treated as a path variable, meaning it will automatically be split on colons,  and joined using colons when quoted (echo "$PATH") or exported.
		# · -p or --prepend causes the values to be prepended to the current set of values for the variable. This can be used with --append to both append and prepend at the same time. This cannot be used when assigning to a  variable slice.
		echo "set ${fish_flags[*]} ${name} \"${value}\";"
	else
		if test -z "${!name-}"; then
			echo "export ${name}=\"${value}\";"
		else
			echo "export ${name}=\"${value}${separator}\$${name}\";"
		fi
	fi
}
function echo_var_set {
	if test "$login_shell" = "fish"; then
		echo_var_del "$1"
		echo "set --export $1 \"$2\";"
	else
		echo "export $1=\"$2\";"
	fi
}
function echo_and_eval_var_set {
	eval "$1=\"$2\""
	echo_var_set "$1" "$2"
}
function rubygems {
	echo_var_set GEM_HOME "$HOME/.gem"
	if test -x "$1"; then
		rubydirs="$("$1" environment gempath | tr ":" "\n")"
		for i in $rubydirs; do
			echo_var_add PATH "$i/bin"
		done
	fi
}
function command-exists {
	stderr echo "cannot use [command-exists $*] yet, as paths have not been setup yet"
	exit 1
}

# user
function before_dorothy_paths {
	return
}
function after_dorothy_paths {
	return
}
function after_everything {
	return
}
load_dorothy_config 'environment.bash'

# reset
echo_var_del PATH
echo_var_add PATH "/bin"
echo_var_add PATH "/sbin"
echo_var_add PATH "/usr/bin"
echo_var_add PATH "/usr/sbin"

# xdg
# https://wiki.archlinux.org/title/XDG_Base_Directory
if test -z "${XDG_CONFIG_HOME-}"; then
	echo_and_eval_var_set XDG_CONFIG_HOME "$HOME/.config"
fi
if test -z "${XDG_CACHE_HOME-}"; then
	echo_and_eval_var_set XDG_CACHE_HOME "$HOME/.cache"
fi
if test -z "${XDG_DATA_HOME-}"; then
	echo_and_eval_var_set XDG_DATA_HOME "$HOME/.local/share"
fi
if test -z "${XDG_STATE_HOME-}"; then
	echo_and_eval_var_set XDG_STATE_HOME "$HOME/.local/state"
fi
if test -z "${XDG_DATA_DIRS-}"; then
	echo_var_del XDG_DATA_DIRS
	echo_var_add XDG_DATA_DIRS '/usr/share'
	echo_var_add XDG_DATA_DIRS '/usr/local/share'
	echo_var_add XDG_DATA_DIRS "$XDG_DATA_HOME"
fi
if test -z "${XDG_CONFIG_DIRS-}"; then
	echo_var_del XDG_CONFIG_DIRS
	echo_var_add XDG_CONFIG_DIRS '/etc/xdg'
	echo_var_add XDG_CONFIG_DIRS "$XDG_CONFIG_HOME"
fi

# dorothy
# commented out, as nothing uses this yet
# if test -z "${DOROTHY_CACHE_HOME-}"; then
# 	echo_and_eval_var_set DOROTHY_CACHE_HOME "$XDG_CACHE_HOME/dorothy"
# fi
# if test -z "${DOROTHY_STATE_HOME-}"; then
# 	echo_and_eval_var_set DOROTHY_STATE_HOME "$XDG_STATE_HOME/dorothy"
# fi

# Xcode
if test -d "/Applications/Xcode.app/Contents/Developer/usr/bin"; then
	echo_var_add PATH "/Applications/Xcode.app/Contents/Developer/usr/bin"
fi

# Snap
if test -d "/snap/bin"; then
	echo_var_add PATH "/snap/bin"
fi

# Homebrew, UNIX
if test -d "/usr/local/bin"; then
	echo_var_add PATH "/usr/local/bin"
fi
if test -d "/usr/local/sbin"; then
	echo_var_add PATH "/usr/local/sbin"
fi
if test -d "/usr/local/man"; then
	echo_var_add MANPATH "/usr/local/man"
fi

# Homebrew
if is-mac; then
	# ensure the brew vars [HOMEBREW_ARCH, HOMEBREW_PREFIX, HOMEBREW_CELLAR, HOMEBREW_REPOSITORY, HOMEBREW_SHELLENV_PREFIX] are set even if brew is not yet installed
	if test -z "${HOMEBREW_ARCH-}"; then
		if test "$(uname -p)" = 'arm' -o "$(uname -m)" = 'arm64'; then
			echo_and_eval_var_set HOMEBREW_ARCH 'arm64e'
		else
			echo_and_eval_var_set HOMEBREW_ARCH 'x86_64'
		fi
	fi
	if test -z "${HOMEBREW_PREFIX-}"; then
		if test "$HOMEBREW_ARCH" = 'arm64e'; then
			echo_and_eval_var_set HOMEBREW_PREFIX '/opt/homebrew'
		else
			echo_and_eval_var_set HOMEBREW_PREFIX '/usr/local'
		fi
	fi
	if test -z "${HOMEBREW_CELLAR-}"; then
		if test -x "${HOMEBREW_PREFIX}/bin/brew"; then
			echo_and_eval_var_set HOMEBREW_CELLAR "$(${HOMEBREW_PREFIX}/bin/brew --cellar)"
		else
			echo_and_eval_var_set HOMEBREW_CELLAR "$HOMEBREW_PREFIX/Cellar"
		fi
	fi
	if test -z "${HOMEBREW_REPOSITORY-}"; then
		if test -x "${HOMEBREW_PREFIX}/bin/brew"; then
			echo_and_eval_var_set HOMEBREW_REPOSITORY "$(${HOMEBREW_PREFIX}/bin/brew --repo)"
		else
			echo_and_eval_var_set HOMEBREW_REPOSITORY "$HOMEBREW_PREFIX"
		fi
	fi
	if test -z "${HOMEBREW_SHELLENV_PREFIX-}"; then
		echo_and_eval_var_set HOMEBREW_SHELLENV_PREFIX "$HOMEBREW_PREFIX"
	fi
fi
# on linux, HOMEBREW_PREFIX will still be missing, so still need to do ${...-}
# if homebrew is installed, then add its paths
if test -x "${HOMEBREW_PREFIX-}/bin/brew"; then
	# /usr/local already added, so only add these if different
	if test "$HOMEBREW_PREFIX" != '/usr/local'; then
		if test -d "$HOMEBREW_PREFIX/bin"; then
			echo_var_add PATH "$HOMEBREW_PREFIX/bin"
		fi
		if test -d "$HOMEBREW_PREFIX/sbin"; then
			echo_var_add PATH "$HOMEBREW_PREFIX/sbin"
		fi
	fi

	# add the rest
	if test -d "$HOMEBREW_PREFIX/share/man"; then
		echo_var_add MANPATH "$HOMEBREW_PREFIX/share/man"
	fi
	if test -d "$HOMEBREW_PREFIX/share/info"; then
		echo_var_add INFOPATH "$HOMEBREW_PREFIX/share/info"
	fi

	# for compilers to find homebrew
	if test -d "$HOMEBREW_PREFIX/lib"; then
		echo_var_add ' ' LDFLAGS "-L$HOMEBREW_PREFIX/lib"
	fi
	if test -d "$HOMEBREW_PREFIX/include"; then
		echo_var_add ' ' CPPFLAGS "-I$HOMEBREW_PREFIX/include"
	fi
	if test -d "$HOMEBREW_PREFIX/lib/pkgconfig"; then
		echo_var_add PKG_CONFIG_PATH "$HOMEBREW_PREFIX/lib/pkgconfig"
	fi

	# llvm
	if test -d "$HOMEBREW_PREFIX/opt/llvm/bin"; then
		p="$HOMEBREW_PREFIX/opt/llvm"
		echo_var_add PATH "$p/bin"
		rubygems "$p/bin/gem"
		# for compilers to find llvm
		if test -d "$p/lib"; then
			echo_var_add ' ' LDFLAGS "-L$p/lib"
		fi
		if test -d "$p/include"; then
			echo_var_add ' ' CPPFLAGS "-I$p/include"
		fi
	fi

	# SQLite (dependency of python)
	if test -d "$HOMEBREW_PREFIX/opt/sqlite/bin"; then
		p="$HOMEBREW_PREFIX/opt/sqlite"
		echo_var_add PATH "$p/bin"
		# for compilers to find sqlite
		if test -d "$p/lib"; then
			echo_var_add ' ' LDFLAGS "-L$p/lib"
		fi
		if test -d "$p/include"; then
			echo_var_add ' ' CPPFLAGS "-I$p/include"
		fi
		# for pkg-config to find sqlite
		if test -d "$p/lib/pkgconfig"; then
			echo_var_add PKG_CONFIG_PATH "$p/lib/pkgconfig"
		fi
	fi

	# guile (dependency of something)
	if test -d "$HOMEBREW_PREFIX/share/guile"; then
		echo_var_set GUILE_LOAD_PATH "$HOMEBREW_PREFIX/share/guile/site/3.0"
		echo_var_set GUILE_LOAD_COMPILED_PATH "$HOMEBREW_PREFIX/lib/guile/3.0/site-ccache"
		echo_var_set GUILE_SYSTEM_EXTENSIONS_PATH "$HOMEBREW_PREFIX/lib/guile/3.0/extensions"
	fi

	# icu4c (dependency of heroku)
	if test -d "$HOMEBREW_PREFIX/opt/icu4c/bin"; then
		echo_var_add PATH "$HOMEBREW_PREFIX/opt/icu4c/bin"
	fi
	if test -d "$HOMEBREW_PREFIX/opt/icu4c/sbin"; then
		echo_var_add PATH "$HOMEBREW_PREFIX/opt/icu4c/sbin"
	fi

	# Sphinx (dependency of ruby)
	if test -d "$HOMEBREW_PREFIX/opt/sphinx-doc/bin"; then
		echo_var_add PATH "$HOMEBREW_PREFIX/opt/sphinx-doc/bin"
	fi

	# GetText (dependency of gpg)
	if test -d "$HOMEBREW_PREFIX/opt/gettext/bin"; then
		echo_var_add PATH "$HOMEBREW_PREFIX/opt/gettext/bin"
	fi

	# Ruby
	if test -n "${RUBY_VERSION-}" && test -d "$HOMEBREW_PREFIX/opt/ruby@$RUBY_VERSION/bin"; then
		p="$HOMEBREW_PREFIX/opt/ruby@$RUBY_VERSION"
		echo_var_add PATH "$p/bin"
		rubygems "$p/bin/gem"
	elif test -d "$HOMEBREW_PREFIX/opt/ruby/bin"; then
		p="$HOMEBREW_PREFIX/opt/ruby"
		echo_var_add PATH "$p/bin"
		rubygems "$p/bin/gem"
		# for compilers to find ruby
		if test -d "$p/lib"; then
			echo_var_add ' ' LDFLAGS "-L$p/lib"
		fi
		if test -d "$p/include"; then
			echo_var_add ' ' CPPFLAGS "-I$p/include"
		fi
		# for pkg-config to find ruby
		if test -d "$p/lib/pkgconfig"; then
			echo_var_add PKG_CONFIG_PATH "$p/lib/pkgconfig"
		fi
	else
		rubydirs="$(expand-path "$HOMEBREW_PREFIX/opt/ruby*/bin")"
		for rubydir in $rubydirs; do
			echo_var_add PATH "$rubydir"
			rubygems "$rubydir/gem"
		done
	fi

	# Node
	nodedirs="$(expand-path "$HOMEBREW_CELLAR/node/*/bin")"
	for nodedir in $nodedirs; do
		echo_var_add PATH "$nodedir"
	done

	# Python
	if test -d "$HOMEBREW_PREFIX/opt/python/libexec/bin"; then
		echo_var_add PATH "$HOMEBREW_PREFIX/opt/python/libexec/bin"
	fi

	# Python: Pip
	pipdirs="$(expand-path "$HOME/Library/Python/*/bin")"
	for pipdir in $pipdirs; do
		echo_var_add PATH "$pipdir"
	done

	# OpenSSL (dependency of python, gpg, and node)
	# openssl is a symlink to whatever directory has the latest version
	if test -d "$HOMEBREW_PREFIX/opt/openssl/bin"; then
		p="$HOMEBREW_PREFIX/opt/openssl"
		echo_var_add PATH "$p/bin"
		if test -d "$p/lib"; then
			echo_var_add ' ' LDFLAGS "-L$p/lib"
		fi
		if test -d "$p/include"; then
			echo_var_add ' ' CPPFLAGS "-I$p/include"
		fi
		if test -d "$p/lib/pkgconfig"; then
			echo_var_add PKG_CONFIG_PATH "$p/lib/pkgconfig"
		fi
		# ^^ setup-util-gocryptfs needs this on macos big sur
		# ```
		# Package libcrypto was not found in the pkg-config search path.
		# Perhaps you should add the directory containing `libcrypto.pc'
		# to the PKG_CONFIG_PATH environment variable
		# No package 'libcrypto' found
		# pkg-config: exit status 1
		# ```
		# and
		# ```
		# ld: library not found for -lcrypto
		# clang: error: linker command failed with exit code 1 (use -v to see invocation)
		# ````
	fi

	# NSS
	if test -d "$HOMEBREW_PREFIX/opt/nss/bin"; then
		echo_var_add PATH "$HOMEBREW_PREFIX/opt/nss/bin"
	fi

	# Anaconda
	if test -d "$HOMEBREW_PREFIX/anaconda3/bin"; then
		echo_var_add PATH "$HOMEBREW_PREFIX/anaconda3/bin"
	fi

	# Heroku
	if test -d "$HOMEBREW_PREFIX/heroku/bin"; then
		echo_var_add PATH "$HOMEBREW_PREFIX/heroku/bin"
	fi

else
	rubygems "$(which gem)"
fi

# NVM
if test -z "${NVM_DIR-}" -a -d "$HOME/.nvm"; then
	echo_and_eval_var_set NVM_DIR "$HOME/.nvm"
fi

# Python: pyenv
if test -z "${PYENV_ROOT-}" -a -d "$HOME/.pyenv"; then
	echo_and_eval_var_set PYENV_ROOT "$HOME/.pyenv"
fi
if test -n "${PYENV_ROOT-}"; then
	echo_var_add PATH "$PYENV_ROOT/bin"
	echo_var_add PATH "$PYENV_ROOT/shims"
fi

# Rust: rustup
if test -z "${RUSTUP_HOME-}" -a -d "$HOME/.rustup"; then
	echo_and_eval_var_set RUSTUP_HOME "$HOME/.rustup"
fi

# Rust: cargo
if test -z "${CARGO_HOME-}" -a -d "$HOME/.cargo"; then
	echo_and_eval_var_set CARGO_HOME "$HOME/.cargo"
fi
if test -n "${CARGO_HOME-}"; then
	mkdir -p "$CARGO_HOME"
	echo_var_add PATH "$CARGO_HOME/bin"
fi

# Rust: cargo target
# workaround for ubuntu server, which /tmp may often be read-only
# https://doc.rust-lang.org/stable/cargo/guide/build-cache.html
if test -z "${CARGO_TARGET_DIR-}" -a -d "$CARGO_HOME/target"; then
	echo_and_eval_var_set CARGO_TARGET_DIR "$CARGO_HOME/target"
fi
if test -n "${CARGO_TARGET_DIR-}"; then
	mkdir -p "$CARGO_TARGET_DIR"
fi

# Go
if test -z "${GO-}"; then
	if test -n "${HOMEBREW_PREFIX-}" -a -x "${HOMEBREW_PREFIX-}/bin/go"; then
		GO="$HOMEBREW_PREFIX/bin/go"
	else
		GO="$(first-executable /usr/local/bin/go /bin/go || :)"
	fi
fi
if test -n "${GO-}" -a -x "${GO-}"; then
	# root: where go is installed
	if test -z "${GOROOT-}"; then
		p="$(echo-or-fail $GO env GOROOT || first-path "${HOMEBREW_CELLAR:-"$HOME"}/go")"
		if test -d "$p/libexec"; then
			echo_and_eval_var_set GOROOT "$p/libexec"
		fi
	fi

	# path: where modules are installed
	if test -z "$GOPATH"; then
		p="$(echo-or-fail $GO env GOPATH || echo-mkdirp "$HOME/go")"
		echo_and_eval_var_set GOPATH "$GOPATH"
	fi

	# bin: where the execs are
	if test -z "$GOBIN"; then
		p="$(echo-or-fail go env GOBIN || echo-dir "$GOROOT/bin")"
		echo_and_eval_var_set GOBIN "$GOBIN"
	fi
	mkdir -p "$GOBIN"
	echo_var_add PATH "$GOBIN"
fi

# Clojurescript
if test -d "$HOME/.clojure/clojure-1.8"; then
	echo_var_add PATH "$HOME/.clojure/clojure-1.8.0"
	echo_var_add CLASSPATH "$HOME/.clojure/clojure-1.8.0"
fi

# Yarn
if test -z "${YARN-}"; then
	if test -n "${HOMEBREW_PREFIX-}" -a -x "${HOMEBREW_PREFIX-}/bin/yarn"; then
		YARN="$HOMEBREW_PREFIX/bin/yarn"
	else
		YARN="$(first-executable /usr/local/bin/yarn /bin/yarn || :)"
	fi
fi
if test -n "${YARN-}" -a -x "${YARN-}"; then
	echo_var_add PATH "$(yarn global bin)"
fi

# Flossbank
if test -d "$HOME/.flossbank/bin"; then
	echo_var_add PATH "$HOME/.flossbank/bin"
fi

# Generics: pip, pipx
# python get-pip.py --user
if test -d "$HOME/.local/bin"; then
	echo_var_add PATH "$HOME/.local/bin"
fi

# Geneics: Java
echo_var_add CLASSPATH "."

# Scripts
before_dorothy_paths
echo_var_add PATH "$DOROTHY/commands"
echo_var_add PATH "$DOROTHY_USER_HOME/commands"
echo_var_add PATH "$DOROTHY_USER_HOME/commands.local"
after_dorothy_paths

# Local
if test -d "$HOME/.bin"; then
	echo_var_add PATH "$HOME/.bin"
fi
if test -d "$HOME/bin"; then
	echo_var_add PATH "$HOME/bin"
fi

# Done
after_everything
