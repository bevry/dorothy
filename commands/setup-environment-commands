#!/usr/bin/env bash

# =====================================
# IMPORTANT NOTES

# Don't use `is-admin` here, as sudo does not necessarily load this, as such sudo should inherit standard config.

# Right to left is the preference for paths.

# =====================================
# Helpers

function __add_directory {
	local directory="$1" target="${2:-PATH}"
	if [[ -d $directory ]]; then
		directory="${directory// /\\ }"
		eval "$target=\"\$directory:\$$target\""
	fi
}

# PATH, LDFLAGS, CPPFLAGS, PKG_CONFIG_PATH
function __add_prefix_directory {
	local p="$1"
	if [[ -n $p && -d $p ]]; then
		# for invokers to discover it
		__add_directory "$p/bin" || return
		# for invokers under root to discover it
		if [[ $USER == 'root' ]]; then
			__add_directory "$p/sbin" || return
		fi
		# for compilers to discover it
		if [[ -d "$p/lib" ]]; then
			LDFLAGS="-L$p/lib $LDFLAGS"
			# for pkg-config to discover it
			__add_directory "$p/lib/pkgconfig" PKG_CONFIG_PATH || return
		fi
		if [[ -d "$p/include" ]]; then
			CPPFLAGS="-I$p/include $CPPFLAGS"
		fi
		# man and share/man
		__add_directory "$p/man" MANPATH || return
		__add_directory "$p/share/man" MANPATH || return
		__add_directory "$p/share/info" INFOPATH || return
	fi
}

# add ruby gems
function __add_ruby_gem {
	local gem="$1"
	export GEM_HOME="$HOME/.gem"
	if [[ -x $gem ]]; then
		# fetch gempaths and replace colons with newlines
		local gemdirs=() gemdir
		__split --target={gemdirs} --no-zero-length --delimiters=':' --invoke -- \
			"$gem" environment gempath || :
		for gemdir in "${gemdirs[@]}"; do
			PATH="$gemdir/bin:$PATH"
		done
	fi
}

function __cut {
	# turn `<hash>  <path>` into `<hash>`
	# cut -f1 -d ' '
	local checksum
	IFS=' ' read -r checksum _
	__print_lines "$checksum"
}

# =====================================
# Requisites

# DOROTHY for sourcing
export DOROTHY
if [[ -z ${DOROTHY-} ]]; then
	self="${BASH_SOURCE:-"$0"}"
	DOROTHY="${self%/commands/setup-environment-commands*}"
fi

# sources
source "$DOROTHY/sources/bash.bash"
source "$DOROTHY/sources/config.sh"

# help
function help {
	__print_help "$@" <<-EOF || return
		ABOUT:
		Outputs commands to be evaluated by the caller to setup the environment for a given shell.

		USAGE:
		\`setup-environment-commands [...options] --shell=<shell>\`

		OPTIONS:
		--shell=<shell> | <shell>
		    The shell to export the environment for.

		--debug
		    If provided, output decisions and their context to STDERR.

		--blank
		    If provided, don't load any environment variables, useful for debugging and demonstration.

		--invalidate
		    If provided, invalidate the cache, if there is one.
	EOF
	return 22 # EINVAL 22 Invalid argument
}

# arguments
option_shell='' # shared by env.bash, as it is handled by a trap, we cannot pass arguments to it. SHELL is taken, it is the login shell
option_debug='no'
option_blank='no'
option_invalidate='no'
while [[ $# -ne 0 ]]; do
	item="$1"
	shift
	case "$item" in
	--help) help ;;
	--shell=*) option_shell="${item#*=}" ;;
	--ppid=*) : ;; # ignore for now, for future cache invalidation idea
	--no-debug* | --debug*) __flag --source={item} --target={option_debug} --affirmative || exit ;;
	--no-blank* | --blank*) __flag --source={item} --target={option_blank} --affirmative || exit ;;
	--no-invalidate* | --invalidate*) __flag --source={item} --target={option_invalidate} --affirmative || exit ;;
	--no-fresh* | --fresh* | --no-refresh* | --refresh*)
		__flag --source+target={item} --affirmative || exit
		if [[ $item == 'yes' ]]; then
			option_blank='yes'
			option_invalidate='yes'
		fi
		;;
	--*) __unrecognised_flag "$item" || exit ;;
	*) __unrecognised_argument "$item" || exit ;;
	esac
done
if [[ $option_debug == 'yes' ]]; then
	# trunk-ignore(shellcheck/SC2034)
	DOROTHY_DEBUG='yes'
	__dump --debug {option_shell} {option_debug} {option_blank} {option_invalidate}
fi
if [[ $option_blank == 'yes' ]]; then
	env -i DOROTHY="$DOROTHY" \
		"$DOROTHY/commands/setup-environment-commands" \
		--shell="$option_shell" \
		--debug="$option_debug" \
		--invalidate="$option_invalidate"
	# don't send blank because then it will recurse forever
	exit 0
fi
if [[ -z $option_shell ]]; then
	help 'Missing required argument: --shell=<shell>'
fi

# caching, depends on options
CACHE_LOCK_FILE=''
CACHE_RESULT_FILE=''
function __cache {
	# cache the environment setup commands
	local cache_dir="$TMPDIR/dorothy/setup-environment-commands"
	if [[ $option_invalidate == 'yes' ]]; then
		__dump --debug --value='== CACHE INVALIDATED ==' {cache_dir}
		rm -rf "$cache_dir" || :
	fi
	local option_validity_seconds='' option_checksum_command=()
	while [[ $# -ne 0 ]]; do
		item="$1"
		shift
		case "$item" in
		'--validity-seconds='*) option_validity_seconds="${item#*=}" ;;
		'--')
			option_checksum_command+=("$@")
			shift "$#"
			break
			;;
		*)
			__print_lines "ERROR: Unrecognised __cache argument: $item" >&2
			return 22 # EINVAL 22 Invalid argument
			;;
		esac
	done
	if [[ -z $option_validity_seconds ]]; then
		# default to thirty minutes
		option_validity_seconds=1800 # 600
	fi
	if [[ ${#option_checksum_command[@]} -eq 0 ]]; then
		option_checksum_command+=(openssl dgst -md5 -r)
	fi
	if __command_missing -- "${option_checksum_command[0]}"; then
		__print_lines "ERROR: To use __cache you must specify a checksum command that exists and is executable, unlike: ${option_checksum_command[0]}" >&2
		return 22 # EINVAL 22 Invalid argument
	fi
	local now_env context_id checksum
	now_env="$(env -u TERM_SESSION_ID | sort)" || return
	checksum="$("${option_checksum_command[@]}" <<<"$now_env" | __cut)" || return
	context_id="setup-environment-commands.$option_shell.$checksum"
	# get an exclusive lock on the context
	CACHE_LOCK_FILE="$(__get_semlock "$context_id")" || return
	# get the result cache of the context
	CACHE_RESULT_FILE="$cache_dir/$context_id"
	# if cache is available and applicable
	if [[ -f $CACHE_RESULT_FILE ]]; then
		local now_seconds cache_seconds cache_ago_seconds
		# if cache is still valid
		# local now_seconds cache_seconds cache_ago_seconds
		now_seconds="$(__get_epoch_seconds)" || return
		cache_seconds="$(date -r "$CACHE_RESULT_FILE" +%s)" || return
		cache_ago_seconds="$((now_seconds - cache_seconds))"
		if [[ $cache_ago_seconds -lt $option_validity_seconds ]]; then
			# then use the cache
			__dump --debug --value='== CACHE HIT ==' {CACHE_RESULT_FILE}
			cat -- "$CACHE_RESULT_FILE" || return
			rm -f -- "$CACHE_LOCK_FILE" || return
			trap - EXIT # disable the `env.bash` trap
			exit 0      # must be exit, otherwise `setup-environment-commands` will continue
		else
			__dump --debug --value='== CACHE EXPIRED ==' {CACHE_RESULT_FILE}
			:
		fi
	else
		__dump --debug --value='== CACHE 404 ==' {CACHE_RESULT_FILE}
		__mkdirp "$cache_dir" || return
		:
	fi
	# cache needs updating
	function __on_env_finish__cache {
		local -i status=$?
		trap - EXIT # disable our cache trap override
		if [[ $status -ne 0 ]]; then
			rm -f -- "$CACHE_LOCK_FILE"
			return "$status"
		fi
		# store the result
		__dump --debug --value='== CACHE UPDATING ==' {CACHE_RESULT_FILE}
		__on_env_finish | tee -- "$CACHE_RESULT_FILE" || __return $? -- rm -f -- "$CACHE_LOCK_FILE" || return
		rm -f -- "$CACHE_LOCK_FILE" || return
		return 0
	}
	trap __on_env_finish__cache EXIT # replace our prior trap with one that caches the result
}

# load env.bash now, so that
# any exported variables changed from now on are echo'd at finish
source "$DOROTHY/sources/env.bash"

# =====================================
# Requisites

# PATH vars contain multiple paths
# _DIR vars contain a single universal path
# _HOME vars contain a single user path

# ensure editor vars are exported
export LANG LC_ALL EDITOR

# Essentials, required for these environments
# crontab
# env -i "$(type -P bash)" -l -- $(type -P 'dorothy-command')
# Fresh install of Dorothy on Ubuntu 21.04 on a Raspberry Pi 400
if [[ -z ${USER-} ]]; then
	__prepare_current_user
	export USER
	USER="$CURRENT_USER"
fi
if [[ -z ${HOME-} ]]; then
	export HOME
	# should coincide with [eval-helper --elevate]
	if [[ -d /Users ]]; then
		HOME="/Users/$USER"
	elif [[ -d "/home/$USER" ]]; then
		HOME="/home/$USER"
	elif [[ -d "/$USER" ]]; then
		HOME="/$USER"
	else
		HOME="$(mktemp -d)"
	fi
fi

# =====================================
# More Requisites
# While these seem optional, if the environment is entirely cleared, which can happen under cron, these are still essential

# Local directories
# https://refspecs.linuxfoundation.org/FHS_3.0/fhs/ch04s09.html
# always override for now, as it is seems unlikely that these will ever change, so allowing override is not necessary
export \
	BIN_DIR='/usr/local/bin' \
	CONF_DIR='/usr/local/etc' \
	DATA_DIR='/usr/local/share' \
	LIB_DIR='/usr/local/lib' \
	STATE_DIR='/var/local/state' \
	SERVICE_DIR LOGS_DIR # set later

# XDG
# https://wiki.archlinux.org/title/XDG_Base_Directory
# https://specifications.freedesktop.org/basedir-spec/basedir-spec-latest.html
# XDG_RUNTIME_DIR is a special directory and variable created by the system
export XDG_PREFIX="${XDG_PREFIX:-"$HOME/.local"}"
export \
	XDG_CONFIG_HOME="${XDG_CONFIG_HOME:-"$HOME/.config"}" \
	XDG_CACHE_HOME="${XDG_CACHE_HOME:-"$HOME/.cache"}" \
	XDG_BIN_HOME="${XDG_BIN_HOME:-"$XDG_PREFIX/bin"}" \
	XDG_DATA_HOME="${XDG_DATA_HOME:-"$XDG_PREFIX/share"}" \
	XDG_STATE_HOME="${XDG_STATE_HOME:-"$XDG_PREFIX/state"}"
# ^ if these are already defined, not to worry, `env.bash` will tidy up duplicates
__mkdirp "$XDG_CONFIG_HOME" "$XDG_CACHE_HOME" "$XDG_BIN_HOME" "$XDG_DATA_HOME" "$XDG_STATE_HOME"

# reset paths and flags
# $PATH last to make sure we inherit operating-system specific paths, such as WSL paths, and let the deduplicator later trim out duplicates in preferred order
export \
	PATH="$DOROTHY/commands:$XDG_BIN_HOME:/usr/sbin:/usr/bin:/sbin:/bin:$PATH" \
	MANPATH="${MANPATH-}" \
	INFOPATH="${INFOPATH-}" \
	CLASSPATH="${CLASSPATH-}" \
	PKG_CONFIG_PATH="${PKG_CONFIG_PATH-}" \
	LDFLAGS="${LDFLAGS-}" \
	CPPFLAGS="${CPPFLAGS-}" \
	CC CXX \
	LIBRARY_PATH="${LIBRARY_PATH-}"

# theme and terminal essentials
export TERM_PROGRAM="${TERM_PROGRAM-}" THEME COLOR
THEME="$(get-terminal-theme || :)"
COLOR="$(get-terminal-color-support --fallback=yes)"

# helpful local vars
p=''

# =====================================
# Configuration

# prepare hooks, and load user overrides
function before_dorothy_paths { :; }
function after_dorothy_paths { :; }
function after_everything { :; }
load_dorothy_config 'environment.bash'
# environment.bash provides:
# NVM_DIR, HOMEBREW_ARCH, PYENV_VERSION, RUBY_VERSION
# and other overrides

# =====================================
# Environment

# Should we prefer XDG?
export PREFER_XDG
if [[ $DOROTHY == "$HOME/.dorothy" ]]; then
	PREFER_XDG='no'
else
	PREFER_XDG='yes'
fi

# XDG compiled properties
export XDG_DATA_DIRS="${XDG_DATA_DIRS:-"$XDG_DATA_HOME:/usr/local/share:/usr/share"}"
export XDG_CONFIG_DIRS="${XDG_CONFIG_DIRS:-"$XDG_CONFIG_HOME:/etc/xdg"}"

# Flatpak adjustments
__add_directory '/var/lib/flatpak/exports/share' XDG_DATA_DIRS
__add_directory "$XDG_DATA_HOME/flatpak/exports/share" XDG_DATA_DIRS

# Appimage
export APPIMAGE_HOME="${APPIMAGE_HOME:-"$HOME/Applications"}"

# Homebrew, UNIX
__add_prefix_directory /usr
__add_prefix_directory /usr/local

# Zsh
# https://zsh.sourceforge.io/Intro/intro_3.html
export ZDOTDIR
if [[ -z ${ZDOTDIR-} ]]; then
	if [[ $PREFER_XDG == 'yes' ]]; then
		ZDOTDIR="$XDG_CONFIG_HOME/zsh"
	elif [[ $PREFER_XDG == 'no' ]]; then
		ZDOTDIR="$HOME"
	fi
fi

# GnuPG
export GNUPGHOME
if [[ -z ${GNUPGHOME-} ]]; then
	# check for existing
	if [[ -d "$XDG_DATA_HOME/gnupg" ]]; then
		GNUPGHOME="$XDG_DATA_HOME/gnupg"
	elif [[ -d "$HOME/.gnupg" ]]; then
		GNUPGHOME="$HOME/.gnupg"
	else
		# none existing, seed preference
		if [[ $PREFER_XDG == 'yes' ]]; then
			GNUPGHOME="$XDG_DATA_HOME/gnupg"
		else
			GNUPGHOME="$HOME/.gnupg"
		fi
	fi
fi

# Xcode
# if [[ -x '/usr/bin/xcode-select' && -x '/usr/bin/xcrun' ]]; then
if __command_exists -- 'xcode-select' 'xcrun'; then
	# Apple Command Line Tools
	__add_prefix_directory '/Library/Developer/CommandLineTools/usr'

	# Xcode Command Line Tools
	#p='/Applications/Xcode.app/Contents/Developer'
	p="$(xcode-select --print-path 2>/dev/null || :)"
	__add_prefix_directory "$p/usr"

	# Xcode Toolchain
	p="$p/Toolchains/XcodeDefault.xctoolchain"
	__add_prefix_directory "$p/usr"
	if [[ -d "$p/usr/bin" ]]; then
		#CC="$p/usr/bin/clang"
		#CXX="$p/usr/bin/clang++"
		CC="$(xcrun --find clang 2>/dev/null || :)"
		CXX="$(xcrun --find clang++ 2>/dev/null || :)"
	fi

	# Xcode LLVM
	# /Library/Developer/CommandLineTools/SDKs/MacOSX.sdk => $p/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk => xcrun --sdk macosx --show-sdk-path
	#p='/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk'
	p="$(xcrun --sdk macosx --show-sdk-path 2>/dev/null || :)"
	__add_prefix_directory "$p/usr"
	if [[ -d "$p/usr/lib" ]]; then
		LIBRARY_PATH="$p/usr/lib:$LIBRARY_PATH"
	fi
	if [[ -d "$p/System/Library/Frameworks" ]]; then
		# https://stackoverflow.com/a/68766210
		LDFLAGS="-F$p/System/Library/Frameworks/ $LDFLAGS"
	fi
fi

# Snap
__add_directory '/snap/bin'

# Windows WSL
# Most of these are handled by inheriting PATH, however VSCode integrated terminal does not inherit WSL's PATH:
# /usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/usr/lib/wsl/lib:/mnt/c/Program Files (x86)/Intel/iCLS Client/:/mnt/c/Program Files/Intel/iCLS Client/:/mnt/c/Windows/system32:/mnt/c/Windows:/mnt/c/Windows/System32/Wbem:/mnt/c/Windows/System32/WindowsPowerShell/v1.0/:/mnt/c/Windows/System32/OpenSSH/:/mnt/c/Program Files/Cloudflare/Cloudflare WARP/:/mnt/c/Users/balup/scoop/shims:/mnt/c/Users/balup/AppData/Local/Microsoft/WindowsApps:/mnt/c/Users/balup/AppData/Local/Programs/Microsoft VS Code/bin:/snap/bin
if is-wsl; then # @ todo is-wsl or is-windows is better?
	wsl_dirs=()
	for wsl_mount in /mnt/*/; do
		# skip mounts that aren't single space [/mnt/c/ = 7], skip mounts already in path
		if [[ ${#wsl_mount} -ne 7 || $PATH == *"$wsl_mount"* ]]; then
			continue
		fi
		for wsl_user in "${wsl_mount}Users/"*/; do
			wsl_dirs+=(
				"${wsl_user}AppData/LocalPrograms/Microsoft VS Code/bin"
				"${wsl_user}AppData/Local/Microsoft/WindowsApps"
				"${wsl_user}scoop/shims" # where [scoop] is installed to, and where the .exe's of scoop packages are installed to
			)
		done
		wsl_dirs+=(
			"${wsl_mount}Windows/System32/OpenSSH/"
			"${wsl_mount}Windows/System32/WindowsPowerShell/v1.0/"
			"${wsl_mount}Windows/System32/Wbem"
			"${wsl_mount}Windows"
			"${wsl_mount}Windows/system32"
		)
	done
	for wsl_dir in "${wsl_dirs[@]}"; do
		__add_directory "$wsl_dir"
	done
fi

# Homebrew, UNIX
__add_prefix_directory /user/local

# macOS
if is-mac; then
	SERVICE_DIR='/Library/LaunchDaemons'
	LOGS_DIR='/var/log'
	# Homebrew
	export HOMEBREW_ARCH HOMEBREW_PREFIX HOMEBREW_CELLAR HOMEBREW_REPOSITORY HOMEBREW_SHELLENV_PREFIX HOMEBREW_NO_AUTO_UPDATE=1 HOMEBREW_NO_ENV_HINTS=1
	if [[ -z ${HOMEBREW_ARCH-} ]]; then
		if [[ "$(uname -p || :)" == 'arm' || "$(uname -m || :)" == 'arm64' ]]; then
			HOMEBREW_ARCH='arm64e'
		else
			HOMEBREW_ARCH='x86_64'
		fi
	fi
	if [[ -z ${HOMEBREW_PREFIX-} ]]; then
		if [[ $HOMEBREW_ARCH == 'arm64e' ]]; then
			HOMEBREW_PREFIX='/opt/homebrew'
		else
			HOMEBREW_PREFIX='/usr/local'
		fi
	fi
	if [[ -z ${HOMEBREW_CELLAR-} ]]; then
		if [[ -x "${HOMEBREW_PREFIX}/bin/brew" ]]; then
			HOMEBREW_CELLAR="$("${HOMEBREW_PREFIX}/bin/brew" --cellar)"
		else
			HOMEBREW_CELLAR="$HOMEBREW_PREFIX/Cellar"
		fi
	fi
	if [[ -z ${HOMEBREW_REPOSITORY-} ]]; then
		if [[ -x "${HOMEBREW_PREFIX}/bin/brew" ]]; then
			HOMEBREW_REPOSITORY="$("${HOMEBREW_PREFIX}/bin/brew" --repo)"
		else
			HOMEBREW_REPOSITORY="$HOMEBREW_PREFIX"
		fi
	fi
	if [[ -z ${HOMEBREW_SHELLENV_PREFIX-} ]]; then
		HOMEBREW_SHELLENV_PREFIX="$HOMEBREW_PREFIX"
	fi
elif is-linux; then
	# Linux
	SERVICE_DIR='/etc/systemd/system'
	LOGS_DIR='/var/log'
	# Homebrew
	# https://docs.brew.sh/Homebrew-on-Linux
	export HOMEBREW_PREFIX="${HOMEBREW_PREFIX:-"$HOME/.linuxbrew"}" HOMEBREW_NO_ENV_HINTS=1
fi

# if homebrew is installed, then add its paths
if [[ -n ${HOMEBREW_PREFIX-} && -x "${HOMEBREW_PREFIX-}/bin/brew" ]]; then
	# /usr/local already added to PATH, so only add these if different
	if [[ $HOMEBREW_PREFIX != '/usr/local' ]]; then
		__add_directory "$HOMEBREW_PREFIX/bin"
		__add_directory "$HOMEBREW_PREFIX/sbin"
	fi

	# add the rest
	__add_directory "$HOMEBREW_PREFIX/share/man" MANPATH
	__add_directory "$HOMEBREW_PREFIX/share/info" INFOPATH

	# for compilers to find llvm
	if [[ $HOMEBREW_PREFIX != '/user/local' ]]; then
		__add_prefix_directory "$HOMEBREW_PREFIX"
	fi

	# llvm
	__add_prefix_directory "$HOMEBREW_PREFIX/opt/llvm"

	# SQLite (dependency of python)
	__add_prefix_directory "$HOMEBREW_PREFIX/opt/sqlite"

	# guile (dependency of something)
	if [[ -d "$HOMEBREW_PREFIX/share/guile" ]]; then
		export GUILE_LOAD_PATH="$HOMEBREW_PREFIX/share/guile/site/3.0"
		export GUILE_LOAD_COMPILED_PATH="$HOMEBREW_PREFIX/lib/guile/3.0/site-ccache"
		export GUILE_SYSTEM_EXTENSIONS_PATH="$HOMEBREW_PREFIX/lib/guile/3.0/extensions"
	fi

	# icu4c (dependency of heroku)
	__add_directory "$HOMEBREW_PREFIX/opt/icu4c/bin"
	__add_directory "$HOMEBREW_PREFIX/opt/icu4c/sbin"

	# Sphinx (dependency of ruby)
	__add_directory "$HOMEBREW_PREFIX/opt/sphinx-doc/bin"

	# GetText (dependency of gpg)
	__add_directory "$HOMEBREW_PREFIX/opt/gettext/bin"

	# Ruby
	if [[ -n ${HOMEBREW_RUBY_VERSION-} ]]; then
		p=''
		if [[ $HOMEBREW_RUBY_VERSION == 'default' ]]; then
			p="$HOMEBREW_PREFIX/opt/ruby"
			if [[ ! -d $p ]]; then
				p=''
			fi
		else
			p="$HOMEBREW_PREFIX/opt/ruby@$HOMEBREW_RUBY_VERSION"
			if [[ ! -d $p ]]; then
				__print_lines "# specified [HOMEBREW_RUBY_VERSION = $HOMEBREW_RUBY_VERSION] was not found at $p" >&2
				p=''
			fi
		fi
		if [[ -n $p ]]; then
			__add_prefix_directory "$p"
		fi
	else
		# add them all, excluding special paths
		rubydirs=("$HOMEBREW_PREFIX/opt/ruby"*'/bin')
		for rubydir in "${rubydirs[@]}"; do
			PATH="$rubydir:$PATH"
			__add_ruby_gem "$rubydir/gem"
		done
	fi

	# Node
	nodedirs=("$HOMEBREW_CELLAR/node/"*'/bin')
	for nodedir in "${nodedirs[@]}"; do
		PATH="$nodedir:$PATH"
	done

	# Python
	# There use to be some very complex logic here to handle `python`, `pip`, and `pipx`
	# However it was all dropped as `uv` is superior, and handles it all, and uses XDG as do we, so no need for `uv python update-shell -q`

	# OpenSSL (dependency of python, gpg, and node)
	# openssl is a symlink to whatever directory has the latest version
	__add_prefix_directory "$HOMEBREW_PREFIX/opt/openssl"
	# ^^ setup-util-gocryptfs needs this on macos big sur
	# ```
	# Package libcrypto was not found in the pkg-config search path.
	# Perhaps you should add the directory containing `libcrypto.pc'
	# to the PKG_CONFIG_PATH environment variable
	# No package 'libcrypto' found
	# pkg-config: exit status 1
	# ```
	# and
	# ```
	# ld: library not found for -lcrypto
	# clang: error: linker command failed with exit code 1 (use -v to see invocation)
	# ````

	# NSS
	__add_directory "$HOMEBREW_PREFIX/opt/nss/bin"

	# Anaconda
	__add_directory "$HOMEBREW_PREFIX/anaconda3/bin"

	# Heroku
	__add_directory "$HOMEBREW_PREFIX/heroku/bin"

	# Package Config
	# This was not recommended anywhere, but it seems logical as a way to have pkg-config bootstrapped with its default paths, of which it includes a lot more available configs than manually doing everything as we have done above
	if [[ -x "$HOMEBREW_PREFIX/bin/pkg-config" ]]; then
		PKG_CONFIG_PATH="$(pkg-config --variable pc_path pkg-config):$PKG_CONFIG_PATH"
	fi
else

	# linux
	# don't use [which] as we haven't finished setting up paths
	# and [which] writes its errors to stdout!

	# Ruby
	__add_ruby_gem /usr/bin/gem
fi

# Deno for official yet stupid deno_install script, commented out as [setup-util-deno] is superior
# if [[ -z "${DENO_INSTALL-}" && -d "$HOME/.deno" ]]; then
# 	export DENO_INSTALL="$HOME/.deno"
# fi
# if [[ -n "${DENO_INSTALL-}" ]]; then
# 	PATH="$DENO_INSTALL/bin:$PATH"
# fi

# NVM, only set if applicable
if [[ -z ${NVM_DIR-} && -d "$HOME/.nvm" ]]; then
	export NVM_DIR="$HOME/.nvm"
fi

# Rust: rustup
if [[ -z ${RUSTUP_HOME-} && -d "$HOME/.rustup" ]]; then
	export RUSTUP_HOME="$HOME/.rustup"
fi

# Rust: cargo
if [[ -z ${CARGO_HOME-} && -d "$HOME/.cargo" ]]; then
	export CARGO_HOME="$HOME/.cargo"
fi
if [[ -n ${CARGO_HOME-} ]]; then
	__mkdirp "$CARGO_HOME"
	PATH="$CARGO_HOME/bin:$PATH"

	# Rust: cargo target
	# workaround for ubuntu server, which /tmp may often be read-only
	# https://doc.rust-lang.org/stable/cargo/guide/build-cache.html
	export CARGO_TARGET_DIR
	__mkdirp "${CARGO_TARGET_DIR:="$CARGO_HOME/target"}"
fi

# Go
# https://pkg.go.dev/cmd/go#hdr-Environment_variables
# only define GOPATH, defining GOROOT and GOBIN cause too many errors on linux
# such as incorrect "is not in GOROOT" errors
# NOTE that go path is not where go is located, but where go packages will be installed
if __command_exists -- go; then
	export GOPATH
	# detect GOPATH if not defined
	if [[ -z ${GOPATH-} ]]; then
		# fetch the go bin paths
		if [[ -n ${HOMEBREW_CELLAR-} ]]; then
			# mac
			gopaths=("$HOMEBREW_CELLAR/go/"*)
			for gopath in "${gopaths[@]}"; do
				GOPATH="$gopath"
				break # only do the first
			done
		elif [[ $PREFER_XDG == 'yes' ]]; then
			# linux
			# prefer xdg, but support not xdg if it is there
			if [[ -d "$XDG_DATA_HOME/go" ]]; then
				GOPATH="$XDG_DATA_HOME/go"
			elif [[ -d "$HOME/go" ]]; then
				GOPATH="$HOME/go"
			else
				GOPATH="$XDG_DATA_HOME/go"
			fi
		else
			# linux
			# prefer not xdg, but support xdg if it is there
			if [[ -d "$HOME/go" ]]; then
				GOPATH="$HOME/go"
			elif [[ -d "$XDG_DATA_HOME/go" ]]; then
				GOPATH="$XDG_DATA_HOME/go"
			else
				GOPATH="$HOME/go"
			fi
		fi
	fi
	# if we were able to find one
	if [[ -n ${GOPATH-} ]]; then
		# then create its parts and add it to PATH
		__mkdirp "$GOPATH/bin" "$GOPATH/libexec"
		PATH="$GOPATH/bin:$PATH"
	fi
fi

# Yarn
if __command_exists -- yarn; then
	# on CI, yarn exists, yet this can return nothing
	p="$(yarn global bin 2>/dev/null || :)"
	if [[ -n $p ]]; then
		PATH="$p:$PATH"
	fi
fi

# Flossbank
__add_directory "$HOME/.flossbank/bin"

# 1Password, exposes op-ssh-sign
__add_directory '/Applications/1Password.app/Contents/MacOS'

# Generics: Java
CLASSPATH=".:$CLASSPATH"

# Generics: pre-XDG user bin paths (note the user should be preferring XDG_BIN_HOME)
__add_directory "$HOME/.bin"
__add_directory "$HOME/bin"

# Generics: when XDG_BIN_HOME is customised, ensure the default XDG_BIN_HOME is still added, for anything that expects it
if [[ $XDG_BIN_HOME != "$HOME/.local/bin" ]]; then
	PATH="$HOME/.local/bin:$PATH"
fi
# Generics: XDG, always add, even if not existent, in case it is created later
PATH="$XDG_BIN_HOME:$PATH"
__add_prefix_directory "$XDG_PREFIX" # only adds directories that exist

# GO LLVM
# https://stackoverflow.com/a/58488820
if [[ -n ${GOPATH-} ]]; then
	export CGO_CPPFLAGS CGO_LDFLAGS
	CGO_CPPFLAGS="$CPPFLAGS -O2 -g -Wno-nullability-completeness"
	CGO_LDFLAGS="$LDFLAGS -O2 -g"
fi

# Scripts
before_dorothy_paths
PATH="$DOROTHY/commands:$PATH"
PATH="$DOROTHY/commands.beta:$PATH"
PATH="$DOROTHY/commands.deprecated:$PATH"
PATH="$DOROTHY/user/commands:$PATH"
PATH="$DOROTHY/user/commands.local:$PATH"
after_dorothy_paths

# =====================================
# Finish

# Load the last user hook, to complete the environment configuration
after_everything

# =====================================
# Editor

# Now that the environment is configured, we can now configure the editor, as it is possible to be detected now that paths are setup.

# C = default locale, necessary for CI
# LC_ALL (LC_ALL also implies LC_COLLATE, LC_CTYPE, LC_MONETARY, LC_NUMERIC, LC_TIME)
if [[ -z ${LANG-} ]]; then
	LANG='C'
fi
if [[ -z ${LC_ALL-} ]]; then
	# fix on ssh into macos: warning: setlocale: LC_ALL: cannot change locale (C.UTF-8): No such file or directory
	# https://stackoverflow.com/questions/49778200/bash-warning-setlocale-lc-all-cannot-change-locale-en-us-utf-8#comment132342818_51361013
	if __command_missing -- locale || locale -a | grep --quiet --fixed-strings --regexp="$LANG"; then
		LC_ALL="$LANG"
	fi
fi

# EDITOR, SUDO_EDITOR doesn't do anything so ignore
if [[ -z ${EDITOR-} ]]; then
	# Always use terminal editor for prompts as GUI editors are too slow.
	EDITOR="$(edit --dry --no-prompt --terminal || :)"
fi

# =====================================
# Finale

# trunk-ignore(shellcheck/SC2034)
DOROTHY_ENVIRONMENT='yes'
