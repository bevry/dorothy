#!/usr/bin/env bash

# TODO: Fix support for:
# - codeberg
# - sourcehut
# - gitlab
# - <any> ?? Can I make it so that this process is automated??

# TODO: - drop single /  subset -> fzf/choose

# TODO: look at tmux-continuum AND resurrect. > setup job backup at intervals

function repo_manager() (
	source "$DOROTHY/sources/bash.bash"

	# =====================================
	# Arguments

	function help {
		__print_help "$@" <<-EOF || return
			ABOUT:
			Helper that manages local code repos, worktrees, etc.
			New repos are cloned to or created at \`\$DOROTHY_LOCAL_CODE_DIR/repos/<host>/<user>/<name.\`

			USAGE:
			\`repo-manager [...options] <action> [--] [...args]\`


			!!! These two would require modifications to args processing !!!
			\`repo-manager <repo>\`
			Query if repo is managed.
			\`repo-manager <repo> <destination>\`
			Query if repo is managed. If true, then symlink the repo to location, and restore repo if it is not already cloned out.

			OPTIONS:
			None.

			ACTIONS:
			clone <repo>
			    Clone a directory
			new|create
			    Creates a new repo. Currently, \`gh\` will create a remote with --private
			remove
			    TODO: Needs fix!!
			list
			    Outputs all local repos to stdout on the form:
			    \`<host> <user> <name>\`
			backup [...arguments]
			    Ensure that (a) local repo(s) are backed up under \`\$DOROTHY/user/backups/repo_manager_cloned_repos.bak\` with extra information added, such as remotes for fetching/pulling. Default: prompt user to select which repos to restore.
			    --all
			        Force backup all repos. Mainly used for testing purposes.
			    <host> <user> <name>
			        If provided, add new entry to backup.
			restore [...arguments]
			    Clone out selected repos from backup with fetch and push remotes, etc. included.
			sync
				You pass a slug, or host/slug explicitly, and RM will try to ensure that repo
				is pulled down and linked to your desired destination.
			fork <repo>
			    Same as clone but creating a fork and syncing it to server/remote.
			fork --user|--user-config
				Make the fork cloned under your user account, and rename to <name>-config
				if it is a utility user config.
			is-cloned <repo>
			    Check if <repo> exists and print the backupline.
			is-tracked <repo>
			    Check if <repo> exists in database.
			nvim-plugin
			    Create a new repo that is an nvim plugin. NOTE: Since this is a rather niche use case and it is a composition of atomic actions, maybe this should be exported from user or at least be defined in somekind of hook or override.

			NOTE:
			<repo>s can be in the form of either SSH or HTTPS string, or on the form of \`<host>/<user>/<name>\`

			QUIRKS:
			For <repo> inputs, if you only specify a single name without forward slashes, then repo-manager will assume that you are targeting a user repository, ie <host>/<current_user>/<name.
		EOF
		return 22 # EINVAL 22 Invalid argument
	}

	# process
	local item action='' option_test_mode='no' option_args=() # option_quiet='no'
	while test "$#" -ne 0; do
		item="$1"
		shift
		case "$item" in
		--help | -h) help ;;
		--test-mode) option_test_mode='yes' ;;
		--override-test) action='override_test' ;;
		'--')
			option_args+=("$@")
			shift "$#"
			break
			;;
		'--'*)
			if [[ -z $action ]]; then
				help 'An unrecognised global flag argument was provided: ' --variable-value={item}
			else
				option_args+=("$item") # forward to action
			fi
			;;
		*)
			if [[ -z $action ]]; then
				action="$item"
			else
				option_args+=("$item")
			fi
			;;
		esac
	done

	# check
	if [[ -z $action ]]; then
		action="testing"
		# help 'No ' --code='<action>' ' was provided.'
	fi

	# ======================
	# Configuration

	local repo_block_description="[[<host>/]<user>/]<name>"

	local repo_block_regex='^((([A-Za-z0-9.-]+)/)?([A-Za-z0-9_-]+)/)?([A-Za-z0-9_.-]+)$'

	if [[ "$option_test_mode" == 'no' ]]; then
		# Use this instead of `ghq root` and just append /repos or /worktrees
		local REPO_MANAGER_DIR="${DOROTHY_LOCAL_CODE_DIR:-"$HOME/.local/code"}"
		local REPOS_DIR="$REPO_MANAGER_DIR/repos"
		local WORKTREES_DIR="$REPO_MANAGER_DIR/worktrees"
		local DOROTHY_USER_BACKUP_DIR="$DOROTHY/user/backups"
		local REPO_MANAGER_BACKUP_FILE="$DOROTHY_USER_BACKUP_DIR/repo_manager_cloned_repos.bak"
		local PERSONAL_USER_ACCOUNT
		local GIT_PROTOCOL="ssh"

	else
		# TODO: configure test mode
		:
	fi

	PERSONAL_USER_ACCOUNT=$(git config github.user)

	local supported_hosts=(
		"github.com"
		# gitlab.com
	)

	# =====================================
	# Helpers

	# this has been moved to its own command?
	load_locate() {
		# https://egeek.me/2020/04/18/enabling-locate-on-osx/
		gupdatedb --localpaths=$HOME --prunepaths=/Volumes --output=$HOME/locatedb
	}

	function __ensure_user_dir_exists() {
		if [[ ! -d ${1-} ]]; then
			mkdir -p "$1" || return
		fi
	}

	# Input: <host> <user> <name>
	# Output: ```
	#   <host>/<repo>/<name> REMOTES:<name>|<url>|<type>;...;...
	# ```
	function __format_backup_line() {
		local repo_block="" remotes_block="REMOTES:"

		IFS=/ repo_block="${*}"

		# __print_lines "repo_block: $repo_block" >/dev/tty

		# Capture git remotes
		# Take output from git remotes -v and then format it with awk
		local remote
		while IFS= read -r remote; do
			remotes_block+="$remote;"
		done < <(git -C "$REPO_MANAGER_DIR/repos/$1/$2/$3" remote -v | awk '{gsub(/[()]/,"",$3); print $1 "|" $2 "|" $3}')

		# Each block is separated with whitespace.
		__print_lines "$repo_block $remotes_block"
	}

	# get host, user, and repo from a repo url.
	# This function is a bit hacky.
	#
	# Supported formats are SSH and HTTPS
	#
	# TODO: Currently this func only works on url. merge this with the logic
	# for repositioning host/user/name from a repo block.
	#
	function __get_parts_from_input_repo_id() {

		# TODO: option --url-only ?? explicitly prevent and inform user.

		local input_id="$1"

		local host user name


		if [[ $input_id =~ $repo_block_regex ]]; then
			host="${BASH_REMATCH[3]:-github.com}"
			user="${BASH_REMATCH[4]:-$PERSONAL_USER_ACCOUNT}"
			name="${BASH_REMATCH[5]}"
		else
			# assume input_id is url

			git_trimmed=${input_id%.git}
			name="${git_trimmed##*/}"

			repo_trimmed="${git_trimmed%/*}"
			user=$(echo "$repo_trimmed" | sed -E 's/.*[:\/]([^\/]*)$/\1/')

			left="${repo_trimmed%?$USER_NAME}"
			host="${left##*[\/@]}"

		fi

		# printf '%s\n' "$host $user $name" >/dev/tty
		printf '%s\n' "$host $user $name"
	}

	# loop over all repos.
	# Named "blocks" because all data blocks are expected to be passed
	# as args
	function __restore_backup_entry() {
		local repo_block=$1 remotes_block=$2 host user name

		IFS=/ read host user name <<<"$repo_block"

		__ensure_user_dir_exists "$REPO_MANAGER_DIR/repos/$host/$user"

		__print_lines " ---- RESTORE: $repo_block"

		# TODO: check host / protocol when building clone url

		local clone_url="git@github.com:$user/$name.git"

		# Clone out repo

		# git clone "$clone_url" "$REPO_MANAGER_DIR/repos/$host/$user/$name"

		# Handle remotes

		local remote_entries="${remotes_block#REMOTES:}" oldIFS
		oldIFS=$IFS
		IFS=';'
		local block
		for block in $remote_entries; do

			local remote_name remote_url remote_type

			IFS='|' read remote_name remote_url remote_type <<<"$block"

			__print_lines $'\t'"REMOTE: $remote_name $remote_url $remote_type"

		done
		IFS=$oldIFS

	}

	function __get_user_for_host() {
		local host=${1-}
		case "$host" in
		'github.com') git config github.user ;;
		esac
	}

	# =======================================================
	# Actions

	function __backup() {
		local host=${1-} user=${2-} name=${3-}

		local item option_all='no' option_args=()

		while [[ $# -ne 0 ]]; do
			item="$1"
			shift
			case "$item" in
			--all) option_all='yes' ;;
			--)
				option_args+=("$@")
				shift "$#"
				break
				;;
			# *) __unrecognised_argument "$item" || return ;;
			*) option_args+=("$item") ;;
			esac
		done

		local lines_to_add=() backup_line_formatted=''

		mkdir -p "$DOROTHY_USER_BACKUP_DIR"

		# backup all / single
		if [[ "$option_all" == 'yes' ]]; then

			# TODO: Only add repos that dont yet exist??
			# ^ Add target lines to `lines_to_add` above and write last.

			{
				local host user name
				while IFS=$' \t' read -r host user name; do

					# ensure that the repo we are operating on is a git repo
					# and not an accidentally empty repo
					if [[ ! -d $REPO_MANAGER_DIR/repos/$host/$user/$name/.git ]]; then
						__print_lines "$REPO_MANAGER_DIR/repos/$host/$user/$name is NOT a git repo!" >/dev/tty
						continue
					fi

					__format_backup_line $host $user $name

				done < <(repo-manager list)

			} >"$REPO_MANAGER_BACKUP_FILE" # overwrite backup file here
			return
		else
			if [[ ! "${#option_args[@]}" -eq 3 ]]; then
				help "__backup: ${#option_args[*]} args were given but requires 4."
			fi

			# TODO: check that input repo exists.

			backup_line_formatted="$(__format_backup_line "${option_args[@]}")"
			lines_to_add+=("$backup_line_formatted")
		fi

		# append data to backup
		local tmp="$DOROTHY/user/backups/repo_manager_backup_tmp_file"
		{
			cat "$REPO_MANAGER_BACKUP_FILE"
			__print_lines "${lines_to_add[@]}"
		} | sort -u >"$tmp" && mv "$tmp" "$REPO_MANAGER_BACKUP_FILE"

		# locatedb-load >/dev/null 2>&1 &
	}

	# restore all, selection, or single.
	# pass either the host/user/name key/string or use choose/fuzzy to select
	# which repos to restore on current machine.
	function __restore() {

		local item option_do_all='no' option_repo_block='' option_repo_destination=''
		while [[ $# -ne 0 ]]; do
			item="$1"
			shift
			case "$item" in
			--all)
				option_do_all='yes'
				break
				;;
			*)
				if [[ -z "$option_repo_block" ]]; then
					option_repo_block="$item"
				else
					option_repo_destination="$item"
				fi
				;;
			esac
		done

		local backup_lines_selected=()

		if [[ "$option_do_all" == 'yes' ]]; then
			if confirm --ppid=$$ \
				--question="Are you sure you want to restore all local github repos from backup file?" \
				--negative; then

				# loop over all backup entries
				local backup_line
				while read -r backup_line; do

					# __print_lines "$repo_block $user $name | $_remotes_blockrest"

					# TODO: extract out

					__restore_backup_entry $backup_line # split args

				done <"$REPO_MANAGER_BACKUP_FILE"

			fi
		elif [[ -n "$option_repo_block" ]]; then
			local backup_line=''
			if ! backup_line="$(grep -F "$option_repo_block" "$REPO_MANAGER_BACKUP_FILE")"; then
				__print_lines "__restore: Target repo [$option_repo_block] does not exist, or an error occured while querying the backup file."
				return
			fi
			__restore_backup_entry $backup_line
			if [[ -n "$option_repo_destination" ]]; then
				fs-move --symlink -- "$DOROTHY_LOCAL_CODE_DIR/$option_repo_block" "$option_repo_destination"
			fi

		else
			local selection option_confirm='yes' backup_line

			# TODO: How to format data for fzf??

			selection="$(
				# echo-lines -- "${window_picker_alternatives[@]}" |
				cat <"$REPO_MANAGER_BACKUP_FILE" |
					fzf-helper -- \
						--border-label 'ðŸŒ´ [GHM]: RESTORE' \
						--header $'Select repos for restoring:\n\n'
			)"

			# __print_lines "${selection[@]}"
			while IFS= read -r backup_line; do
				# __print_lines "RESTORE SEL: $backup_line"
				__restore_backup_entry $backup_line
			done <<<"$selection"
		fi

	}

	# if you dont pass a user, then RM will query a user account for current user
	# on this machine for all supported hosts. this is a good callback.
	#
	# TODO: option_arg: --within-user: Only check remotes for repos within user's
	# own account, unless a different account name is explicitly given.
	# ^ This partially also for safety reasons.
	function __sync() {
		local input_source_block=$1 destination_path=$2 host='' user='' name='' repo_block='' repo_dir='' tracked_key='' host_not_provided='no' remote_acct_user_name=''

		local check_hosts=()

		__print_lines "enter __sync"

		# split repo block
		IFS=/ read host user name <<<"$input_source_block"

		# TODO: Move to __get_parts_from_input
		# If name is non-empty string, means user submitted a full input block,
		# <host>/<user>/<name>
		if [[ -n "$name" ]]; then
			check_hosts+=("$host")
		else
			check_hosts=("${supported_hosts[@]}")
			if [[ -n "$user" ]]; then
				# both user/name
				name="$user"
				user="$host"
			else
				# only name
				name="$host"
			fi
		fi

		for check_host in "${check_hosts[@]}"; do

			if [[ "$host_not_provided" == 'yes' ]]; then
				repo_block="$check_host/$repo_slug"
			fi

			# If the user account is not explicitly given, then we only check
			# for user's account across hosts
			if [[ -z "$user" ]]; then
				user="$(__get_user_for_host "$check_host")"
			fi

			repo_slug="$user/$name"
			repo_block="$check_host/$repo_slug"

			local repo_url="git@$check_host:$repo_slug.git"

			__print_lines "repo-manager(sync): Checking for repo [$user/$name] at host [$check_host]"

			# cloned already
			if __is_cloned "$repo_block"; then
				__print_lines "Found cloned"
				false && fs-move --symlink -- "$REPOS_DIR/$repo_block" "$destination_path"
				return 0
			elif __is_tracked "$repo_block"; then
				# exists in database
				__print_lines "Found in database"
				false && repo-manager restore "$repo_block" "$destination_path"
				return 0
			elif gh repo view "$repo_slug" &>dev/null; then
				# pull down into store
				__print_lines "Found remote"
				false && repo-manager clone "$repo_url" "$destination_path"
				return 0
			fi
		done

		__print_lines "Could not sync a repo for [$input_source_block] to destinaton [$destination_path]"

		return 1

	}

	# Remove not-cloned repos from backup file.
	function __clean() {
		:
	}

	# Remove repo locally, and remove it from backup file.
	# Wont delete any remotes.
	# @args host user name
	function __remove() {
		:

		# TODO:
		# get host from $1
		# get user from $2
		# get repo from $3

		# # Specify the GitHub repo URL you want to remove
		# github_url="https:\/\/github\.com\/username\/repo"
		#
		# # Specify the input file
		# input_file="input_file.txt"
		#
		# # Create a temporary file for storing modified content
		# temp_file=$(mktemp)
		#
		# # Use grep to filter out lines that match the GitHub URL
		# grep -v "$github_url" "$input_file" >"$temp_file"
		#
		# # Replace the original file with the modified content
		# mv "$temp_file" "$input_file"
		#
		# echo "Lines with the GitHub URL removed."
	}

	function init_github_remote() {
		local local_repo_path=${1-}

		__print_lines "# README is empty" >README.md

		git add --all && git commit -m 'first'
		gh repo create --source="$local_repo_path" --private --push
	}

	# ======================

	function __clone() {
		local item option_url='' option_link_destination=''
		while [[ $# -ne 0 ]]; do
			item="$1"
			shift
			case "$item" in
			--*) __unrecognised_flag "$item" || return ;;
			# *) __unrecognised_argument "$item" || return ;;
			*)
				if [[ -z "$option_url" ]]; then
					option_url="$item"
				else
					option_link_destination="$item"
				fi
				;;
			esac
		done

		if [[ -z "$option_url" ]]; then
			help '__clone requires at least one valid URL for cloing.'
		fi

		local host user name
		read -r host user name < <(__get_parts_from_input_repo_id "$option_url")

		local parts_concat="$host/$user/$name"

		local repo_user_dir="$REPO_MANAGER_DIR/repos/$host/$user"
		local repo_name_path="$repo_user_dir/$name"

		__print_lines "$repo_name_path"

		if [[ -d "$repo_name_path" ]]; then
			__print_lines "Repo [$parts_concat] already exists!"
			return
		fi

		# git@github.com:neovim/neovim.git

		__ensure_user_dir_exists "$repo_user_dir"

		false && git clone -- "$option_url" "$repo_name_path"

		if [[ -n "$option_link_destination" ]]; then
			fs-move --symlink -- "$repos_name_path" "$option_link_destination"
		fi

		__backup "$host" "$user" "$name"
	}

	function __list() {
		{
			for host_dir in "$REPO_MANAGER_DIR/repos/"*; do
				for user_dir in "$host_dir/"*; do
					for repo_dir in "$user_dir/"*; do
						__print_lines "$repo_dir"
					done
				done
			done
		} | awk -F/ '{print $(NF-2)" "$(NF-1)" "$NF}'
	}

	function __is_cloned() {
		local repo_block=$1
		# if has been cloned on this machine
		if [[ ! -d "$REPO_MANAGER_DIR/repos/$repo_block" ]]; then
			return 1
		fi
	}

	function __is_tracked() {
		local repo_block=$1
		if grep -qF "$repo_block" "$REPO_MANAGER_BACKUP_FILE" || :; then
			return
		else
			return 1
		fi
	}

	# Create new repo and add github remote
	function __new() {
		local item option_repo_name='' option_link_destination=''

		while [[ $# -ne 0 ]]; do
			item="$1"
			shift
			case "$item" in
			--*) __unrecognised_flag "$item" || return ;;
			# *) __unrecognised_argument "$item" || return ;;
			*)
				if [[ -z "$option_repo_name" ]]; then
					option_repo_name="$item"
				else
					option_link_destination="$item"
				fi
				;;
			esac
		done

		local host=github.com user="$PERSONAL_USER_ACCOUNT" name="$option_repo_name"

		if [[ -z "$PERSONAL_USER_ACCOUNT" ]]; then
			__print_lines "Error: github user was empty.."
		fi

		local repo_user_dir="$REPO_MANAGER_DIR/repos/github.com/$PERSONAL_USER_ACCOUNT"

		local repo_name_path="$repo_user_dir/$option_repo_name"

		__ensure_user_dir_exists "$repo_user_dir"

		git init "$repo_name_path"

		init_github_remote "$repo_name_path" "$repo_name"

		if [[ -n "$option_link_destination" ]]; then
			fs-move --symlink -- "$DOROTHY_LOCAL_CODE_DIR/repos/$host/$user/$name" "$option_link_destination"
		fi

		__backup "$host" "$user" "$name"
	}

	# TODO: Forking should default to keep the repo under the original users account
	# name, but if you supply the flag --user-config, then it will create the fork under
	# your own user account and rename it to <name>-config. Supplying --user should
	# make the fork to your user account.
	# TODO: If you pass a repo block, instead of url, then allow for forking and
	# moving the repo into your user account if you supply the above flags.
	function __fork() {

		local gh_fork_cmd=(gh repo fork)

		local item option_args=() option_repo_key='' option_link_destination='' option_locate_fork_under_personal_user='no' option_fork_name_new=''
		while [[ $# -ne 0 ]]; do
			item="$1"
			shift
			case "$item" in
			# Move, if existing clone, to github user dir.
			--move-to-user) option_locate_fork_under_personal_user='yes' ;;
			# Use a different remote name.
			'--fork-name='*) option_fork_name_new="${item#*=}" ;;
			--*) __unrecognised_flag "$item" || return ;;
				# *) __unrecognised_argument "$item" || return ;;
			# '--')
			# 	option_args+=("$@")
			# 	shift "$#"
			# 	break
			# 	;;
			*)
				# if [[ -z "$action" ]]; then
				# 	action="$item"
				# else
					# __unrecognised_argument "$item" || return
				# fi
				option_args+=("$item")
				;;
			esac
		done

		# All of this option args proc is easier to make int the switch above by
		# just shifting for each arg.
		if [[ "${#option_args[@]}" -eq 0 ]]; then
			help "__fork requires at least a repo key on the form $($repo_block_description) or source url."
		fi
		option_repo_key="${option_args[0]}"

		if [[ "${#option_args[@]}" -gt 1 ]]; then
			option_link_destination="${option_args[1]}"
		fi

		# get repo block parts

		local host user name target_repo_is_clone='no'
		read -r host user name < <(__get_parts_from_input_repo_id "$option_repo_key")
		__print_lines "{$host} {$user} {$name}"

		local msg="Fork repo by key=[$option_repo_key]"

		if [[ "$user" == "$PERSONAL_USER_ACCOUNT" ]] ; then
			# TODO: This requires renaming the project!
			__print_lines "You cannot fork one of your own projects. At least not for now :D"
			return
		fi

		# check original path
		local original_user_repo_path="$REPO_MANAGER_DIR/repos/$host/$user/$name"
		if [[ ! -d "$original_user_repo_path" ]]; then
			original_user_repo_path=''
			return
		fi

		# handle new fork name
		if [[ -n "$option_fork_name_new" ]] ; then
			name="$option_fork_name_new"
			msg+=", with new name=[$option_fork_name_new]"
			gh_fork_cmd+=(--fork-name "$option_fork_name_new")
		fi

		__ensure_user_dir_exists "$host/$PERSONAL_USER_ACCOUNT"

		# handle preparing for (moving) fork into personal user account.
		local clone_to_user="$user"

		if [[ "$option_locate_fork_under_personal_user" == 'yes' ]] ; then
			clone_to_user="$PERSONAL_USER_ACCOUNT"
		fi

		local repo_target_user_dir="$REPO_MANAGER_DIR/repos/$host/$clone_to_user"
		local clone_path="$repo_target_user_dir/$name"


		# if original repo dir and move to user
		if [[ "$option_locate_fork_under_personal_user" == 'yes' ]] ; then

			if [[ -n "$original_user_repo_path"  ]] ; then
				if [[ -d "$clone_path" ]]; then
					__print_lines "Could not move repo from [$original_user_repo_path] to target clone path [$clone_path] as it already exists! Aborting..."
					return
				fi
				# Also, remove from backup.
				false && fs-move -- "$original_user_repo_path" "$clone_path"
			else
				false && git clone -- "$option_repo_key" "$clone_path"
			fi
		else
			if [[ "$original_user_repo_path" == "$clone_path" ]];  then
				# targetting a path that already exists as cloned out.
				:
			else
				if [[ ! -d "$clone_path" ]]; then
					false && git clone -- "$option_repo_key" "$clone_path"
				else
					__print_lines "Target clone path [$clone_path] already exists!"
				fi
			fi
		fi
		# ^ All of this could probably be made more elegant.

		msg+=", into path=[$clone_path]"

		__print_lines "$msg"

		false && {
			# only need to clone if it does not exist

			# git clone -- "$option_repo_key" "$clone_path"

			__backup "$host" "$user" "$name"

			# checkout default / set default branch?

			#

			pushd "$clone_path" >/dev/null 2>&1
			"${gh_fork_cmd[@]}"
			popd >/dev/null 2>&1


			if [[ -n "$option_link_destination" ]]; then
				false && fs-move --symlink -- "$clone_path" "$option_link_destination"
			fi

		}
	}

	# Create worktrees from entries in the main clone tree.
	# and put them under $REPO_MANAGER_DIR/worktrees, ($WORKTREES_DIR)
	function __worktree() {
		:
	}

	# function create_new_nvim_plugin() {
	# 	# initial check
	# 	local repo_name=$1
	#
	# 	if ! command-exists boilit; then
	# 		echo "This command requires $(boilit) package." >/dev/stderr
	# 		return 1
	# 	fi
	#
	# 	repo_name="$repo_name.nvim"
	#
	# 	# SPAWN NEW PLUGIN
	# 	# boilit >> need to fix it so that it strips the `.nvim` string within the plugin/code
	# 	boilit -p "$GHQ_GH_USER_PATH" "$repo_name" || exit 1
	# 	init_github_remote "$GHQ_GH_USER_PATH" "$repo_name"
	# 	__backup "github.com/$PERSONAL_USER_ACCOUNT/$repo_name" true
	# }

	# What is this func??!!
	#
	# for each repo store the remotes as space separated entries on the same line
	# ^<repo> <remoteName,repoUrl> <remoteName,repoUrl> ..
	#
	# NOTE:This function looks at all locally cloned repos, and then checks if
	# the they exist in the database backup file. If they exist, then we update the
	# values for remotes, else we call `add_new_repo_to_database` which then in turn
	# is responsible for collecting the remote data anew and store everything..
	#
	# NOTE: This func has slight overlapping with backup?
	#
	# TODO: Rename to __sync -> Maybe use the git-helper sync command.
	#   ~ 1
	#
	# TODO:
	# 1. loop over...
	#
	# capture_and_overwrite_local_repos_remotes() {
	# 	local ghq_all_repos remotes repo_match_line_to_append_remotes=''
	#
	# 	# TODO: Replace with inhouse implementation
	# 	ghq_all_repos=$(ghq list)
	#
	# 	# set -x
	#
	# 	# A. loop over all repos
	# 	while IFS= read -r ghq_list_single_repo; do
	# 		# always outputs a dot as first entry for some reason?
	# 		if [[ "$ghq_list_single_repo" == "." ]]; then
	# 			continue
	# 		fi
	#
	# 		remotes=$(git -C "$GHQ_ROOT/$ghq_list_single_repo" remote -v)
	#
	# 		# # echoing / debugging
	# 		# while IFS= read -r remote; do
	# 		#   __print_line "- $remote"
	# 		# done < <(echo "$remotes")
	#
	# 		# TODO: grep handle duplicates, eg.:
	# 		# github.com/LukeSmithxyz/dwm
	# 		# github.com/LukeSmithxyz/dwmblocks
	#
	# 		local grep_status_repo_exists grep_out=()
	# 		eval_capture --statusvar=grep_status_repo_exists --stdoutvar=grep_out -- \
	# 			grep "^$ghq_list_single_repo" "$GHQ_BACKUP_FILE"
	#
	# 		local print_status='x'
	# 		local num_duplicates
	# 		if test "$grep_status_repo_exists" -eq 0; then
	# 			num_duplicates="${#grep_out[@]}"
	# 		else
	# 			num_duplicates=0
	# 			print_status=" "
	# 		fi
	#
	# 		echo-style --h1="Repo single [#$num_duplicates], #$num_duplicates: $ghq_list_single_repo"
	#
	# 		if test "$num_duplicates" = 0; then
	# 			echo-style --notice="No item found in database for current repo. Needs to be added to DB first."
	# 			continue
	# 		fi
	#
	# 		if test "$num_duplicates" -gt 1; then
	# 			echo-style --warning="I need to ensure I dont get duplicates back from grep."
	# 			continue
	# 		fi
	#
	# 		# These are the final remote string chunks that I should put between
	# 		# the <REMOTES> keyword and the next special keyword ??
	# 		remotes_string_chunk=()
	# 		while IFS= read -r remote; do
	# 			local stripped_line comma_replaced repo_match_line_to_append_remotes
	# 			stripped_line="${remote% *}"
	# 			comma_replaced="${stripped_line//$'\t'/,}"
	# 			repo_match_line_to_append_remotes="$repo_match_line_to_append_remotes $comma_replaced"
	# 			remotes_string_chunk+=("$comma_replaced")
	# 		done < <(echo "$remotes")
	#
	# 		__print_lines "${remotes_string_chunk[@]}"
	# 		# echo "$repo_match_line_to_append_remotes"
	# 		echo-style --g2="$ghq_list_single_repo"
	#
	# 		# TODO: put together the full new line string.
	# 		#
	# 		#
	# 		# TODO: revers insert lines?
	#
	# 		# suffix="suffix"
	# 		# target="target"
	# 		# input_file="input_file.txt"
	# 		# sed -i "/$target/ s/$/ $suffix/" "$input_file"
	#
	# 	done <<<"$ghq_all_repos"
	# }

	# =====================================
	# Action

	case "$action" in

	test) __test "${option_args[@]}" ;;
	backup) __backup "${option_args[@]}" ;;
	remove) __remove "${option_args[@]}" ;;
	restore) __restore "${option_args[@]}" ;;
	sync) __sync "${option_args[@]}" ;;
	list) __list "${option_args[@]}" ;;
	new | create) __new "${option_args[@]}" ;;
	clone) __clone "${option_args[@]}" ;;
	fork) __fork "${option_args[@]}" ;;
	worktree) __worktree "${option_args}" ;;
	# is-cloned) __is_cloned ;;
	# is-managed) __is_tracked ;;

	# ??
	capture_and_overwrite_local_repos_remotes) capture_and_overwrite_local_repos_remotes ;;
	esac
)

# fire if invoked standalone
if test "$0" = "${BASH_SOURCE[0]}"; then
	if [[ $* == '--test' ]]; then
		repo_manager_test
	else
		repo_manager "$@"
	fi
fi