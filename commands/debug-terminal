#!/usr/bin/env bash

# prepare
self="${BASH_SOURCE[0]}"
if [[ -z ${DOROTHY-} ]]; then
	export DOROTHY
	DOROTHY="${XDG_DATA_HOME:-"$HOME/.local/share"}/dorothy"
	source "$DOROTHY/sources/environment.sh"
fi
source "$DOROTHY/sources/bash.bash"
if [[ -z $* ]]; then
	test='--normal'
else
	test="$*"
	if is-ci; then
		test+=' --within-ci'
	fi
	__replace --optional --source+target={test} --value='--no-recurse' --leading-whitespace --trailing-whitespace
fi
result_file="$(fs-temp --directory='debug-terminal' --file='debug-terminal.tsv')"
newline=$'\n'

# process action
if [[ -z $* || $1 == '--normal' || $* == *'--no-recurse'* ]]; then
	:
elif [[ $1 == '--all' ]]; then
	variations=(
		'--normal'
		'--background'
		'--stdin-pipe'
		'--stdin-redirection'
		'--stdin-stdout-pipe'
		'--stdin-stdout-stderr-redirection'
		'--closed-stdin-stdout'
		'--delayed-stdin-pipe'
		'--delayed-stdin-redirection'
		'--immediate-and-delayed-stdin-pipe'
		'--immediate-and-delayed-stdin-redirection'
	)
	for variation in "${variations[@]}"; do
		eval-helper --wrap -- "$self" "$variation" "${@:2}"
	done
	exit
elif [[ $1 == '--test' ]]; then
	# erase the result file
	: >"$result_file"

	# run all the variations
	"$self" --all "${@:2}"
	if ! is-ci; then
		"$self" --ssh "${@:2}"
	fi

	# it goes header row, data row, header row, data row, ...
	# so we want to remove all header rows except the first one
	awk 'NR==1 || (NR%2==0)' "$result_file" >"$result_file.trimmed"

	# transpose the columns and rows, the following breaks the file, so we have to do it ourself:
	# qsv transpose -d $'\t' ...
	echo-transpose --stdin <"$result_file.trimmed" >"$result_file.transposed"

	# render the result
	if [[ $IS_STDIN_OPENED_ON_TERMINAL == 'no' || ${DEBUG_BASH-} == 'yes' ]] || __command_missing -- csvlens; then
		echo-file --plain -- "$result_file.transposed"
	else
		csvlens -t "$result_file.transposed"
	fi
	exit
elif [[ $1 == '--ssh' ]]; then
	ssh -T localhost "$self" --all --within-ssh
	exit
elif [[ $1 == '--background' ]]; then
	"$self" "$@" --no-recurse &
	wait $! # just [wait] is bash v5
	exit
elif [[ $1 == '--stdin-pipe' ]]; then
	printf '%s\n' 1 2 3 4 5 6 7 8 9 0 | "$self" "$@" --no-recurse
	exit
elif [[ $1 == '--stdin-redirection' ]]; then
	"$self" "$@" --no-recurse < <(printf '%s\n' 1 2 3 4 5 6 7 8 9 0)
	exit
elif [[ $1 == '--stdin-stdout-pipe' ]]; then
	printf '%s\n' 1 2 3 4 5 6 7 8 9 0 | "$self" "$@" --no-recurse | cat
	exit
elif [[ $1 == '--stdin-stdout-stderr-redirection' ]]; then
	"$self" "$@" --no-recurse 2> >(cat) > >(cat) < <(printf '%s\n' 1 2 3 4 5 6 7 8 9 0)
	exit
elif [[ $1 == '--closed-stdin-stdout' ]]; then
	"$self" "$@" --no-recurse >&- <&- # can't close stderr, as for some reason, it hangs: 2>&-
	# > BASH_XTRACEFD=1 debug-bash -x -- debug-terminal --closed-stdin-stdout-stderr --no-recurse 2>&-
	exit
elif [[ $1 == '--delayed-stdin-pipe' ]]; then
	{
		sleep 5
		# on ci mac this returns 1, everywhere else this returns 141, and there doesn't seem to be a workaround
		printf '%s\n' 1 2 3 4 5 6 7 8 9 0
	} | "$self" "$@" --no-recurse || __ignore_sigpipe || __ignore_exit_status 1 # this will sigpipe fail as the command will finish before the sleep finishes
	exit
elif [[ $1 == '--delayed-stdin-redirection' ]]; then
	"$self" "$@" --no-recurse < <(
		sleep 5
		printf '%s\n' 1 2 3 4 5 6 7 8 9 0
	)
	exit
elif [[ $1 == '--immediate-and-delayed-stdin-pipe' ]]; then
	{
		printf '%s\n' 1 2 3 4 5 6 7 8 9 0
		sleep 5
		# on ci mac this returns 1, everywhere else this returns 141, and there doesn't seem to be a workaround
		printf '%s\n' 1 2 3 4 5 6 7 8 9 0
	} | "$self" "$@" --no-recurse || __ignore_sigpipe || __ignore_exit_status 1 # this will sigpipe fail as the command will finish before the sleep finishes
	exit
elif [[ $1 == '--immediate-and-delayed-stdin-redirection' ]]; then
	"$self" "$@" --no-recurse < <(
		printf '%s\n' 1 2 3 4 5 6 7 8 9 0
		sleep 5
		printf '%s\n' 1 2 3 4 5 6 7 8 9 0
	)
	exit
else
	echo "Unknown option: $1" >&2
	exit 22 # EINVAL 22 Invalid argument
fi

# helpers
check_keys=('test')
check_values=("$test")
function __check {
	check_keys+=("$1")
	printf '%s\t\t%s\n' "$test" "$1" >&2 || : # this will fail on our closed file descriptor test
	if eval "$1"; then
		check_values+=(OK)
	else
		check_values+=(FAIL)
	fi
}
function __finish {
	local joined_keys='' joined_values='' result semlock_file
	__join --source={check_keys} --delimiter=$'\t' --target={joined_keys} || exit 110
	__join --source={check_values} --delimiter=$'\t' --target={joined_values} || exit 111
	result="${joined_keys}${newline}${joined_values}${newline}"
	semlock_file="$(__get_semlock 'debug-terminal')" || exit 112
	printf '%s' "$result" >>"$result_file" || exit 113
	# @todo remove need for manual semlock tracking and do: `| echo-write --append -- "$result_file"` instead which will be updated to use a semlock
	rm -f "$semlock_file" || exit 114
}

function __file {
	[[ -e $1 ]] || return 2 # ENOENT 2 No such file or directory
	file "$1" || return 74  # EPROGUNAVAIL 74 RPC prog. not avail
}

__check 'ls -la /proc/self/fd'
__check '__file /proc/self/fd/0'
__check '__file /proc/self/fd/1'
__check '__file /proc/self/fd/2'

__check 'ls -la /proc/$$/fdinfo'
__check '__file /proc/$$/fdinfo/0'
__check '__file /proc/$$/fdinfo/1'
__check '__file /proc/$$/fdinfo/2'

__check 'ls -la /dev/fd'
__check '__file /dev/fd/0'
__check '__file /dev/fd/1'
__check '__file /dev/fd/2'

__check 'ls -la /dev/pts'
__check '__file /dev/pts/0'
__check '__file /dev/pts/1'
__check '__file /dev/pts/2'

__check '__file /dev/stdin'
__check '__file /dev/stdout'
__check '__file /dev/stderr'
__check '__file /dev/tty'

# __check 'printf [%s] $SSH_CONNECTION'
# __check 'printf [%s] $SSH_CLIENT'
# __check 'printf [%s] $SSH_TTY'

# stdin can be output and input depending, whereas the rest in practice are only output
__check '(: </dev/stdin >/dev/stdin)'
__check '(: </dev/stdin)'
__check '(: >/dev/stdin)'
__check '(: </dev/stdout >/dev/stdout)'
__check '(: </dev/stdout)'
__check '(: >/dev/stdout)'
__check '(: </dev/stderr >/dev/stderr)'
__check '(: </dev/stderr)'
__check '(: >/dev/stderr)'
__check '(: </dev/tty >/dev/tty)'
__check '(: </dev/tty)'
__check '(: >/dev/tty)'

# True if FD is opened on a terminal.
__check '[[ -t 0 ]]'
__check '[[ -t 1 ]]'
__check '[[ -t 2 ]]'

# True if file is a named pipe.
__check '[[ -p /dev/stdin ]]'
__check '[[ -p /dev/stdout ]]'
__check '[[ -p /dev/stderr ]]'
__check '[[ -p /dev/tty ]]' # This is always false

# True if file is character special.
__check '[[ -c /dev/stdin ]]'
__check '[[ -c /dev/stdout ]]'
__check '[[ -c /dev/stderr ]]'
__check '[[ -c /dev/tty ]]'

# True if file is block special.
# These are always false
# __check '[[ -b /dev/stdin ]]'
# __check '[[ -b /dev/stdout ]]'
# __check '[[ -b /dev/stderr ]]'
# __check '[[ -b /dev/tty ]]'

# True if file is readable by you.
__check '[[ -r /dev/stdin ]]'
__check '[[ -r /dev/stdout ]]'
__check '[[ -r /dev/stderr ]]'
__check '[[ -r /dev/tty ]]'

# True if file is writable by you.
__check '[[ -w /dev/stdin ]]'
__check '[[ -w /dev/stdout ]]'
__check '[[ -w /dev/stderr ]]'
__check '[[ -w /dev/tty ]]'

# True if data is already available for reading.
__check 'read -t 0 </dev/stdin'
__check 'read -t 0 </dev/stdout' # This is always false
__check 'read -t 0 </dev/stderr' # This is always false
__check 'read -t 0 </dev/tty'    # This is always false, but perhaps, if we preload some data, it will work

function __get_terminal_size {
	if [[ -n ${BASH_SUBSHELL-} && $BASH_SUBSHELL -ne 0 ]]; then
		return 76 # EPROCUNAVAIL 76 Bad procedure for program
	else
		# checkwinsize: If set, Bash checks the window size after each external (non-builtin) command and, if necessary, updates the values of LINES and COLUMNS. This option is enabled by default.
		shopt -s checkwinsize || return 115
		(:) # noop subshell which updates LINES and COLUMNS
		if [[ -n ${LINES-} && -n ${COLUMNS-} ]]; then
			printf "%s\n" "$LINES" "$COLUMNS" || :
			return 0
		else
			return 116
		fi
	fi
}
__check '__get_terminal_size'

function __get_terminal_cursor_position {
	local input_device_file="$1" line column
	IFS='[;' read -t 2 -srd R -p $'\e[6n' _ line column <"$input_device_file" || return 117
	if [[ -n ${line-} && -n ${column-} ]]; then
		printf "%s\n" "$line" "$column" || :
		return 0
	else
		return 118
	fi
}

__check '__get_terminal_cursor_position /dev/stdin'
__check '__get_terminal_cursor_position /dev/stdout'
# on the CI arm runners, this stderr read never times out, and goes forever
# https://github.com/bevry/dorothy/actions/runs/17858215146/job/50782141605
if [[ -z $CI ]]; then
	__check '__get_terminal_cursor_position /dev/stderr'
	if [[ $IS_TTY_AVAILABLE == 'yes' ]]; then
		__check '__get_terminal_cursor_position /dev/tty'
	fi
fi

# function __get_terminal_theme {
# 	local input_device_file="$1" original_tty_settings REPLY=''
# 	original_tty_settings="$(stty -g || :)"
# 	stty raw -echo || return 1
# 	read -n 24 -t 1 -rsp $'\e]11;?\a' <"$input_device_file" || return 1
# 	stty "$original_tty_settings" || return 1
# 	if [[ -n $REPLY ]]; then
# 		printf "%s\n" "$REPLY"
# 		return 0
# 	else
# 		return 1
# 	fi
# }
# __check '__get_terminal_theme /dev/stdin'
# __check '__get_terminal_theme /dev/stdout'
# __check '__get_terminal_theme /dev/stderr'
# __check '__get_terminal_theme /dev/tty'

__finish
