#!/usr/bin/env bash

function echo_wait_test() (
	source "$DOROTHY/sources/bash.bash"
	source "$(type -P eval-tester)"
	echo-style --h1="TEST: $0"

	# optional dependencies
	setup-util-moreutils --quiet --optional --no-fallback # sponge

	# prepare
	local broken_pipe_status=23
	function broken_pipe {
		# the curl will fail because of the progress bar
		__print_lines 'before broken pipe'
		curl --fail-early --head --write-out '%{http_code}' --location 'https://www.google.com' | "$@" | tail -n 1 # 23
		# find . | head -n 1 # 141
		# yes | head -n 1 # 141
		__print_lines 'after broken pipe'
	}
	function broken_pipe_to_control {
		broken_pipe 'echo'
	}
	function broken_pipe_to_sponge {
		broken_pipe 'sponge'
	}
	function broken_pipe_to_echo_wait {
		broken_pipe echo-wait "$@"
	}
	function binary_test {
		curl -fsSL https://pkg.cloudflare.com/cloudflare-main.gpg | echo-wait | gpg --import
	}

	# prepare
	local file rand
	file="$(fs-temp --file --extension='txt')"

	# broken pipe tests
	eval_tester --name='broken pipe is broken' --status="$broken_pipe_status" --stdout=$'before broken pipe' --ignore-stderr \
		-- broken_pipe_to_control

	eval_tester --name='broken pipe to echo-wait --no-sponge' --stdout=$'before broken pipe\n200after broken pipe' --ignore-stderr \
		-- broken_pipe_to_echo_wait --no-sponge

	eval_tester --name='broken pipe to echo-wait' --stdout=$'before broken pipe\n200after broken pipe' --ignore-stderr \
		-- broken_pipe_to_echo_wait

	# binary tests
	if __command_exists -- gpg; then
		setup-util-gpg --quiet # ensure gpg is configured correctly: https://github.com/bevry/dorothy/actions/runs/7790951085/job/21245946464#step:4:1644
		eval_tester --name='binary data is binary data' --ignore-stdout --ignore-stderr \
			-- binary_test
	fi

	# generic tests
	rand="$RANDOM"
	eval_tester --name='write to file with padding, without sponge' \
		-- echo-wait --no-sponge "$file" <<<" $rand "
	eval_tester --name='write to file with padding, without sponge: assertion' --stdout=" $rand " \
		-- cat -- "$file"

	rand="$RANDOM"
	eval_tester --name='write to file with padding, with sudo and without sponge' \
		-- echo-wait --sudo --no-sponge "$file" <<<" $rand "
	eval_tester --name='write to file with padding, with sudo and without sponge: assertion' --stdout=" $rand " \
		-- sudo-helper -- cat -- "$file"

	if __command_exists -- sponge; then # on fresh macos ci, it won't exist
		eval_tester --name='broken pipe to sponge' --stdout=$'before broken pipe\n200after broken pipe' --ignore-stderr \
			-- broken_pipe_to_sponge

		eval_tester --name='broken pipe to echo-wait --sponge' --stdout=$'before broken pipe\n200after broken pipe' --ignore-stderr \
			-- broken_pipe_to_echo_wait --sponge

		rand="$RANDOM"
		eval_tester --name='write to file with padding, with sponge' \
			-- echo-wait --sponge "$file" <<<" $rand "
		eval_tester --name='write to file with padding, with sponge: assertion' --stdout=" $rand " \
			-- cat -- "$file"

		rand="$RANDOM"
		eval_tester --name='write to file with padding, with sudo and sponge' \
			-- echo-wait --sudo --sponge "$file" <<<" $rand "
		eval_tester --name='write to file with padding, with sudo and sponge: assertion' --stdout=" $rand " \
			-- sudo-helper -- cat -- "$file"
	fi

	echo-style --g1="TEST: $0"
	return 0
)
function echo_wait() (
	source "$DOROTHY/sources/bash.bash"

	# =====================================
	# Arguments

	function help {
		cat <<-EOF >/dev/stderr
			ABOUT:
			Process STDIN ignoring pipe failures.

			USAGE:
			curl -I -fail https://www.google.com | echo-wait [...options] [--] [...<file>] | cat

			OPTIONS:
			--sponge | --no-tee
			    Enforce usage of [sponge] for output buffering. This is required for binary data.
			--no-sponge | --tee
			    Disable usage of [sponge] for output buffering, use [tee] instead. This does not support binary data.

			--sudo
			    Use sudo to write to the <file>.

			--append
			    Append to the <file> instead of overwriting it.

			[...<file>]
			    A file to write to.
		EOF
		if [[ $# -ne 0 ]]; then
			echo-error "$@"
		fi
		return 22 # EINVAL 22 Invalid argument
	}

	# process
	local item option_sponge='' option_sudo='no' option_append='no' option_files=()
	while [[ $# -ne 0 ]]; do
		item="$1"
		shift
		case "$item" in
		'--help' | '-h') help ;;
		'--no-sponge'* | '--sponge'*)
			option_sponge="$(get-flag-value --affirmative --fallback="$option_sponge" -- "$item")"
			;;
		'--no-tee'* | '--tee'*)
			option_sponge="$(get-flag-value --non-affirmative --fallback="$option_sponge" -- "$item")"
			;;
		'--no-sudo'* | '--sudo'*)
			option_sudo="$(get-flag-value --affirmative --fallback="$option_sudo" -- "$item")"
			;;
		'--no-append'* | '--append'*)
			option_append="$(get-flag-value --affirmative --fallback="$option_append" -- "$item")"
			;;
		'--')
			option_files+=("$@")
			shift $#
			break
			;;
		'--'*) help "An unrecognised flag was provided: $item" ;;
		*) option_files+=("$item") ;;
		esac
	done

	# install sponge if required
	if [[ $option_sponge == 'yes' ]]; then
		setup-util-moreutils --quiet # sponge
	fi
	# unless sponge is missing, or undesired, use it, this is because sponge supports binary data
	if [[ $option_sponge == 'no' ]] || __command_missing -- sponge; then
		option_sponge='no'
	else
		option_sponge='yes'
	fi

	# check file arguments
	if [[ $option_sudo == 'yes' && ${#option_files[@]} -eq 0 ]]; then
		help '<sudo> requires <file>s'
	fi
	if [[ $option_append == 'yes' && ${#option_files[@]} -eq 0 ]]; then
		help '<append> requires <file>s'
	fi

	# adapt commands for sudo and files, and check sudo
	local output_command=()
	if [[ ${#option_files[@]} -ne 0 ]]; then
		if [[ $option_sudo == 'yes' ]]; then
			output_command+=(
				sudo-helper
				--reason="Your sudo/root/login password is required to update the files: ${option_files[*]}"
				--
			)
		fi
		if [[ $option_sponge == 'yes' ]]; then
			output_command+=("$(type -P sponge)")
		else
			output_command+=("$(type -P tee)")
		fi
		if [[ $option_append == 'yes' ]]; then
			output_command+=(-a)
		fi
		output_command+=(-- "${option_files[@]}")
	fi

	# =====================================
	# Action

	# echo-wait does three things

	# wait without a timeout for reading data, this means no timeout for first read nor subsequent read, this means it waits until EOF is reached
	# this is what prevents this issue:
	#
	# > set -o pipefail
	#
	# > { sleep 1; echo 1; sleep 2; echo 2; sleep 3; echo 3; } | echo-count-lines --timeout=1
	# 1
	# [141] sigpipe
	#
	# > { sleep 1; echo 1; sleep 2; echo 2; sleep 3; echo 3; } | echo-count-lines --no-timeout
	# 3
	# [0] success

	# read all data to write all data at once, this means it waits until EOF is reached before writing anything
	# this is what prevents this issue:
	#
	# notes:
	# [head -n1] has same functionality on macos and ubuntu, on ubuntu [sed 1q] doesn't cause sigpipe but on macos it does
	# [tee -p] does not exist on macos but does exist on ubuntu, it has no effect
	# [read -r -d ''] does not support binary data as that can contain null characters which are then dropped, and [IFS= read -r] is even worse
	#
	# > set -o pipefail
	#
	# > { sleep 1; echo 1; sleep 2; echo 2; sleep 3; echo 3; } | head -n1
	# > { sleep 1; echo 1; sleep 2; echo 2; sleep 3; echo 3; } | cat | head -n1
	# > { sleep 1; echo 1; sleep 2; echo 2; sleep 3; echo 3; } | tee | head -n1
	# 1
	# [141] sigpipe
	#
	# > { sleep 1; echo 1; sleep 2; echo 2; sleep 3; echo 3; } | sponge | head -n1
	# > { sleep 1; echo 1; sleep 2; echo 2; sleep 3; echo 3; } | dd status=none | head -n1
	# > { sleep 1; echo 1; sleep 2; echo 2; sleep 3; echo 3; } | { read -r -d ''; printf '%s' "$REPLY"; } | head -n1
	# > { sleep 1; echo 1; sleep 2; echo 2; sleep 3; echo 3; } | ( cat > tempfile; cat tempfile; rm tempfile; ) | sed 1q
	# 1
	# [0] success

	# other notable commands:
	# > echo-style --stdout=my-stdout --stderr=my-stderr > >(flock 1 waiter 5 --stdout=stdout) 2> >(flock 2 waiter 5 --stderr=stderr >/dev/stderr); flock 1 echo stdout-done; flock 2 echo stderr-done; flock -u 1; flock -u 2
	# stderr
	# stdout
	# stdout-done
	# stderr-done

	# write the data to output files, with support for sudo and appending

	if [[ $option_sponge == 'yes' ]]; then
		if [[ ${#option_files[@]} -ne 0 ]]; then # bash v3 compat
			"${output_command[@]}" </dev/stdin
		else
			sponge </dev/stdin
		fi
	else
		function read_everything {
			# note, that despite this meant to support binary, it doesn't seem to, it results in lost data when using --no-sponge, and results in a hang when using --sponge, using [sponge] instead of [echo-wait] works fine
			# binary_file='...'; delta <(echo-escape-special --stdin <"$binary_file") <(cat "$binary_file" | echo-wait --no-sponge | echo-escape-special --stdin)
			#

			# local counter=0
			# while read -r -d ''; do
			# 	counter=$((counter + 1))
			# 	__print_lines "inner read - $counter"
			# 	# printf %s'\0' "$REPLY"
			# done </dev/stdin
			# __print_lines 'outer read'
			# printf %s "$REPLY"

			# [-d ''] and [-d $'\0'] are equivalent
			# the problem with binary data is that it may have the null byte within it, so multiple inner reads occurs
			while read -r -d ''; do
				printf %s'\0' "$REPLY"
			done </dev/stdin
			printf %s "$REPLY"
		}
		if [[ ${#option_files[@]} -ne 0 ]]; then # bash v3 compat
			read_everything | "${output_command[@]}" >/dev/null
			# ^ /dev/null to be consistent with sponge
		else
			read_everything
		fi
	fi
)

# fire if invoked standalone
if [[ $0 == "${BASH_SOURCE[0]}" ]]; then
	if [[ $* == '--test' ]]; then
		echo_wait_test
	else
		echo_wait "$@"
	fi
fi
