#!/usr/bin/env bash

# NOTES:
# [echo -en] doesn't work with escape codes on bash v3, [printf ...] does
# [/dev/tty] is used as otherwise "$(confirm ...)" will not output anything to the user, as stdout gets captured in those situations
#    why would anyone use confirm in that way? they don't but confirm within a getter does, such as [select_installer] within [macos-drive]

function confirm() (
	source "$DOROTHY/sources/bash.bash"

	# =====================================
	# Arguments

	function help {
		cat <<-EOF >/dev/stderr
			USAGE:
			confirm --ppid=\$\$ [...options] -- <question> ...[detail]

			OPTIONS:
			--bool | --positive | --negative | --confirm || --mode=<bool|positive|negative|confirm>
			    [bool] mode forces a positive or negative confirmation, with no default.
			    [positive] mode defaults to a positive confirmation.
			    [negative] mode defaults to a negative confirmation.
			    [confirm] mode forces a confirmation, with no default; it is the default mode.

			--timeout=<timeout>
			    Specify the timeout in seconds.
			    Under <negative> mode, defaults to 60 seconds (one minute) before defaulting to a negative confirmation.
			    Under <positive> mode, defaults to 60 seconds (one minute) before defaulting to a positive confirmation.
			    Under other modes, defaults to 3600 seconds (one hour) before abortion occurs.

			--yes=<OK>
			    What to display to the user for positive confirmations, defaults to "OK".

			--no=<CANCEL>
			    What to display to the user for negative confirmations, defaults to "CANCEL".

			--abort=<ABORT>
			    What to display to the user for aborted confirmations, defaults to "ABORT".

			--ppid=<ppid>
			    Specifies the parent process ID to also terminate upon abortion.
			    In bourne shells this is specified like so [--ppid=\$\$]
			    This is necessary because the typical usage of [if confirm ...; then ...; else ...; fi]
			    will only catch positive and negative confirmations, but not abortion cases,
			    as such abortions would otherwise be registered as negative cases.
			    Providing the parent process ID allows the abortion to propagate to the parent,
			    allowing the intended abortion behaviour to propagate.
		EOF
		if test "$#" -ne 0; then
			echo-error "$@"
		fi
		return 22 # EINVAL 22 Invalid argument
	}

	# prepare
	local item option_question_parts=() option_mode='confirm' option_timeout='3600' option_yes='OK' option_no='CANCEL' option_abort='ABORT' option_ppid=''
	while test "$#" -ne 0; do
		item="$1"
		shift
		case "$item" in
		'--help' | '-h') help ;;
		'--bool') option_mode='bool' ;;
		'--positive') option_mode='positive' ;;
		'--negative') option_mode='negative' ;;
		'--confirm') option_mode='confirm' ;;
		'--mode='*) option_mode="${item#*--mode=}" ;;
		'--timeout='*) option_timeout="${item#*--timeout=}" ;;
		'--yes='*) option_yes="${item#*--yes=}" ;;
		'--no='*) option_no="${item#*--no=}" ;;
		'--abort='*) option_abort="${item#*--abort=}" ;;
		'--ppid='*) option_ppid="${item#*--ppid=}" ;;
		'--')
			option_question_parts+=("$@")
			shift $#
			break
			;;
		'--'*) help "An unrecognised flag was provided: $item" ;;
		*) help "An unrecognised argument was provided: $item" ;;
		esac
	done

	# mode
	if test "$option_mode" = 'positive' -o "$option_mode" = 'negative'; then
		option_timeout='60' # one minute
		option_yes='YES'
		option_no='NO'
	elif test "$option_mode" = 'bool'; then
		option_yes='YES'
		option_no='NO'
	fi

	# checks
	if test -z "$option_ppid"; then
		help '<ppid> is necessary'
	fi
	if test -z "${option_question_parts[*]}"; then
		help '<question> is necessary'
	fi

	# =====================================
	# Helpers

	# used to process the input
	function do_read {
		local answer read_status

		# ask and timeout
		eval_capture --statusvar=read_status --stdoutvar=answer -- \
			read-key --timeout="$option_timeout"

		# process
		if test "$option_mode" = 'positive'; then
			# positive
			if test "$read_status" -eq 60; then
				return 0 # timeout
			elif test "$read_status" -ne 0; then
				return "$read_status" # failure
			fi
			eval_capture --statusvar=read_status -- is-affirmative -- "$answer"
			if test "$read_status" -lt 2; then
				return "$read_status"
			elif test "$answer" = 'enter' -o "$answer" = 'space'; then
				return 0
			elif test "$answer" = 'escape' -o "$answer" = 'q'; then
				return 125 # ECANCELED 125 Operation cancelled
			fi

		elif test "$option_mode" = 'negative'; then
			# negative
			if test "$read_status" -eq 60; then
				return 1 # timeout
			elif test "$read_status" -ne 0; then
				return "$read_status" # failure
			fi
			eval_capture --statusvar=read_status -- \
				is-affirmative -- "$answer"
			if test "$read_status" -lt 2; then
				return "$read_status"
			elif test "$answer" = 'enter' -o "$answer" = 'space'; then
				return 1
			elif test "$answer" = 'escape' -o "$answer" = 'q'; then
				return 125 # ECANCELED 125 Operation cancelled
			fi

		elif test "$option_mode" = 'bool'; then
			# bool
			if test "$read_status" -ne 0; then
				return "$read_status" # timeout and failure
			fi
			eval_capture --statusvar=read_status -- \
				is-affirmative -- "$answer"
			if test "$read_status" -lt 2; then
				return "$read_status"
			elif test "$answer" = 'escape' -o "$answer" = 'q'; then
				return 125 # ECANCELED 125 Operation cancelled
			fi

		elif test "$option_mode" = 'confirm'; then
			# confirm
			if test "$read_status" -ne 0; then
				return "$read_status" # timeout and failure
			fi
			eval_capture --statusvar=read_status -- \
				is-affirmative -- "$answer"
			if test "$read_status" -lt 2; then
				return "$read_status"
			elif test "$answer" = 'enter' -o "$answer" = 'space'; then
				return 0
			elif test "$answer" = 'escape' -o "$answer" = 'q'; then
				return 125 # ECANCELED 125 Operation cancelled
			fi

		else
			# unknown
			help "An invalid <mode> was provided: $option_mode"
		fi

		# try reading again, and erase any leaked characters
		printf '\e[%sG\e[K' "$hx" >/dev/tty
		do_read
	}

	function do_question {
		local question_parts_total question_parts_last header hx question_index lines

		# add the confirmation to the first question part
		if test "$option_mode" = 'positive'; then
			option_question_parts[0]+=" $(echo-style --blink='(' --blink+green+bold='Y' --blink='/n)')"
		elif test "$option_mode" = 'negative'; then
			option_question_parts[0]+=" $(echo-style --blink='(y/' --blink+red+bold='N' --blink=')')"
		elif test "$option_mode" = 'bool'; then
			option_question_parts[0]+=" $(echo-style --blink='(y/n)')"
		elif test "$option_mode" = 'confirm'; then
			option_question_parts[0]+=" $(echo-style --blink='(CONFIRM)')"
		else
			help "An invalid <mode> was provided: $option_mode"
		fi

		# output the question parts
		# saving the cursor position of the first line
		# and outputting a newline beteen all lines, except the last, which should not have a trailing line
		question_parts_total="${#option_question_parts[@]}"
		question_parts_last="$((question_parts_total - 1))"
		header="$(mktemp)"
		hx=''
		for ((question_index = 0; question_index < "$question_parts_total"; question_index++)); do
			echo_string "${option_question_parts[question_index]} " | tee -a "$header" >/dev/tty
			if test "$question_index" -eq 0; then
				# read cursor x y, discard y, set hx to y
				IFS='[;' read -srd R -p $'\e[6n' _ _ hx
			fi
			if test "$question_index" -ne "$question_parts_last"; then
				echo | tee -a "$header" >/dev/tty
			fi
		done

		# move the cursor
		lines=0
		if test "$question_parts_total" -ne 0; then
			# reposition the cursor, to after the options in the first part
			lines="$(echo-count-lines --no-inline <"$header")"
			# move these lines up
			if test "$lines" -ne 0; then
				printf '\e[%sF' "$lines" >/dev/tty
			fi
			# move to the hx column
			printf '\e[%sG' "$hx" >/dev/tty
		fi

		# read
		do_read
	}

	# =====================================
	# Action

	# handle termination
	local RESULT=0 question_first_part="${option_question_parts[0]} " # this is cached for the finale, as it gets modified
	function on_confirm_terminate {
		RESULT=$?
		if test -z "$RESULT" -o "$RESULT" -eq 0; then
			RESULT=100 # EPROTO 100 Protocol error
		fi
		on_finish
	}
	function on_finish {
		trap - SIGINT SIGTERM

		# make sure to erase question, as ctrl+c buggers everything
		printf '\e[G\e[J' >/dev/tty

		# output the finale
		if test "$RESULT" -eq 0; then
			# positive response
			echo-style "$question_first_part" --green+bold="$option_yes" >/dev/tty
		elif test "$RESULT" -eq 1; then
			# negative response
			echo-style "$question_first_part" --red+bold="$option_no" >/dev/tty
		else
			# crash response
			echo-style "$question_first_part" --red+bold="$option_abort" >/dev/tty
			# kill caller's parent
			if test -n "$option_ppid"; then
				# kill "-$option_ppid" ...
				# ^ fails because 130 isn't supported
				# kill -n ... ...
				# kill "-$(kill -l "$option_ppid")" ...
				# ^ works but isn't serious enough to cause the termination
				# "$(ps -p $$ -o ppid=)"
				# ^ doesn't work, as is different pid than manual
				kill "$option_ppid"
			fi
			# kill our parent
			kill "$$"
			# kill our subshell
			kill 0
			# kill our shell
			exit "$RESULT"
		fi
		# kill this
		return "$RESULT"
	}
	trap on_confirm_terminate SIGINT SIGTERM # this is necessary to always show ABORT message

	# read and handle answer
	local result_status
	eval_capture --statusvar=result_status -- do_question
	if test "$result_status" -ne 0; then
		RESULT="$result_status"
	fi
	on_finish
	return "$RESULT"

	# @todo
	# an alternative implementation could be a new line like this at the end, with ENTER and ESCAPE and SPACE as the correct outputs
	# echo-style --blink='Press: ' --blink+green+bold='y ' --blink='for ' --blink+green='YES' --blink=', ' --blink+red+bold='n ' --blink='for ' --blink+red='NO' --blink=', ' --blink+bold='ENTER '  --blink='for ' --blink+red='NO'

	# using \e[s (save) and \e[u (restore) for ctrl+c handling did not work
)

# fire if invoked standalone
if test "$0" = "${BASH_SOURCE[0]}"; then
	confirm "$@"
fi
