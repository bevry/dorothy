#!/usr/bin/env bash

# NOTES:
# [echo -en] doesn't work with escape codes on bash v3, [printf ...] does
# ["$tty_target"] is used as otherwise "$(confirm ...)" will not output anything to the user, as stdout gets captured in those situations
#    why would anyone use confirm in that way? they don't but confirm within a getter does, such as [select_installer] within [macos-drive]

function confirm_test() (
	source "$DOROTHY/sources/bash.bash"
	echo-style --h1="TEST: $0"

	# --ignore-stderr otherwise only \n^[[68;1R is output

	{
		sleep 3
		__print_line
	} | eval-tester --name='receive positive response by enter key' --ignore-stderr \
		-- confirm --ppid=$$ --positive --timeout=5 -- 'What is your response?'

	{
		sleep 3
		__print_line
	} | eval-tester --name='receive negative response by enter key' --status=1 --ignore-stderr \
		-- confirm --ppid=$$ --negative --timeout=5 -- 'What is your response?'

	{
		sleep 3
		__print_lines 'y'
	} | eval-tester --name='receive positive response by y key' --ignore-stderr \
		-- confirm --ppid=-1 --bool --timeout=5 -- 'What is your response?'

	{
		sleep 3
		__print_lines 'n'
	} | eval-tester --name='receive negative response by n key' --status=1 --ignore-stderr \
		-- confirm --ppid=-1 --bool --timeout=5 -- 'What is your response?'

	{
		sleep 3
		__print_line
	} | eval-tester --name='receive timeout response by timeout and enter key rejected by require' --status=60 --ignore-stderr \
		-- confirm --ppid=-1 --bool --timeout=5 -- 'What is your response?'

	eval-tester --name='receive positive response by timeout and no input' --ignore-stderr \
		-- confirm --ppid=$$ --positive --timeout=5 -- 'What is your response?'

	eval-tester --name='receive negative response by timeout and no input' --status=1 --ignore-stderr \
		-- confirm --ppid=$$ --negative --timeout=5 -- 'What is your response?'

	eval-tester --name='receive timeout response by timeout and no input' --status=60 --ignore-stderr \
		-- confirm --ppid=-1 --bool --timeout=5 -- 'What is your response?'

	{
		# press escape key
		sleep 3
		printf $'\x1b'
	} | eval-tester --name='receive abort response by escape key' --status=125 --ignore-stderr \
		-- confirm --ppid=-1 --bool --timeout=5 -- 'What is your response?'

	echo-style --g1="TEST: $0"
	return 0
)
function confirm_() (
	source "$DOROTHY/sources/bash.bash"

	# =====================================
	# Arguments

	function help {
		cat <<-EOF >/dev/stderr
			USAGE:
			confirm --ppid=\$\$ [...options]

			OPTIONS:
			<question> | --question=<question>
			    Display this question in the prompt. If specified multiple times, they will be joined by newline, and only the first will be lingered.

			--bool | --positive | --negative | --confirm
			--mode=<bool|positive|negative|confirm>
			    [bool] mode forces a positive or negative confirmation, with no default.
			    [positive] mode defaults to a positive confirmation.
			    [negative] mode defaults to a negative confirmation.
			    [confirm] mode forces a confirmation, with no default; it is the default mode.

			--yes=<OK>
			    What to display to the user for positive confirmations, defaults to "OK".

			--no=<CANCEL>
			    What to display to the user for negative confirmations, defaults to "CANCEL".

			--abort=<ABORT>
			    What to display to the user for aborted confirmations, defaults to "ABORT".

			--ppid=<ppid>
			    The parent process ID to also terminate upon abortion.
			    In bourne shells this is specified like so [--ppid=\$\$]
			    This is necessary because the typical usage of [if confirm ...; then ...; else ...; fi]
			    will only catch positive and negative confirmations, but not abortion cases, as such abortions would otherwise be registered as negative cases.
			    Providing the parent process ID allows the abortion to propagate to the parent, allowing the intended abortion behaviour to propagate.

			--timeout=<timeout>
			    Timeout in seconds.
			    Under <negative> mode, defaults to 60 seconds (one minute) before defaulting to a negative confirmation.
			    Under <positive> mode, defaults to 60 seconds (one minute) before defaulting to a positive confirmation.
			    Under other modes, defaults to 3600 seconds (one hour) before abortion occurs.

			--[no-]linger=[yes|NO]
			    Whether the prompt should persist afterwards.

		EOF
		if test "$#" -ne 0; then
			echo-error "$@"
		fi
		return 22 # EINVAL 22 Invalid argument
	}

	# prepare
	local item option_question=() option_mode='confirm' option_timeout='3600' option_ppid='' option_linger='no'
	while test "$#" -ne 0; do
		item="$1"
		shift
		case "$item" in
		'--help' | '-h') help ;;
		'--question='*) option_question+=("${item#*=}") ;;
		'--bool') option_mode='bool' ;;
		'--positive' | '--positive=yes' | '--negative=no' | '--no-negative') option_mode='positive' ;;
		'--negative' | '--negative=yes' | '--positive=no' | '--no-positive') option_mode='negative' ;;
		'--confirm') option_mode='confirm' ;;
		'--mode='*) option_mode="${item#*=}" ;;
		'--timeout='*) option_timeout="${item#*=}" ;;
		'--ppid='*) option_ppid="${item#*=}" ;;
		'--no-linger'* | '--linger'*)
			option_linger="$(get-flag-value --affirmative --fallback="$option_linger" -- "$item")"
			;;
		'--')
			option_question+=("$@")
			shift $#
			break
			;;
		'--'*) help "An unrecognised flag was provided: $item" ;;
		*) option_question+=("$item") ;;
		esac
	done

	# mode
	if test "$option_mode" = 'positive' -o "$option_mode" = 'negative'; then
		if test -z "$option_timeout"; then
			option_timeout='60' # one minute
		fi
	fi

	# checks
	if test -z "$option_ppid"; then
		help '<ppid> is necessary'
	fi

	# question
	local question_title question_body
	if test "${#option_question[@]}" -ne 0; then # bash v3 compat
		if test -n "${option_question[0]}"; then
			question_title="${option_question[0]}"
			question_body="$(__print_lines "${option_question[@]:1}")"
		else
			question_title="$(__print_lines "${option_question[@]:1}")"
			question_body=''
		fi
	else
		question_title=''
		question_body=''
	fi

	# =====================================
	# TTY

	# fetch the targets
	local tty_target using_tty_stderr_fallback='no'
	tty_target="$(is-tty --fallback)"
	if test "$tty_target" = '/dev/stderr'; then
		# fix [/dev/stderr: Permission denied] errors when reading cursor position on CI
		using_tty_stderr_fallback=yes
	fi

	# =====================================
	# Styles

	source "$DOROTHY/sources/config.sh"

	# styles.bash provides:
	# all style variables
	# load_dorothy_config 'styles.bash'

	# refresh the styles
	# refresh_style_cache -- 'question_title_prompt' 'question_title_result' 'question_body' 'input_warning' 'input_error' 'icon_question_positive' 'icon_question_negative' 'icon_question_bool' 'icon_question_confirm' 'result_positive' 'result_negative' 'result_abort'

	# style the question
	local question_prompt='' question_prompt_lines=0 question_title_result='' ri
	if test -n "$question_title"; then
		if test -n "$question_body"; then
			question_prompt="$(echo-style --bold+underline="$question_title" $'\n' --dim="$question_body")"
		else
			question_prompt="$(echo-style --bold+underline="$question_title")"
		fi
		if test "$using_tty_stderr_fallback" = 'no'; then
			question_prompt_lines="$(echo-wrap -- "$question_prompt" | echo-count-lines --stdin)"
		else
			question_prompt_lines="$(echo-count-lines -- "$question_prompt")"
		fi
		question_title_result="$(echo-style --bold="$question_title")"
		ri='  '
	else
		ri=''
	fi

	# renders
	local options_unselected=() options_selected=() options_results=() selected_index='' selectable_count selectable_last yes_index no_index='' abort_index
	if test "$option_mode" = 'positive' -o "$option_mode" = 'negative' -o "$option_mode" = 'bool'; then
		if test 1 -eq 2; then # @todo, make this color detection, or create proper style keys
			options_selected+=(
				"$(echo-style '  ' --invert+legend+green+bold=' YES  ' --key+green+bold='Y')"
				"$(echo-style '   ' --invert+legend+red+bold=' NO  ' --key+red+bold='N')"
			)
			options_unselected+=(
				"$(echo-style '  ' --legend+green=' YES  ' --key+green='Y')"
				"$(echo-style '   ' --legend+red=' NO  ' --key+red='N')"
				"$(echo-style '   ' --legend+red+dim=' ABORT  ' --key+red+dim='ESC' ' ' --key+red+dim='Q')"
			)
			options_results=(
				"$(echo-style '  ' --invert+legend+green+bold=' YES ')"
				"$(echo-style '  ' --invert+legend+red+bold=' NO ')"
				"$(echo-style '  ' --invert+legend+red+bold=' ABORT ')"
			)
		else
			options_selected+=(
				'  *YES* [Y]'
				'   *NO* [N]'
			)
			options_unselected+=(
				'   YES  [Y]'
				'    NO  [N]'
				'    ABORT  [ESC] [Q]'
			)
			options_results=(
				"${ri}[YES]"
				"${ri}[NO]"
				"${ri}[ABORT]"
			)
		fi
		if test "$option_mode" = 'positive'; then
			selected_index=0
		elif test "$option_mode" = 'negative'; then
			selected_index=1
		fi # if bool, don't set index
		yes_index=0
		no_index=1
		abort_index=2
	elif test "$option_mode" = 'confirm'; then
		# @todo implement no-color styles
		options_selected+=(
			"$(echo-style --invert+legend+bold=' PROCEED ' --legend-key-spacer='' --key+bold='ENTER' --key-key-spacer='' --key+bold='SPACE' --key-key-spacer='' --key+bold='Y')"
		)
		options_unselected+=(
			'' # never used
			"$(echo-style --legend+red+dim=' ABORT ' --legend-key-spacer='' --key+red+dim='ESC' --key-key-spacer='' --key+red+dim='Q')"
		)
		options_results=(
			"$(echo-style "$ri" --invert+legend+green+bold=' PROCEED ')"
			"$(echo-style "$ri" --invert+legend+red+bold=' ABORT ')"
		)
		selected_index=0
		yes_index=1
		abort_index=1
	fi
	selectable_count="${#options_selected[@]}"
	selectable_last="$((selectable_count - 1))"

	# =====================================
	# Action

	local cursor_rows=0 FINISHED=''
	__print_value_lines_or_nothing "$question_prompt"
	function refresh {
		local fmt str='' index
		# delete the cursor rows
		if test "$cursor_rows" -gt 0; then
			fmt="\e[${cursor_rows}F\e[J"
		else
			fmt='\e[G\e[J'
		fi

		# re-render the keys prompt
		for index in "${!options_unselected[@]}"; do
			if test -n "$selected_index" && test "$index" -eq "$selected_index"; then
				str+="${options_selected[$index]}"
			else
				str+="${options_unselected[$index]}"
			fi
		done
		printf "$fmt%s" "$str  " >"$tty_target"
	}
	function on_confirm_terminate {
		RESULT=$?
		if test -z "$RESULT" -o "$RESULT" -eq 0; then
			RESULT=100 # EPROTO 100 Protocol error
		fi
		on_finish
	}
	function on_finish {
		trap - SIGINT SIGTERM

		# this can run twice if ctrl+c
		if test "$FINISHED" = 'yes'; then
			return "$RESULT"
		fi
		FINISHED='yes'

		# clear
		local fmt str result
		cursor_rows="$((cursor_rows + question_prompt_lines))"
		if test "$cursor_rows" -gt 0; then
			# trunk-ignore(shellcheck/SC2059)
			printf "\e[${cursor_rows}F\e[J" >"$tty_target"
		else
			printf '\e[G\e[J' >"$tty_target"
		fi

		# output the finale
		if test "$RESULT" -le "$selectable_last"; then
			# success response
			if test "$option_linger" = 'yes'; then
				result="${options_results[RESULT]}"
				printf '%s\n' "$question_title_result$result$commentary" >"$tty_target"
			fi
		else
			# crash response
			result="${options_results[abort_index]}"
			if test "$option_linger" = 'yes'; then
				printf '%s\n' "$question_title_result$result$commentary" >"$tty_target"
			else
				printf '%s\n' "$question_title_result$result$commentary" >/dev/stderr
			fi
			# kill caller's parent
			if test "$option_ppid" -ge 0; then
				if test "$option_ppid" -ge 1; then
					# kill "-$option_ppid" ...
					# ^ fails because 130 isn't supported
					# kill -n ... ...
					# kill "-$(kill -l "$option_ppid")" ...
					# ^ works but isn't serious enough to cause the termination
					# "$(ps -p $$ -o ppid=)"
					# ^ doesn't work, as is different pid than manual
					kill "$option_ppid"
				fi
				# kill our parent
				kill "$$"
				# kill our subshell
				kill 0
				# kill our shell
				exit "$RESULT"
			fi
		fi
		# kill this
		return "$RESULT"
	}
	trap on_confirm_terminate SIGINT SIGTERM # this is necessary to always show ABORT message

	local input keys commentary='' RESULT=''
	while :; do
		# render
		refresh

		# capture
		eval_capture --statusvar=read_status --stdoutvar=input -- \
			read-key --keep-line-buffer-newlines --timeout="$option_timeout"

		# input => keys => key
		keys=()
		mapfile -t keys <<<"$input"

		# prep clearing of any input that leaked
		cursor_rows=0
		if test "$using_tty_stderr_fallback" = 'yes'; then
			for key in "${keys[@]}"; do
				if test "$key" = 'enter' -o "$key" = 'line-buffer'; then
					cursor_rows="$((cursor_rows + 1))"
				fi
			done
		fi

		# handle status
		if test "$read_status" -eq 60; then
			# timeout
			commentary="  $(echo-style --input-warning='[timed out: used default]')"
			if test "$option_mode" = 'positive'; then
				RESULT=0
				break
			elif test "$option_mode" = 'negative'; then
				RESULT=1
				break
			else # bool, confirm
				commentary="  $(echo-style --inpurt-error='[input failure: timed out: required]')"
				RESULT="$read_status" # timeout
				break
			fi
		elif test "$read_status" -ne 0; then
			# failure
			commentary="  $(echo-style --inpurt-error="[input failure: $read_status]")"
			RESULT="$read_status"
			break
		fi

		# process the keys
		for key in "${keys[@]}"; do
			case "$key" in
			'Y' | 'y')
				if test -n "${yes_index-}"; then
					RESULT="$yes_index"
					break
				else
					printf $'\a' >"$tty_target" # bell
				fi
				;;
			'N' | 'n')
				if test -n "${no_index-}"; then
					RESULT="$no_index"
					break
				else
					printf $'\a' >"$tty_target" # bell
				fi
				;;
			'left' | 'right' | 'up' | 'down')
				if test -z "$selected_index" -o "$selectable_count" -eq 1; then
					if test "$key" = 'right' -o "$key" = 'up'; then
						selected_index="$selectable_last"
					elif test "$key" = 'left' -o "$key" = 'down'; then
						selected_index=0
					fi
				elif test "$key" = 'left' -o "$key" = 'up'; then
					if test "$selected_index" -eq 0; then
						selected_index="$selectable_last"
					else
						selected_index="$((selected_index - 1))"
					fi
				elif test "$key" = 'right' -o "$key" = 'down'; then
					if test "$selected_index" -eq "$selectable_last"; then
						selected_index=0
					else
						selected_index="$((selected_index + 1))"
					fi
				fi
				;;
			'enter' | 'space')
				if test -n "$selected_index"; then
					if test "$selected_index" -eq 0; then
						RESULT=0
						break
					elif test "$selected_index" -eq 1; then
						# not possible in bool mode, as selected_index will never be 1, so nothing needed here
						RESULT=1
						break
					else
						RESULT=125 # abort
						break
					fi
				fi
				printf $'\a' >"$tty_target" # bell
				;;
			'escape' | 'Q' | 'q')
				RESULT=125 # abort
				break
				;;
			esac
		done

		# check
		if test -n "$RESULT"; then
			break
		fi
	done
	on_finish
	return
)

# fire if invoked standalone
if test "$0" = "${BASH_SOURCE[0]}"; then
	if test "$*" = '--test'; then
		confirm_test
	else
		confirm_ "$@"
	fi
fi
