#!/usr/bin/env bash
source "$DOROTHY/sources/strict.bash"
source "$DOROTHY/sources/edit.sh"
source "$DOROTHY/sources/nullglob.bash"
source "$DOROTHY/sources/arrays.bash"
requires_array_support 'mapfile' 'empty'

# NOTE:
# do not use the `ok` command instead of `|| :` â€” this file uses functions, and the `ok` command only works with commands

function secret() (
	# =====================================
	# Arguments

	function help {
		cat <<-EOF >/dev/stderr
			ABOUT:
			Helper for 1password, allowing you to invoke applications with secrets securely.

			ACTIONS:
			install
			    The 1Password CLI tool will be installed upfront if it does not exist, however this command forces its upgrade.

			login|signin

			    Authenticate with the 1Password CLI tool.
			    You will need to do this often, as sessions expire quickly for security.

			logout|signout

			    Invalidates your current authentication with the 1Password CLI tool.

			map <secret> [vault] [item] [field]

			    Map a secret to a specific 1Password vault, item, and field.

			    For example:

			        secret map MY_SECRET

			        Will ask you which of your vaults you would like to use,
			        then ask you which item inside that vault you would like to use,
			        then ask you which field inside that item you would like to use,
			        then it will map the MY_SECRET secret to that specification.

			        Once done, this enables:

			        secret get MY_SECRET
			        secret env MY_SECRET -- echo 'my secret is: \$MY_SECRET'

			get <secret>

			    Get the value of what the secret maps to,
			    from the cache if possible, otherwise from 1Password's API if signed in.

			env <secret...> -- <command> [args...]

			    Gets the value of the secret(s) and passes them as configured environment variables to solely the command.
			    This prevents exposing your secrets to your general shell, your shell history, and unauthorised commands,
			    as with this, only the command you intend to run is given the secrets.

			    For example:

			        secret env MY_SECRET -- echo 'my secret is: \$MY_SECRET'

			        Will get the value of MY_SECRET, and provide it to the echo command's environment
			        such that when it is interpolated into

			            echo my secret is: \$MY_SECRET

			        \$MY_SECRET will be exist in that environment, and be outputted accordingly.

			unmap <secret>

			    Removes the mapping for the secret, such that its shorthand can no longer be fetched.

			invalidate [secret]

			    If a the secret argument was provided, then that secret alone will be cleared from the cache.
			    If no argument is provided, then all cached secrets will be cleared.

			fetch [vault] [item] [field]

			    Fetches the value of a field, from an item, from a 1Password vault.
			    If an argument is missing, you will be prompted to select its value from the available options.
			    Arguments can be partial values (for filtering), and can be the label or value.
			    Labels for vaults and items are converted to the UUID, to avoid conflicts against ambiguous names.
			    Results will be cached until they are invalidated by \`secret invalidate <secret>\`
			        or unmapped by \`secret unmap <secret>\`.

			    For example:

			        secret fetch

			            Will ask you which of your vaults to use,
			            then ask you which item inside that vault to use,
			            then ask you which field inside that item to fetch the value for.

			https

			    Update all the login URLs in your 1Password vault to use HTTPS if they support it,
			    otherwise attempt several variations and use what does work,
			    and if nothing works, then advise that the service appears unresponsive and is likely ready for archiving.

			help

			    Output this help message.
		EOF
		if test "$#" -ne 0; then
			echo-error "$@"
		fi
		return 22 # Invalid argument
	}

	# process
	local item action='' args=() option_conceal='no' option_quiet
	option_quiet="$(echo-quiet -- "$@")"
	while test "$#" -ne 0; do
		item="$1"
		shift
		case "$item" in
		'--help' | '-h') help ;;
		'--no-conceal'* | '--conceal'*)
			option_conceal="$(
				get-flag-value conceal --missing="$option_conceal" -- "$item" | echo-affirmative
			)"
			;;
		'--no-quiet'* | '--quiet'* | '--no-verbose'* | '--verbose'*) ;; # handled by echo-quiet
		*)
			if test -z "$action"; then
				action="$item"
			else
				args+=("$item")
			fi
			;;
		esac
	done

	# emsure
	local actions=(
		'install'
		'login'
		'logout'
		'map'
		'env'
		'get'
		'invalidate'
		'unmap'
		'fetch'
		'https'
		'help'
	)
	action="$(
		choose-option \
			--question='What action do you wish to take?' \
			--filter="$action" -- "${actions[@]}"
	)"

	# =====================================
	# Dependencies

	setup-util-jq --quiet
	setup-util-1password --quiet

	# =====================================
	# Configuration

	# database
	local database="$DOROTHY/user/config.local/secrets.json"
	if ! sudo test -f "$database"; then
		echo '{}' | sudo tee "$database" &>/dev/null
	fi

	# move old state location to new state location
	local state="$XDG_STATE_HOME/secrets"
	if test -d "$DOROTHY/user/secrets"; then
		mv -v "$DOROTHY/user/secrets" "$state"
	fi
	mkdir -p "$state"

	# prepare
	export OP_SESSION='' OP_SUBDOMAIN=''

	# conceal
	local ask_password_arguments=()
	if test "$option_conceal" = 'yes'; then
		ask_password_arguments+=('--password')
	fi

	# =====================================
	# Action

	function cache_clear {
		sudo rm -Rf "$state/"*
	}

	function cache_exists {
		local key ec
		for key in "$@"; do
			ec=0 && sudo test -f "$state/$key" || ec="$?"
			if test "$ec" -ne 0; then
				return 1
			fi
		done
	}

	function cache_delete {
		local key ec
		for key in "$@"; do
			ec=0 && sudo rm -f "$state/$key" || ec="$?"
			if test "$ec" -ne 0; then
				return 1
			fi
		done
	}

	function cache_write {
		local key value
		key="$1"
		value="$2"
		cache_delete "$key"
		if is-value "$value"; then
			echo -n "$value" >"$state/$key"
			sudo chown root: "$state/$key"
			sudo chmod 600 "$state/$key"
		else
			echo-error "Attempted to write an empty secret key [$key]"
			return 1
		fi
	}

	function cache_read {
		local key="$1" value
		if cache_exists "$key"; then
			value="$(sudo cat "$state/$key" | tr -d '\n')"
			if is-value "$value"; then
				echo -n "$value"
			else
				echo-error "Cached secret key [$key] was empty [$value]"
				cache_delete "$key"
				return 1
			fi
		else
			echo-error "Cached secret key [$key] was missing."
			return 1
		fi
	}

	function secret_get {
		local ec key result vault item field value

		# many
		if test "$#" -gt '1'; then
			for key in "$@"; do
				ec=0 && value="$(secret_get "$key")" || ec="$?"
				if test "$ec" -ne 0; then
					echo-error "Unable to fetch the secret key [$key] of many."
					return 1
				fi
				echo "$key=$value"
			done
			return
		fi

		# singular
		key="$1"

		# fetch from cache
		if cache_exists "$key"; then
			cache_read "$key"
			return "$?"
		fi

		# fetch from api
		vault="$(sudo jq -r ".${key}[0]" "$database")"
		item="$(sudo jq -r ".${key}[1]" "$database")"
		field="$(sudo jq -r ".${key}[2]" "$database")"
		if is-value "$vault" && is-value "$item" && is-value "$field"; then
			value="$(fetch_field "$vault" "$item" "$field")"
		else
			{
				echo-error "Key [$key] was missing all three parts of its mapping:"
				echo "vault = [$vault]"
				echo "item  = [$item]"
				echo "field = [$field]"
				echo
				echo "Manually edit the database [$database],"
				echo "or use the [secret map ...] command to set the mapping accordingly."
			} >/dev/stderr
			return 1
		fi
		if is-empty-value "$value"; then
			echo-error "Key [$key] failed to resolve."
			return 1
		fi
		cache_write "$key" "$value"
		echo -n "$value"
	}

	# secret_signout [--quiet]
	# [--quiet] used when its operation is secondary to another
	function secret_signout {
		local quiet
		quiet="$(echo-quiet "$option_quiet" -- "$@")"
		if test "$quiet" != 'yes'; then
			echo 'Unauthenticating...'
		fi
		if test -z "${OP_SESSION-}"; then
			if cache_exists "OP_SESSION"; then
				OP_SESSION="$(cache_read OP_SESSION)"
				op signout --session="$OP_SESSION" 2>&1 || :
			fi
		else
			op signout --session="$OP_SESSION" 2>&1 || :
		fi
		cache_delete "OP_SESSION"
		cache_delete "OP_SUBDOMAIN"
		OP_SESSION=''
		if test "$quiet" != 'yes'; then
			echo 'Unauthenticated.'
		fi
	}

	# secret_signin [--quiet]
	# [--quiet] used when its operation is secondary to another
	function secret_signin {
		local quiet email key ec
		quiet="$(echo-quiet "$option_quiet" -- "$@")"
		# session
		if test "$quiet" != 'yes'; then
			echo 'Authenticating...'
		fi
		if test -z "${OP_SESSION-}"; then
			OP_SESSION="$( (cache_exists OP_SESSION && cache_read OP_SESSION) || :)"
			if test -z "$OP_SESSION"; then
				# subdomain
				if test -z "${OP_SUBDOMAIN-}"; then
					OP_SUBDOMAIN="$( (cache_exists OP_SUBDOMAIN && cache_read OP_SUBDOMAIN) || :)"
					if test -z "${OP_SUBDOMAIN-}"; then
						OP_SUBDOMAIN="$(
							ask --required "${ask_password_arguments[@]}" \
								--question='What is your 1password subdomain?'
						)"
						cache_write "OP_SUBDOMAIN" "$OP_SUBDOMAIN"
					fi
				fi
				email="$(
					ask --required "${ask_password_arguments[@]}" \
						--question='What is your 1password email? This is not stored.'
				)"
				key="$(
					ask --required "${ask_password_arguments[@]}" \
						--question='What is your 1password account key? This is not stored.'
				)"
				# signin
				# unfortunately, this still leaks email and subdomain
				# https://1password.community/discussion/122030/flag-to-disable-op-signin-from-outputting-email-and-subdomain/p1?new=1
				# don't pipe to anything else, as it breaks the OTP question
				ec=0 && OP_SESSION="$(op signin "$OP_SUBDOMAIN" "$email" "$key" --raw)" || ec="$?"
				if test "$ec" -ne 0; then
					echo-errir \
						"Failed to sign into [$OP_SUBDOMAIN] via the email [$email] and account key [$key]." \
						"OP_SESSION = [$OP_SESSION]"
					return 1
				fi
				cache_write "OP_SESSION" "$OP_SESSION"
			fi
		fi
		if test "$quiet" != 'yes'; then
			echo 'Authenticated.'
		fi
	}

	function opwrap {
		local ec result
		ec=0 && result="$(op "$@" 2>&1)" || ec="$?"
		if test "$ec" -ne 0 || [[ $result == '[ERROR]'* ]]; then
			if [[ $result == *'signed in'* ]] || [[ $result == *'session expired'* ]]; then
				echo-error "Session expired, run [secret login] and try again."
				return 1
			fi
			echo-error "$result"
			return 1
		else
			echo -n "$result"
		fi
	}

	function opgrab {
		local vault="${1-}" item="${2-}" ec

		if is-empty-value "$vault"; then
			# fetch available values
			ec=0 && opwrap list vaults --session="$OP_SESSION" || ec="$?"
		elif is-empty-value "$item"; then
			# fetch available items
			ec=0 && opwrap list items --vault="$vault" --session="$OP_SESSION" || ec="$?"
		else
			# fetch item
			ec=0 && opwrap get item "$item" --vault="$vault" --session="$OP_SESSION" || ec="$?"
		fi

		return "$ec"
	}

	function fetch_vault {
		local vault="${1-}" tuples

		# fetch available vaults
		mapfile -t tuples < <(opgrab | jq -r '.[] | (.uuid, .name)')
		if is-array-empty "${tuples[@]}"; then
			echo-error "Failed to fetch a vault:" $'\n' \
				"$(echo-verbose "${tuples[@]}")"
			return 1
		fi

		# filter or ask
		choose-option \
			--question="Which vault did you want with [$vault]?" \
			--filter="$vault" --label --visual="\$LABEL [\$VALUE]" \
			-- "${tuples[@]}"
		return "$?" # return with the above on success and failure
	}

	function fetch_item {
		local vault="${1-}" item="${2-}" tuples

		# fetch available items
		mapfile -t tuples < <(opgrab "$vault" | jq -r '.[] | (.uuid, .overview.title)')
		if is-array-empty "${tuples[@]}"; then
			echo-error "Failed to fetch any items:" $'\n' \
				"$(echo-verbose "${tuples[@]}")"
			return 1
		fi

		# filter or ask
		choose-option \
			--question="Which item did you want with [$item]?" \
			--filter="$item" --label --visual="\$LABEL [\$VALUE]" \
			-- "${tuples[@]}"
		return "$?" # return with the above on success and failure
	}

	function fetch_field {
		local vault="${1-}" item="${2-}" field="${3-}" wants
		local fields=() data fields_via_section fields_via_name fields_via_designation
		if test "${4-}" = '--label'; then
			# trunk-ignore(shellcheck/SC2016)
			wants='$LABEL'
		else
			# trunk-ignore(shellcheck/SC2016)
			wants='$VALUE'
		fi

		# fetch available items
		data="$(opgrab "$vault" "$item")"

		# section fields
		mapfile -t fields_via_section < <(echo "$data" | jq -r '.details.sections[]? | select(.fields).fields[]? | select(.t != "" and .v != "") | (.v, .t)')
		if is-array-count-ge 2 "${fields_via_section[@]}"; then
			fields+=("${fields_via_section[@]}")
		fi

		# name fields
		mapfile -t fields_via_name < <(echo "$data" | jq -r '.details.fields[]? | select(.name != "" and .value != "") | (.value, .name)')
		if is-array-count-ge 2 "${fields_via_name[@]}"; then
			fields+=("${fields_via_name[@]}")
		fi

		# designation fields
		mapfile -t fields_via_designation < <(echo "$data" | jq -r '.details.fields[]? | select(.designation != "" and .value != "") | (.value, .designation)')
		if is-array-count-ge 2 "${fields_via_designation[@]}"; then
			fields+=("${fields_via_designation[@]}")
		fi

		# filter or ask
		choose-option \
			--question="Which field did you want with [$field]?" \
			--filter="$field" --label --visual="\$LABEL [\$VALUE]" --return="$wants" \
			-- "${fields[@]}"
		return "$?" # return with the above on success and failure
	}

	function get_job_count {
		jobs -p | get-line-count
	}

	function item_upgrade {
		local vault="$1" item="$2" ec result
		# fetch
		ec=0 && website="$(opwrap get item --session="$OP_SESSION" --vault "$vault" "$item" --fields website)" || ec="$?"
		if test "$ec" -ne 0; then
			echo-error "[$item] [$website] failed to fetch"
			return 1
		fi
		if test -z "$website"; then
			echo-error "[$item] [$website] empty"
			return 1
		fi
		# upgrade
		result="$(silent-stderr get-url-upgrade "$website" || :)"
		if test -z "$result"; then
			# echo to stdout, as is actionable for user if they are piping
			echo-error "[$item] [$website] unresponsive, consider archiving"
			return 1
		fi
		# check if changed
		if test "$result" = "$website"; then
			echo-error "[$item] [$website] already upgraded"
			return 1
		fi
		# echo to stdout, as is actionable for user if they are piping
		echo "[$item] [$website] => [$result]"
		# apply
		ec=0 && opwrap edit item --session="$OP_SESSION" --vault "$vault" "$item" website="$result" || ec="$?"
		if test "$ec" -ne 0; then
			echo-error "[$item] [$website] failed to save"
			return 1
		fi
	}

	function secret_https {
		local last="${1-}" ec vault item
		ec=0 && vaults="$(opwrap list vaults --session="$OP_SESSION" | jq -r '.[].uuid' | sort)" || ec="$?"
		if test "$ec" -ne 0 -o -z "$vaults"; then
			echo-error "failed to fetch vaults..."
			return 1
		fi
		for vault in $vaults; do
			ec=0 && items="$(opwrap list items --session="$OP_SESSION" --categories Login --vault "$vault" | jq -r '.[].uuid' | sort)" || ec="$?"
			if test "$ec" -ne 0 -o -z "$vaults"; then
				echo-error "failed to fetch items from vault [$vault]"
				return 1
			fi
			# ignoring of status code is in case it returned a vault we don't have write access to
			for item in $items; do
				# resume
				if test -n "$last"; then
					if test "$item" = "$last"; then
						# stop skipping
						last=''
					else
						# continue skipping
						echo "[$item] skipping"
						continue
					fi
				fi
				while test "$(get_job_count)" -eq 15; do
					sleep 1
				done
				(item_upgrade "$vault" "$item" || :) &
			done
		done
		# wait for completed jobs, then note completion
		while test "$(get_job_count)" -ne 0; do
			echo "Waiting on [$(get_job_count)] jobs..."
			sleep 5
			jobs &>/dev/null # for some reason, this seems necessary to prevent hung jobs
		done
		echo 'All done.'
	}

	function secret_fetch {
		local vault item
		value="$(fetch_vault "${1-}")"
		item="$(fetch_item "$vault" "${2-}")"
		fetch_field "$vault" "$item" "${3-}"
		return "$?" # return with the above on success and failure
	}

	function secret_map {
		local secret vault item field result
		secret="$(
			ask --required \
				--question='What shall the name of the environment variable (secret) be?' \
				--default="${1-}"
		)"
		vault="$(fetch_vault "${2-}")"
		item="$(fetch_item "$vault" "${3-}")"
		field="$(fetch_field "$vault" "$item" "${4-}" --label)"
		result="$(sudo jq -r \
			--arg secret "$secret" \
			--arg vault "$vault" \
			--arg item "$item" \
			--arg field "$field" \
			'.[$secret] = [$vault, $item, $field]' \
			"$database")"
		echo "$result" | sudo tee "$database" &>/dev/null
		sudo chown root "$database"
		sudo chmod 600 "$database"
		{
			echo "Sucessfully updated [$database] so that [$secret] fetches [$vault].[$item].[$field]"
			echo "Fetching [$secret]..."
		} >/dev/stderr
		cache_delete "$secret"
		secret_get "$secret"
	}

	function secret_unmap {
		local secret result
		secret="$(
			ask --required \
				--question='What environment variable (secret) name do you wish to unmap?' \
				--default="${1-}"
		)"
		echo 'Enter your sudo password to update the database with the correct permissions...'
		result="$(sudo jq -r \
			--arg secret "$secret" \
			'del(.[$secret])' \
			"$database")"
		echo "$result" | sudo tee "$database"
		sudo chown root "$database"
		sudo chmod 600 "$database"
		cache_delete "$secret"
		echo "Sucessfully unmapped [$secret]" >/dev/stderr
	}

	function secret_env {
		local before=() after=() found='no' args arg
		local keys key value
		local envSecrets envArgs envArg

		for arg in "$@"; do
			if test "$arg" = '--'; then
				found='yes'
				continue
			fi
			if test "$found" = 'yes'; then
				after+=("$arg")
			else
				before+=("$arg")
			fi
		done

		if test "$found" = 'yes' && is-array-full "${before[@]}" && is-array-full "${after[@]}"; then
			keys=("${before[@]}")
			args=("${after[@]}")
		else
			help "env action requires -- separator"
		fi

		# load secrets
		envSecrets=()
		for key in "${keys[@]}"; do
			value="$(secret_get "$key")"
			envSecrets+=("$key=$value")
		done

		# replace secrets in args
		envArgs=()
		for arg in "${args[@]}"; do
			envArg="$arg"
			for key in "${keys[@]}"; do
				value="$(secret_get "$key")"
				envArg="${envArg//\$$key/$value}"
			done
			envArgs+=("$envArg")
		done

		# echo "loaded secrets:  ${vars[*]}"
		# echo "running command: ${args[*]}"
		# echo ''

		env "${envSecrets[@]}" "${envArgs[@]}"
	}

	# =====================================
	# Act

	if test "$action" = 'install'; then
		setup-util-1password --upgrade
	elif test "$action" = 'login'; then
		secret_signout --quiet >/dev/stderr
		secret_signin
	elif test "$action" = 'logout'; then
		secret_signout
	elif test "$action" = 'map'; then
		secret_signin >/dev/stderr
		secret_map "${args[@]}"
	elif test "$action" = 'env'; then
		secret_signin --quiet >/dev/stderr
		secret_env "${args[@]}"
	elif test "$action" = 'get'; then
		secret_signin --quiet >/dev/stderr
		if test -n "${args[*]}"; then
			secret_get "${args[@]}"
		else
			help "get action requires <name> argument"
		fi
	elif test "$action" = 'invalidate'; then
		if test -n "${args[*]}"; then
			cache_delete "${args[@]}"
		else
			cache_clear
		fi
	elif test "$action" = 'unmap'; then
		secret_unmap "${args[@]}"
	elif test "$action" = 'fetch'; then
		secret_signin >/dev/stderr
		secret_fetch "${args[@]}"
	elif test "$action" = 'https'; then
		secret_signin >/dev/stderr
		secret_https "${args[@]}"
	elif test "$action" = 'help'; then
		help
	else
		help 'Invalid <action>'
	fi
)

# fire if invoked standalone
if test "$0" = "${BASH_SOURCE[0]}"; then
	secret "$@"
fi
