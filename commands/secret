#!/usr/bin/env bash
source "$DOROTHY/sources/essentials.sh"
source "$DOROTHY/sources/edit.sh"
source "$DOROTHY/sources/strict.bash"
# source "$DOROTHY/sources/debug.bash"
# @NOTE do not use the `ok` command instead of `|| :` â€” this file uses functions, and the `ok` command only works with commands

# dependencies
env QUIET=y setup-util-jq
env QUIET=y CLI=op CASK='1password-cli' setup-util

# quiet mode: whether or not we output account details
quiet='no'
if is-affirmative "${QUIET-}"; then
	quiet='yes'
fi

# Location
if test -z "${SECRETS-}"; then
	SECRETS="$DOROTHY/user/secrets"
fi
mkdir -p "$SECRETS"

# Make this global to this script
export OP_SESSION
export OP_SUBDOMAIN
export database="$SECRETS/secrets.json"

function secret_resolve() {
	# Write the database if it does not exist
	if ! sudo test -f "$database"; then
		echo '{}' | sudo tee "$database"  &>/dev/null
	fi

	# many
	if test "${#@}" -gt '1'; then
		for var in "$@"; do
			value="$(secret_resolve "$var")"
			echo "$var=$value"
		done
		exit
	fi

	# singular
	key="$1"
	result="$(secret_read "$key" || :)"
	if is-string "$result"; then
		echo -n "$result"
	elif is-empty-string "$result"; then
		vault="$(sudo jq -r ".${key}[0]" "$database")"
		item="$(sudo jq -r ".${key}[1]" "$database")"
		field="$(sudo jq -r ".${key}[2]" "$database")"
		if is-value "$vault" && is-value "$item" && is-value "$field"; then
			value="$(secret_fetch "$vault" "$item" "$field")"
		else
			stderr echo "ERROR: [$database] needs [$key] to have all three parts of its mapping: [$vault, $item, $field]"
			stderr echo "Use the [secret map ...] command to set the mapping accordingly."
			return 1
		fi
		if is-empty-value "$value"; then
			stderr echo "ERROR: resolve returned nothing for: $key"
			return 1
		fi
		secret_write "$key" "$value"
		echo -n "$value"
	else
		echo "ERROR: could not fetch the secret: $key"
		return 1
	fi
}

function secret_write() {
	key="$1"
	value="$2"
	secret_delete "$key"
	if is-string "$value"; then
		echo -n "$value" >"$SECRETS/$key"
		sudo chown root: "$SECRETS/$key"
		sudo chmod 600 "$SECRETS/$key"
	else
		stderr echo "ERROR: wanted to write empty secret: $key"
		return 1
	fi
}

function secret_clear() {
	t="$(mktemp)"
	mv "$database" "$t"
	sudo rm -Rf "$SECRETS/"*
	mv "$t" "$database"
}

function secret_exists() {
	for key in "$@"; do
		sudo test -f "$SECRETS/$key"
	done
}

function secret_delete() {
	for key in "$@"; do
		sudo rm -f "$SECRETS/$key"
	done
}

function secret_read() {
	key="$1"
	if secret_exists "$key"; then
		value="$(sudo cat "$SECRETS/$key" | tr -d '\n')"
		if is-string "$value"; then
			echo -n "$value"
		else
			stderr echo "ERROR: cached secret was empty: $key"
			secret_delete "$key"
			return 1
		fi
	else
		stderr echo "ERROR: cached secret was missing: $key"
		return 1
	fi
}

function secret_signout() {
	echo 'Signing out...'
	if is-empty-string "${OP_SESSION-}"; then
		if secret_exists "OP_SESSION"; then
			OP_SESSION="$(secret_read OP_SESSION)"
			op signout --session="$OP_SESSION" 2>&1 || :
		fi
	else
		op signout --session="$OP_SESSION" 2>&1 || :
	fi
	secret_delete "OP_SESSION"
	secret_delete "OP_SUBDOMAIN"
	OP_SESSION=''
	echo 'Signed out.'
}

function secret_signin() {
	# session
	echo 'Singing in...'
	if is-empty-string "${OP_SESSION-}"; then
		OP_SESSION="$(secret_read OP_SESSION || :)"
		if is-empty-string "$OP_SESSION"; then
			# subdomain
			if is-empty-string "${OP_SUBDOMAIN-}"; then
				OP_SUBDOMAIN="$(secret_read OP_SUBDOMAIN || :)"
				if is-empty-string "${OP_SUBDOMAIN-}"; then
					OP_SUBDOMAIN="$(env PASS="$quiet" ask-mandatory 'What is your 1password subdomain?')"
					secret_write "OP_SUBDOMAIN" "$OP_SUBDOMAIN"
				fi
			fi
			if test "$quiet" = 'no'; then
				stderr echo "Logging into [$OP_SUBDOMAIN], if that is incorrect use [secret clear]."
			fi
			# email
			email="$(env PASS="$quiet" ask-mandatory 'What is your 1password email? This is not stored.')"
			# secret
			key="$(env PASS="$quiet" ask-mandatory 'What is your 1password account key? This is not stored.')"
			# signin
			# unfortunately, this still leaks email and subdomain
			# https://1password.community/discussion/122030/flag-to-disable-op-signin-from-outputting-email-and-subdomain/p1?new=1
			OP_SESSION="$(op signin "$OP_SUBDOMAIN" "$email" "$key" --raw)"  # don't pipe to anything else, as it breaks the OTP question
			if test "$?" -ne 0; then
				stderr echo "ERROR: Failed to sign into [$OP_SUBDOMAIN] via the email [$email] and account key [$key]."
				stderr echo "$OP_SESSION"
				return 1
			fi
			secret_write "OP_SESSION" "$OP_SESSION"
			stderr echo 'Signed in successfully.'
		fi
	fi
}

function secret_grab() {
	secret_signin
	vault="${1-}"
	item="${2-}"
	if is-empty-value "$vault"; then
		# fetch available values
		result="$(op list vaults --session="$OP_SESSION" 2>&1 || :)"
	elif is-empty-value "$item"; then
		# fetch available items
		result="$(op list items --vault="$vault" --session="$OP_SESSION" 2>&1 || :)"
	else
		# fetch item
		result="$(op get item "$item" --vault="$vault" --session="$OP_SESSION" 2>&1 || :)"
	fi
	# process result
	if is-empty-value "$result"; then
		stderr echo "ERROR: Nothing was returned: vault=[$vault], item=[$item], result=[$result]"
		return 1
	elif [[ "$result" = *'signed in'* ]]; then
		stderr echo "ERROR: Unable to return: vault=[$vault], item=[$item]"
		stderr echo "Session expired, run [secret signin] and try again."
		return 1
	elif [[ "$result" = *'ERROR'* ]]; then
		stderr echo "ERROR: Failed to return: vault=[$vault], item=[$item]"
		stderr echo "$result"
		return 1
	else
		echo -n "$result"
	fi
}

function secret_fetch() {
	vault="${1-}"
	if is-empty-value "$vault"; then
		# fetch available vaults
		data="$(secret_grab)"
		if test "$?" -ne 0 || is-empty-value "$data"; then
			return 1
		fi
		# output options
		echo "$data" | jq -r '.[].name' # | (.uuid, .name)'
		return
	fi
	item="${2-}"
	if is-empty-value "$item"; then
		stderr echo "ERROR: Vault was provided [$vault] but item was missing [$item]"
		return 1
		# # fetch available items
		# data="$(secret_grab "$vault")"
		# if test "$?" -ne 0 || is-empty-value "$data"; then
		# 	return 1
		# fi
		# # output options
		# echo "$data" | jq -r '.[] | (.uuid, .overview.title)'
		# return
	fi
	field="${3-}"
	data="$(secret_grab "$vault" "$item")"
	if test "$?" -ne 0; then
		return 1
	fi

	# fetch field value
	if is-value "$field"; then
		# fetch based on section
		result="$(echo "$data" | jq -r --arg key "$field" ".details.sections[] | select(.fields).fields[] | select(.t==\$key).v")"
		if is-empty-value "$result"; then
			# fetch based on standalone
			result="$(echo "$data" | jq -r --arg key "$field" ".details.fields[] | select(.name==\$key).value")"
			# fetch based on designation
			if is-empty-value "$result"; then
				result="$(echo "$data" | jq -r --arg key "$field" ".details.fields[] | select(.designation==\$key).value")"
			fi
		fi
		# output
		echo -n "$result"
	else
		# fetch available field values
		# fetch based on section
		echo "$data" | jq -r ".details.sections[] | select(.fields).fields[] | .t"
		# fetch based on standalone
		echo "$data" | jq -r ".details.fields[] | .name"
		# fetch based on designation
		echo "$data" | jq -r ".details.fields[] | .designation"
	fi
}

function secret_map() {
	secret="$(ask-mandatory 'What shall the name of the environment variable (secret) be?' "${1-}")"
	vault="$(ask-options 'What vault should it map to?' "${2-}" "$(secret_fetch)")"
	item="$(ask-mandatory 'What item should it map to?' "${3-}")"
	field="$(ask-options 'What field should it map to?' "${4-}" "$(secret_fetch "$vault" "$item")")"
	result="$(sudo jq -r \
		--arg secret "$secret" \
		--arg vault "$vault" \
		--arg item "$item" \
		--arg field "$field" \
		'.[$secret] = [$vault, $item, $field]' \
		"$database")"
	echo "$result" | sudo tee "$database"
	sudo chown root "$database"
	sudo chmod 600 "$database"
	stderr echo "Sucessfully wrote [$secret] to fetch from [$vault].[$item].[$field]"
	stderr echo "Attempting fetch of [$secret] now..."
	secret_delete "$secret"
	secret_resolve "$secret"
}

function secret_unmap() {
	secret="$(ask-mandatory 'What environment variable (secret) name do you wish to unmap?' "${1-}")"
	echo 'Enter your sudo password to update the database with the correct permissions...'
	result="$(sudo jq -r \
		--arg secret "$secret" \
		'del(.[$secret])' \
		"$database")"
	echo "$result" | sudo tee "$database"
	sudo chown root "$database"
	sudo chmod 600 "$database"
	secret_delete "$secret"
	stderr echo "Sucessfully unmapped [$secret]"
}

function secret_env() {
	before=()
	after=()
	found='no'

	for arg in "$@"; do
		if test "$arg" = '--'; then
			found='yes'
			continue
		fi
		if test "$found" = 'yes'; then
			after+=("$arg")
		else
			before+=("$arg")
		fi
	done

	if test "$found" = 'yes' -a "${#before[@]}" -ne '0' -a "${#after[@]}" -ne '0'; then
		vars=("${before[@]}")
		args=("${after[@]}")
	else
		stderr echo 'ERROR: -- was not found. Refer to usage.'
		return 1
		# vars=()
		# args=("${before[@]}")
	fi

	# load secrets
	envSecrets=()
	for var in "${vars[@]}"; do
		value="$(secret_resolve "$var")"
		envSecrets+=("$var=$value")
	done

	# replace secrets in args
	envArgs=()
	for arg in "${args[@]}"; do
		envArg="$arg"
		for var in "${vars[@]}"; do
			value="$(secret_resolve "$var")"
			envArg="${envArg//\$$var/$value}"
		done
		envArgs+=("$envArg")
	done

	# echo "loaded secrets:  ${vars[*]}"
	# echo "running command: ${args[*]}"
	# echo ''

	env "${envSecrets[@]}" "${envArgs[@]}"
}

if test -n "${1-}"; then
	if test "$1" = "env"; then
		secret_env "${@:2}"
	elif test "$1" = "clear" -o "$1" = "delete"; then
		if is-string "${2-}"; then
			secret_delete "${@:2}"
		else
			secret_clear
		fi
	elif test "$1" = "edit"; then
		edit "$database"
	elif test "$1" = "signin" -o "$1" = "login"; then
		secret_signout
		secret_signin
	elif test "$1" = "signout" -o "$1" = "logout"; then
		secret_signout
	elif test "$1" = "refresh"; then
		if is-string "$2"; then
			secret_delete "${@:2}"
			secret_resolve "${@:2}"
		else
			stderr echo 'ERROR: <name> was not found. Refer to usage.'
			exit 1
		fi
	elif test "$1" = "get"; then
		if is-string "$2"; then
			secret_resolve "${@:2}"
		else
			stderr echo 'ERROR: <name> was not found. Refer to usage.'
			exit 1
		fi
	elif test "$1" = "upgrade"; then
		# https://app-updates.agilebits.com/product_history/CLI
		brew install --cask 1password-cli --force
		# if contains-string "$(op update)" "available"; then
		# 	brew install --cask 1password-cli --force
		# fi
	elif test "$1" = "map"; then
		secret_map "${@:2}"
	elif test "$1" = "unmap"; then
		secret_unmap "${@:2}"
	elif test "$1" = "fetch"; then
		secret_fetch "${@:2}"
	else
		stderr echo 'invalid command'
	fi
else
	stderr echo 'USAGE:'
	stderr echo 'secret upgrade'
	stderr echo 'secret edit'
	stderr echo 'secret signin'
	stderr echo 'secret signout'
	stderr echo 'secret clear'
	stderr echo 'secret clear <name>'
	stderr echo 'secret refresh <name>'
	stderr echo 'secret get <name>'
	stderr echo 'secret env <secret...> -- <command> [args...]'
	stderr echo 'secret map <environment variable / secret name> <vault name> <item name> <field name>'
	stderr echo 'secret unmap <environment variable / secret name>'
	# stderr echo 'secret fetch <vault name> <item name>'
fi
