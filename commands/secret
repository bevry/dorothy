#!/usr/bin/env bash

# @todo support these:
# https://github.com/FiloSottile/age
# https://github.com/gopasspw/gopass
# https://github.com/sorairolake/hf
# https://github.com/70sh1/eddy

function secret_() (
	source "$DOROTHY/sources/bash.bash"

	# =====================================
	# Arguments

	function help {
		__print_help "$@" <<-EOF || return
			ABOUT:
			Helper for 1password, allowing you to invoke applications with secrets securely.

			USAGE:
			\`secret [...options] <action> [...arguments]\`

			ACTIONS:
			install
			    The 1Password CLI tool will be installed upfront if it does not exist, however this command forces its upgrade.

			login|signin
			    Authenticate with the 1Password CLI tool.
			    If using 1Password CLI v1, sessions expire quickly for security, so this is occasionally required.
			    If using 1Password CLI v2 with Biometric security, this is rarely required.

			logout|signout
			    Invalidates your current authentication with the 1Password CLI tool.

			map <secret> [vault] [item] [field]
			    Map a secret to a specific 1Password vault, item, and field.

			    E.g. \`secret map MY_SECRET\` will ask you which of your vaults you would like to use,
			    then ask you which item inside that vault you would like to use,
			    then ask you which field inside that item you would like to use,
			    then it will map the MY_SECRET secret to that specification.
			    Once done, this enables \`secret get MY_SECRET\` and \`secret env MY_SECRET -- printf '%s\n' 'my secret is: \$MY_SECRET'\`.

			get [...<secret>]
			    Get the value of what the secret maps to, from the cache if possible, otherwise from 1Password's API if signed in.

			env ...<secret> -- <command> [args...]
			    Gets the value of the secret(s) and passes them as configured environment variables to solely the command.
			    This prevents exposing your secrets to your general shell, your shell history, and unauthorised commands,
			    as with this, only the command you intend to run is given the secrets.

			    E.g. \`secret env MY_SECRET -- printf '%s\n' 'my secret is: \$MY_SECRET'\` will get the value of \`MY_SECRET\`,
			    and provide it to the \`printf\` command's environment,
			    such that when it is interpolated into \`printf '%s\n' "my secret is: \$MY_SECRET"\`,
			    in which \`\$MY_SECRET\` will exist in that environment, and be outputted accordingly.

			unmap <secret>
			    Removes the mapping for the secret, such that its shorthand can no longer be fetched.

			invalidate [secret]
			    If a the secret argument was provided, then that secret alone will be cleared from the cache.
			    If no argument is provided, then all cached secrets will be cleared.

			fetch [vault] [item] [field]
			    Fetches the value of a field, from an item, from a 1Password vault.
			    If an argument is missing, you will be prompted to select its value from the available options.
			    Arguments can be partial values (for filtering), and can be the label or value.
			    Labels for vaults and items are converted to the UUID, to avoid conflicts against ambiguous names.
			    Results will be cached until they are invalidated by \`secret invalidate <secret>\` or unmapped by \`secret unmap <secret>\`.

			    E.g. \`secret fetch\` will ask you which of your vaults to use, then ask you which item inside that vault to use, then ask you which field inside that item to fetch the value for.

			https
			    Update all the login URLs in your 1Password vault to use HTTPS if they support it,
			    otherwise attempt several variations and use what does work,
			    and if nothing works, then advise that the service appears unresponsive and is likely ready for archiving.

			help
			    Output this help message.
		EOF
		return 22 # EINVAL 22 Invalid argument
	}

	# process
	local item action='' option_args=() option_conceal='no'
	while [[ $# -ne 0 ]]; do
		item="$1"
		shift
		case "$item" in
		'--help' | '-h') help ;;
		'--no-conceal'* | '--conceal'*) __flag --source={item} --target={option_conceal} --affirmative ;;
		'signin') action='login' ;;
		'signout') action='logout' ;;
		'--')
			option_args+=("$@")
			shift $#
			break
			;;
		*)
			if [[ -z $action ]]; then
				action="$item"
			else
				option_args+=("$item" "$@")
				shift $#
				break
			fi
			;;
		esac
	done

	# =====================================
	# Dependencies

	__command_required -- 'jq' || return
	__command_required -- 'op' || return

	# check compatibility
	local op_version
	op_version="$(op --version)"
	if [[ "$(version-compare "$op_version" 1)" -eq 0 ]]; then
		# https://developer.1password.com/docs/cli/v1/reference
		op_version=1
	elif [[ "$(version-compare "$op_version" 2)" -eq 0 ]]; then
		# https://developer.1password.com/docs/cli/upgrade
		# https://developer.1password.com/docs/cli/upgrade#step-2-update-your-scripts
		op_version=2
	else
		help "Unsupported 1Password CLI version: $op_version"
	fi

	# =====================================
	# Adjustments

	local actions=(
		'install'
		'login'
		'logout'
		'map'
		'env'
		'get'
		'invalidate'
		'unmap'
		'fetch'
		'https'
		'help'
	)
	action="$(
		choose \
			--question='What action do you wish to take?' \
			--skip-default --default="$action" -- "${actions[@]}"
	)"

	# =====================================
	# Configuration

	# database
	local sudo_reason='Your password is required to momentarily grant privileges to securely store and access the secrets.'
	local database="$DOROTHY/user/config.local/secrets.json"
	local op_cli_config="$XDG_CONFIG_HOME/op"
	function __correct_database_permission {
		__do --redirect-stdout=TTY -- fs-own --me --u --optional --recursive -- "$database" "$op_cli_config" || return
	}
	function __correct_key_permission {
		local state_key="$1"
		__do --redirect-stdout=TTY -- fs-own --root --u -- "$state_key" || return
	}
	if ! is-file --reason="$sudo_reason" -- "$database"; then
		fs-remove --quiet --no-confirm -- "$database"
		__print_lines '{}' | echo-write -- "$database"
	fi

	# move old state location to new state location
	local state="$XDG_STATE_HOME/secrets"
	if [[ -d "$DOROTHY/user/secrets" ]]; then
		mv -v -- "$DOROTHY/user/secrets" "$state"
	else
		__mkdirp "$state"
	fi

	# ensure env vars are available
	export OP_SESSION OP_SUBDOMAIN
	if [[ -z ${OP_SESSION-} ]]; then
		OP_SESSION=''
	fi
	if [[ -z ${OP_SUBDOMAIN-} ]]; then
		OP_SUBDOMAIN=''
	fi

	# conceal
	local ask_password_arguments=()
	if [[ $option_conceal == 'yes' ]]; then
		ask_password_arguments+=('--password')
	fi

	# =====================================
	# Action

	# cache actions
	function __cache_clear {
		fs-remove --quiet --elevate --no-confirm --optional -- "$state/"* || return
	}
	function __cache_exists {
		local key files=()
		for key in "$@"; do
			files+=("$state/$key")
		done
		is-file --reason="$sudo_reason" -- "${files[@]}"
		return
	}
	function __cache_delete {
		local key
		for key in "$@"; do
			fs-remove --quiet --elevate --no-confirm -- "$state/$key" || return
		done
	}
	function __cache_write {
		local key="$1" value="$2"
		__cache_delete "$key" || return
		if is-value -- "$value"; then
			__print_string "$value" >"$state/$key" || return
			__correct_key_permission "$state/$key" || return
		else
			__print_error 'Attempted to write an empty secret key ' --variable-value={key} || return
			return 1
		fi
	}
	function __cache_read {
		local key="$1" value
		if __cache_exists "$key"; then
			value="$(echo-file --raw --reason="$sudo_reason" -- "$state/$key" | tr -d '\n')" || return
			if is-value -- "$value"; then
				__print_string "$value" || return
			else
				__print_error 'Cached secret key ' --variable-value={key} ' was empty ' --variable-value={value} || return
				__cache_delete "$key" || return
				return 1
			fi
		else
			__print_error 'Cached secret key ' --variable-value={key} ' was missing.' || return
			return 1
		fi
	}
	function __cache_read_if_exists {
		local key="$1"
		if __cache_exists "$key"; then
			__cache_read "$key" || return
		fi
		return 0
	}

	# secret actions
	function __secret_get {
		local status key result vault item field value

		# handle the amount of keys
		if [[ $# -gt '1' ]]; then
			# convert many to one
			for key in "$@"; do
				__do --redirect-status={status} --redirect-stdout={value} -- __secret_get "$key" || return
				if [[ $status -ne 0 ]]; then
					__print_error 'Unable to fetch the secret key ' --variable-value={key} ' of many.' || return
					return 1
				fi
				__print_lines "$key=$value" || return
			done
			return 0
		elif [[ $# -eq 0 ]]; then
			# no keys, pick
			local secrets=() choices=()
			__split --target={secrets} --no-zero-length --invoke=try -- \
				jq -r 'keys_unsorted[]' "$database" || return
			if [[ ${#secrets[@]} -eq 0 ]]; then
				__print_error 'No secrets are mapped yet, run ' --code='secret map' ' to map a secret.' || return
				return 6 # ENXIO 6 Device not configured
			fi
			__split --target={choices} --no-zero-length --invoke -- \
				choose \
				--question='Which secret(s) do you want to get?' \
				--required --multi -- "${secrets[@]}" || return
			__secret_get "${choices[@]}" || return
			return
		fi
		# single key
		key="$1"

		# fetch from cache
		if __cache_exists "$key"; then
			__cache_read "$key" || return
			return 0
		fi

		# fetch from api
		vault="$(jq -r ".${key}[0]" "$database" || :)" || return
		item="$(jq -r ".${key}[1]" "$database" || :)" || return
		field="$(jq -r ".${key}[2]" "$database" || :)" || return
		if is-value -- "$vault" "$item" "$field"; then
			value="$(__fetch_field "$vault" "$item" "$field")"
		else
			__print_error 'Key ' --variable-value={key} ' was missing all three parts of its mapping:' --newline \
				--variable={vault} --newline \
				--variable={item} --newline \
				--variable={field} --newline \
				--newline \
				'Manually edit the database at ' --path="$database" ' or use the ' --code='secret map ...' ' command to set the mapping accordingly.' || return
			return 1
		fi
		if is-empty-value -- "$value"; then
			__print_error 'Key ' --variable-value={key} ' failed to resolve.' || return
			return 1
		fi
		__cache_write "$key" "$value" || return
		__print_string "$value" || return
	}

	# __secret_signout
	function __secret_signout {
		local status
		if [[ -z $OP_SESSION ]]; then
			__try {status} -- __cache_exists 'OP_SESSION' || return
			if [[ $status -eq 0 ]]; then
				OP_SESSION="$(__cache_read 'OP_SESSION')"
				if [[ $op_version -eq 2 ]]; then
					__do --discard-status --redirect-stdout=TTY -- op signout --session "$OP_SESSION" || return
				else
					__do --discard-status --redirect-stdout=TTY -- op signout --session="$OP_SESSION" || return
				fi
			fi
		else
			if [[ $op_version -eq 2 ]]; then
				__do --discard-status --redirect-stdout=TTY -- op signout --session "$OP_SESSION" || return
			else
				__do --discard-status --redirect-stdout=TTY -- op signout --session="$OP_SESSION" || return
			fi
		fi
		__cache_delete 'OP_SESSION' || return
		__cache_delete 'OP_SUBDOMAIN' || return
		OP_SESSION=''
	}

	# __secret_signin
	function __secret_signin {
		local email='' key='' status
		# setup permissions
		__correct_database_permission || return
		# signout
		__secret_signout || return
		# session
		if [[ -z $OP_SESSION ]]; then
			OP_SESSION="$(__cache_read_if_exists OP_SESSION)" || return
			if [[ -z $OP_SESSION ]]; then
				# subdomain
				if [[ -z $OP_SUBDOMAIN ]]; then
					OP_SUBDOMAIN="$(__cache_read_if_exists OP_SUBDOMAIN)" || return
					if [[ -z $OP_SUBDOMAIN ]]; then
						OP_SUBDOMAIN="$(
							ask --required "${ask_password_arguments[@]}" --question='What is your 1password subdomain?'
						)" || return
						__cache_write 'OP_SUBDOMAIN' "$OP_SUBDOMAIN" || return
					fi
				fi
				email="$(
					ask --required "${ask_password_arguments[@]}" \
						--question='What is your 1password email? This is not stored.'
				)" || return
				if [[ $op_version -eq 2 ]]; then
					__do --redirect-status={status} --copy-stdout={OP_SESSION} --redirect-stdout=TTY -- \
						op account add --address "$OP_SUBDOMAIN" --email "$email" --signin --raw || return
					# OP_SESSION will equal '' if biometric auth is used
				else
					key="$(
						ask --required "${ask_password_arguments[@]}" \
							--question='What is your 1password account key? This is not stored.'
					)" || return
					# unfortunately, this still leaks email and subdomain
					# https://1password.community/discussion/122030/flag-to-disable-op-signin-from-outputting-email-and-subdomain/p1?new=1
					# don't pipe to anything else, as it breaks the OTP question
					__do --redirect-status={status} --copy-stdout={OP_SESSION} --redirect-stdout=TTY -- \
						op signin "$OP_SUBDOMAIN" "$email" "$key" --raw || return
				fi
				if [[ $status -ne 0 ]]; then
					__print_error 'Failed to sign into ' --variable={OP_SUBDOMAIN} ' ' --variable={email} ' ' --variable={key} ' ' --variable{OP_SESSION} ' ' --status="$status" || return
					return "$status"
				fi
				if [[ -n $OP_SESSION ]]; then
					__cache_write 'OP_SESSION' "$OP_SESSION" || return
				else
					__cache_delete 'OP_SESSION' || return # biometric
				fi
			fi
		fi
	}

	function __op_wrap {
		local cmd=() status result
		if [[ -z $OP_SESSION ]] && __cache_exists "OP_SESSION"; then
			OP_SESSION="$(__cache_read OP_SESSION)" || return
		fi
		if [[ $op_version -eq 2 ]]; then
			cmd+=(op "$@" --session "$OP_SESSION")
		else
			cmd+=(op "$@" --session="$OP_SESSION")
		fi
		__do --redirect-status={status} --redirect-output={result} -- "${cmd[@]}" || return
		if [[ $status -ne 0 || $result == '[ERROR]'* ]]; then
			if [[ $result =~ (signed in|session expired) ]]; then
				__print_style --tty --notice='Session expired. Logging in...' || return
				__do --redirect-stdout=TTY -- __secret_signin || return
				__op_wrap "$@" || return
				return 0
			else
				__print_lines "$result" >&2 || return
				return "$status"
			fi
		else
			__print_string "$result" || return
		fi
	}

	function __get_values_id_and_name {
		if [[ $op_version -eq 2 ]]; then
			# https://developer.1password.com/docs/cli/reference/management-commands/vault#vault-list
			__op_wrap vault list --format=json | jq -r '.[] | (.id, .name)' || return
		else
			__op_wrap list vaults | jq -r '.[] | (.uuid, .name)' || return
		fi
	}

	function __get_items_id_and_title {
		local vault="$1"
		if [[ $op_version -eq 2 ]]; then
			# https://developer.1password.com/docs/cli/reference/management-commands/item#item-list
			__op_wrap item list --vault "$vault" --format json | jq -r '.[] | (.id, .title)' || return
		else
			__op_wrap list items --vault="$vault" | jq -r '.[] | (.uuid, .overview.title)' || return
		fi
	}

	function __op_grab {
		local vault="${1-}" item="${2-}" status=0 data
		# don't use > >(...) as that requires semaphores to prevent continuation beyond completion, and it seems that pipe works fine
		if is-empty-value -- "$vault"; then
			# fetch available values
			__get_values_id_and_name || return
			return
		elif is-empty-value -- "$item"; then
			# fetch available items
			__get_items_id_and_title "$vault" || return
			return
		else
			# fetch item
			if [[ $op_version -eq 2 ]]; then
				# https://developer.1password.com/docs/cli/reference/management-commands/item#item-get
				# https://stackoverflow.com/a/40321859
				# newlines in notes will produces superfluous tuples, so replace them four spaces
				# cli v2 needs null checks too
				__op_wrap item get "$item" --vault "$vault" --format json |
					jq -r '.fields[]? | select(.label != "" and .label != null and .value != "" and .value != null) | (.value, .label) | walk(if type == "string" then gsub("\\p{Cc}"; "    ") else . end)' || return
			else
				__do --redirect-stdout={data} -- \
					__op_wrap get item "$item" --vault="$vault" || return

				# section fields
				local fields_via_section=()
				__split --target={fields_via_section} --no-zero-length --invoke=try -- \
					jq -r '.details.sections[]? | select(.fields).fields[]? | select(.t != "" and .v != "") | (.v, .t)' <<<"$data" || return
				if [[ ${#fields_via_section[@]} -ge 2 ]]; then
					__print_lines "${fields_via_section[@]}" || return
				fi

				# name fields
				local fields_via_name=()
				__split --target={fields_via_name} --no-zero-length --invoke=try -- \
					jq -r '.details.fields[]? | select(.name != "" and .value != "") | (.value, .name)' <<<"$data" || return
				if [[ ${#fields_via_name[@]} -ge 2 ]]; then
					__print_lines "${fields_via_name[@]}" || return
				fi

				# designation fields
				local fields_via_designation=()
				__split --target={fields_via_designation} --no-zero-length --invoke=try -- \
					jq -r '.details.fields[]? | select(.designation != "" and .value != "") | (.value, .designation)' <<<"$data" || return
				if [[ ${#fields_via_designation[@]} -ge 2 ]]; then
					__print_lines "${fields_via_designation[@]}" || return
				fi
			fi
		fi
	}

	function __fetch_vault {
		local vault="${1-}" tuples=()

		# fetch available vaults
		__split --target={tuples} --no-zero-length --invoke=try -- \
			__op_grab || return
		if [[ ${#tuples[@]} -eq 0 ]]; then
			__print_error 'Failed to fetch vault:' --newline --="$(__dump vault)" || return
			return 1
		fi

		# filter or ask
		choose \
			--question="Which vault did you want with [$vault]?" \
			--default="$vault" --label --visual="\$LABEL [\$VALUE]" --match="\$VALUE" --match="\$LABEL" -- \
			"${tuples[@]}" || return
	}

	function __fetch_item {
		local vault="${1-}" item="${2-}" tuples=()

		# fetch available items
		__split --target={tuples} --no-zero-length --invoke=try -- \
			__op_grab "$vault" || return
		if [[ ${#tuples[@]} -eq 0 ]]; then
			__print_error 'Failed to fetch item:' --newline --="$(__dump vault item)" || return
			return 1
		fi

		# filter or ask
		choose \
			--question="Which item did you want with [$item]?" \
			--default="$item" --label --visual="\$LABEL [\$VALUE]" --match="\$VALUE" --match="\$LABEL" -- \
			"${tuples[@]}" || return
	}

	function __fetch_field {
		local vault="${1-}" item="${2-}" field="${3-}" tuples=()
		local wants
		if [[ ${4-} == '--label' ]]; then
			wants='$LABEL'
		else
			wants='$VALUE'
		fi

		# fetch available items
		__split --target={tuples} --no-zero-length --invoke=try -- \
			__op_grab "$vault" "$item" || return
		if [[ ${#tuples[@]} -eq 0 ]]; then
			__print_error 'Failed to fetch field:' --newline --="$(__dump vault item field)" || return
			return 1
		fi

		# filter or ask
		choose \
			--question="Which field did you want with [$field]?" \
			--default="$field" --label --visual="\$LABEL [\$VALUE]" --return="$wants" --match="\$LABEL" -- \
			"${tuples[@]}" || return
	}

	function __get_job_count {
		jobs -p | echo-count-lines --stdin || return
	}

	function __get_website {
		local vault="$1" item="$2"
		if [[ $op_version -eq 2 ]]; then
			# [select(.primary = true)] returns multiple urls
			__op_wrap item get "$item" --vault "$vault" --format json | jq -r '.urls[]? | .href' | echo-write --buffer | echo-first-line || return
		else
			__op_wrap get item "$item" --vault "$vault" --fields website || return
		fi
	}

	function __item_upgrade {
		local vault="$1" item="$2" website status new_website

		# fetch
		__do --redirect-status={status} --redirect-stdout={website} -- __get_website "$vault" "$item" || return
		if [[ $status -ne 0 ]]; then
			__print_style --stderr --variable={vault} ' ' --variable={item} ' ' --variable={website} ' ' --error='failed to fetch website' ' ' --status="$status" || :
			return 1
		fi
		if [[ -z $website ]]; then
			__print_style --tty --dim --variable={vault} ' ' --variable={item} ' ' --variable={website} ' ' --bold='skipping as no website.' || return
			return 0
		fi

		# upgrade
		new_website="$(get-url-upgrade "$website" 2>/dev/null || :)" || return
		if [[ -z $new_website ]]; then
			__print_style --stderr --variable={vault} ' ' --variable={item} ' ' --variable={website} ' ' -error='failed to upgrade, because the website is unresponsive, consider archiving instead.' || :
			return 1
		fi

		# check if changed
		if [[ $new_website == "$website" ]]; then
			__print_style --tty --dim --variable={vault} ' ' --variable={item} ' ' --variable={website} ' ' --success='already upgraded.' || return
			return 0
		fi

		# log
		__print_style --tty --variable={vault} ' ' --variable={item} ' ' --variable={website} --variable={new_website} ' ' --bold='applying...' || return

		# apply
		if [[ $op_version -eq 2 ]]; then
			__try {status} -- __op_wrap item edit "$item" --vault "$vault" --url "$new_website" --format json >/dev/null || return
		else
			__try {status} -- __op_wrap edit item "$item" --vault "$vault" website="$new_website" || return
		fi
		if [[ $status -ne 0 ]]; then
			__print_style --stderr --variable={vault} ' ' --variable={item} ' ' --variable={website} ' ' --variable={new_website} ' ' --error='failed to upgrade.' ' ' --status="$status" || :
			return 1
		fi
		__print_style --tty --variable={vault} ' ' --variable={item} ' ' --variable={website} --variable={new_website} ' ' --success='successfully applied.' || return
	}

	function __get_vaults {
		if [[ $op_version -eq 2 ]]; then
			__op_wrap vault list --format json | jq -r '.[].id' | echo-write --buffer | sort || return
		else
			__op_wrap list vaults | jq -r '.[].uuid' | echo-write --buffer | sort || return
		fi
	}
	function __get_items {
		local vault="$1"
		if [[ $op_version -eq 2 ]]; then
			__op_wrap item list --categories Login --vault "$vault" --format json | jq -r '.[].id' | echo-write --buffer | sort || return
		else
			__op_wrap list items --categories Login --vault "$vault" | jq -r '.[].uuid' | echo-write --buffer | sort || return
		fi
	}

	function __secret_https {
		local last="${1-}" status vault item
		__do --redirect-status={status} --redirect-stdout={vaults} -- __get_vaults || return
		if [[ $status -ne 0 || -z $vaults ]]; then
			__print_error 'Failed to fetch vaults...' || :
			return 1
		fi
		for vault in $vaults; do
			__do --redirect-status={status} --redirect-stdout={items} -- __get_items "$vault" || return
			if [[ $status -ne 0 || -z $items ]]; then
				__print_style --stderr --variable={vault} ' ' --error='failed to fetch items.' || :
				status=1
				continue
			fi
			# ignoring of status code is in case it returned a vault we don't have write access to
			for item in $items; do
				# resume
				if [[ -n $last ]]; then
					if [[ $item == "$last" ]]; then
						# stop skipping
						last=''
					else
						# continue skipping
						__print_style --stderr --dim --variable={vault} ' ' --variable={item} ' ' --bold='skipping.' || :
						continue
					fi
				fi
				while [[ "$(__get_job_count)" -eq 15 ]]; do
					sleep 3
				done
				(__item_upgrade "$vault" "$item" || :) &
			done
		done

		# @todo get failure status for the jobs
		# wait for completed jobs, then note completion
		local -i count
		count="$(__get_job_count)"
		while [[ $count -ne 0 ]]; do
			__print_style --tty --notice="Waiting on $count jobs..." || return
			sleep 3
			jobs &>/dev/null # for some reason, this seems necessary to prevent hung jobs
			count="$(__get_job_count)"
		done
		__print_style --tty --success='All done.' || return
	}

	function __secret_fetch {
		local vault item
		vault="$(__fetch_vault "${1-}")" || return
		item="$(__fetch_item "$vault" "${2-}")" || return
		__fetch_field "$vault" "$item" "${3-}" || return
	}

	function __secret_map {
		local secret vault item field
		secret="$(
			ask --required \
				--question='What shall the name of the environment variable (secret) be?' \
				--default="${1-}"
		)" || return
		vault="$(__fetch_vault "${2-}")" || return
		item="$(__fetch_item "$vault" "${3-}")" || return
		field="$(__fetch_field "$vault" "$item" "${4-}" --label)" || return
		jq -r \
			--arg secret "$secret" \
			--arg vault "$vault" \
			--arg item "$item" \
			--arg field "$field" \
			'.[$secret] = [$vault, $item, $field]' \
			"$database" | echo-write --atomic -- "$database" || return
		__print_style --stderr \
			'Successfully updated ' --path="$database" ' so that ' --variable-value={secret} ' fetches ' --variable={vault} ' ' --variable={item} ' ' --variable={field} --newline \
			'Fetching ' --variable-value={secret] '...' || return
		__cache_delete "$secret" || return
		__secret_get "$secret" || return
	}

	function __secret_unmap {
		local secret
		secret="$(
			ask --required \
				--question='What environment variable (secret) name do you wish to unmap?' \
				--default="${1-}"
		)" || return
		jq -r \
			--arg secret "$secret" \
			'del(.[$secret])' \
			"$database" | echo-write --atomic -- "$database" || return
		__cache_delete "$secret" || return
		__print_style --stderr 'Successfully unmapped ' --variable-value={secret} || return
	}

	function __secret_env {
		local before=() after=() found='no' args item
		local keys key value
		local env_secrets env_args env_arg

		while [[ $# -ne 0 ]]; do
			item="$1"
			shift
			case "$item" in
			'--')
				found='yes'
				after+=("$@")
				shift $#
				break
				;;
			*)
				before+=("$item")
				;;
			esac
		done

		# ensure we have valid arguments, before -- and after --
		if [[ $found == 'yes' ]] && is-not-whitespace -- "${before[@]}" && is-not-whitespace -- "${after[@]}"; then
			keys=("${before[@]}")
			args=("${after[@]}")
		else
			help --code='secret env' ' requires ' --code='--' ' separator' --newline \
				--variable={found} --newline \
				--variable={before} --newline \
				--variable={after} || return
		fi

		# load secrets
		env_secrets=()
		for key in "${keys[@]}"; do
			value="$(__secret_get "$key")" || return
			env_secrets+=("$key=$value")
		done

		# replace secrets in args
		env_args=()
		for arg in "${args[@]}"; do
			env_arg="$arg"
			for key in "${keys[@]}"; do
				value="$(__secret_get "$key")" || return
				env_arg="${env_arg//\$$key/$value}"
			done
			env_args+=("$env_arg")
		done

		# __print_lines "loaded secrets:  ${vars[*]}"
		# __print_lines "running command: ${args[*]}"
		# __print_line

		env "${env_secrets[@]}" "${env_args[@]}" || return
	}

	# =====================================
	# Act

	function __ensure_authed {
		local status
		# @todo this is probably where it hangs and we are hiding input so we don't know: https://github.com/bevry/dorothy/issues/209
		__do --redirect-status={status} --discard-output -- __op_wrap account list || return
		if [[ $status -ne 0 ]]; then
			__secret_signin || return
		fi
	}

	if [[ $action == 'install' ]]; then
		setup-util-1password-cli --upgrade
	elif [[ $action == 'login' ]]; then
		__secret_signin
	elif [[ $action == 'logout' ]]; then
		__secret_signout
	elif [[ $action == 'map' ]]; then
		__ensure_authed
		__secret_map "${option_args[@]}"
	elif [[ $action == 'env' ]]; then
		__ensure_authed
		__secret_env "${option_args[@]}"
	elif [[ $action == 'get' ]]; then
		__ensure_authed
		if [[ -n ${option_args[*]} ]]; then
			__secret_get "${option_args[@]}"
		else
			__secret_get
		fi
	elif [[ $action == 'invalidate' ]]; then
		if [[ -n ${option_args[*]} ]]; then
			__cache_delete "${option_args[@]}"
		else
			__cache_clear
		fi
	elif [[ $action == 'unmap' ]]; then
		__ensure_authed
		__secret_unmap "${option_args[@]}"
	elif [[ $action == 'fetch' ]]; then
		__ensure_authed
		__secret_fetch "${option_args[@]}"
	elif [[ $action == 'https' ]]; then
		__ensure_authed
		__secret_https "${option_args[@]}"
	elif [[ $action == 'help' ]]; then
		help
	else
		help 'Invalid <action>'
	fi
)

# fire if invoked standalone
if [[ $0 == "${BASH_SOURCE[0]}" ]]; then
	secret_ "$@"
fi
