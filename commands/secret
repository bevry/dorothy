#!/usr/bin/env bash
source "$DOROTHY/sources/essentials.sh"
source "$DOROTHY/sources/edit.sh"
source "$DOROTHY/sources/strict.bash"
# source "$DOROTHY/sources/debug.bash"
# @NOTE do not use the `ok` command instead of `|| :` â€” this file uses functions, and the `ok` command only works with commands

# dependencies
env QUIET=y setup-util-jq
env QUIET=y CLI=op CASK='1password-cli' setup-util

# quiet mode: whether or not we output account details
quiet='no'
if is-affirmative "${QUIET-}"; then
	quiet='yes'
fi

# Location
if test -z "${SECRETS-}"; then
	SECRETS="$DOROTHY/user/secrets"
fi
mkdir -p "$SECRETS"

# Make this global to this script
export OP_SESSION
export OP_SUBDOMAIN
export database="$SECRETS/secrets.json"

# Write the database if it does not exist
if ! sudo test -f "$database"; then
	echo '{}' | sudo tee "$database"  &>/dev/null
fi

function cache_clear() {
	t="$(mktemp)"
	mv "$database" "$t"
	sudo rm -Rf "$SECRETS/"*
	mv "$t" "$database"
}

function cache_exists() {
	for key in "$@"; do
		sudo test -f "$SECRETS/$key"
		if test "$?" -ne 0; then
			return 1
		fi
	done
}

function cache_delete() {
	for key in "$@"; do
		sudo rm -f "$SECRETS/$key"
		if test "$?" -ne 0; then
			return 1
		fi
	done
}

function cache_write() {
	key="$1"
	value="$2"
	cache_delete "$key"
	if is-value "$value"; then
		echo -n "$value" >"$SECRETS/$key"
		sudo chown root: "$SECRETS/$key"
		sudo chmod 600 "$SECRETS/$key"
	else
		stderr echo "ERROR: wanted to write empty secret: $key"
		return 1
	fi
}

function cache_read() {
	key="$1"
	if cache_exists "$key"; then
		value="$(sudo cat "$SECRETS/$key" | tr -d '\n')"
		if is-value "$value"; then
			echo -n "$value"
		else
			stderr echo "ERROR: cached secret [$key] was empty [$value]"
			cache_delete "$key"
			return 1
		fi
	else
		stderr echo "ERROR: cached secret [$key] was missing"
		return 1
	fi
}

function fetch_secret() {
	# many
	if test "${#@}" -gt '1'; then
		for var in "$@"; do
			value="$(fetch_secret "$var")"
			if test "$?" -ne 0; then
				stderr echo "ERROR: Unable to fetch the secret [$var] of many"
				return 1
			fi
			echo "$var=$value"
		done
		return
	fi

	# singular
	key="$1"
	result="$( (cache_exists "$key" && cache_read "$key") || :)"
	if test "$?" -ne 0; then
		stderr echo "ERROR: Unable to fetch the secret [$var]"
		return 1
	fi

	# fetch
	if test -n "$result"; then
		echo -n "$result"
	else
		vault="$(sudo jq -r ".${key}[0]" "$database")"
		item="$(sudo jq -r ".${key}[1]" "$database")"
		field="$(sudo jq -r ".${key}[2]" "$database")"
		if is-value "$vault" && is-value "$item" && is-value "$field"; then
			value="$(fetch_field "$vault" "$item" "$field")"
		else
			stderr echo "ERROR: [$database] needs [$key] to have all three parts of its mapping: [$vault, $item, $field]"
			stderr echo "Use the [secret map ...] command to set the mapping accordingly."
			return 1
		fi
		if is-empty-value "$value"; then
			stderr echo "ERROR: resolve returned nothing for: $key"
			return 1
		fi
		cache_write "$key" "$value"
		echo -n "$value"
	fi
}


function secret_signout() {
	echo 'Signing out...'
	if test -z "${OP_SESSION-}"; then
		if cache_exists "OP_SESSION"; then
			OP_SESSION="$(cache_read OP_SESSION)"
			op signout --session="$OP_SESSION" 2>&1 || :
		fi
	else
		op signout --session="$OP_SESSION" 2>&1 || :
	fi
	cache_delete "OP_SESSION"
	cache_delete "OP_SUBDOMAIN"
	OP_SESSION=''
	echo 'Signed out.'
}

function secret_signin() {
	# session
	echo 'Signing in...'
	if test -z "${OP_SESSION-}"; then
		OP_SESSION="$( (cache_exists OP_SESSION && cache_read OP_SESSION) || :)"
		if test -z "$OP_SESSION"; then
			# subdomain
			if test -z "${OP_SUBDOMAIN-}"; then
				OP_SUBDOMAIN="$( (cache_exists OP_SUBDOMAIN && cache_read OP_SUBDOMAIN) || :)"
				if test -z "${OP_SUBDOMAIN-}"; then
					OP_SUBDOMAIN="$(env PASS="$quiet" ask-mandatory 'What is your 1password subdomain?')"
					cache_write "OP_SUBDOMAIN" "$OP_SUBDOMAIN"
				fi
			fi
			# email
			email="$(env PASS="$quiet" ask-mandatory 'What is your 1password email? This is not stored.')"
			# secret
			key="$(env PASS="$quiet" ask-mandatory 'What is your 1password account key? This is not stored.')"
			# signin
			# unfortunately, this still leaks email and subdomain
			# https://1password.community/discussion/122030/flag-to-disable-op-signin-from-outputting-email-and-subdomain/p1?new=1
			OP_SESSION="$(op signin "$OP_SUBDOMAIN" "$email" "$key" --raw)"  # don't pipe to anything else, as it breaks the OTP question
			if test "$?" -ne 0; then
				stderr echo "ERROR: Failed to sign into [$OP_SUBDOMAIN] via the email [$email] and account key [$key]."
				stderr echo "$OP_SESSION"
				return 1
			fi
			cache_write "OP_SESSION" "$OP_SESSION"
		fi
	fi
	echo 'Signed in.'
}

function opwrap () {
	result="$(op "$@" 2>&1 || :)"
	if test "$?" -ne 0 || [[ "$result" = '[ERROR]'* ]]; then
		if [[ "$result" = *'signed in'* ]] || [[ "$result" = *'session expired'* ]]; then
			stderr echo "ERROR: Session expired, run [secret signin] and try again."
			return 1
		fi
		stderr echo "FAILURE: $result"
		return 1
	else
		echo -n "$result"
	fi
}

function opgrab() {
	vault="${1-}"
	item="${2-}"

	if is-empty-value "$vault"; then
		# fetch available values
		opwrap list vaults --session="$OP_SESSION"
	elif is-empty-value "$item"; then
		# fetch available items
		opwrap list items --vault="$vault" --session="$OP_SESSION"
	else
		# fetch item
		opwrap get item "$item" --vault="$vault" --session="$OP_SESSION"
	fi

	return "$?"
}

function fetch_vault () {
	vault="${1-}"

	# fetch available vaults
	mapfile -t tuples <<<"$(opgrab | jq -r '.[] | (.name, .uuid)')"
	if test "$?" -ne 0 -o "${#tuples[@]}" -le 1; then
		return 1
	fi

	# filter or ask
	choose-tuple 'Which vault do you want?' "$vault" -- "${tuples[@]}"
	return "$?"
}

function fetch_item () {
	vault="${1-}"
	item="${2-}"

	# fetch available items
	mapfile -t tuples <<<"$(opgrab "$vault" | jq -r '.[] | (.overview.title, .uuid)')"
	if test "$?" -ne 0 -o "${#tuples[@]}" -le 1; then
		return 1
	fi

	# filter or ask
	choose-tuple 'Which item do you want?' "$item" -- "${tuples[@]}"
	return "$?"
}

function fetch_field () {
	vault="${1-}"
	item="${2-}"
	field="${3-}"
	if test "${4-}" = '--label'; then
		option='label'
	else
		option='value'
	fi

	# fetch available items
	data="$(opgrab "$vault" "$item")"
	fields=()
	mapfile -t fields_via_section <<<"$(echo "$data" | jq -r '.details.sections[]? | select(.fields).fields[]? | select(.t != "" and .v != "") | (.t, .v)')"
	if test "$?" -eq 0 -a "${#fields_via_section[@]}" -ge 2; then
		fields+=("${fields_via_section[@]}")
	fi
	mapfile -t fields_via_name <<<"$(echo "$data" | jq -r '.details.fields[]? | select(.name != "" and .value != "") | (.name, .value)')"
	if test "$?" -eq 0 -a "${#fields_via_name[@]}" -ge 2; then
		fields+=("${fields_via_name[@]}")
	fi
	mapfile -t fields_via_designation <<<"$(echo "$data" | jq -r '.details.fields[]? | select(.designation != "" and .value != "") | (.designation, .value)')"
	if test "$?" -eq 0 -a "${#fields_via_designation[@]}" -ge 2; then
		fields+=("${fields_via_designation[@]}")
	fi

	# filter or ask
	env VALUE_IN_LABEL=never RETURN="$option" choose-tuple 'Which field do you want?' "$field" -- "${fields[@]}"
	return "$?"
}

function get_job_count () {
	jobs -p | get-line-count
}

function item_upgrade () {
	vault="$1"
	item="$2"
	# fetch
	website="$(opwrap get item --session="$OP_SESSION" --vault "$vault" "$item" - --fields website)"
	if test "$?" -ne 0; then
		echo "[$item] [$website] failed to fetch"
		return 1
	fi
	if test -z "$website"; then
		stderr echo "[$item] [$website] empty"
		return 1
	fi
	# upgrade
	result="$(silent-stderr get-url-upgrade "$website" || :)"
	if test -z "$result"; then
		# echo to stdout, as is actionable for user if they are piping
		echo "[$item] [$website] unresponsive, consider archiving"
		return 1
	fi
	# check if changed
	if test "$result" = "$website"; then
		stderr echo "[$item] [$website] already upgraded"
		return 1
	fi
	# echo to stdout, as is actionable for user if they are piping
	echo "[$item] [$website] => [$result]"
	# apply
	opwrap edit item --session="$OP_SESSION" --vault "$vault" "$item" website="$result"
	if test "$?" -ne 0; then
		stderr echo "[$item] [$website] failed to save"
		return 1
	fi
}

function secret_https() {
	last="${1-}"
	vaults="$(opwrap list vaults --session="$OP_SESSION" | jq -r '.[].uuid' | sort || :)"
	if test "$?" -ne 0 -o -z "$vaults"; then
		stderr echo "failed to fetch vaults..."
		return 1
	fi
	for vault in $vaults; do
		items="$(opwrap list items --session="$OP_SESSION" --categories Login --vault "$vault" | jq -r '.[].uuid' | sort || :)"
		if test "$?" -ne 0 -o -z "$vaults"; then
			stderr echo "failed to fetch items from vault [$vault]"
			return 1
		fi
		# ignoring of status code is in case it returned a vault we don't have write access to
		for item in $items; do
			# resume
			if test -n "$last"; then
				if test "$item" = "$last"; then
					# stop skipping
					last=''
				else
					# continue skipping
					echo "[$item] skipping"
					continue
				fi
			fi
			while test "$(get_job_count)" -eq 15; do
				sleep 1
			done
			(item_upgrade "$vault" "$item" || :) &
		done
	done
	# wait for completed jobs, then note completion
	while test "$(get_job_count)" -ne 0; do
		echo "Waiting on [$(get_job_count)] jobs..."
		sleep 5
		jobs &> /dev/null # for some reason, this seems necessary to prevent hung jobs
	done
	echo 'All done.'
}

function secret_map() {
	secret="$(ask-mandatory 'What shall the name of the environment variable (secret) be?' "${1-}")"
	vault="$(fetch_vault "${2-}")"
	item="$(fetch_item "$vault" "${3-}")"
	field="$(fetch_field "$vault" "$item" "${4-}" --label)"
	result="$(sudo jq -r \
		--arg secret "$secret" \
		--arg vault "$vault" \
		--arg item "$item" \
		--arg field "$field" \
		'.[$secret] = [$vault, $item, $field]' \
		"$database")"
	echo "$result" | sudo tee "$database" &>/dev/null
	sudo chown root "$database"
	sudo chmod 600 "$database"
	stderr echo "Sucessfully updated [$database] so that [$secret] fetches [$vault].[$item].[$field]"
	stderr echo "Fetching [$secret]..."
	cache_delete "$secret"
	fetch_secret "$secret"
}

function secret_unmap() {
	secret="$(ask-mandatory 'What environment variable (secret) name do you wish to unmap?' "${1-}")"
	echo 'Enter your sudo password to update the database with the correct permissions...'
	result="$(sudo jq -r \
		--arg secret "$secret" \
		'del(.[$secret])' \
		"$database")"
	echo "$result" | sudo tee "$database"
	sudo chown root "$database"
	sudo chmod 600 "$database"
	cache_delete "$secret"
	stderr echo "Sucessfully unmapped [$secret]"
}

function secret_env() {
	before=()
	after=()
	found='no'

	for arg in "$@"; do
		if test "$arg" = '--'; then
			found='yes'
			continue
		fi
		if test "$found" = 'yes'; then
			after+=("$arg")
		else
			before+=("$arg")
		fi
	done

	if test "$found" = 'yes' -a "${#before[@]}" -ne '0' -a "${#after[@]}" -ne '0'; then
		vars=("${before[@]}")
		args=("${after[@]}")
	else
		stderr echo 'ERROR: -- was not found. Refer to usage.'
		return 1
		# vars=()
		# args=("${before[@]}")
	fi

	# load secrets
	envSecrets=()
	for var in "${vars[@]}"; do
		value="$(fetch_secret "$var")"
		envSecrets+=("$var=$value")
	done

	# replace secrets in args
	envArgs=()
	for arg in "${args[@]}"; do
		envArg="$arg"
		for var in "${vars[@]}"; do
			value="$(fetch_secret "$var")"
			envArg="${envArg//\$$var/$value}"
		done
		envArgs+=("$envArg")
	done

	# echo "loaded secrets:  ${vars[*]}"
	# echo "running command: ${args[*]}"
	# echo ''

	env "${envSecrets[@]}" "${envArgs[@]}"
}

if test -n "${1-}"; then
	if test "$1" = "env"; then
		secret_signin >&2 # redirect function to stderr
		secret_env "${@:2}"
	elif test "$1" = "clear" -o "$1" = "delete"; then
		if is-string "${2-}"; then
			cache_delete "${@:2}"
		else
			cache_clear
		fi
	elif test "$1" = "edit"; then
		edit "$database"
	elif test "$1" = "signin" -o "$1" = "login"; then
		secret_signout
		secret_signin
	elif test "$1" = "signout" -o "$1" = "logout"; then
		secret_signout
	elif test "$1" = "refresh"; then
		secret_signin >&2 # redirect function to stderr
		if is-string "$2"; then
			cache_delete "${@:2}"
			fetch_secret "${@:2}"
		else
			stderr echo 'ERROR: <name> was not found. Refer to usage.'
			exit 1
		fi
	elif test "$1" = "get" -o "$1" = "fetch"; then
		secret_signin >&2 # redirect function to stderr
		if is-string "$2"; then
			fetch_secret "${@:2}"
		else
			stderr echo 'ERROR: <name> was not found. Refer to usage.'
			exit 1
		fi
	elif test "$1" = "upgrade"; then
		# https://app-updates.agilebits.com/product_history/CLI
		brew install --cask 1password-cli --force
		# if contains-string "$(op update)" "available"; then
		# 	brew install --cask 1password-cli --force
		# fi
	elif test "$1" = "map"; then
		secret_signin >&2 # redirect function to stderr
		secret_map "${@:2}"
	elif test "$1" = "unmap"; then
		secret_unmap "${@:2}"
	elif test "$1" = "https"; then
		secret_signin >&2 # redirect function to stderr
		secret_https "${@:2}"
	else
		stderr echo 'invalid command'
	fi
else
	stderr echo 'USAGE:'
	stderr echo 'secret upgrade'
	stderr echo 'secret edit'
	stderr echo 'secret signin'
	stderr echo 'secret signout'
	stderr echo 'secret clear'
	stderr echo 'secret clear <name>'
	stderr echo 'secret refresh <name>'
	stderr echo 'secret get <name>'
	stderr echo 'secret env <secret...> -- <command> [args...]'
	stderr echo 'secret map <environment variable / secret name> <vault name> <item name> <field name>'
	stderr echo 'secret unmap <environment variable / secret name>'
	stderr echo 'secret https'
	# stderr echo 'secret fetch <vault name> <item name>'
fi
