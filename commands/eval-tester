#!/usr/bin/env bash

function eval_tester() (
	source "$DOROTHY/sources/bash.bash"
	source "$DOROTHY/sources/tty.bash"

	# =====================================
	# Arguments

	function help {
		cat <<-EOF >/dev/stderr
			USAGE:
			eval-tester [...options] -- <command> [...args]

			OPTIONS:
			--name=<test name>
			--status=<expected exit code> (defaults to 0)
			--ignore-status
			--stdout=<expected stdout> (defaults to empty)
			--ignore-stdout
			--stderr=<expected stderr> (defaults to empty)
			--ignore-stderr
			--debug (implies --ignore-stderr)
			--bash=<bash path>
			    Used to ensure that the command is invoked through a specific bash binary. Defaults to the env var EVAL_TESTER_BASH.
		EOF
		if test "$#" -ne 0; then
			echo-error "$@"
		fi
		return 22 # EINVAL 22 Invalid argument
	}

	# process
	local item cmd=() ignore_option=$'\e' option_name='' option_status='0' option_stdout='' option_stderr='' option_debug='no' option_bash="${EVAL_TESTER_BASH-}"
	while test "$#" -ne 0; do
		item="$1"
		shift
		case "$item" in
		'--help' | '-h') help ;;
		'--name='*) option_name="${item#*--name=}" ;;
		'--bash='*) option_bash="${item#*--bash=}" ;;
		'--ignore-status') option_status="$ignore_option" ;;
		'--ignore-stdout') option_stdout="$ignore_option" ;;
		'--ignore-stderr') option_stderr="$ignore_option" ;;
		'--status='*) option_status="${item#*--status=}" ;;
		'--stdout='*) option_stdout="${item#*--stdout=}" ;;
		'--stderr='*) option_stderr="${item#*--stderr=}" ;;
		'--no-debug'* | '--debug'*)
			option_debug="$(get-flag-value debug --missing="$option_debug" -- "$item" | echo-affirmative --stdin)"
			;;
		'--')
			cmd+=("$@")
			shift $#
			break
			;;
		'--'*) help "An unrecognised flag was provided: $item" ;;
		*) help "An unrecognised argument was provided: $item" ;;
		esac
	done

	# if invoking a dorothy command (not a function, nor things like cat), then support debug and custom bash
	# otherwise, custom bash not necessary as already inherited
	# and debug-bash not possible
	local cmd_path
	cmd_path="$(type -P "${cmd[0]}" 2>/dev/null || :)"
	if test -n "$cmd_path" && [[ $cmd_path == "$DOROTHY"* ]]; then
		cmd[0]="$cmd_path"
		if test "$option_debug" = 'yes'; then
			cmd=(
				'debug-bash'
				"--bash=$option_bash"
				'--'
				"${cmd[@]}"
			)
		elif test -n "$option_bash"; then
			cmd=(
				"$option_bash"
				"${cmd[@]}"
			)
		fi
	fi

	# =====================================
	# Action

	# run the command
	local args=() cmd_status stdout stderr cmd_string fail='no' title='' using_tty_stderr_fallback='no'
	cmd_string="$(echo-quote -- "${cmd[@]}" | echo-join ' ' --stdin)"
	if ! is-tty; then
		using_tty_stderr_fallback='yes'
	fi
	if test -n "$option_name"; then
		title="$option_name: $cmd_string"
	else
		title="$cmd_string"
	fi
	if test -n "$option_status" -a "$option_status" != "$ignore_option"; then
		args+=('--statusvar=cmd_status')
	fi
	if test "$option_stdout" != "$ignore_option"; then
		args+=('--stdoutvar=stdout')
	else
		args+=('--no-stdout')
	fi
	if test "$option_debug" = 'yes' -o "$using_tty_stderr_fallback" = 'yes'; then
		: # allow stdderr to go directly to stderr
	elif test "$option_stderr" != "$ignore_option"; then
		args+=('--stderrvar=stderr')
	else
		args+=('--no-stderr')
	fi
	echo-segment --h3="$title"
	eval_capture "${args[@]}" -- "${cmd[@]}"

	# test exit code
	if test -n "$option_status" -a "$option_status" != "$ignore_option"; then
		if test "$option_status" -ne "$cmd_status"; then
			fail='yes'
			echo-style --red="Actual Exit Code [$cmd_status]  !=  Expected Exit Code [$option_status]"
		else
			echo-style --green="Actual Exit Code [$cmd_status]  ==  Expected Exit Code [$option_status]"
		fi
	fi

	# test stdout
	if test "$option_stdout" != "$ignore_option"; then
		if test "$option_stdout" != "$stdout"; then
			fail='yes'
			echo-style --red="Actual Stdout  !=  Expected Stdout" $'\n' \
				--h3='< actual stdout>' $'\n' \
				"$stdout" $'\n' \
				--h3='</ actual stdout>' $'\n' \
				--h3='< expected stdout>' $'\n' \
				"$option_stdout" $'\n' \
				--h3='</ expected stdout>'
		else
			echo-style --green="Actual Stdout  ==  Expected Stdout"
		fi
	fi

	# test stderr
	if test "$option_stderr" != "$ignore_option"; then
		if test "$option_debug" = 'yes'; then
			echo-style --notice='Unable to test stderr, as debugging.'
		elif test "$using_tty_stderr_fallback" = 'yes'; then
			echo-style --notice='Unable to test stderr, as it will be filled with TTY output.'
		elif test "$option_stderr" != "$stderr"; then
			fail='yes'
			echo-style --red="Actual Stderr  !=  Expected Stderr" $'\n' \
				--h3='< actual stderr>' $'\n' \
				"$stderr" $'\n' \
				--h3='</ actual stderr>' $'\n' \
				--h3='< expected stderr>' $'\n' \
				"$option_stderr" $'\n' \
				--h3='</ expected stderr>'
		else
			echo-style --green="Actual Stderr  ==  Expected Stderr"
		fi
	fi

	# pass or fail
	if test "$fail" = 'yes'; then
		echo-segment --e3="$title" $'\n'
		return 1
	else
		echo-segment --g3="$title" $'\n'
	fi
)

# fire if invoked standalone
if test "$0" = "${BASH_SOURCE[0]}"; then
	eval_tester "$@"
fi
