#!/usr/bin/env bash

function eval_tester() (
	source "$DOROTHY/sources/bash.bash"
	source "$(type -P debug-bash)"

	# =====================================
	# Arguments

	function help {
		cat <<-EOF >&2
			USAGE:
			eval-tester [...options] -- <command> [...args]

			OPTIONS:
			--name=<test name>
			--status=<expected exit code> (defaults to 0)
			--ignore-status
			--stdout=<expected stdout> (defaults to empty)
			--ignore-stdout
			--stderr=<expected stderr> (defaults to empty)
			--ignore-stderr
			--debug (implies --ignore-stderr)
			    Will run the command with debugging enabled.
			--bash=<bash path>
			    Used to ensure that the command is invoked through a specific bash binary.
		EOF
		if [[ $# -ne 0 ]]; then
			echo-error "$@"
		fi
		return 22 # EINVAL 22 Invalid argument
	}

	# process
	local item option_cmd=() ignore_option=$'\e' option_name='' option_bash='' option_status='0' option_stdout='' option_stderr='' option_debug=''
	while [[ $# -ne 0 ]]; do
		item="$1"
		shift
		case "$item" in
		'--help' | '-h') help ;;
		'--name='*) option_name="${item#*=}" ;;
		'--bash='*) option_bash="${item#*=}" ;; # unlike [dorothy test] and [debug-bash] only support a single bash binary here, as nothing else makes sense for the [eval-tester] use case, as it is for getting specific results for a specific bash version
		'--ignore-status') option_status="$ignore_option" ;;
		'--ignore-stdout') option_stdout="$ignore_option" ;;
		'--ignore-stderr') option_stderr="$ignore_option" ;;
		'--status='*) option_status="${item#*=}" ;;
		'--stdout='*) option_stdout="${item#*=}" ;;
		'--stderr='*) option_stderr="${item#*=}" ;;
		'--no-debug'* | '--debug'*)
			option_debug="$(get-flag-value --affirmative --fallback="$option_debug" -- "$item")"
			;;
		'--')
			option_cmd+=("$@")
			shift $#
			break
			;;
		'--'*) help "An unrecognised flag was provided: $item" ;;
		*) help "An unrecognised argument was provided: $item" ;;
		esac
	done

	# if debugging, or custom bash, wrap in debug_bash
	if [[ $option_debug == 'yes' && -n $option_bash ]]; then
		option_cmd=(debug_bash -x --bash="$option_bash" -- "${option_cmd[@]}")
	elif [[ $option_debug == 'yes' ]]; then
		option_cmd=(debug_bash -x -- "${option_cmd[@]}")
	elif [[ -n $option_bash ]]; then
		option_cmd=(debug_bash --bash="$option_bash" -- "${option_cmd[@]}")
	fi

	# =====================================
	# Action

	local FAIL='no'
	function __compare {
		local name="$1" actual="$2" expected="$3" actual_escaped expected_escaped actual_file expected_file
		if [[ $actual == "$expected" ]]; then
			echo-style --success="actual $name  ==  expected $name"
		else
			FAIL='yes'
			if [[ $actual =~ [[:cntrl:]] || $expected =~ [[:cntrl:]] ]]; then
				actual_escaped="$(printf '%q' "$actual")"
				expected_escaped="$(printf '%q' "$expected")"
				echo-style --header3+red="<actual escaped $name>" --newline \
					"$actual_escaped" --newline \
					--header3+red="</actual escaped $name>" --newline \
					--header3+red="<expected escaped $name>" --newline \
					"$expected_escaped" --newline \
					--header3+red="</expected escaped $name>"
			else
				echo-style --error="actual $name  !=  expected $name" --newline \
					--header3+red="<actual $name>" --newline \
					"$actual" --newline \
					--header3+red="</actual $name>" --newline \
					--header3+red="<expected $name>" --newline \
					"$expected" --newline \
					--header3+red="</expected $name>"
			fi
			actual_file="$(fs-temp --directory='eval-tester' --file)"
			expected_file="$actual_file.expected"
			actual_file="$actual_file.actual"
			__print_string "$actual" >"$actual_file"
			__print_string "$expected" >"$expected_file"
			fs-diff --before="$expected_file" --after="$actual_file" || :
		fi
	}
	function __dump {
		local name="$1" actual="$2"
		echo-style \
			--header3="<actual $name>" --newline \
			"$actual" --newline \
			--header3="</actual $name>"
		if [[ $actual =~ [[:cntrl:]] ]]; then
			echo-style --header3="<actual escaped $name>" --newline \
				"$(printf '%q' "$actual")" --newline \
				--header3="</actual escaped $name>"
		fi
	}

	# run the command
	local args=() actual_exit_status actual_stdout actual_stderr cmd_string title='' can_test_stderr='yes'
	cmd_string="$(echo-escape-command -- "${option_cmd[@]}")"
	if [[ -n $option_name ]]; then
		title="$option_name: $cmd_string"
	else
		title="$cmd_string"
	fi
	if ! __has_tty_support; then
		can_test_stderr='no'
	fi

	# capture
	args+=('--redirect-status={actual_exit_status}')
	args+=('--redirect-stdout={actual_stdout}')
	args+=('--redirect-stderr={actual_stderr}')

	# run
	echo-style --h3="$title"
	__do "${args[@]}" -- "${option_cmd[@]}"

	# check exit code
	if [[ -n $option_status && $option_status != "$ignore_option" ]]; then
		if [[ $option_status -ne $actual_exit_status ]]; then
			FAIL='yes'
			echo-style --error="actual exit status [$actual_exit_status]  !=  expected exit status [$option_status]"
		else
			echo-style --success="actual exit status [$actual_exit_status]  ==  expected exit status [$option_status]"
		fi
	fi

	# check stdout
	if [[ $option_stdout != "$ignore_option" ]]; then
		__compare 'stdout' "$actual_stdout" "$option_stdout"
	elif [[ $FAIL == 'yes' ]]; then
		__dump 'stdout' "$actual_stdout"
	fi

	# not ignored
	if [[ $option_stderr != "$ignore_option" ]]; then
		if [[ $can_test_stderr == 'yes' || $actual_stderr == "$option_stderr" ]]; then
			__compare 'stderr' "$actual_stderr" "$option_stderr"
		else
			echo-style --stderr --notice='Unable to validate stderr, as it will be filled with TTY output.'
		fi
	elif [[ $FAIL == 'yes' ]]; then
		__dump 'stderr' "$actual_stderr"
	fi

	# pass or fail
	if [[ $FAIL == 'yes' ]]; then
		echo-style --e3="$title" $'\n'
		return 1
	else
		echo-style --g3="$title" $'\n'
	fi
)

# fire if invoked standalone
if [[ $0 == "${BASH_SOURCE[0]}" ]]; then
	eval_tester "$@"
fi
