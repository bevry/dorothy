#!/usr/bin/env bash

function eval_tester() (
	source "$DOROTHY/sources/bash.bash"
	source "$(type -P debug-bash)"
	source "$(type -P eval-helper)"

	# =====================================
	# Arguments

	function help {
		cat <<-EOF >&2
			USAGE:
			eval-tester [...options] -- <command> [...args]

			OPTIONS:
			--name=<test name>

			--status=<expected exit code> (defaults to 0)
			--ignore-status

			--stdout=<expected stdout> (defaults to empty)
			--ignore-stdout

			--stderr=<expected stderr> (defaults to empty)
			--ignore-stderr

			--tty=<expected tty> (defaults to empty)
			--ignore-tty

			--debug
			    Will run the command with debugging enabled.
			--bash=<bash path>
			    Used to ensure that the command is invoked through a specific bash binary.
		EOF
		if [[ $# -ne 0 ]]; then
			echo-error "$@"
		fi
		return 22 # EINVAL 22 Invalid argument
	}

	# process
	local item option_cmd=() ignore_value=$'\f' option_quiet='yes' option_name='' option_bash='' option_status='0' option_stdout='' option_stderr='' option_tty='' option_debug=''
	while [[ $# -ne 0 ]]; do
		item="$1"
		shift
		case "$item" in
		'--help' | '-h') help ;;
		'--no-verbose'* | '--verbose'*)
			option_quiet="$(get-flag-value --non-affirmative --fallback="$option_quiet" -- "$item")"
			;;
		'--no-quiet'* | '--quiet'*)
			option_quiet="$(get-flag-value --affirmative --fallback="$option_quiet" -- "$item")"
			;;
		'--name='*) option_name="${item#*=}" ;;
		'--bash='*) option_bash="${item#*=}" ;; # unlike [dorothy test] and [debug-bash] only support a single bash binary here, as nothing else makes sense for the [eval-tester] use case, as it is for getting specific results for a specific bash version
		'--ignore-status') option_status="$ignore_value" ;;
		'--ignore-stdout') option_stdout="$ignore_value" ;;
		'--ignore-stderr') option_stderr="$ignore_value" ;;
		'--ignore-tty') option_tty="$ignore_value" ;;
		'--ignore-outputs')
			option_stdout="$ignore_value"
			option_stderr="$ignore_value"
			option_tty="$ignore_value"
			;;
		'--status='*) option_status="${item#*=}" ;;
		'--stdout='*) option_stdout="${item#*=}" ;;
		'--stderr='*) option_stderr="${item#*=}" ;;
		'--tty='*) option_tty="${item#*=}" ;;
		'--no-debug'* | '--debug'*)
			option_debug="$(get-flag-value --affirmative --fallback="$option_debug" -- "$item")"
			;;
		'--')
			option_cmd+=("$@")
			shift $#
			break
			;;
		'--'*) help "An unrecognised flag was provided: $item" ;;
		*) help "An unrecognised argument was provided: $item" ;;
		esac
	done

	# quiet already defaults to yes, but if they did --quiet= or so, then change it to CI status
	if [[ -z $option_quiet ]]; then
		option_quiet="$(is-ci --verbose)"
	fi

	# if debugging, or custom bash, wrap in debug_bash
	if [[ $option_debug == 'yes' ]]; then
		if [[ -n $option_bash ]]; then
			option_cmd=(debug_bash -x --bash="$option_bash" -- "${option_cmd[@]}")
		else
			option_cmd=(debug_bash -x -- "${option_cmd[@]}")
		fi
	elif [[ -n $option_bash ]]; then
		option_cmd=(debug_bash --bash="$option_bash" -- "${option_cmd[@]}")
	fi

	# determine bash version, so we can know if BASH_XTRACEFD is supported
	local stderr_unable_reason=''
	if [[ $option_debug == 'yes' ]]; then
		local bash_version_major bash_version_minor
		if [[ -n $option_bash ]]; then
			local versions
			__split versions --no-zero-length < <(debug_bash --bash="$option_bash" -c 'printf "%s\n" "${BASH_VERSINFO[@]}"')
			if [[ ${#versions[@]} -lt 2 ]]; then
				echo-style --error="Unable to determine bash version from $option_bash"
				return 1
			fi
			bash_version_major="${versions[0]}"
			bash_version_minor="${versions[1]}"
		else
			bash_version_major="$BASH_VERSION_MAJOR"
			bash_version_minor="$BASH_VERSION_MINOR"
		fi
		if ! [[ $bash_version_major -ge 5 || $bash_version_major -eq 4 && $bash_version_minor -ge 1 ]]; then
			stderr_unable_reason='Unable to validate stderr, as it will be filled with debugging output.'
		fi
	fi

	# =====================================
	# Action

	local FAIL='no'
	function __element {
		local label="$1" style="$2" value="$3"
		if [[ -n $value ]]; then
			echo-style --"$style"+element="$label" --newline --="$value" --newline --"$style"+/element="$label"
		else
			echo-style --"$style"+element/="$label" --dim+icon-nothing-provided
		fi
	}
	function __escaped_element {
		local label="$1" style="$2" value="$3"
		if [[ -n $value ]]; then
			__element "$label escaped" "$style" "$(printf '%q' "$value")"
		else
			echo-style --"$style"+element/="$label escaped" --dim+icon-nothing-provided
		fi
	}
	function __compare {
		local name="$1" actual="$2" expected="$3"
		if [[ $option_quiet == 'no' && $name == 'STATUS' ]]; then
			__print_line
		fi
		if [[ $name == 'STDERR' && -n $stderr_unable_reason ]]; then
			echo-style --stderr --notice="$stderr_unable_reason"
		elif [[ $name == 'STATUS' ]]; then
			if [[ $expected == "$ignore_value" ]]; then
				echo-style --note="${name} is IGNORED [$actual]"
			elif [[ $actual == "$expected" ]]; then
				echo-style --success="${name} is EXPECTED [$expected]"
			else
				echo-style --error="${name} [$actual] is NOT EXPECTED [$expected]"
			fi
		elif [[ $expected == "$ignore_value" ]]; then
			echo-style --note="${name} is IGNORED"
			if [[ $option_quiet == 'no' ]]; then
				__element "$name" blue "$actual"
				__escaped_element "$name" blue "$actual"
			fi
		else
			if [[ $actual == "$expected" ]]; then
				echo-style --success="${name} is EXPECTED"
				if [[ $option_quiet == 'no' ]]; then
					__element "$name" green "$actual"
					if [[ $actual =~ [[:cntrl:]] ]]; then
						__escaped_element "$name" green "$actual"
					fi
				fi
			else
				echo-style --error="${name} is NOT EXPECTED"
				__element "actual $name" red "$actual"
				__element "expected $name" red "$expected"
				if [[ $actual$expected =~ [[:cntrl:]] ]]; then
					__escaped_element "actual $name" red "$actual"
					__escaped_element "expected $name" red "$expected"
				fi
				__element "diff $name" red "$(fs-diff -- <(__print_string "$actual") <(__print_string "$expected") || __ignore_exit_status 1)"
			fi
		fi
		if [[ $option_quiet == 'no' && $name != 'TTY' ]]; then
			__print_line
		fi
	}

	# run the command
	local args=() cmd_string title=''
	cmd_string="$(echo-escape-command -- "${option_cmd[@]}")"
	if [[ -n $option_name ]]; then
		title="$option_name" # no longer need to append cmd_string as we always output it now via the element wrap later
	else
		title="$cmd_string"
	fi

	# file descriptor magic
	local semaphores=() output_file
	output_file="$(fs-temp --directory='eval-tester' --file)"
	# tty
	local terminal_output_file_for_comparison="$output_file.tty" terminal_output_target_original="$TERMINAL_OUTPUT_TARGET" terminal_output_semaphore
	export TERMINAL_OUTPUT_TARGET
	terminal_output_semaphore="$(__get_semaphore)"
	semaphores+=("$terminal_output_semaphore")
	__open_fd terminal_output_fd '>' >(
		set +e
		__do --redirect-stdout="$terminal_output_target_original" -- tee -- "$terminal_output_file_for_comparison"
		printf '%s' "$?" >"$terminal_output_semaphore"
	)
	TERMINAL_OUTPUT_TARGET="$terminal_output_fd"
	# debug
	if [[ $option_debug == 'yes' ]]; then
		local debug_output_target_original="$BASH_XTRACEFD" debug_output_semaphore
		debug_output_semaphore="$(__get_semaphore)"
		semaphores+=("$debug_output_semaphore")
		__open_fd debug_output_fd '>' >(
			set +e
			__do --redirect-stdout="$debug_output_target_original" -- cat
			printf '%s' "$?" >"$debug_output_semaphore"
		)
		BASH_XTRACEFD="$debug_output_fd"
	fi

	# capture
	local command_string time actual_exit_status actual_stdout actual_stderr actual_tty
	args+=('--redirect-status={actual_exit_status}')
	args+=('--copy-stdout={actual_stdout}')
	args+=('--copy-stderr={actual_stderr}')
	command_string="$(echo-escape-command -- "${option_cmd[@]}")"
	echo-style --h2="$title" --newline --element+bold="$command_string"
	time="$(__get_epoch_time)"
	# __eval_helper --quiet="$option_quiet" --wrap <-- if this is done, element rendering, quite mode, and time duration can all be moved to eval-helper
	__do "${args[@]}" -- "${option_cmd[@]}"
	time="$(echo-math -- "$(__get_epoch_time) - $time")"
	echo-style --/element+bold="$command_string"
	__return $? -- __wait_for_and_return_semaphores "${semaphores[@]}"
	actual_tty="$(<"$terminal_output_file_for_comparison")"

	# determine if we fail, then we can decide what we are outputting
	if [[ 
		($option_status != "$ignore_value" && $actual_exit_status -ne $option_status) ||
		($option_stdout != "$ignore_value" && $actual_stdout != "$option_stdout") ||
		($option_stderr != "$ignore_value" && $actual_stderr != "$option_stderr") ||
		($option_tty != "$ignore_value" && $actual_tty != "$option_tty") ]]; then
		FAIL='yes'
		option_quiet='no'
	fi

	# compare
	if [[ $FAIL == 'yes' || $option_quiet != 'yes' ]]; then
		__compare STATUS "$actual_exit_status" "$option_status"
		__compare STDOUT "$actual_stdout" "$option_stdout"
		__compare STDERR "$actual_stderr" "$option_stderr"
		__compare TTY "$actual_tty" "$option_tty"
	fi

	# pass or fail
	if [[ $FAIL == 'yes' ]]; then
		echo-style --e2="$title" ' ' --code="in $time seconds" $'\n'
		return 1
	else
		echo-style --g2="$title" ' ' --code="in $time seconds" $'\n'
	fi
)

# fire if invoked standalone
if [[ $0 == "${BASH_SOURCE[0]}" ]]; then
	eval_tester "$@"
fi
