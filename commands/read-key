#!/bin/bash
# trunk-ignore-all(shellcheck/SC2162)

function read_key_test() (
	source "$DOROTHY/sources/bash.bash"
	echo-style --h1="TEST: $0"

	# refer to [is-tty --test] for more comprehensive testing

	# do a test without any capturing
	local book status

	printf '%s\n' "read-key bash version [$BASH_VERSION] [$BASH_VERSION_MAJOR] "

	status=0
	read -t 0 || status=$?
	printf '%s\n' "read-key check status [$status] "

	status=0
	printf '%s\n' 'abc' | read -t 0 || status=$?
	printf '%s\n' "read-key pipe check status [$status] "

	status=0
	read -t 0 <<<"$(printf '%s\n' 'abc')" || status=$?
	printf '%s\n' "read-key <<< check status [$status] "

	status=0
	read -t 0 < <(printf '%s\n' 'abc') || status=$?
	printf '%s\n' "read-key < <(...) check status [$status] "

	if test "$BASH_VERSION_MAJOR" -ge '4'; then
		status=0
		date
		read -sN1 -t 5 book || status=$?
		date
		printf '%s\n' "read-key v4 status [$status] and read [$book]"
	fi

	status=0
	date
	IFS= read -sn1 -t 5 book || status=$?
	date
	printf '%s\n' "read-key v3 status [$status] and read [$book]"

	if test "$BASH_VERSION_MAJOR" -ge '4'; then
		status=0
		printf '%s\n' 'abc' | read -sN1 -t 5 book || status=$?
		printf '%s\n' "read-key v4 status [$status] and read [$book]"
	fi

	status=0
	printf '%s\n' 'def' | IFS= read -sn1 -t 5 book || status=$?
	printf '%s\n' "read-key v3 status [$status] and read [$book]"

	status=0
	printf '%s\n' 'abc' | read -s -t 5 book || status=$?
	printf '%s\n' "read-key -s status [$status] and read [$book]"

	status=0
	printf '%s\n' 'abc' | read -t 5 book || status=$?
	printf '%s\n' "read-key status [$status] and read [$book]"

	status=0
	(
		sleep 3
		printf '%s\n' 'abc'
	) | read -t 60 book || status=$?
	printf '%s\n' "read-key manual timeout [$status] and read [$book]"

	eval-tester --name='timeout was detected' --status='60' \
		-- read-key --timeout=10

	{
		sleep 3
		echo
	} | eval-tester --name='enter was detected' --stdout='enter' \
		-- read-key --timeout=10

	{
		sleep 3
		printf '%s' $'\x0a'
	} | eval-tester --name='enter was detected' --stdout='enter' \
		-- read-key --timeout=10

	{
		sleep 3
		printf '%s' $'\eOB'
	} | eval-tester --name='down was detected' --stdout='down' \
		-- read-key --timeout=10

	{
		sleep 3
		printf '%s' $'\e[B'
	} | eval-tester --name='down was detected' --stdout='down' \
		-- read-key --timeout=10

	echo-style --g1="TEST: $0"
	return 0
)
function read_key() (
	source "$DOROTHY/sources/bash.bash"

	# =====================================
	# Arguments

	function help {
		cat <<-EOF >/dev/stderr
			ABOUT:
			Read the pressed character and output what it was, such as [a], [left], [backspace], [enter], etc.

			USAGE:
			read-key [--timeout=600]
		EOF
		if test "$#" -ne 0; then
			echo-error "$@"
		fi
		return 22 # EINVAL 22 Invalid argument
	}

	# process
	local item option_escaped='no' option_timeout=''
	while test "$#" -ne 0; do
		item="$1"
		shift
		case "$item" in
		'--help' | '-h') help ;;
		'--no-escaped'* | '--escaped'*)
			option_escaped="$(get-flag-value --affirmative --fallback="$option_escaped" -- "$item")"
			;;
		'--timeout='*) option_timeout="${item#*=}" ;;
		'--'*) help "An unrecognised flag was provided: $item" ;;
		*) help "An unrecognised argument was provided: $item" ;;
		esac
	done

	# timeout
	if ! is-number -- "$option_timeout"; then
		option_timeout=600 # ten minutes
	fi
	option_timeout="$(__get_read_decimal_timeout "$option_timeout")"

	# =====================================
	# Action

	# helper
	# -s do not echo input coming from a terminal
	# -t timeout	time out and return failure if a complete line of
	# 	input is not read within TIMEOUT seconds.  The value of the
	# 	TMOUT variable is the default timeout.  TIMEOUT may be a
	# 	fractional number.  If TIMEOUT is 0, read returns
	# 	immediately, without trying to read any data, returning
	# 	success only if input is available on the specified
	# 	file descriptor.  The exit status is greater than 128
	# 	if the timeout is exceeded
	# -n nchars	return after reading NCHARS characters rather than waiting
	# 	for a newline, but honor a delimiter if fewer than
	# 	NCHARS characters are read before the delimiter
	# -N nchars	return only after reading exactly NCHARS characters, unless
	# 	EOF is encountered or read times out, ignoring any
	# 	delimiter
	local last_key='' key='' parse_key
	if (: </dev/tty >/dev/tty) &>/dev/null; then # is-tty but copied for performance
		function ignore_key_as_it_to_send_a_line_buffer {
			return 1
		}
	else
		function ignore_key_as_it_to_send_a_line_buffer {
			test "$key" = $'\n' -a -n "$last_key" -a "$last_key" != $'\n'
		}
	fi
	function buffer_or_flush_char_into_key {
		local char="$1"
		#printf 'BUFFER char = %q\tkey = %q\n' "$char" "$key"
		if test "$char" = $'\e' -o "$char" = $'\n'; then
			# this is the start of a new key
			flush_key
			key="$char"
		else
			# add char to current key
			key+="$char"
		fi
	}
	function flush_key {
		# check we have a key, which may not be the case due to timeout of follow-up keys
		#printf 'FLUSH char = %q\tkey = %q\n' "$char" "$key"
		if test -n "$key"; then
			if ignore_key_as_it_to_send_a_line_buffer; then
				: # ignore as this enter as it was to send a line buffer
			else
				parse_key="$key"
				parse_key
			fi
		fi
		last_key="$key"
		key=''
	}
	function read_chars_into_keys {
		local char status=0
		if test "$BASH_VERSION_MAJOR" -ge '4'; then
			# bash v4+ technique
			char=''
			read -sN1 -t "$option_timeout" char || status=$?
			if test "$status" -eq 0; then
				buffer_or_flush_char_into_key "$char"
				while :; do
					if ! read -sN1 -t 0.0001 char; then
						break
					fi
					buffer_or_flush_char_into_key "$char"
				done
				flush_key
				return 0
			fi
		else
			# bash v3 technique, @Todo requires double-escape handling
			# IFS= is necessary to separate space from enter
			char=''
			IFS= read -sn1 -t "$option_timeout" char || status=$?
			if test "$status" -eq 0; then
				if test -z "$char"; then
					char=$'\n'
				fi
				buffer_or_flush_char_into_key "$char"
				while :; do
					char=''
					if ! IFS= read -sn1 -t1 char; then
						break
					fi
					if test -z "$char"; then
						char=$'\n'
					fi
					buffer_or_flush_char_into_key "$char"
				done
				flush_key
				return 0
			fi
		fi
		if test "$status" -eq 142; then
			return 60 # ETIMEDOUT 60 Operation timed out
		elif test "$status" -eq 1 && (! test -t 0 || ! read -t 0); then
			# this can happen on CI environments, and other environments with stdin and TTY trickery
			# the read isn't wrapped in this, as those check are immediate, whereas read-key supports non-immediate timeouts
			# return a timeout, read-key always functions with a timeout, so no input = is the same result as a timeout
			return 60 # ETIMEDOUT 60 Operation timed out
		elif test "$status" -ne 0; then
			return "$status" # some other issue, let the caller figure it out
		fi
	}
	function match_and_trim {
		local name="$1" value
		for value in "$@"; do
			if [[ $parse_key == "$value"* ]]; then
				printf '%s\n' "$name"
				# the key starts with value, so remove value from key
				parse_key="${parse_key#"$value"}"
				# if anything trailing, then parse it
				if test -n "$parse_key"; then
					parse_key
				fi
			fi
		done
	}
	function parse_key {
		# special keys for common environments (manually verified)
		# don't do fn+key on ubuntu, as that is probably invoking a media key instead
		# https://en.wikipedia.org/wiki/Alt_key
		# https://en.wikipedia.org/wiki/Caps_Lock
		# https://en.wikipedia.org/wiki/Control_key
		# https://en.wikipedia.org/wiki/Command_key
		# https://en.wikipedia.org/wiki/Backspace
		# https://en.wikipedia.org/wiki/Delete_key
		# https://en.wikipedia.org/wiki/End_key
		# https://en.wikipedia.org/wiki/Enter_key
		# https://en.wikipedia.org/wiki/Esc_key
		# https://en.wikipedia.org/wiki/Home_key
		# https://en.wikipedia.org/wiki/Insert_key
		# https://en.wikipedia.org/wiki/List_of_Unicode_characters
		# https://en.wikipedia.org/wiki/Option_key
		# https://en.wikipedia.org/wiki/Page_Up_and_Page_Down_keys
		# https://en.wikipedia.org/wiki/Shift_key
		# https://en.wikipedia.org/wiki/Super_key_(keyboard_button)
		# https://en.wikipedia.org/wiki/Tab_key
		# https://stackoverflow.com/a/29243081/130638
		# https://www.acrobatfaq.com/atbref95/index/Keyboard_Shortcuts/Unicode_Codes_for_Keyboard_symbols.html
		# ‚åÖ, ‚å§ = enter key: [return enter] old macos keyboards, [return] new macos keyboards, [Enter ‚Üµ] raspberry keyboards
		# ‚Üµ = return key, alias for enter
		# ‚Üë = up arrow key
		# ‚Üì = down arrow key
		# ‚Üí = right arrow key
		# ‚éã = escape key: [esc] macos keyboards, [Esc] raspberry keyboard
		# ‚å¶ = delete key, aka delete forward key: [not present] macos keyboards, [Delete] raspberry keyboard
		# ‚å´ = backspace key, aka delete backward key: [Backspace ‚¨∏] raspberry keyboard
		# ‚Üê = left arrow key
		# ‚áß = shift key
		# ‚éá = alt key: [not present] macos keyboards, [Alt] raspberry keyboards
		# ‚å• = option key: [option alt] old macos keybaords, [option ‚å•] new macos keyboards, [not present] raspberry keyboard
		# ‚åÉ, ‚éà = control key: [control] old macos keyboards, [control ‚åÉ] new macos keyboards, [Ctrl] raspberry keyboards, [‚éà] rarely used official symbol
		# ‚åò = command key: [command ‚åò] macos keyboards, [raspberry symbol] raspberry keyboards
		# ‚ùñ = super key, alias for command key
		# üåê = function key: [fn] old macos keybaords, [üåê fn] new macos keyboards, [Fn] raspberry keyboards
		# ‚á™ = caps lock key: [caps lock] macos and raspberry keyboards
		# ‚á• = tab key: [tab] on macos keyboard, [tab ‚á§ ‚á•] raspberry keyboards
		# ‚á§ = backtab key: [visible as the alt] raspberry keyboards
		# ‚á± = home key: [Home] raspberry keyboards
		# ‚á≤ = end key: [End] raspberry keyboards
		# ‚áû = page up key: [PgUp] raspberry keyboards
		# ‚áü = page down key: [PgDn] raspberry keyboards
		# Insert key does not have an official symbol: [not present] macos keyboards, [Ins] raspberry keyboards

		case "$parse_key" in
		$'\e[A'*) match_and_trim 'up' $'\e[A' ;;                                    # [‚Üë] ubuntu, macos   [k] vim
		$'\e[B'*) match_and_trim 'down' $'\e[B' ;;                                  # [‚Üì] ubuntu, macos   [j] vim
		$'\e[C'*) match_and_trim 'right' $'\e[C' ;;                                 # [‚Üí] ubuntu, macos   [l] vim
		$'\e[D'*) match_and_trim 'left' $'\e[D' ;;                                  # [‚Üê] ubuntu, macos   [h] vim
		$'\e[H'*) match_and_trim 'home' $'\e[H' ;;                                  # [‚á±] ubuntu, macos   [numlock 7] ubuntu       [üåê ‚áß ‚Üê] macos
		$'\e[F'*) match_and_trim 'end' $'\e[F' ;;                                   # [‚á≤] ubuntu, macos   [numlock 1] ubuntu       [üåê ‚áß ‚Üí] macos
		$'\e[2'*) match_and_trim 'insert' $'\e[2~' $'\e[2' ;;                       # $'\e[2~' bash v4    $'\e[2' bash v3          [INSERT] [numlock 0] ubuntu
		$'\e[3'*) match_and_trim 'delete' $'\e[3~' $'\e[3' ;;                       # $'\e[3~' bash v4    $'\e[3' bash v3     [‚å¶] [numlock .] ubuntu   [üåê ‚å´] macos
		$'\e[5'* | $'\006'*) match_and_trim 'page-up' $'\e[5~' $'\e[5' $'\006' ;;   # $'\e[5~' bash v4    $'\e[5' bash v3     [‚áû] [numlock 9] ubuntu   [$'\006'] [‚åÉ f] vim      [üåê ‚áß ‚Üë] macos
		$'\e[6'* | $'\002'*) match_and_trim 'page-down' $'\e[6~' $'\e[6' $'\002' ;; # $'\e[6~' bash v4    $'\e[6' bash v3     [‚áü] [numlock 3] ubuntu   [$'\002'] [‚åÉ b] vim      [üåê ‚áß ‚Üì] macos
		$'\177'*) match_and_trim 'backspace' $'\177' ;;                             # $'\177' = $'\x7f'   [‚å´] ubuntu, macos
		$'\x0a'*) match_and_trim 'enter' $'\x0a' ;;                                 # $'\x0a' =  $'\n'
		$'\t'*) match_and_trim 'tab' $'\t' ;;                                       # universal, ‚á•
		$'\e[Z'*) match_and_trim 'backtab' $'\e[Z' ;;                               # shift+tab on macos, ‚á§
		' '*) match_and_trim 'space' ;;                                             # universal

		# special keys for other environments (tried to verify, haven't been able to)
		$'\eOA'*) match_and_trim 'up' $'\eOA' ;;     # v100, screen, xterm
		$'\eOB'*) match_and_trim 'down' $'\eOB' ;;   # v100, screen, xterm
		$'\eOC'*) match_and_trim 'right' $'\eOC' ;;  # v100, screen, xterm
		$'\eOD'*) match_and_trim 'left' $'\eOD' ;;   # v100, screen, xterm
		$'\eOH'*) match_and_trim 'home' $'\eOH' ;;   # xterm
		$'\eOF'*) match_and_trim 'end' $'\eOF' ;;    # xterm
		$'\e[1~'*) match_and_trim 'home' $'\e[1~' ;; # linux, screen
		$'\e[4~'*) match_and_trim 'end' $'\e[4~' ;;  # linux, screen
		$'\x01'*) match_and_trim 'all' $'\x01' ;;    # what type of key is this?
		# G = end, g = home

		# final
		$'\e'*) match_and_trim 'escape' $'\e' ;; # $'\e' = $'\x1b'

		# standard key or unknown special key
		*)
			if test "$option_escaped" = 'yes'; then
				printf '%q\n' "$parse_key"
			else
				printf '%s\n' "$parse_key"
			fi
			;;
		esac
	}
	read_chars_into_keys
)

# fire if invoked standalone
if test "$0" = "${BASH_SOURCE[0]}"; then
	if test "$*" = '--test'; then
		read_key_test
	else
		read_key "$@"
	fi
fi
