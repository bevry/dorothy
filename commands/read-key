#!/usr/bin/env bash
# trunk-ignore-all(shellcheck/SC2162,shellcheck/SC2030,shellcheck/SC2031)
# We use lastpipe so 2030 and 2031 are false positives.

# read
# -s do not echo input coming from a terminal
# -t timeout	time out and return failure if a complete line of input is not read within TIMEOUT seconds.  The value of the TMOUT variable is the default timeout.  TIMEOUT may be a fractional number.  If TIMEOUT is 0, read returns immediately, without trying to read any data, returning success only if input is available on the specified file descriptor.  The exit status is greater than 128 if the timeout is exceeded
# -n nchars	return after reading NCHARS characters rather than waiting for a newline, but honor a delimiter if fewer than NCHARS characters are read before the delimiter
# -N nchars	return only after reading exactly NCHARS characters, unless EOF is encountered or read times out, ignoring any delimiter
# Exit Status: The return code is zero, unless end-of-file is encountered, read times out (in which case it's greater than 128), a variable assignment error occurs, or an invalid file descriptor is supplied as the argument to -u.

function read_key_test() (
	source "$DOROTHY/sources/bash.bash"
	source "$DOROTHY/sources/ansi.bash" # ANSI_ALL
	eval-tester --ignore-stderr --status=22 -- read-key --help

	local -i delay=1
	local book status

	printf '%s\n' "read-key bash version [$BASH_VERSION] [$BASH_VERSION_MAJOR] "

	status=0
	read -t 0 || status=$?
	printf '%s\n' "read-key check status [$status] "

	status=0
	printf '%s\n' 'abc' | read -t 0 || status=$?
	printf '%s\n' "read-key pipe check status [$status] "

	status=0
	read -t 0 <<<"$(printf '%s\n' 'abc')" || status=$?
	printf '%s\n' "read-key <<< check status [$status] "

	status=0
	read -t 0 < <(printf '%s\n' 'abc') || status=$?
	printf '%s\n' "read-key < <(...) check status [$status] "

	if [[ $BASH_VERSION_MAJOR -ge 4 ]]; then
		status=0
		date
		read -sN1 -t 5 book || status=$?
		date
		printf '%s\n' "read-key v4 status [$status] and read [$book]"
	fi

	status=0
	date
	IFS= read -sn1 -t 5 book || status=$?
	date
	printf '%s\n' "read-key v3 status [$status] and read [$book]"

	if [[ $BASH_VERSION_MAJOR -ge 4 ]]; then
		status=0
		printf '%s\n' 'abc' | read -sN1 -t 5 book || status=$?
		printf '%s\n' "read-key v4 status [$status] and read [$book]"
	fi

	status=0
	printf '%s\n' 'def' | IFS= read -sn1 -t 5 book || status=$?
	printf '%s\n' "read-key v3 status [$status] and read [$book]"

	status=0
	printf '%s\n' 'abc' | read -s -t 5 book || status=$?
	printf '%s\n' "read-key -s status [$status] and read [$book]"

	status=0
	printf '%s\n' 'abc' | read -t 5 book || status=$?
	printf '%s\n' "read-key status [$status] and read [$book]"

	status=0
	(
		printf '%s\n' 'abc'
	) | read -t 60 book || status=$?
	printf '%s\n' "read-key manual timeout [$status] and read [$book]"

	{
		printf '%s' "$ANSI_ALL"
	} | eval-tester --name='all was detected' --stdout='all' -- \
		read-key --timeout="$delay"

	eval-tester --name='timeout was detected' --status='60' -- \
		read-key --timeout="$delay"

	{
		__print_line
	} | eval-tester --name='enter was detected' --stdout='enter' -- \
		read-key --timeout="$delay"

	{
		printf '%s' $'\x0a'
	} | eval-tester --name='enter was detected' --stdout='enter' -- \
		read-key --timeout="$delay"

	{
		printf '%s' $'\e\e\e\e'
	} | eval-tester --name='escapes were detected' --stdout=$'escape\nescape\nescape\nescape' -- \
		read-key --timeout="$delay"

	{
		printf '%s' $'\e[Ha\e[1~'
	} | eval-tester --name='home variants were detected' --stdout=$'home\na\nhome' -- \
		read-key --timeout="$delay"

	{
		printf '%s' $'\e[B'
	} | eval-tester --name='down was detected' --stdout='down' -- \
		read-key --timeout="$delay"

	{
		printf '%s' $'\e[F'
	} | eval-tester --name='end was detected' --stdout='end' -- \
		read-key --timeout="$delay"

	local enter_if_not_ignored
	if [[ $IS_STDIN_LINE_BUFFERED == 'no' ]]; then
		enter_if_not_ignored=$'enter\n'
	else
		enter_if_not_ignored=''
	fi
	{
		printf '%s' $'\e\e\n\e[Hab\e[1~cd'
	} | eval-tester --name='a series of characters were detected' --stdout=$'escape\nescape\n'"$enter_if_not_ignored"$'home\na\nb\nhome\nc\nd' -- \
		read-key --timeout="$delay"

	{
		printf '%s' $'\e[Hab\e[1~cd\e[F\e[Jef'
	} | eval-tester --name='unknown read-key ANSI escape codes report failure' --status=94 --stdout=$'home\na\nb\nhome\nc\nd\nend' -- \
		read-key --timeout="$delay"

	{
		printf '%s' $'\e[Hab\e[1~cd\e[F\e[Jef'
	} | eval-tester --name='unknown read-key ANSI escape codes report verbal failure if verbose' --status=94 --stdout=$'home $\'\\E[H\'\na a\nb b\nhome $\'\\E[1~\'\nc c\nd d\nend $\'\\E[F\'' --stderr="unknown \$'\E[Jef'" -- \
		read-key --verbose --timeout="$delay"

	return 0
)
function read_key() (
	source "$DOROTHY/sources/bash.bash"

	# =====================================
	# Arguments

	function __help {
		__print_help "$@" <<-EOF || return $?
			ABOUT:
			Reads the immediately received characters and outputs which keys they are.

			USAGE:
			\`read-key [...options]\`

			OPTIONS:
			--verbose | --no-quiet
			    If an unknown key is encountered, output a warning about it.

			--timeout=<timeout>
			    Custom timeout value in seconds. Defaults to \`600\`.

			--keep-line-buffer-newlines
			    By default, when in non-TTY environments, characters are line buffered and require an \`enter\` key to be sent, of which we will discard such \`enter\` keys. Enabling this flag will send \`line-buffer\` on such \`enter\` keys.

			--continue
			    Continue reading keys.

			RETURNS:
			[0] if only printable keys and known non-printable keys were received.
			[60] if a timeout occurred.
			[94] if an unknown non-printable character sequence was received.

			QUIRKS:
			A pressable key can be a printable key, like \`a\` and \`!\`, or a non-printable key, like \`enter\`, \`backspace\`, and \`left\`.
			Non-printable keys can be a sequence of non-printable and printable characters.
			ANSI Escape Codes are a sequence of non-printable and printable characters, that the terminal interprets as a command, such as \`erase line\` and \`move cursor\`, and are not always pressable keys (things like the \`home\` and \`end\` pressable keys actually function by sending ANSI Escape Codes).
			As the utility of this command is for reactivity to user interactions, only pressable keys are supported, and does not attempt to translate all ANSI Escape Codes into human readable commands, such as \`move cursor up 5 lines\`.
			Furthermore, under typical circumstances this will react to a single key press, however under the line-buffer mode of non-TTY environments, which requires an enter key to be pressed to send the prior keys for processing, or under the circumstance of rapid key presses under Bash v3 which requires a second to process received input, then multiple keys may be rightfully be received and processed, in which multiple keys will be outputted, as such to properly handle key presses, you should treat the output of this command as an array.
			Because the \`escape\` key is translated as the start of an escaped character sequence, the \`escape\` key will only be understood if done at the end of a known sequence.
		EOF
		return 22 # EINVAL 22 Invalid argument
	}
	if [[ $* == '--help' ]]; then
		__help || return $?
	fi

	# forward
	__read_key "$@" || return $?
)

# fire if invoked standalone
if [[ $0 == "${BASH_SOURCE[0]}" ]]; then
	if [[ $* == '--test' ]]; then
		read_key_test
	else
		read_key "$@"
	fi
fi
