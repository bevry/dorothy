#!/usr/bin/env bash
# trunk-ignore-all(shellcheck/SC2162)

# read
# -s do not echo input coming from a terminal
# -t timeout	time out and return failure if a complete line of input is not read within TIMEOUT seconds.  The value of the TMOUT variable is the default timeout.  TIMEOUT may be a fractional number.  If TIMEOUT is 0, read returns immediately, without trying to read any data, returning success only if input is available on the specified file descriptor.  The exit status is greater than 128 if the timeout is exceeded
# -n nchars	return after reading NCHARS characters rather than waiting for a newline, but honor a delimiter if fewer than NCHARS characters are read before the delimiter
# -N nchars	return only after reading exactly NCHARS characters, unless EOF is encountered or read times out, ignoring any delimiter
# Exit Status: The return code is zero, unless end-of-file is encountered, read times out (in which case it's greater than 128), a variable assignment error occurs, or an invalid file descriptor is supplied as the argument to -u.

function read_key_test() (
	source "$DOROTHY/sources/bash.bash"

	local -i delay=1
	local book status

	printf '%s\n' "read-key bash version [$BASH_VERSION] [$BASH_VERSION_MAJOR] "

	status=0
	read -t 0 || status=$?
	printf '%s\n' "read-key check status [$status] "

	status=0
	printf '%s\n' 'abc' | read -t 0 || status=$?
	printf '%s\n' "read-key pipe check status [$status] "

	status=0
	read -t 0 <<<"$(printf '%s\n' 'abc')" || status=$?
	printf '%s\n' "read-key <<< check status [$status] "

	status=0
	read -t 0 < <(printf '%s\n' 'abc') || status=$?
	printf '%s\n' "read-key < <(...) check status [$status] "

	if [[ $BASH_VERSION_MAJOR -ge 4 ]]; then
		status=0
		date
		read -sN1 -t 5 book || status=$?
		date
		printf '%s\n' "read-key v4 status [$status] and read [$book]"
	fi

	status=0
	date
	IFS= read -sn1 -t 5 book || status=$?
	date
	printf '%s\n' "read-key v3 status [$status] and read [$book]"

	if [[ $BASH_VERSION_MAJOR -ge 4 ]]; then
		status=0
		printf '%s\n' 'abc' | read -sN1 -t 5 book || status=$?
		printf '%s\n' "read-key v4 status [$status] and read [$book]"
	fi

	status=0
	printf '%s\n' 'def' | IFS= read -sn1 -t 5 book || status=$?
	printf '%s\n' "read-key v3 status [$status] and read [$book]"

	status=0
	printf '%s\n' 'abc' | read -s -t 5 book || status=$?
	printf '%s\n' "read-key -s status [$status] and read [$book]"

	status=0
	printf '%s\n' 'abc' | read -t 5 book || status=$?
	printf '%s\n' "read-key status [$status] and read [$book]"

	status=0
	(
		printf '%s\n' 'abc'
	) | read -t 60 book || status=$?
	printf '%s\n' "read-key manual timeout [$status] and read [$book]"

	{
		printf '%s' "$ANSI_ALL"
	} | eval-tester --name='all was detected' --stdout='all' -- \
		read-key --timeout="$delay"

	eval-tester --name='timeout was detected' --status='60' -- \
		read-key --timeout="$delay"

	{
		__print_line
	} | eval-tester --name='enter was detected' --stdout='enter' -- \
		read-key --timeout="$delay"

	{
		printf '%s' $'\x0a'
	} | eval-tester --name='enter was detected' --stdout='enter' -- \
		read-key --timeout="$delay"

	{
		printf '%s' $'\e\e\e\e'
	} | eval-tester --name='escapes were detected' --stdout=$'escape\nescape\nescape\nescape' -- \
		read-key --timeout="$delay"

	{
		printf '%s' $'\e[Ha\e[1~'
	} | eval-tester --name='home variants were detected' --stdout=$'home\na\nhome' -- \
		read-key --timeout="$delay"

	{
		printf '%s' $'\e[B'
	} | eval-tester --name='down was detected' --stdout='down' -- \
		read-key --timeout="$delay"

	{
		printf '%s' $'\e[F'
	} | eval-tester --name='end was detected' --stdout='end' -- \
		read-key --timeout="$delay"

	local enter_if_not_ignored
	if [[ $IS_STDIN_LINE_BUFFERED == 'no' ]]; then
		enter_if_not_ignored=$'enter\n'
	else
		enter_if_not_ignored=''
	fi
	{
		printf '%s' $'\e\e\n\e[Hab\e[1~cd'
	} | eval-tester --name='a series of characters were detected' --stdout=$'escape\nescape\n'"$enter_if_not_ignored"$'home\na\nb\nhome\nc\nd' -- \
		read-key --timeout="$delay"

	{
		printf '%s' $'\e[Hab\e[1~cd\e[F\e[Jef'
	} | eval-tester --name='unknown read-key ANSI escape codes report failure' --status=94 --stdout=$'home\na\nb\nhome\nc\nd\nend' -- \
		read-key --timeout="$delay"

	{
		printf '%s' $'\e[Hab\e[1~cd\e[F\e[Jef'
	} | eval-tester --name='unknown read-key ANSI escape codes report verbal failure if verbose' --status=94 --stdout=$'home $\'\\E[H\'\na a\nb b\nhome $\'\\E[1~\'\nc c\nd d\nend $\'\\E[F\'' --stderr="unknown \$'\E[Jef'" -- \
		read-key --verbose --timeout="$delay"

	return 0
)
function read_key() (
	source "$DOROTHY/sources/bash.bash"

	# =====================================
	# Arguments

	function help {
		cat <<-EOF >&2
			ABOUT:
			Reads the immediately received characters and outputs which keys they are.

			USAGE:
			read-key [...options]

			OPTIONS:
			--verbose | --no-quiet
			    If an unknown key is encountered, output a warning about it.

			--timeout=<timeout>
			    Custom timeout value in seconds. Defaults to 600.

			--keep-line-buffer-newlines
			    By default, when in non-TTY environments, characters are line buffered and require an [enter] key to be sent, of which we will discard such [enter] keys. Enabling this flag will send [line-buffer] on such [enter] keys.

			--continue
			    Continue reading keys.

			RETURNS:
			[0] if only printable keys and known non-printable keys were received
			[60] if a timeout occurred
			[94] if an unknown non-printable character sequence was received

			QUIRKS:
			A pressable key can be a printable key, like [a] and [!], or a non-printable key, like [enter], [backspace], and [left].
			Non-printable keys can be a sequence of non-printable and printable characters.
			ANSI Escape Codes are a sequence of non-printable and printable characters, that the terminal interprets as a command, such as [erase line] and [move cursor], and are not always pressable keys (things like the [home] and [end] pressable keys actually function by sending ANSI Escape Codes).
			As the utility of this command is for reactivity to user interactions, only pressable keys are supported, and does not attempt to translate all ANSI Escape Codes into human readable commands, such as [move cursor up 5 lines].
			Furthermore, under typical circumstances this will react to a single key press, however under the line-buffer mode of non-TTY environments, which requires an enter key to be pressed to send the prior keys for processing, or under the circumstance of rapid key presses under Bash v3 which requires a second to process received input, then multiple keys may be rightfully be received and processed, in which multiple keys will be outputted, as such to properly handle key presses, you should treat the output of this command as an array.
			Because the [escape] key is translated as the start of an escaped character sequence, the [escape] key will only be understood if done at the end of a known sequence.
		EOF
		if [[ $# -ne 0 ]]; then
			__print_error "$@"
		fi
		return 22 # EINVAL 22 Invalid argument
	}

	# process
	# do not use a subsequent_timeout smaller than 0.01, as that is still 100 keys a second, which is faster than any human can press and reasonable enough for automated key presses, and more importantly, anything smaller introduces issues where only a portion of the ansi escape combination is read, and in which re-attempting to read the remaining portion results in discarded characters of the ansi escape sequence, see alternative failed implementations at: https://gist.github.com/balupton/d8ee5f5d6022d3988f148df26909d638
	local item option_quiet='yes' option_timeout='' option_continue='no' subsequent_timeout='0.01' option_keep_line_buffer_newlines='no'
	while [[ $# -ne 0 ]]; do
		item="$1"
		shift
		case "$item" in
		'--help' | '-h') help ;;
		'--no-verbose'* | '--verbose'*) __flag --source={item} --target={option_quiet} --non-affirmative ;;
		'--no-quiet'* | '--quiet'*) __flag --source={item} --target={option_quiet} --affirmative ;;
		'--no-continue'* | '--continue'*) __flag --source={item} --target={option_continue} --affirmative ;;
		'--timeout='*) option_timeout="${item#*=}" ;;
		'--no-keep-line-buffer-newlines'* | '--keep-line-buffer-newlines'*) __flag --source={item} --target={option_keep_line_buffer_newlines} --affirmative ;;
		'--'*) help "An unrecognised flag was provided: $item" ;;
		*) help "An unrecognised argument was provided: $item" ;;
		esac
	done

	# timeout
	if ! is-number -- "$option_timeout"; then
		option_timeout=600 # ten minutes
	fi

	# bash v3 compat
	option_timeout="$(__get_read_decimal_timeout "$option_timeout")"
	subsequent_timeout="$(__get_read_decimal_timeout "$subsequent_timeout")"

	# =====================================
	# Action

	local inputs='' input='' last_key=''
	if [[ $IS_STDIN_LINE_BUFFERED == 'no' ]]; then
		function __discard_key_if_line_buffer_enter {
			return 1
		}
	else
		function __discard_key_if_line_buffer_enter {
			[[ $input == $'\n' && -n $last_key && $last_key != $'\n' ]] || return
		}
	fi
	function add {
		local input="$1"
		if [[ -z $input ]]; then
			input=$'\n'
		fi
		if [[ $input == $'\e' || $input == $'\n' ]]; then
			flush
		fi
		if __discard_key_if_line_buffer_enter; then
			if [[ $option_keep_line_buffer_newlines == 'yes' ]]; then
				printf '%s\n' 'line-buffer'
			fi
			last_key="$input"
			input=''
		fi
		#printf 'input: %q\tinputs: %q\n' "$input" "$inputs"
		inputs+="$input"
	}
	function read_and_flush {
		# read
		local status=0
		IFS= read -rsn1 -t "$option_timeout" input || status=$?
		if [[ $status -eq 0 ]]; then
			add "$input"
			while :; do
				# IFS= allows the space character [ ] to be indentation
				# -r allows backslash key [\] to be kept
				# -s prevents the input from being echoed
				# -n1 reads only one character, which is necessary surprisingly to read non-printable characters
				if ! IFS= read -rsn1 -t "$subsequent_timeout" input; then
					break
				fi
				add "$input"
			done
		fi

		# handle errors
		# in practice, timeouts are only ever 148, however docs say >=128 should be considered timeout
		if [[ $status -ge 128 ]]; then
			return 60 # ETIMEDOUT 60 Operation timed out
		elif [[ $status -eq 1 ]] && ([[ ! -t 0 ]] || ! read -t 0); then
			# this can happen on CI environments, and other environments with stdin and TTY trickery
			return 60 # ETIMEDOUT 60 Operation timed out
		elif [[ $status -ne 0 ]]; then
			return "$status" # some other issue, let the caller figure it out
		fi

		# got key
		flush
	}
	function __print_and_trim_key {
		local name="$1" key="$2"
		local -i size="${#key}"
		last_key="$key"
		inputs="${inputs:size}"
		if [[ $option_quiet == 'no' ]]; then
			printf '%s %q\n' "$name" "$key"
		else
			printf '%s\n' "$name"
		fi
	}
	function __match_pattern_and_trim_once {
		local tags pattern key name match
		local -i ansi_index
		for ((ansi_index = 0; ansi_index < ANSI_SIZE; ansi_index += 4)); do
			# 0=<KEY> 1=<PATTERN> 2=<NAME> 3=<TAGS>
			tags="${ANSI[ansi_index + 3]}"
			if [[ $tags != *"[read-key]"* ]]; then
				continue
			fi
			pattern="${ANSI[ansi_index + 1]}"
			if [[ -z $pattern ]]; then
				key="${ANSI[ansi_index]}"
				if [[ $inputs == $key* ]]; then
					match="$key"
				else
					match=''
				fi
			elif [[ $inputs =~ ^$pattern ]]; then
				match="${BASH_REMATCH[0]}"
			else
				match=''
			fi
			if [[ -n $match ]]; then
				name="${ANSI[ansi_index + 2]}"
				__print_and_trim_key "$name" "$match"
				return 0
			fi
		done
		return 1
	}
	function __match_key_and_trim_once {
		local name="$1" key
		for key in "$@"; do
			if [[ $inputs == "$key"* ]]; then
				__print_and_trim_key "$name" "$key"
				return 0
			fi
		done
		return 1
	}
	function __match_print_and_trim_once {
		local key
		if [[ $inputs =~ ^[[:print:]] ]]; then
			key="${BASH_REMATCH[0]}" # bash 3.2 does not support multiple calls to BASH_REMATCH so it must be cached
			__print_and_trim_key "$key" "$key"
			# __print_and_trim_key "${BASH_REMATCH[0]}" "${BASH_REMATCH[0]}" <-- bash 3.2 does not like this
			return 0
		fi
		return 1
	}
	function flush {
		while [[ -n $inputs ]]; do
			case "$inputs" in

			# escape
			# [0x1B = $'\x1b' = $'\033' = $'\u001B' = $'\e'] is [âŽ‹] ubuntu, macos
			$'\e' | $'\e\n'* | $'\e\e'*) __match_key_and_trim_once 'escape' $'\e' ;;

			# standard key or unknown special key
			*)
				if ! __match_pattern_and_trim_once && ! __match_print_and_trim_once; then
					if [[ $option_quiet == 'no' ]]; then
						printf '%s %q\n' 'unknown' "$inputs" >&2 # should be the same as __print_and_trim_key but go to stderr instead
					fi
					return 94 # EBADMSG 94 Bad message
				fi
				;;
			esac
		done
	}

	# act
	if [[ $option_continue == 'no' ]]; then
		read_and_flush
	else
		while :; do
			read_and_flush
		done
	fi
)

# fire if invoked standalone
if [[ $0 == "${BASH_SOURCE[0]}" ]]; then
	if [[ $* == '--test' ]]; then
		read_key_test
	else
		read_key "$@"
	fi
fi
