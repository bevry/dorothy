#!/usr/bin/env bash
# trunk-ignore-all(shellcheck/SC2162)

# read
# -s do not echo input coming from a terminal
# -t timeout	time out and return failure if a complete line of input is not read within TIMEOUT seconds.  The value of the TMOUT variable is the default timeout.  TIMEOUT may be a fractional number.  If TIMEOUT is 0, read returns immediately, without trying to read any data, returning success only if input is available on the specified file descriptor.  The exit status is greater than 128 if the timeout is exceeded
# -n nchars	return after reading NCHARS characters rather than waiting for a newline, but honor a delimiter if fewer than NCHARS characters are read before the delimiter
# -N nchars	return only after reading exactly NCHARS characters, unless EOF is encountered or read times out, ignoring any delimiter
# Exit Status: The return code is zero, unless end-of-file is encountered, read times out (in which case it's greater than 128), a variable assignment error occurs, or an invalid file descriptor is supplied as the argument to -u.

function read_key_test() (
	source "$DOROTHY/sources/bash.bash"
	echo-style --h1="TEST: $0"

	# do a test without any capturing
	local book status

	printf '%s\n' "read-key bash version [$BASH_VERSION] [$BASH_VERSION_MAJOR] "

	status=0
	read -t 0 || status=$?
	printf '%s\n' "read-key check status [$status] "

	status=0
	printf '%s\n' 'abc' | read -t 0 || status=$?
	printf '%s\n' "read-key pipe check status [$status] "

	status=0
	read -t 0 <<<"$(printf '%s\n' 'abc')" || status=$?
	printf '%s\n' "read-key <<< check status [$status] "

	status=0
	read -t 0 < <(printf '%s\n' 'abc') || status=$?
	printf '%s\n' "read-key < <(...) check status [$status] "

	if [[ $BASH_VERSION_MAJOR -ge '4' ]]; then
		status=0
		date
		read -sN1 -t 5 book || status=$?
		date
		printf '%s\n' "read-key v4 status [$status] and read [$book]"
	fi

	status=0
	date
	IFS= read -sn1 -t 5 book || status=$?
	date
	printf '%s\n' "read-key v3 status [$status] and read [$book]"

	if [[ $BASH_VERSION_MAJOR -ge '4' ]]; then
		status=0
		printf '%s\n' 'abc' | read -sN1 -t 5 book || status=$?
		printf '%s\n' "read-key v4 status [$status] and read [$book]"
	fi

	status=0
	printf '%s\n' 'def' | IFS= read -sn1 -t 5 book || status=$?
	printf '%s\n' "read-key v3 status [$status] and read [$book]"

	status=0
	printf '%s\n' 'abc' | read -s -t 5 book || status=$?
	printf '%s\n' "read-key -s status [$status] and read [$book]"

	status=0
	printf '%s\n' 'abc' | read -t 5 book || status=$?
	printf '%s\n' "read-key status [$status] and read [$book]"

	status=0
	(
		printf '%s\n' 'abc'
	) | read -t 60 book || status=$?
	printf '%s\n' "read-key manual timeout [$status] and read [$book]"

	eval-tester --name='timeout was detected' --status='60' -- \
		read-key --timeout=10

	{
		__print_line
	} | eval-tester --name='enter was detected' --stdout='enter' -- \
		read-key --timeout=10

	{
		printf '%s' $'\x0a'
	} | eval-tester --name='enter was detected' --stdout='enter' -- \
		read-key --timeout=10

	{
		printf '%s' $'\e\e\e\e'
	} | eval-tester --name='escapes were detected' --stdout=$'escape\nescape\nescape\nescape' -- \
		read-key --timeout=10

	{
		printf '%s' $'\e[Ha\e[1~'
	} | eval-tester --name='home variants were detected' --stdout=$'home\na\nhome' -- \
		read-key --timeout=10

	{
		printf '%s' $'\e[B'
	} | eval-tester --name='down was detected' --stdout='down' -- \
		read-key --timeout=10

	{
		printf '%s' $'\e[F'
	} | eval-tester --name='end was detected' --stdout='end' -- \
		read-key --timeout=10

	local enter_if_not_ignored
	if [[ $IS_STDIN_LINE_BUFFERED == 'no' ]]; then
		enter_if_not_ignored=$'enter\n'
	else
		enter_if_not_ignored=''
	fi
	{
		printf '%s' $'\e\e\n\e[Hab\e[1~cd'
	} | eval-tester --name='a series of characters were detected' --stdout=$'escape\nescape\n'"$enter_if_not_ignored"$'home\na\nb\nhome\nc\nd' -- \
		read-key --timeout=10

	{
		printf '%s' $'\e[Hab\e[1~cd\e[F\e[Jef'
	} | eval-tester --name='ANSI escape codes result in failure' --status=94 --stdout=$'home\na\nb\nhome\nc\nd\nend' -- \
		read-key --timeout=10
	{
		printf '%s' $'\e[Hab\e[1~cd\e[F\e[Jef'
	} | eval-tester --name='ANSI escape codes result in verbal failure if verbose' --status=94 --stdout=$'home $\'\\E[H\'\na a\nb b\nhome $\'\\E[1~\'\nc c\nd d\nend $\'\\E[F\'' --stderr="unknown \$'\E[Jef'" -- \
		read-key --verbose --timeout=10

	echo-style --g1="TEST: $0"
	return 0
)
function read_key() (
	source "$DOROTHY/sources/bash.bash"

	# =====================================
	# Arguments

	function help {
		cat <<-EOF >&2
			ABOUT:
			Reads the immediately received characters and outputs which keys they are.

			USAGE:
			read-key [...options]

			OPTIONS:
			--verbose | --no-quiet
			    If an unknown key is encountered, output a warning about it.

			--timeout=<timeout>
			    Custom timeout value in seconds. Defaults to 600.

			--keep-line-buffer-newlines
			    By default, when in non-TTY environments, characters are line buffered and require an [enter] key to be sent, of which we will discard such [enter] keys. Enabling this flag will send [line-buffer] on such [enter] keys.

			--continue
			    Continue reading keys.

			RETURNS:
			[0] if only printable keys and known non-printable keys were received
			[60] if a timeout occurred
			[94] if an unknown non-printable character sequence was received

			QUIRKS:
			A pressable key can be a printable key, like [a] and [!], or a non-printable key, like [enter], [backspace], and [left].
			Non-printable keys can be a sequence of non-printable and printable characters.
			ANSI Escape Codes are a sequence of non-printable and printable characters, that the terminal interprets as a command, such as [erase line] and [move cursor], and are not always pressable keys (things like the [home] and [end] pressable keys actually function by sending ANSI Escape Codes).
			As the utility of this command is for reactivity to user interactions, only pressable keys are supported, and does not attempt to translate all ANSI Escape Codes into human readable commands, such as [move cursor up 5 lines].
			Furthermore, under typical circumstances this will react to a single key press, however under the line-buffer mode of non-TTY environments, which requires an enter key to be pressed to send the prior keys for processing, or under the circumstance of rapid key presses under Bash v3 which requires a second to process received input, then multiple keys may be rightfully be received and processed, in which multiple keys will be outputted, as such to properly handle key presses, you should treat the output of this command as an array.
			Because the [escape] key is translated as the start of an escaped character sequence, the [escape] key will only be understood if done at the end of a known sequence.
		EOF
		if [[ $# -ne 0 ]]; then
			echo-error "$@"
		fi
		return 22 # EINVAL 22 Invalid argument
	}

	# process
	# do not use a subsequent_timeout smaller than 0.01, as that is still 100 keys a second, which is faster than any human can press and reasonable enough for automated key presses, and more importantly, anything smaller introduces issues where only a portion of the ansi escape combination is read, and in which re-attempting to read the remaining portion results in discarded characters of the ansi escape sequence, see alternative failed implementations at: https://gist.github.com/balupton/d8ee5f5d6022d3988f148df26909d638
	local item option_quiet='yes' option_timeout='' option_continue='no' subsequent_timeout='0.01' option_keep_line_buffer_newlines='no'
	while [[ $# -ne 0 ]]; do
		item="$1"
		shift
		case "$item" in
		'--help' | '-h') help ;;
		'--no-verbose'* | '--verbose'*)
			option_quiet="$(get-flag-value --non-affirmative --fallback="$option_quiet" -- "$item")"
			;;
		'--no-quiet'* | '--quiet'*)
			option_quiet="$(get-flag-value --affirmative --fallback="$option_quiet" -- "$item")"
			;;
		'--no-continue'* | '--continue'*)
			option_continue="$(get-flag-value --affirmative --fallback="$option_continue" -- "$item")"
			;;
		'--timeout='*) option_timeout="${item#*=}" ;;
		'--no-keep-line-buffer-newlines'* | '--keep-line-buffer-newlines'*)
			option_keep_line_buffer_newlines="$(get-flag-value --affirmative --fallback="$option_keep_line_buffer_newlines" -- "$item")"
			;;
		'--'*) help "An unrecognised flag was provided: $item" ;;
		*) help "An unrecognised argument was provided: $item" ;;
		esac
	done

	# timeout
	if ! is-number -- "$option_timeout"; then
		option_timeout=600 # ten minutes
	fi

	# bash v3 compat
	option_timeout="$(__get_read_decimal_timeout "$option_timeout")"
	subsequent_timeout="$(__get_read_decimal_timeout "$subsequent_timeout")"

	# =====================================
	# Action

	local inputs='' input='' last_key=''
	if [[ $IS_STDIN_LINE_BUFFERED == 'no' ]]; then
		function __discard_key_if_line_buffer_enter {
			return 1
		}
	else
		function __discard_key_if_line_buffer_enter {
			[[ $input == $'\n' && -n $last_key && $last_key != $'\n' ]] || return
		}
	fi
	function add {
		local input="$1"
		if [[ -z $input ]]; then
			input=$'\n'
		fi
		if [[ $input == $'\e' || $input == $'\n' ]]; then
			flush
		fi
		if __discard_key_if_line_buffer_enter; then
			if [[ $option_keep_line_buffer_newlines == 'yes' ]]; then
				printf '%s\n' 'line-buffer'
			fi
			last_key="$input"
			input=''
		fi
		#printf 'input: %q\tinputs: %q\n' "$input" "$inputs"
		inputs+="$input"
	}
	function read_and_flush {
		# read
		local status=0
		IFS= read -rsn1 -t "$option_timeout" input || status=$?
		if [[ $status -eq 0 ]]; then
			add "$input"
			while :; do
				# IFS= allows the space character [ ] to be indentation
				# -r allows backslash key [\] to be kept
				# -s prevents the input from being echoed
				# -n1 reads only one character, which is necessary surprisingly to read non-printable characters
				if ! IFS= read -rsn1 -t "$subsequent_timeout" input; then
					break
				fi
				add "$input"
			done
		fi

		# handle errors
		# in practice, timeouts are only ever 148, however docs say >=128 should be considered timeout
		if [[ $status -ge 128 ]]; then
			return 60 # ETIMEDOUT 60 Operation timed out
		elif [[ $status -eq 1 ]] && ([[ ! -t 0 ]] || ! read -t 0); then
			# this can happen on CI environments, and other environments with stdin and TTY trickery
			return 60 # ETIMEDOUT 60 Operation timed out
		elif [[ $status -ne 0 ]]; then
			return "$status" # some other issue, let the caller figure it out
		fi

		# got key
		flush
	}
	local patterns=(
		# app-specific hotkeys that should be interpreted by the caller instead
		# up: [k] vim
		# down: [j] vim
		# right: [l] vim
		# left: [h] vim

		# @todo add a third column, that contains any combination of `press` (pressable via keyboard), `print` (printable to paper), `place` (shapeshifter of cursor)

		# The below are shortcut combinations read or written by Dorothy
		# $'\e\[G\e\[2K' 'clear-line'
		# $'\e\[F\e\[J' 'delete-line'
		# $'\n\e\[H\e\[J' 'clear-screen'
		# $'\e\[H\e\[J' 'clear-screen'
		# $'\e\[\?1049h\e\[H\e\[J' 'alternative-screen-buffer'

		# The below are pressable keys read or written by Dorothy

		# up
		# unverified: [$'\eOA'] v100, screen, xterm
		$'\e\[A' 'up' # [$'\e[A'] is [‚Üë] ubuntu, macos, [cursor up one] ansi escape code
		$'\eM' 'up'   # [$'\eM'] ansi escape code to cursor up a line and scroll if necessary, note that scrolling moves visible content down but content from above is empty/erased; note that this is also documented as: Reverse Index ( RI is 0x8d); note $'\x8d' becomes a ? in Apple Terminal

		# down
		# unverified: [$'\eOB'] v100, screen, xterm
		$'\e\[B' 'down' # [$'\e[B'] is [‚Üì] ubuntu, macos, [cursor down one] ansi escape code

		# right
		# unverified: [$'\eOC'] v100, screen, xterm
		$'\e\[C' 'right' # [$'\e[C'] is [‚Üí] ubuntu, macos, [cursor right one] ansi escape code

		# left
		# unverified: [$'\eOD'] v100, screen, xterm
		$'\e\[D' 'left' # [$'\e[D'] is [‚Üê] ubuntu, macos, [cursor left one] ansi escape code

		# home
		# unverified: [$'\eOH'] xterm
		$'\e\[H' 'home'     # [$'\e[H'] is [‚á±] ubuntu, macos, [numlock 7] ubuntu, [üåê ‚áß ‚Üê] macos, [cursor to top left] ansi escape code
		$'\e\[1~' 'home'    # [$'\e[1~'] is [üåê ‚Üê] screen/vt macos
		$'\e\[1\;2D' 'home' # [$'\e[1;2D'] is [‚áß ‚Üê] macos, [cursor left twice: the `1;` prefix is not supported on macos] ansi escape code

		# carriage-return
		$'\e\[G' 'carriage-return' # [$'\e[G'] is [cursor to start of current line] ansi escape code
		$'\r' 'carriage-return'    # [0x0D = $'\x0d' = $'\r'] is ansi escape code

		# end
		# unverified: [$'\eOF'] xterm
		$'\e\[F' 'end'     # [$'\e[F'] is [‚á≤] ubuntu, macos, [numlock 1] ubuntu, [üåê ‚áß ‚Üí] macos, [cursor to start of prior line] ansi escape code
		$'\e\[4~' 'end'    # [$'\e[4~'] is [üåê ‚Üí] screen/vt macos
		$'\e\[1\;2C' 'end' # [$'\e[1;2C'] is [‚áß ‚Üê] macos, [cursor right twice: the `1;` prefix is not supported on macos] ansi escape code

		# insert
		$'\e\[2~' 'insert' # [$'\e[2~'] is [INSERT] [numlock 0] ubuntu

		# delete
		$'\e\[3~' 'delete' # [$'\e[3~'] is [‚å¶] [numlock .] ubuntu, [üåê ‚å´] macos

		# page up
		# unverified: [$'\006'] [‚åÉ f] vim
		$'\e\[5~' 'page-up'    # [$'\e[5~'] is [‚áû] [numlock 9] ubuntu, [üåê ‚áß ‚Üë] macos, [üåê ‚Üë] screen/vt macos
		$'\e\[1\;5D' 'page-up' # [$'\E[1;5D'] is [‚åÉ ‚Üê] macos
		$'\eb' 'page-up'       # [$'\eb'] is [‚å• ‚Üê] macos

		# page down
		# unverified: [$'\002'] [‚åÉ b] vim
		$'\e\[6~' 'page-down'    # [$'\e[6~'] is [‚áü] [numlock 3] ubuntu, [üåê ‚áß ‚Üì] macos, [üåê ‚Üë] screen/vt macos
		$'\e\[1\;5C' 'page-down' # [$'\e[1;5C'] is [‚åÉ ‚Üí] macos
		$'\ef' 'page-down'       # [$'\ef'] is [‚å• ‚Üí] macos

		# backspace
		$'\177' 'backspace' # [$'\x7f' = $'\177'] is [‚å´] ubuntu, macos
		$'\b' 'backspace'   # [0x08 = $'\x08' = $'\b'] is ansi escape code

		# enter / line-feed
		$'\n' 'enter' # [0x0A = $'\x0a' =  $'\n'] is ubuntu, macos, [^ M] macos

		# tab
		$'\t' 'tab' # [0x09 = $'\x09' = $'\t'] is [‚á•] ubuntu, macos

		# backtab
		$'\e\[Z' 'backtab' # [$'\e[Z'] is [‚á§] [shift ‚á•] macos

		# all / select all
		# $'\001' 'all' # [$'\x01' = $'\001'] is [^ A] macos

		# space
		' ' 'space' # [0x20 = $'\x20 = ' '] is [ ] ubuntu, macos

		# bell or end terminal title
		$'\a' 'bell' # [0x07 = $'\x07' = $'\007' = $'\a'] is ansi escape code, is [^ G] macos

		# form feed / new page
		$'\f' 'form-feed' # [0x0C = $'\x0c' = $'\f] is [‚åÉ L] macos

		# bash cannot match the null character, \0, as it is immediately discarded

		# CSI Control Sequence Introducer
		# See <ansi-escape-codes.md> <https://en.wikipedia.org/wiki/ANSI_escape_code> <https://www.gnu.org/software/screen/manual/html_node/Control-Sequences.html> <https://learn.microsoft.com/en-us/windows/console/console-virtual-terminal-sequences> <https://invisible-island.net/xterm/ctlseqs/ctlseqs.pdf>
		# @todo finish implementing from <https://learn.microsoft.com/en-us/windows/console/console-virtual-terminal-sequences>
		# @todo one day finish implementing from <https://invisible-island.net/xterm/ctlseqs/ctlseqs.pdf>

		# The below are read or written by Dorothy
		# $'\e\[[0-9\;]*m' 'style' # Select Graphic Rendition
		# $'\e\[[0-9]*A' 'cursor-up'
		# $'\e\[[0-9]*B' 'cursor-down'
		# $'\e\[[0-9]*C' 'cursor-forward'             # Cursor Right
		# $'\e\[[0-9]*D' 'cursor-back'                # Cursor Left
		# $'\e\[[0-9]*E' 'cursor-next-line'           # Cursor Next Line; Cursor Down Line; Cursor Below Line
		# $'\e\[[0-9]*F' 'cursor-previous-line'       # Cursor Previous Line; Cursor Prior Line; Cursor Up Line
		# $'\e\[[0-9]*G' 'cursor-horizontal-position' # Cursor Horizontal Position; Cursor Horizontal Absolute
		# $'\e\[[0-9\;]*H' 'cursor-position'          # Direct Cursor Addressing, same as Horizontal Vertical Position

		# $'\e\[[0-2]*J' 'erase-in-display'
		# ESC [ Pn J           Erase in Display
		# Pn = None or 0       From Cursor to End of Screen
		# 1                    From Beginning of Screen to Cursor
		# 2                    Entire Screen

		# $'\e\[[0-2]*K' 'erase-in-line'
		# ESC [ Pn K           Erase in Line
		# Pn = None or 0       From Cursor to End of Line
		# 1                    From Beginning of Line to Cursor
		# 2                    Entire Line

		# $'\e\[6n' 'report-cursor-position'         # used by [get-terminal-cursor-line-and-column]; Device Status Report; Reports the cursor position (CPR) by transmitting `ESC[n;mR`, where n is the row and m is the column; `ESC [ 6 n` Send Cursor Position Report; DECXCPR; Report Cursor Position; Emit the cursor position as: ESC [ <r> ; <c> R Where <r> = cursor row and <c> = cursor column
		# $'\e\[[0-6] q' 'cursor-style'              # Cursor Style; Cursor Shape
		# $'\e\[\?25h' 'show-cursor'                 # used by [styles.bash]
		# $'\e\[\?25l' 'hide-cursor'                 # used by [styles.bash]
		# $'\e\[\?1049h' 'alternative-screen-buffer' # used by [styles.bash]
		# $'\e\[\?1049l' 'default-screen-buffer'     # used by [styles.bash]
		# $'\e\]11\;\?\a' 'report-colors'            # used by [get-terminal-theme]
		# $'\e\[8\;[0-9\;]*t' 'terminal-resize'      # used by [styles.bash]; `ESC [ 8 ; Ph ; Pw t` Resize the window to ‚ÄòPh‚Äô lines and ‚ÄòPw‚Äô columns (SunView special)
		# $'\e\]52\;c\;.*\a' 'clipboard'             # used by [styles.bash]
		# # $'\e\]52\;c\;' 'begin-clipboard'           # in case it isn't terminated correctly
		# $'\e\]0\;.*\a' 'terminal-title'            # used by [styles.bash]; Operating System Command (Hardstatus, xterm title hack)
		# $'\e\]0\;' 'begin-terminal-title'          # in case it isn't terminated correctly

		# The following are not used within Dorothy, and they appear to work as expected in Apple Terminal even if not used by Dorothy itself:
		# $'\ec' 'reset'                            # Reset to Initial State
		# $'\e#8' 'test-card'                       # Fill Screen with E's
		# $'\e\[[0-9]*d' 'cursor-vertical-position' # Cursor vertical position; Cursor Vertical Absolute
		# $'\e\[[0-9\;]*f' 'cursor-position'        # Horizontal Vertical Position, same as Direct Cursor Addressing

		# The following are not used within Dorothy, and I do not have time nor care to figure out if they work or not:
		# $'\016' 'lock-shift-g1'                      # Lock Shift G1 (SO)
		# $'\e_' 'application-program-command'         # Application Program Command (Hardstatus)
		# $'\e\!' 'global-message-string'              # Global Message String (Message Line)
		# $'\e\[[0-9]*\`' 'cursor-horizontal-absolute' # Cursor Horizontal Absolute; Cursor horizontal position
		# $'\e\[[0-9]*\^' 'scroll-down'                # Scroll Scrolling Region Down
		# $'\e\[[0-9]*I' 'horizontal-tab'              # Horizontal Tab
		# $'\e\[[0-9]*L' 'insert-line'                 # Insert Line; in Apple Terminal, no matter the N value, it removes the current and lower lines maintaining horizontal cursor
		# $'\e\[[0-9]*M' 'delete-line'                 # Delete Line; in Apple Terminal, no matter the N value, it removes the current and lower lines maintaining horizontal cursor
		# $'\e\[[0-9]*S' 'scroll-up'                   # Scroll Scrolling Region Up
		# $'\e\[[0-9]*T' 'scroll-down'                 # Scroll Scrolling Region Down
		# $'\e\[[0-9]*X' 'erase-character'             # Erase character
		# $'\e\[[0-9]*Z' 'backward-tab'                # Backward Tab; in Apple Terminal, no matter the N value, it goes back to the start of the line
		# $'\e\[[0-9\;]*r' 'set-scrolling-region'      # Set Scrolling Region
		# $'\e\[[03]*g' 'tab-clear'                    # Tab Clear; Pn = None or 0 Clear Tab at Current Position; 3 Clear All Tabs
		# $'\e\[\?1004h' 'enable-reporting-focus'
		# $'\e\[\?1004l' 'disable-reporting-focus'
		# $'\e\[\?2004h' 'enable-bracketed-paste-mode'
		# $'\e\[\?2004l' 'disable-bracketed-paste-mode'
		# $'\e\[\>c' 'send-secondary-device-attributes-string' # `ESC [ > c` Send Secondary Device Attributes String
		# $'\e\[200~' 'begin-bracketed-paste'
		# $'\e\[201~' 'end-bracketed-paste'
		# $'\e\[4i' 'disable-aux-port'                # `ESC [ 4 i` (A) Stop relay to printer (ANSI Media Copy)
		# $'\e\[5i' 'enable-aux-port'                 # `ESC [ 5 i` (A) Start relay to printer (ANSI Media Copy)
		# $'\e\[6p' 'hide-cursor'                     # Cursor Visibility (97801) Invisible
		# $'\e\[7p' 'show-cursor'                     # Cursor Visibility (97801) Visible
		# $'\e\[c' 'send-vt100-identification-string' # Send VT100 Identification String
		# $'\e\[s' 'save-cursor'                     # save-cursor-position, save-current-cursor-position
		# $'\e\[u' 'restore-cursor'                  # restore-cursor-position, restore-saved-cursor-position
		# $'\e\[x' 'send-terminal-parameter-report'   # (V) Send Terminal Parameter Report
		# $'\e\]83\;.*\a' 'screen-command'            # Execute screen command.
		# $'\e\]83\;' 'begin-screen-command'
		# $'\e\\' 'string-terminator'       # String Terminator
		# $'\e\^' 'privacy-message-string'  # Privacy Message String (Message Line)
		# $'\e\=' 'application-keypad-mode' # Application Keypad Mode
		# $'\e\>' 'numeric-keypad-mode'     # Numeric Keypad Mode
		# $'\e7' 'save-cursor'                       # Save Cursor and Attributes
		# $'\e8' 'restore-cursor'                    # Restore Cursor and Attributes
		# $'\eD' 'index'                    # Index (IND is 0x84); note $'\x84' becomes a ? in Apple Terminal; note \eD just seems to be a newline that maintains horizontal cursor position while moving the vertical cursor position to the new line
		# $'\eg' 'visual-bell'
		# $'\eH' 'horizontal-tab-set'                          # Tab Set (HTS is 0x88); note $'\x88' becomes a ? in Apple Terminal
		# $'\ek' 'title-definition-string'                     # Title Definition String
		# $'\en' 'lock-shift-g2'                               # Lock Shift G2
		# $'\eN' 'single-shift-g2'                             # Single Shift G2; Single Shift Select of G2 Character Set (SS2 is 0x8e), VT220. This affects next character only; note $'\x8e' becomes a ? in Apple Terminal
		# $'\eo' 'lock-shift-g3'                               # Lock Shift G3
		# $'\eO' 'single-shift-g3'                             # Single Shift G3; Single Shift Select of G3 Character Set (SS3 is 0x8f), VT220. This affects next character only; note $'\x8f' becomes a ? in Apple Terminal
		# $'\eP' 'device-control-string'                       # Device Control String (DCS is 0x90); note $'\x90' becomes a ? in Apple Terminal
		# $'\eZ' 'send-vt100-identification-string'            # Send VT100 Identification String

		# The below documentation did not make it clear what their actual syntax is, so they are not implemented:
		# Control-O (A) Lock Shift G0 (SI)
		# `ESC ( Pcs` (A) Designate character set as G0
		# `ESC ) Pcs` (A) Designate character set as G1
		# `ESC * Pcs` (A) Designate character set as G2
		# `ESC + Pcs` (A) Designate character set as G3

		# The below were found from <https://invisible-island.net/xterm/ctlseqs/ctlseqs.pdf> which is too exhaustive to implement all of them, and most don't seem supported
		# $'\e\[I' 'focus-in' # FocusIn
		# $'\e\[O' 'focus-out' # FocusOut
		# $'\eE' 'next-line' # Next Line (NEL is 0x85); note $'\x85' becomes a ? in Apple Terminal; behaves just like \n in Apple Terminal
		# $'\v' 'cursor-up' # Cursor up (Ctrl-K);  behaves just like \n in Apple Terminal
		# $'\eV' '' # start-of-guarded-area... this is where I give up as there are too many that don't seem to do anything in Apple Terminal

		# The below is a generic match for setting and resetting terminal modes, of which some are already captured above:
		# $'\e\[[0-9\;]*h' 'set-mode'   # `ESC [ Ps ;...; Ps h` Set Mode
		# $'\e\[[0-9\;]*l' 'reset-mode' # `ESC [ Ps ;...; Ps l` Reset Mode
		# Ps = 4       (A)     Insert Mode
		# 20           (A)     ‚ÄòAutomatic Linefeed‚Äô Mode.
		# 34                   Normal Cursor Visibility
		# ?1           (V)     Application Cursor Keys
		# ?3           (V)     Change Terminal Width to 132 columns
		# ?5           (V)     Reverse Video
		# ?6           (V)     ‚ÄòOrigin‚Äô Mode
		# ?7           (V)     ‚ÄòWrap‚Äô Mode
		# ?9                   X10 mouse tracking
		# ?25          (V)     Visible Cursor
		# ?47                  Alternate Screen (old xterm code)
		# ?1000        (V)     VT200 mouse tracking
		# ?1047                Alternate Screen (new xterm code)
		# ?1049                Alternate Screen (new xterm code)
	)
	local -i patterns_size="${#patterns[@]}"
	function __print_and_trim_key {
		local name="$1" key="$2"
		local -i size="${#key}"
		last_key="$key"
		inputs="${inputs:size}"
		if [[ $option_quiet == 'no' ]]; then
			printf '%s %q\n' "$name" "$key"
		else
			printf '%s\n' "$name"
		fi
	}
	function __match_pattern_and_trim_once {
		local pattern name
		local -i index
		for ((index = 0; index < patterns_size; index += 2)); do
			pattern="${patterns[index]}"
			if [[ $inputs =~ ^$pattern ]]; then
				name="${patterns[index + 1]}"
				__print_and_trim_key "$name" "${BASH_REMATCH[0]}"
				return 0
			fi
		done
		return 1
	}
	function __match_key_and_trim_once {
		local name="$1" key
		for key in "$@"; do
			if [[ $inputs == "$key"* ]]; then
				__print_and_trim_key "$name" "$key"
				return 0
			fi
		done
		return 1
	}
	function __match_print_and_trim_once {
		local key
		if [[ $inputs =~ ^[[:print:]] ]]; then
			key="${BASH_REMATCH[0]}" # bash 3.2 does not support multiple calls to BASH_REMATCH so it must be cached
			__print_and_trim_key "$key" "$key"
			# __print_and_trim_key "${BASH_REMATCH[0]}" "${BASH_REMATCH[0]}" <-- bash 3.2 does not like this
			return 0
		fi
		return 1
	}
	function flush {
		while [[ -n $inputs ]]; do
			case "$inputs" in

			# escape
			# [0x1B = $'\x1b' = $'\033' = $'\u001B' = $'\e'] is [‚éã] ubuntu, macos
			$'\e' | $'\e\n'* | $'\e\e'*) __match_key_and_trim_once 'escape' $'\e' ;;

			# standard key or unknown special key
			*)
				if ! __match_pattern_and_trim_once && ! __match_print_and_trim_once; then
					if [[ $option_quiet == 'no' ]]; then
						printf '%s %q\n' 'unknown' "$inputs" >&2 # should be the same as __print_and_trim_key but go to stderr instead
					fi
					return 94 # EBADMSG 94 Bad message
				fi
				;;
			esac
		done
	}

	# act
	if [[ $option_continue == 'no' ]]; then
		read_and_flush
	else
		while :; do
			read_and_flush
		done
	fi
)

# fire if invoked standalone
if [[ $0 == "${BASH_SOURCE[0]}" ]]; then
	if [[ $* == '--test' ]]; then
		read_key_test
	else
		read_key "$@"
	fi
fi
