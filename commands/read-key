#!/usr/bin/env bash
#!/bin/bash
# trunk-ignore-all(shellcheck/SC2162)

# https://learn.microsoft.com/en-us/windows/console/console-virtual-terminal-sequences
# https://www.gnu.org/software/screen/manual/html_node/Control-Sequences.html
# https://gist.github.com/fnky/458719343aabd01cfb17a3a4f7296797 and https://gist.github.com/ConnerWill/d4b6c776b509add763e17f9f113fd25b - they look the same but have different commit histories
# https://en.wikipedia.org/wiki/ANSI_escape_code#CSI_(Control_Sequence_Introducer)_sequences
# https://tldp.org/HOWTO/Bash-Prompt-HOWTO/bash-prompt-escape-sequences.html
# https://en.wikipedia.org/wiki/ANSI_escape_code#Terminal_input_sequences <-- mentions screen/vt codes, whcih can be verified by entering [read] then entering [read-key] then entering the key
# https://invisible-island.net/xterm/ctlseqs/ctlseqs.pdf

# read
# -s do not echo input coming from a terminal
# -t timeout	time out and return failure if a complete line of input is not read within TIMEOUT seconds.  The value of the TMOUT variable is the default timeout.  TIMEOUT may be a fractional number.  If TIMEOUT is 0, read returns immediately, without trying to read any data, returning success only if input is available on the specified file descriptor.  The exit status is greater than 128 if the timeout is exceeded
# -n nchars	return after reading NCHARS characters rather than waiting for a newline, but honor a delimiter if fewer than NCHARS characters are read before the delimiter
# -N nchars	return only after reading exactly NCHARS characters, unless EOF is encountered or read times out, ignoring any delimiter
# Exit Status: The return code is zero, unless end-of-file is encountered, read times out (in which case it's greater than 128), a variable assignment error occurs, or an invalid file descriptor is supplied as the argument to -u.

# special keys for common environments (manually verified)
# don't do fn+key on ubuntu, as that is probably invoking a media key instead
# https://en.wikipedia.org/wiki/Alt_key
# https://en.wikipedia.org/wiki/Caps_Lock
# https://en.wikipedia.org/wiki/Control_key
# https://en.wikipedia.org/wiki/Command_key
# https://en.wikipedia.org/wiki/Backspace
# https://en.wikipedia.org/wiki/Delete_key
# https://en.wikipedia.org/wiki/End_key
# https://en.wikipedia.org/wiki/Enter_key
# https://en.wikipedia.org/wiki/Esc_key
# https://en.wikipedia.org/wiki/Home_key
# https://en.wikipedia.org/wiki/Insert_key
# https://en.wikipedia.org/wiki/List_of_Unicode_characters
# https://en.wikipedia.org/wiki/Option_key
# https://en.wikipedia.org/wiki/Page_Up_and_Page_Down_keys
# https://en.wikipedia.org/wiki/Shift_key
# https://en.wikipedia.org/wiki/Super_key_(keyboard_button)
# https://en.wikipedia.org/wiki/Tab_key
# https://stackoverflow.com/a/29243081/130638
# https://www.acrobatfaq.com/atbref95/index/Keyboard_Shortcuts/Unicode_Codes_for_Keyboard_symbols.html
# ⌅, ⌤ = enter key: [return enter] old macos keyboards, [return] new macos keyboards, [Enter ↵] raspberry keyboards
# ↵ = return key, alias for enter
# ↑ = up arrow key
# ↓ = down arrow key
# → = right arrow key
# ⎋ = escape key: [esc] macos keyboards, [Esc] raspberry keyboard
# ⌦ = delete key, aka delete forward key: [not present] macos keyboards, [Delete] raspberry keyboard
# ⌫ = backspace key, aka delete backward key: [Backspace ⬸] raspberry keyboard
# ← = left arrow key
# ⇧ = shift key
# ⎇ = alt key: [not present] macos keyboards, [Alt] raspberry keyboards
# ⌥ = option key: [option alt] old macos keybaords, [option ⌥] new macos keyboards, [not present] raspberry keyboard
# ⌃, ⎈ = control key: [control] old macos keyboards, [control ⌃] new macos keyboards, [Ctrl] raspberry keyboards, [⎈] rarely used official symbol
# ⌘ = command key: [command ⌘] macos keyboards, [raspberry symbol] raspberry keyboards
# ❖ = super key, alias for command key
# 🌐 = function key: [fn] old macos keybaords, [🌐 fn] new macos keyboards, [Fn] raspberry keyboards
# ⇪ = caps lock key: [caps lock] macos and raspberry keyboards
# ⇥ = tab key: [tab] on macos keyboard, [tab ⇤ ⇥] raspberry keyboards
# ⇤ = backtab key: [visible as the alt] raspberry keyboards
# ⇱ = home key: [Home] raspberry keyboards
# ⇲ = end key: [End] raspberry keyboards
# ⇞ = page up key: [PgUp] raspberry keyboards
# ⇟ = page down key: [PgDn] raspberry keyboards
# Insert key does not have an official symbol: [not present] macos keyboards, [Ins] raspberry keyboards

function read_key_test() (
	source "$DOROTHY/sources/bash.bash"
	echo-style --h1="TEST: $0"

	# refer to [is-tty --test] for more comprehensive testing

	# do a test without any capturing
	local book status

	printf '%s\n' "read-key bash version [$BASH_VERSION] [$BASH_VERSION_MAJOR] "

	status=0
	read -t 0 || status=$?
	printf '%s\n' "read-key check status [$status] "

	status=0
	printf '%s\n' 'abc' | read -t 0 || status=$?
	printf '%s\n' "read-key pipe check status [$status] "

	status=0
	read -t 0 <<<"$(printf '%s\n' 'abc')" || status=$?
	printf '%s\n' "read-key <<< check status [$status] "

	status=0
	read -t 0 < <(printf '%s\n' 'abc') || status=$?
	printf '%s\n' "read-key < <(...) check status [$status] "

	if test "$BASH_VERSION_MAJOR" -ge '4'; then
		status=0
		date
		read -sN1 -t 5 book || status=$?
		date
		printf '%s\n' "read-key v4 status [$status] and read [$book]"
	fi

	status=0
	date
	IFS= read -sn1 -t 5 book || status=$?
	date
	printf '%s\n' "read-key v3 status [$status] and read [$book]"

	if test "$BASH_VERSION_MAJOR" -ge '4'; then
		status=0
		printf '%s\n' 'abc' | read -sN1 -t 5 book || status=$?
		printf '%s\n' "read-key v4 status [$status] and read [$book]"
	fi

	status=0
	printf '%s\n' 'def' | IFS= read -sn1 -t 5 book || status=$?
	printf '%s\n' "read-key v3 status [$status] and read [$book]"

	status=0
	printf '%s\n' 'abc' | read -s -t 5 book || status=$?
	printf '%s\n' "read-key -s status [$status] and read [$book]"

	status=0
	printf '%s\n' 'abc' | read -t 5 book || status=$?
	printf '%s\n' "read-key status [$status] and read [$book]"

	status=0
	(
		printf '%s\n' 'abc'
	) | read -t 60 book || status=$?
	printf '%s\n' "read-key manual timeout [$status] and read [$book]"

	eval-tester --name='timeout was detected' --status='60' \
		-- read-key --timeout=10

	{
		__print_line
	} | eval-tester --name='enter was detected' --stdout='enter' \
		-- read-key --timeout=10

	{
		printf '%s' $'\x0a'
	} | eval-tester --name='enter was detected' --stdout='enter' \
		-- read-key --timeout=10

	{
		printf '%s' $'\e\e\e\e'
	} | eval-tester --name='escapes were detected' --stdout=$'escape\nescape\nescape\nescape' \
		-- read-key --timeout=10

	{
		printf '%s' $'\e[Ha\e[1~'
	} | eval-tester --name='home variants were detected' --stdout=$'home\na\nhome' \
		-- read-key --timeout=10

	{
		printf '%s' $'\e[B'
	} | eval-tester --name='down was detected' --stdout='down' \
		-- read-key --timeout=10

	{
		printf '%s' $'\e[F'
	} | eval-tester --name='end was detected' --stdout='end' \
		-- read-key --timeout=10

	local maybe_enter
	if is-tty; then
		maybe_enter=$'enter\n'
	else
		maybe_enter=''
	fi
	{
		printf '%s' $'\e\e\n\e[Hab\e[1~cd'
	} | eval-tester --name='a series of characters were detected' --stdout=$'escape\nescape\n'"$maybe_enter"$'home\na\nb\nhome\nc\nd' \
		-- read-key --timeout=10

	{
		printf '%s' $'\e[Hab\e[1~cd\e[F\e[Jef'
	} | eval-tester --name='ANSI escape codes result in failure' --status=94 --stdout=$'home\na\nb\nhome\nc\nd\nend' --stderr="unknown input: $'\E[Jef'" \
		-- read-key --timeout=10

	echo-style --g1="TEST: $0"
	return 0
)
function read_key() (
	source "$DOROTHY/sources/bash.bash"

	# =====================================
	# Arguments

	function help {
		cat <<-EOF >/dev/stderr
			ABOUT:
			Reads the immediately received characters and outputs which keys they are.

			USAGE:
			read-key [--keep-line-buffer-newlines] [--timeout=600]

			OPTIONS:
			--timeout=<timeout>
			    Custom timeout value in seconds.

			--keep-line-buffer-newlines
			    By default, when in non-TTY environments, characters are line buffered and require an [enter] key to be sent, of which we will discard such [enter] keys. Enabling this flag will send [line-buffer] on such [enter] keys.

			RETURNS:
			[0] if only printable keys and known non-printable keys were received
			[60] if a timeout occured
			[94] if an unknown non-printable character sequence was received

			QUIRKS:
			A pressable key can be a printable key, like [a] and [!], or a non-printable key, like [enter], [backspace], and [left].
			Non-printable keys can be a sequence of non-printable and printable characters.
			ANSI Escape Codes are a sequence of non-printable and printable characters, that the terminal interprets as a command, such as [erase line] and [move cursor], and are not always pressable keys (things like the [home] and [end] pressable keys actually function by sending ANSI Escape Codes).
			As the utility of this command is for reactivity to user interactions, only pressable keys are supported, and does not attempt to translate all ANSI Escape Codes into human readable commands, such as [move cursor up 5 lines].
			Furthermore, under typical circumstances this will react to a single key press, however under the line-buffer mode of non-TTY environments, which requires an enter key to be pressed to send the prior keys for processing, or under the circumstance of rapid key presses under Bash v3 which requires a second to process received input, then multiple keys may be rightfully be received and processed, in which multiple keys will be outputted, as such to properly handle key presses, you should treat the output of this command as an array.
			Because the [escape] key is translated as the start of an escaped character sequence, the [escape] key will only be understood if done at the end of a known sequence.
		EOF
		if test "$#" -ne 0; then
			echo-error "$@"
		fi
		return 22 # EINVAL 22 Invalid argument
	}

	# process
	local item option_timeout='' subsequent_timeout='0.0001' option_keep_line_buffer_newlines='no'
	while test "$#" -ne 0; do
		item="$1"
		shift
		case "$item" in
		'--help' | '-h') help ;;
		'--timeout='*) option_timeout="${item#*=}" ;;
		'--no-keep-line-buffer-newlines'* | '--keep-line-buffer-newlines'*)
			option_keep_line_buffer_newlines="$(get-flag-value --affirmative --fallback="$option_keep_line_buffer_newlines" -- "$item")"
			;;
		'--'*) help "An unrecognised flag was provided: $item" ;;
		*) help "An unrecognised argument was provided: $item" ;;
		esac
	done

	# timeout
	if ! is-number -- "$option_timeout"; then
		option_timeout=600 # ten minutes
	fi

	# bash v3 compat
	option_timeout="$(__get_read_decimal_timeout "$option_timeout")"
	subsequent_timeout="$(__get_read_decimal_timeout "$subsequent_timeout")"

	# =====================================
	# Action

	local inputs='' input='' last_key=''
	if get-terminal-tty-support --quiet; then
		function __discard_key_if_line_buffer_enter {
			return 1
		}
	else
		function __discard_key_if_line_buffer_enter {
			test "$input" = $'\n' -a -n "$last_key" -a "$last_key" != $'\n'
		}
	fi
	function add {
		local input="$1"
		if test -z "$input"; then
			input=$'\n'
		fi
		if test "$input" = $'\e' -o "$input" = $'\n'; then
			flush
		fi
		if __discard_key_if_line_buffer_enter; then
			if test "$option_keep_line_buffer_newlines" = 'yes'; then
				printf '%s\n' 'line-buffer'
			fi
			last_key="$input"
			input=''
		fi
		#printf 'input: %q\tinputs: %q\n' "$input" "$inputs"
		inputs+="$input"
	}
	function read_and_flush {
		# read
		local status=0
		IFS='' read -rsn1 -t "$option_timeout" input || status=$?
		if test "$status" -eq 0; then
			add "$input"
			while :; do
				# IFS='' allows the space character [ ] to be indentified
				# -r allows backslash key [\] to be kept
				# -s prevents the input from being echoed
				# -n1 reads only one character, which is necessary surprisingly to read non-printable characters
				if ! IFS='' read -rsn1 -t "$subsequent_timeout" input; then
					break
				fi
				add "$input"
			done
		fi

		# handle errors
		# in practice, timeouts are only ever 148, however docs say >=128 should be considered timeout
		if test "$status" -ge 128; then
			return 60 # ETIMEDOUT 60 Operation timed out
		elif test "$status" -eq 1 && (! test -t 0 || ! read -t 0); then
			# this can happen on CI environments, and other environments with stdin and TTY trickery
			return 60 # ETIMEDOUT 60 Operation timed out
		elif test "$status" -ne 0; then
			return "$status" # some other issue, let the caller figure it out
		fi

		# got key
		flush
	}
	function __match_special_and_trim_once {
		local name="$1" special found='no'
		for special in "$@"; do
			if [[ $inputs == "$special"* ]]; then
				last_key="$special"
				printf '%s\n' "$name"
				# starts with special, so remove special
				inputs="${inputs#"$special"}"
				found='yes'
			fi
		done
		test "$found" = 'yes'
	}
	function __match_print_and_trim {
		if [[ $inputs =~ ^[[:print:]] ]]; then
			last_key="${inputs:0:1}"
			printf '%s\n' "$last_key"
			inputs="${inputs:1}"
			return 0
		fi
		return 1
	}
	function flush {
		while test -n "$inputs"; do
			case "$inputs" in
			# ansi_regex="[[:cntrl:]][[0-9;?]*[ABCDEFGHJKSTfhlmnsu]"

			# cursor up one
			# [↑] ubuntu, macos
			# [$'\eM'] ansi escape code to cursor up a line and scroll if necessary, note that scrolling moves visible content down but content from above is empty/erased
			$'\e[A'* | $'\eM'*) __match_special_and_trim_once 'up' $'\e[A' $'\eM'* ;;

			# cursor down one
			# [↓] ubuntu, macos
			$'\e[B'*) __match_special_and_trim_once 'down' $'\e[B' ;;

			# cursor right one
			# [→] ubuntu, macos
			$'\e[C'*) __match_special_and_trim_once 'right' $'\e[C' ;;

			# cursor left one
			# [←] ubuntu, macos
			$'\e[D'*) __match_special_and_trim_once 'left' $'\e[D' ;;

			# cursor to top left
			# [⇱] ubuntu, macos
			# [numlock 7] ubuntu
			# [🌐 ⇧ ←] macos
			# [$'\e[H'] pressable key on the above systems
			# [$'\e[1~'] screen/vt on [🌐 ←] macos
			$'\e[H'* | $'\e[1~'*) __match_special_and_trim_once 'home' $'\e[H' $'\e[1~' ;;

			# cursor to start of current line
			# [$'\e[G'] ansi escape code
			# [0x0D = $'\x0d' = $'\r'] ansi escape code
			$'\e[G'* | $'\r'*) __match_special_and_trim_once 'carriage-return' $'\e[G' $'\r' ;;

			# cursor to start of prior line
			# [⇲] ubuntu, macos
			# [numlock 1] ubuntu
			# [🌐 ⇧ →] macos
			# [$'\e[F'] pressable key on the above systems
			# [$'\e[4~'] screen/vt on [🌐 →] macos
			$'\e[F'* | $'\e[4~'*) __match_special_and_trim_once 'end' $'\e[F' $'\e[4~' ;;

			# insert
			# [INSERT] [numlock 0] ubuntu
			$'\e[2~'*) __match_special_and_trim_once 'insert' $'\e[2~' ;;

			# delete
			# [⌦] [numlock .] ubuntu
			# [🌐 ⌫] macos
			$'\e[3~'*) __match_special_and_trim_once 'delete' $'\e[3~' ;;

			# page up
			# [⇞] [numlock 9] ubuntu
			# [🌐 ⇧ ↑] macos
			# screen/vt on [🌐 ↑] macos
			$'\e[5~'*) __match_special_and_trim_once 'page-up' $'\e[5~' ;;

			# page down
			# [⇟] [numlock 3] ubuntu
			# [🌐 ⇧ ↓] macos
			# screen/vt on [🌐 ↑] macos
			$'\e[6~'*) __match_special_and_trim_once 'page-down' $'\e[6~' ;;

			# backspace
			# [⌫] ubuntu, macos
			# [$'\x7f' = $'\177'] pressable key on the above systems
			# [0x08 = $'\x08' = $'\b'] ansi escape code
			$'\177'* | $'\b'*) __match_special_and_trim_once 'backspace' $'\177' $'\b' ;;

			# enter
			# [0x0A = $'\x0a' =  $'\n'] pressable key and ansi escape code
			$'\n'*) __match_special_and_trim_once 'enter' $'\n' ;;

			# tab
			# [⇥] ubuntu, macos
			# [0x09 = $'\x09' = $'\t'] pressable key and ansi escape code
			$'\t'*) __match_special_and_trim_once 'tab' $'\t' ;;

			# backtab
			# [shift ⇥] macos, ⇤
			$'\e[Z'*) __match_special_and_trim_once 'backtab' $'\e[Z' ;;

			# select all
			# [ctrl a] on macos, unicode symbol
			# [$'\x01' = $'\001'] pressable key and ansi escape code
			$'\x01'*) __match_special_and_trim_once 'all' $'\x01' ;;

			# space
			# [0x20 = $'\x20 = ' '] pressable key and ansi escape code
			' '*) __match_special_and_trim_once 'space' ' ' ;;

			# bell or end terminal title
			# [0x07 = $'\x07' = $'\007' = $'\a'] ansi escape code
			$'\a'*) __match_special_and_trim_once 'bell' $'\a' ;;

			# app-specific hotkeys that should be interpreted by the caller instead
			# up: [k] vim
			# down: [j] vim
			# right: [l] vim
			# left: [h] vim

			# unverified special keys for other environments
			# all: [$'\x01'] what type of key is this?
			# down: [$'\eOB'] v100, screen, xterm
			# end: [$'\eOF'] xterm
			# home: [$'\eOH'] xterm
			# left: [$'\eOD'] v100, screen, xterm
			# page-down: [$'\002'] [⌃ b] vim
			# page-up: [$'\006'] [⌃ f] vim
			# right: [$'\eOC'] v100, screen, xterm
			# up: [$'\eOA'] v100, screen, xterm

			# escape
			# 0x1B = $'\x1b' = $'\033' = $'\u001B' = $'\e'
			$'\e' | $'\e\n'* | $'\e\e'*) __match_special_and_trim_once 'escape' $'\e' ;;

			# standard key or unknown special key
			*)
				if ! __match_print_and_trim; then
					printf 'unknown input: %q\n' "$inputs" >/dev/stderr
					return 94 # EBADMSG 94 Bad message
				fi
				;;
			esac
		done
	}

	# act
	read_and_flush
)

# fire if invoked standalone
if test "$0" = "${BASH_SOURCE[0]}"; then
	if test "$*" = '--test'; then
		read_key_test
	else
		read_key "$@"
	fi
fi
