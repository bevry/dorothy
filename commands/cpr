#!/usr/bin/env bash

# @todo figure out how to make --eval compatible with paths that have spaces

# @todo support these:
# https://github.com/veeso/termscp - 1.9k stars, maintained, last update 3 weeks ago
# https://github.com/schollz/croc - 28.6k stars, maintained, last update 2 weeks ago
# https://github.com/magic-wormhole/magic-wormhole - 20.8k stars, maintained, last update 3 days ago
#
# https://github.com/ShareDropio/sharedrop - 10.4k stars, maintained, last update 2 months ago - is a web app
# https://github.com/kern/filepizza - 4.5k stars, maintained, last update 3 days ago - is a web app
#
# https://github.com/SpatiumPortae/portal - 1.6k stars, last update 8 months ago
# https://github.com/nils-werner/zget - 484 stars, last update 7 months ago
# https://github.com/abdfnx/tran - 421 stars, last update 6 months ago
#
# https://github.com/mozilla/send - 13.3k stars, archived
# https://github.com/dennis-tra/pcp - 1.1k stars, last update 4 years ago
# https://github.com/zerotier/toss - 339 stars, archived
# https://github.com/subins2000/WebDrop - 278 stars, last update 2 years ago
# https://github.com/lmangani/gunstore.io - 41 stars, last update 3 years ago
# https://github.com/devclub-iitd/SenData - 16 stars, last update 5 years ago
# https://github.com/rockymadden/github-crypt - 15 stars, last update 7 years ago

# drop support for these:
# gcp - last update 2019
# https://github.com/aelafifi/gcp
# https://code.lm7.fr/mcy/gcp
# https://repology.org/project/gcp/packages

function cpr_() (
	source "$DOROTHY/sources/bash.bash"

	# determine tools
	local verify_tools=()
	local copy_tools=()
	if __command_exists -- rsync; then
		# setup-util-rsync
		verify_tools+=(rsync)
		copy_tools+=(rsync)
	fi
	if __command_exists -- gcp; then
		# @todo drop, as it is outdated
		copy_tools+=(gcp)
	fi
	if __command_exists -- scp; then
		# bundled wih openssh-client
		copy_tools+=(scp)
	fi
	if __command_exists -- cp; then
		# setup-util-coreutils
		copy_tools+=(cp)
	fi
	if __command_exists -- diff; then
		# setup-util-diff
		verify_tools+=(diff)
	fi
	if __command_exists -- git; then
		# setup-util-git
		verify_tools+=(git)
	fi

	# =====================================
	# Arguments

	# help
	function help {
		cat <<-EOF >&2
			ABOUT:

			Copy everything from one location to another, features:
			- preserves attributes
			- progress updates
			- local and remote sources

			USAGE:

			cpr [...options] [--] <origin> <destination>
			cpr [...options] [--origin=<origin>] [--destination=<destination>]

			<origin> and <destination> can be a local path on your current machine, or a remote path.

			If a remote path, it should be in the format of:
			    [username@hostname:/path] for files
			    [username@hostname:/path/] for directories

			The [hostname] is the hostname or IP address of a valid SSH server.

			Enable SSH on macOS via System Preferences > Sharing > Remote Login.
			Enable SSH on Ubuntu via https://ubuntu.com/server/docs/service-openssh


			OPTIONS:

			--tool=<tool>
			    if specified, skips tool prompt. Available tools on this machine are:
			    for copy: $(__join --source={copy_tools} --delimiter=', ')
			    for verify: $(__join --source={verify_tools} --delimiter=', ')

			--no-confirm
			    if enabled, do not confirm anything.

			--dry
			    if enabled, only output the determined command, do not run it.

			--elevate
			    if enabled, run the determined command with elevated privileges.

			--verify
			    if enabled, only verify that the target contains all the files from the source, do not modify anything.

			Additional OPTIONS enabled when [--tool=rsync] is used:

			--remove
			    if enabled, remove source files as they are successfully copied to the target.

			--checksum
			    if enabled, files are compared by their checksums, instead of the default quicker date and size comparison.

			--linux
			    if enabled, increases compatibility with between linux systems.

			--owner=<user>:<group>
			    if specified, uses this value for the ownership of copied files.
		EOF
		if [[ $# -ne 0 ]]; then
			__print_error "$@"
		fi
		return 22 # EINVAL 22 Invalid argument
	}

	# process
	local item option_tool='' option_origin='' option_destination='' option_confirm='yes' option_dry='no' option_elevate='no' option_verify='no' option_remove='no' option_checksum='no' option_linux='no' option_owner=''
	while [[ $# -ne 0 ]]; do
		item="$1"
		shift
		case "$item" in
		'--help' | '-h') help ;;
		'--tool='*) option_tool="${item#*=}" ;;
		'--origin='* | '--source='*) option_origin="${item#*=}" ;;
		'--destination='*) option_ destination="${item#*=}" ;;
		'--owner='*) option_owner="${item#*=}" ;;
		'--no-confirm'* | '--confirm'*) __flag --source={item} --target={option_confirm} --affirmative ;;
		'--no-dry'* | '--dry'*) __flag --source={item} --target={option_dry} --affirmative ;;
		'--no-elevate'* | '--elevate'*) __flag --source={item} --target={option_elevate} --affirmative ;;
		'--no-verify'* | '--verify'*) __flag --source={item} --target={option_verify} --affirmative ;;
		'--no-remove'* | '--remove'*) __flag --source={item} --target={option_remove} --affirmative ;;
		'--no-checksum'* | '--checksum'*) __flag --source={item} --target={option_checksum} --affirmative ;;
		'--no-linux'* | '--linux'*) __flag --source={item} --target={option_linux} --affirmative ;;
		'--')
			if [[ -n $option_origin || -n $option_destination ]]; then
				help "[--] can only be used if <origin> and <destination> are not set via other means"
			fi
			option_origin="$1"
			option_destination="$2"
			shift "$#"
			;;
		'--'*) help 'An unrecognised flag was provided: ' --variable-value={item} ;;
		*)
			if [[ -z $item ]]; then
				help "Empty <origin> or <destination> argument provided."
			elif [[ -z $option_origin ]]; then
				option_origin={item}
			elif [[ -z $option_destination ]]; then
				option_destination="$item"
			else
				help 'An unrecognised argument was provided: ' --variable-value={item}
			fi
			;;
		esac
	done

	# check origin and destination
	if [[ -z $option_origin || -z $option_destination ]]; then
		help "Both <origin> and <destination> must be specified."
	fi

	# ensure tool
	local tools=()
	if [[ $option_verify == 'yes' ]]; then
		if [[ ${#verify_tools[@]} -eq 0 ]]; then
			help 'No verify tools are available.' || :
			return 42 # ENOPROTOOPT 42 Protocol not available
		else
			tools=("${verify_tools[@]}")
		fi
	else
		if [[ ${#copy_tools[@]} -eq 0 ]]; then
			help 'No copy tools are available.' || :
			return 42 # ENOPROTOOPT 42 Protocol not available
		else
			tools=("${copy_tools[@]}")
		fi
	fi
	option_tool="$(
		choose --required \
			--question='Which tool to use?' \
			--skip-default --default="$option_tool" -- "${tools[@]}"
	)"

	# rsync options
	if [[ $option_tool == 'rsync' ]]; then
		# ensure checksum, if copy or verify
		if [[ -z $option_checksum ]]; then
			if confirm --negative --ppid=$$ -- 'Compare files via checksum, instead of the quicker and default date and size comparison?'; then
				option_checksum='yes'
			else
				option_checksum='no'
			fi
		fi
		# ensure remove, if copy or verify
		if [[ -z $option_remove ]]; then
			if confirm --negative --ppid=$$ -- 'Remove the source files after successful copies?'; then
				option_remove='yes'
			else
				option_remove='no'
			fi
		fi
		# ensure linux, if copy or verify
		if [[ -z $option_linux ]]; then
			if confirm --bool --ppid=$$ -- 'Are both machines Linux machines?'; then
				option_linux='yes'
			else
				option_linux='no'
			fi
		fi
	fi

	# adjustments
	function __adjust_format {
		local thing="$1" value="$2" what last_char styled
		last_char="${value: -1}" # get last char
		if [[ $last_char == '/' ]]; then
			what='directory'
		else
			what='file'
		fi
		styled="$(__print_style --code="$value")" || return
		what="$(
			choose --required \
				--question="Is the $thing a file or a directory? $styled" \
				--skip-default --default="$what" -- file directory
		)" || return
		if [[ $what == 'file' && $last_char == '/' ]]; then
			__replace --source+target={value} --trailing='/' || return
			__print_style --stderr "Adjusted $thing to $styled" || return
		elif [[ $what == 'directory' && $last_char != '/' ]]; then
			value="${value}/"
			__print_style --stderr "Adjusted $thing to $styled" || return
		fi
		__print_lines "$value" || return
	}
	function __adjust_spaces {
		local thing="$1" value="$2" adjustment
		adjustment="$(echo-escape-spaces -- "$value")" || return
		if [[ $adjustment != "$value" ]]; then
			__print_style --stderr "Adjusted $thing to $styled" || return
		fi
		__print_lines "$adjustment" || return
	}
	local RECURSED='no'
	function __adjust_faux {
		local question suggestion tangent
		suggestion="$(get-local-to-remote "$1" 2>/dev/null || :)"
		if [[ -n $suggestion ]]; then
			question="$(
				__print_style \
					--bold+underline='What would you like to do?' --newline \
					'Using rsync with a remote directory that is mounted locally can be slow.' --newline \
					'It is recommended to use its remote location instead, which autodetection implies it as:' --newline \
					--code-notice1="$suggestion" --newline \
					'Alternatively, attempt a different tool as they can be better under these circumstances.'
			)" || return
			tangent="$(
				choose \
					--question="$question" \
					--label -- \
					'exit' 'rethink and exit' \
					'ignore' 'ignore suggestion and continue anyway' \
					'different' 'attempt a different tool'
			)" || return
			if [[ $tangent == 'ignore' ]]; then
				__print_style --dim='Faux Remotes: ignore and continue' || return
				return 0
			elif [[ $tangent == 'different' ]]; then
				RECURSED='yes'
				__print_style --dim='Faux Remotes: attempting a different tool' || return
				cpr --confirm="$option_confirm" --dry="$option_dry" --elevate="$option_elevate" --verify="$option_verify" -- "$option_origin" "$option_destination" || return
				return
			else
				__print_style --dim='Faux Remotes: exit' || return
				# exit / default
				return 1
			fi
		fi
		return 0
	}
	if [[ $option_confirm != 'no' ]]; then
		option_origin="$(__adjust_format origin "$option_origin")" || return
		option_destination="$(__adjust_format destination "$option_destination")" || return
		option_origin="$(__adjust_spaces origin "$option_origin")" || return
		option_destination="$(__adjust_spaces destination "$option_destination")" || return
		if [[ $option_tool == 'rsync' ]]; then
			__adjust_faux "$option_origin" || return
			if [[ $RECURSED == 'yes' ]]; then
				return 0
			fi
			__adjust_faux "$option_destination" || return
			if [[ $RECURSED == 'yes' ]]; then
				return 0
			fi
		fi
	fi

	# =====================================
	# Action

	# prepare
	local cmd=()

	# tool
	if [[ $option_tool == 'rsync' ]]; then
		# via rsync, file by file progress
		cmd+=(rsync)

		# -P: same as --partial --progress
		# --partial: keep partially transferred files
		# --progress: show progress during transfer
		#
		# --archive, -a: archive mode; equals -rlptgoD (no -H,-A,-X)
		#   --recursive, -r: recurse into directories
		#   --links, -l: copy symlinks as symlinks
		#   --perms, -p: preserve permissions
		#   --times, -t: preserve modification times
		#   --group, -g: preserve group
		#   --owner, -o: preserve owner (super-user only)
		#   -D: same as --devices --specials
		#   --devices: preserve device files (super-user only)
		#   --specials: preserve special files
		#
		# --human-readable, -h: output numbers in a human-readable format
		cmd+=(
			'-P'
			'--archive'
			'--human-readable'
		)

		# verify
		if [[ $option_verify == 'yes' ]]; then
			# -i, --itemize-changes       output a change-summary for all updates
			# -n, --dry-run               show what would have been transferred
			cmd+=(
				'--itemize-changes'
				'--dry-run'
			)
		fi

		# linux
		if [[ $option_linux == 'yes' ]]; then
			# --acls, -A: preserve ACLs (implies --perms)
			# --xattrs, -X: preserve extended attributes
			# --atimes, -U: preserve access (use) times
			cmd+=(
				'--acls'
				'--xattrs'
				'--atimes'
			)

			# --crtimes, -N: preserve create times (newness)
			# --crtimes not supported on ubuntu server on arm, nor manjero on x86
			# cmd+=('--crtimes')
		fi

		# checksum
		if [[ $option_checksum == 'yes' ]]; then
			# --checksum, -c: skip based on checksum, not mod-time & size
			cmd+=('--checksum')
		fi

		# remove
		if [[ $option_remove == 'yes' ]]; then
			cmd+=('--remove-source-files')
		fi

		# owner
		if [[ -n $option_owner ]]; then
			cmd+=("--chown=$option_owner")
		fi

		# paths
		cmd+=(
			"$option_origin"
			"$option_destination"
		)

		# workaround for rsync always returning success exit code
		# https://superuser.com/q/1700581/32418
		if [[ $option_verify == 'yes' ]]; then
			function __verify_stdout {
				# check for errors
				if grep --quiet --regexp='^>'; then
					# has error
					return 1
				fi
				return 0
			}
		fi

	elif [[ $option_tool == 'gcp' ]]; then
		# via gcp, overall progress
		cmd+=('gcp')

		# sanity check
		if [[ $option_verify == 'yes' ]]; then
			help --code='--tool=gcp' --bold=' is incompatible with ' --code='--verify'
		fi

		# -a, --archive: same as -dR --preserve=all
		# -d: same as --no-dereference --preserve=links
		# -R, -r, --recursive: copy directories recursively
		# --preserve PRESERVE: preserve specified attributes; accepted values: 'all', or one or more amongst {'ownership', 'timestamps', 'mode'}
		#
		# -v, --verbose: display what is being done
		cmd+=(
			'--archive'
			'--verbose'
		)

		# paths
		cmd+=(
			"$option_origin"
			"$option_destination"
		)

	elif [[ $option_tool == 'scp' ]]; then
		# via scp
		cmd+=('scp')

		# sanity check
		if [[ $option_verify == 'yes' ]]; then
			help '[--tool=scp] is incompatible with [--verify]'
		fi

		# -A: Allows forwarding of ssh-agent(1) to the remote system.  The default is not to forward an authentication agent.
		# -p: Preserves modification times, access times, and modes from the original file.
		# -r: Recursively copy entire directories.  Note that scp follows symbolic links encountered in the tree traversal.
		cmd+=(
			'-A'
			'-p'
			'-r'
		)

		# paths
		cmd+=(
			"$option_origin"
			"$option_destination"
		)

	elif [[ $option_tool == 'cp' ]]; then
		# via cp
		cmd+=('cp')

		# sanity check
		if [[ $option_verify == 'yes' ]]; then
			help '[--tool=cp] is incompatible with [--verify]'
		fi

		# -a: Same as -pPR options. Preserves structure and attributes of files but not directory structure.
		# -P; If the -R option is specified, no symbolic links are followed.  This is the default.
		# -R: When source_file designates a directory, cp copies the directory and the entire subtree connected at that point.  If the source_file ends in a /, the contents of the directory are copied rather than the directory itself.  This option also causes symbolic links to be copied, rather than indirected through, and for cp to create special files rather than copying them as normal files.  Created directories have the same mode as the corresponding source directory, unmodified by the process' umask.
		#
		# -L: If the -R option is specified, all symbolic links are followed.
		# -p: Cause cp to preserve the following attributes of each source file in the copy: modification time, access time, file flags, file mode, user ID, and group ID, as allowed by permissions.  Access Control Lists (ACLs) and Extended Attributes (EAs), including resource forks, will also be preserved.
		# -f: If the destination file cannot be opened, remove it and create a new file, without prompting for confirmation regardless of its permissions.
		# -v: Cause cp to be verbose, showing files as they are copied.
		cmd+=(
			'-a'
			'-L'
			'-p'
			'-f'
			'-v'
		)

		# paths
		cmd+=(
			"$option_origin"
			"$option_destination"
		)

	elif [[ $option_tool == 'diff' ]]; then
		cmd+=('diff')

		# sanity check
		if [[ $option_verify != 'yes' ]]; then
			help '[--tool=diff] requires [--verify]'
		fi

		# -q  --brief: Output only whether files differ.
		# -r  --recursive: Recursively compare any subdirectories found.
		cmd+=(
			'--brief'
			'--recursive'
		)

		# paths
		cmd+=(
			"$option_origin"
			"$option_destination"
		)

	elif [[ $option_tool == 'git' ]]; then
		cmd+=(
			'git'
			'diff'
		)

		# sanity check
		if [[ $option_verify != 'yes' ]]; then
			help --code='--tool=git' --bold=' requires ' --code='--verify'
		fi

		# --no-index: This form is to compare the given two paths on the filesystem. You can omit the --no-index option when running the command in a working tree controlled by Git and at least one of the paths points outside the working tree, or when running the command outside a working tree controlled by Git. This form implies --exit-code.
		cmd+=('--no-index')

		# paths
		cmd+=(
			"$option_origin"
			"$option_destination"
		)

	else
		help "Invalid tool: $option_tool"
	fi

	function __wrap {
		eval-helper --verbose --wrap --shapeshifter --elevate="$option_elevate" -- "$@"
	}

	# run
	if [[ $option_dry == 'yes' ]]; then
		__print_lines "${cmd[@]}"
	elif [[ "$(type -t '__verify_stdout')" == 'function' ]]; then
		__wrap "${cmd[@]}" | echo-wait --buffer | __verify_stdout
	else
		__wrap "${cmd[@]}"
	fi
)

# fire if invoked standalone
if [[ $0 == "${BASH_SOURCE[0]}" ]]; then
	cpr_ "$@"
fi
