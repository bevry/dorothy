#!/usr/bin/env bash

function debug_bash() (
	source "$DOROTHY/sources/bash.bash"

	# =====================================
	# Arguments

	function help {
		cat <<-EOF >&2
			ABOUT:
			Run a bash script with [-x] applied: Print a trace of simple commands.

			USAGE:
			debug-bash [...options] [--] <command> [...args]

			OPTIONS:
			--bash=<bash-path>
			    If you want to invoke the command through a custom bash binary, then provide it here.
			    The PATH will be modified to enforce it.
			--all
			    Use all available bash binaries on the system.
			--continue
			    Continue on failure to the next bash version.

			--wrap
			    Wrap the command so we can see what we are executing.

			-v | -x | -xv | -vx
			    Pass these flags to bash.

			[--] <command> [...args]
			    The command to run.
		EOF
		if [[ $# -ne 0 ]]; then
			echo-error "$@"
		fi
		return 22 # EINVAL 22 Invalid argument
	}

	# process
	local item option_bash_binaries=() option_bash_options=() option_wrap='no' option_continue='no' option_bash_arguments=() option_only_print_binaries='no'
	while [[ $# -ne 0 ]]; do
		item="$1"
		shift
		case "$item" in
		--help | -h) help ;;
		--no-wrap* | --wrap*) __flag {option_wrap} --affirmative -- "$item" ;;
		--no-continue* | --continue*) __flag {option_continue} --affirmative -- "$item" ;;
		--no-only-print-binaries* | --only-print-binaries*) __flag {option_only_print_binaries} --affirmative -- "$item" ;;
		--all) option_bash_binaries+=(all) ;;
		--ab | --all-binaries | --all-bash-binaries) option_bash_binaries+=(all-binaries) ;;
		--av | --all-versions | --all-bash-versions) option_bash_binaries+=(all-versions) ;;
		--bash=* | --b=* | --binary=* | --binaries=* | --bash-binary=* | --bash-binaries=*) __split --target={option_bash_binaries} --append --no-zero-length --delimiters=$'\n\t' -- "${item#*=}" ;;
		--v=* | --version=* | --versions=* | --bash-version=* | --bash-versions=*) __split --target={option_bash_binaries} --append --no-zero-length --delimiters=$'\n\t ,|' -- "${item#*=}" ;;
		-c=* | --code=* | --eval=*)
			option_bash_options+=(-c "${item#*=}")
			;;
		-x)
			export BASH_DEBUG_X=yes
			option_bash_options+=(-x)
			;;
		-v)
			export BASH_DEBUG_V=yes
			option_bash_options+=(-v)
			;;
		-xv | -vx)
			export BASH_DEBUG_X=yes BASH_DEBUG_V=yes
			option_bash_options+=(-xv)
			;;
		--)
			if [[ $1 == bash ]]; then
				shift
				if [[ $1 == -- ]]; then
					shift
				fi
			fi
			if [[ $1 == -* ]]; then
				help "Custom options for bash are not supported."
			fi
			option_bash_arguments+=("$@")
			shift "$#"
			break
			;;
		--*) help "An unrecognised flag was provided: $item" ;;
		*) help "An unrecognised argument was provided: $item" ;;
		esac
	done

	# prepare
	local __exit_status=0
	function __get_all_bash_binaries_and_versions {
		{
			type -pa bash || :
			expand-path -- "$XDG_BIN_HOME/bash-*" || :
		} | echo-unique --stdin
	}
	function __get_all_bash_binaries {
		type -pa bash | echo-unique --stdin
	}
	function __get_all_bash_versions {
		expand-path -- "$XDG_BIN_HOME/bash-*" || :
	}

	# determine bash binaries
	local bash_input bash_binary bash_binaries=()
	if [[ ${#option_bash_binaries[@]} -eq 0 ]]; then
		option_bash_binaries+=('bash')
	fi
	for bash_input in "${option_bash_binaries[@]}"; do
		if [[ $bash_input == 'all' ]]; then
			setup-util-bash --all-versions
			__split --target={bash_binaries} --no-zero-length --invoke -- \
				__get_all_bash_binaries_and_versions
			continue
		elif [[ $bash_input == 'all-versions' ]]; then
			# install all versions, and use all binaries
			setup-util-bash --all-versions
			__split --target={bash_binaries} --no-zero-length --invoke -- \
				__get_all_bash_versions
			continue
		elif [[ $bash_input == 'all-binaries' ]]; then
			__split --target={bash_binaries} --no-zero-length --invoke -- \
				__get_all_bash_binaries
			continue
		fi
		if [[ $bash_input =~ ^[0-9] ]]; then
			# convert version number to executable
			setup-util-bash --version="$bash_input"
			bash_input="$(expand-path -- "$XDG_BIN_HOME/bash-$bash_input*" | echo-first-line --stdin)"
			# if it doesn't exist, install it
		fi
		bash_binary="$(type -P "$bash_input" || :)"
		if [[ -z $bash_binary ]]; then
			echo-style --error='The bash binary ' --code="$bash_input" ' does not exist.'
			__exit_status=2 # ENOENT 2 No such file or directory
			continue
		else
			bash_binaries+=("$bash_binary")
		fi
	done
	__unique --source+target={bash_binaries}
	if [[ $option_only_print_binaries == 'yes' ]]; then
		__print_lines "${bash_binaries[@]}"
		return "$__exit_status"
	fi

	# execute bash commands now
	local cmd=() bash_binary bash_version bash_path
	for bash_binary in "${bash_binaries[@]}"; do
		bash_version="$("$bash_binary" -c 'printf '%s' "${BASH_VERSINFO[0]}.${BASH_VERSINFO[1]}.${BASH_VERSINFO[2]}"')"
		# check bash version
		if [[ $bash_version == '4.1'* || $bash_version == '3.1'* || $bash_version == '3.0'* || $bash_version == '2.'* || $bash_version == '1.'* || $bash_version == '0.'* ]]; then
			echo-style --error="The bash binary [$bash_input] is version [$bash_version], which is not supported."
			__exit_status=75 # EPROGMISMATCH 75 Program version wrong
			continue
		fi
		# enforce the bash version if custom
		if [[ ${#option_bash_binaries[@]} -eq 0 ]]; then
			# we are just using the default one
			cmd=("$bash_binary" "${option_bash_options[@]}" -- "${option_bash_arguments[@]}")
			if [[ $option_wrap == 'yes' ]]; then
				cmd=(eval-helper --verbose --wrap -- "${cmd[@]}")
			fi
		else
			bash_path="$(fs-temp --directory='debug-bash' --directory="custom-path-for-bash-$bash_version" --directory --touch)"
			ln -sf -- "$bash_binary" "$bash_path/bash"
			cmd=(env PATH="$bash_path:$PATH" "$bash_binary" "${option_bash_options[@]}" -- "${option_bash_arguments[@]}")
			if [[ $option_wrap == 'yes' ]]; then
				cmd=(eval-helper --verbose --wrap --command="${cmd[*]/$PATH/\"\$PATH\"}" -- "${cmd[@]}")
			fi
		fi
		export BASH_DEBUG=yes PS4="$BASH_DEBUG_FORMAT"
		if [[ $option_continue == 'yes' ]]; then
			"${cmd[@]}" || __exit_status=$? # eval
		else
			"${cmd[@]}" # eval
		fi
		unset BASH_DEBUG PS4
	done
	if [[ $__exit_status -ne 0 ]]; then
		return "$__exit_status"
	fi
)

# fire if invoked standalone
if [[ $0 == "${BASH_SOURCE[0]}" ]]; then
	debug_bash "$@"
fi
