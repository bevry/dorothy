#!/usr/bin/env bash

# @todo add a get-user and get-group, using something like this:
# function get_user {
# 	local path='/lib/systemd/system/plexmediaserver.service'
# 	local path='/etc/systemd/system/plexmediaserver.service.d/override.conf''
# 	sudo-helper --inherit \
# 		-- config-helper --file="$path" -- \
# 		--field='User'
# }
# function get_group {
# 	sudo-helper --inherit \
# 		-- config-helper --file="$path" -- \
# 		--field='Group'
# }

function fs_own() (
	source "$DOROTHY/sources/bash.bash"

	# =====================================
	# Arguments

	function help {
		cat <<-EOF >/dev/stderr
			ABOUT:
			Cross-platform service management.

			USAGE:
			service-helper [...options] -- ...<service>

			OPTIONS:
			--quiet
			    Whether to output the executed commands.

			--ignore-missing | --ignore
			    Only run on registered services, skipping and ignoring services that aren't yet registered / do not exist.

			--supported
			    Exit immediately with a status code reflecting whether services are supported on this platform.

			-- ...<service>
			    The service(s) to manage.

			SERVICE OPTIONS:
			--start
			    Start the <service>.

			--stop
			    Stop the <service>.

			--restart
			    Restart the <service>.

			--unmask
			    Unmask the <service>.

			--load
			    Load the <service>.

			--unload
			    Unload the <service>.

			--enable
			    Enable the <service>.

			--disable
			    Disable the <service>.

			--reenable
			    Reenable the <service>.

			--status
			    Output the <service> status, ignores exit code for cross-platform consistency.

			--logs
			    Output the <service> logs, ignores exit code for cross-platform consistency.

			--running
			    Returns failure exit code if the <service> is not running. No output.

			--remove
			    Uninstalls the service.

			--exists
			    Returns failure exit code if the <service> does not exist.

			--edit
			    Edit the <service>.
		EOF
		if test "$#" -ne 0; then
			echo-error "$@"
		fi
		return 22 # EINVAL 22 Invalid argument
	}

	# process, @todo rewrite with option_ prefix
	# don't use empty quiet, as that only outputs wraps
	local item option_quiet services=() ignore='no' supported='' start='' stop='' restart='' unmask='' load='' unload='' enable='' disable='' reenable='' status='' logs='' running='' remove='' exists='' edit=''
	option_quiet="$(echo-quiet-enabled --fallback=no -- "$@")"
	while test "$#" -ne 0; do
		item="$1"
		shift
		case "$item" in
		'--help' | '-h') help ;;
		'--no-quiet'* | '--quiet'* | '--no-verbose'* | '--verbose'*) ;; # handled by echo-quiet-enabled
		'--supported') supported='yes' ;;
		'--ignore-missing' | '--ignore') ignore='yes' ;;
			# service options
		'--no-start'* | '--start'*)
			start="$(get-flag-value --affirmative --fallback="$start" -- "$item")"
			;;
		'--no-stop'* | '--stop'*)
			stop="$(get-flag-value --affirmative --fallback="$stop" -- "$item")"
			;;
		'--no-restart'* | '--restart'*)
			restart="$(get-flag-value --affirmative --fallback="$restart" -- "$item")"
			;;
		'--no-unmask'* | '--unmask'*)
			unmask="$(get-flag-value --affirmative --fallback="$unmask" -- "$item")"
			;;
		'--no-load'* | '--load'*)
			load="$(get-flag-value --affirmative --fallback="$load" -- "$item")"
			;;
		'--no-unload'* | '--unload'*)
			unload="$(get-flag-value --affirmative --fallback="$unload" -- "$item")"
			;;
		'--no-enable'* | '--enable'*)
			enable="$(get-flag-value --affirmative --fallback="$enable" -- "$item")"
			;;
		'--no-disable'* | '--disable'*)
			disable="$(get-flag-value --affirmative --fallback="$disable" -- "$item")"
			;;
		'--no-reenable'* | '--reenable'*)
			reenable="$(get-flag-value --affirmative --fallback="$reenable" -- "$item")"
			;;
		'--no-status'* | '--status'*)
			status="$(get-flag-value --affirmative --fallback="$status" -- "$item")"
			;;
		'--no-logs'* | '--logs'*)
			logs="$(get-flag-value --affirmative --fallback="$logs" -- "$item")"
			;;
		'--no-running'* | '--running'*)
			running="$(get-flag-value --affirmative --fallback="$running" -- "$item")"
			;;
		'--no-remove'* | '--remove'*)
			remove="$(get-flag-value --affirmative --fallback="$remove" -- "$item")"
			;;
		'--no-exists'* | '--exists'*)
			exists="$(get-flag-value --affirmative --fallback="$exists" -- "$item")"
			;;
		'--no-edit'* | '--edit'*)
			edit="$(get-flag-value --affirmative --fallback="$edit" -- "$item")"
			;;
		'--')
			services+=("$@")
			shift $#
			break
			;;
		'--'*) help "An unrecognised flag was provided: $item" ;;
		*) services+=("$item") ;;
		esac
	done

	# =====================================
	# Services

	# @todo support translation between files and identifiers
	# SERVICE_DIR='/Library/LaunchDaemons' # macos
	# SERVICE_DIR='/etc/systemd/system' # linux

	if command-exists launchctl; then
		# quirks about macos/launchctl
		# - service identifiers can have a `system/`, `user/`, `pid/`, and `session/` prefix, such as `system/com.apple.smbd`
		# - service identifiers can also have extensions it seems, such as `system/com.apple.smb.preferences`
		function do_unmask {
			return 0 # not needed
		}
		function do_load {
			# Usage: launchctl load <service-path, service-path2, ...>
			# -w      If the service is disabled, it will be enabled. In previous
			# 		versions of launchd, being disabled meant that a service was
			# 		not loaded. Now, services are always loaded. If a service is
			# 		disabled, launchd does not advertise its service endpoints
			# 		(sockets, Mach ports, etc.).
			local plist
			plist="$(do_find "$1")"
			sudo-helper --reason="Loading the service $1 requires your sudo/root/login password." \
				-- launchctl load -w "$plist"
		}
		function do_unload {
			# Usage: launchctl unload <service-path, service-path2, ...>
			# -w      Additionally disables the service such that future load
			# 		operations will result in a service which launchd tracks but
			# 		cannot be launched or discovered in any way.
			# ...
			sudo-helper --reason="Unloading the service $1 requires your sudo/root/login password." \
				-- launchctl unload -w "$1"
		}
		function do_start {
			local id="$1"
			id="${id#*system/}" # trim system/
			sudo-helper --reason="Starting the service $1 requires your sudo/root/login password." \
				-- launchctl start "$id"
		}
		function do_stop {
			local id="$1"
			id="${id#*system/}" # trim system/
			sudo-helper --reason="Stopping the service $1 requires your sudo/root/login password." \
				-- launchctl stop "$id"
		}
		function do_restart {
			eval_capture -- do_stop "$1"
			do_load "$1"
			do_start "$1"
		}
		function do_enable {
			sudo-helper --reason="Enabling the service $1 requires your sudo/root/login password." \
				-- launchctl enable "$1"
		}
		function do_enable_now {
			do_enable "$1"
			do_start "$1"
		}
		function do_disable {
			sudo-helper --reason="Disabling the service $1 requires your sudo/root/login password." \
				-- launchctl disable "$1"
		}
		function do_disable_now {
			do_disable "$1"
			do_stop "$1"
		}
		function do_reenable {
			do_disable "$1"
			do_enable "$1"
		}
		function do_status {
			# return code based on service existence, so ignore, save for running and exists
			sudo-helper --reason="Checking the status of the service $1 requires your sudo/root/login password." \
				-- launchctl print "$1" || :
		}
		function do_logs {
			# @todo
			# https://stackoverflow.com/a/29926482/130638
			# https://stackoverflow.com/a/6887421/130638
			# https://stackoverflow.com/a/46004497/130638
			# https://apple.stackexchange.com/a/435504/15131
			return 78 # ENOSYS 78 Function not implemented
		}
		function do_running {
			# return code based on service pid existing / running, hide outpu
			sudo-helper --reason="Checking the run status of the service $1 requires your sudo/root/login password." \
				-- launchctl list | grep --regexp="$1" | grep --quiet --regexp='^[^-]'
		}
		function do_remove {
			return 78 # ENOSYS 78 Function not implemented
		}
		function __do_exists {
			# return code based on service existence
			sudo-helper --reason="Checking the existence of the service $1 requires your sudo/root/login password." \
				-- launchctl print "$1" &>/dev/null
		}
		function do_edit {
			local plist
			plist="$(do_find "$1")"
			edit --wait --sudo -- "$plist"
		}
		function do_find {
			local id="$1"
			id="${id#*system/}" # trim system/
			if test -f "$id"; then
				print_line "$id"
				return 0
			fi
			local paths=(
				# user
				/Library/LaunchAgents/*"$id"*
				/System/Library/LaunchDaemons/*"$id"*
				# everyone
				/Library/LaunchDaemons/*"$id"*
				/System/Library/LaunchAgents/*"$id"*
			)
			if test "${#paths[@]}" -eq 0; then
				echo-error 'Service does not exist:' ' ' --code="$id"
				return 2 # ENOENT 2 No such file or directory
			else
				echo-lines -- "${paths[@]}"
			fi
		}
	elif command-exists systemctl; then
		function do_unmask {
			sudo-helper --reason="Unmkasing the service $1 requires your sudo/root/login password." \
				-- systemctl unmask "$1"
		}
		function do_load {
			sudo-helper --reason="Loading the service $1 requires your sudo/root/login password." \
				-- systemctl daemon-reload
		}
		function do_unload {
			sudo-helper --reason="Unloading the service $1 requires your sudo/root/login password." \
				-- systemctl daemon-reload
		}
		function do_start {
			sudo-helper --reason="Starting the service $1 requires your sudo/root/login password." \
				-- systemctl start "$1"
		}
		function do_stop {
			sudo-helper --reason="Stopping the service $1 requires your sudo/root/login password." \
				-- systemctl stop "$1"
		}
		function do_restart {
			sudo-helper --reason="Restarting the service $1 requires your sudo/root/login password." \
				-- systemctl restart "$1"
		}
		function do_enable {
			sudo-helper --reason="Enabling the service $1 requires your sudo/root/login password." \
				-- systemctl enable "$1"
		}
		function do_enable_now {
			sudo-helper --reason="Enabling the service $1 requires your sudo/root/login password." \
				-- systemctl enable --now "$1"
		}
		function do_disable {
			sudo-helper --reason="Disabling service $1 requires your sudo/root/login password." \
				-- systemctl disable "$1"
		}
		function do_disable_now {
			sudo-helper --reason="Disabling service $1 requires your sudo/root/login password." \
				-- systemctl disable --now "$1"
		}
		function do_reenable {
			sudo-helper --reason="Reenabling service $1 requires your sudo/root/login password." \
				-- systemctl reenable "$1"
		}
		function do_status {
			# return code based on service running, so ignore, save for running and exists
			sudo-helper --reason="Checking the status of the service $1 requires your sudo/root/login password." \
				-- systemctl status "$1" --no-pager || :
		}
		function do_logs {
			sudo-helper --reason="Checking the logs of the service $1 requires your sudo/root/login password." \
				-- sudo journalctl -u "$1" --no-pager || :
		}
		function do_running {
			# return code based on service running, hide output
			sudo-helper --reason="Checking the run status of the service $1 requires your sudo/root/login password." \
				-- systemctl status "$1" --no-pager &>/dev/null
		}
		function do_remove {
			local id="$1" paths
			if [[ $id == *'@'* ]]; then
				id="${id%@*}@" # `syncthing@user` => `syncthing@`
			fi
			paths=(
				/etc/init.d/*"$id"*
				/lib/systemd/system/*"$id"*
				/etc/systemd/system/*"$id"*
				/usr/lib/systemd/system/*"$id"*
			)
			if test "${#paths[@]}" -ne 0; then
				fs-rm --confirm --sudo -- "${paths[@]}"
			fi
		}
		function __do_exists {
			# return code based on service existence
			# sudo-helper -- service "$1" | rg --regexp=' * Usage:'
			# sudo-helper -- service --status-all | rg --regexp="$1"
			# @todo this fails for virtual ids, e.g. `syncthing@ubuntu`
			local id="$1" paths
			if [[ $id == *'@'* ]]; then
				id="${id%@*}@" # `syncthing@user` => `syncthing@`
			fi
			paths=(
				/etc/init.d/*"$id"*
				/lib/systemd/system/*"$id"*
				/etc/systemd/system/*"$id"*
				/usr/lib/systemd/system/*"$id"*
			)
			test "${#paths[@]}" -ne 0
		}
		function do_edit {
			local id="$1"
			# --inherit to maintain editor preferences
			sudo-helper --inherit -- systemctl edit "$id"
			# apply the changes, otherwise they will be reverted
			sudo-helper -- systemctl daemon-reload
			# if you aren't seeing your changes saved, make sure you save them between the comment sections where it tells you to, and not just say at the very top of the file
		}
	elif command-exists rc-service; then
		function do_unmask {
			return 0 # not needed
		}
		function do_load {
			return 0 # not needed
		}
		function do_unload {
			return 0 # not needed
		}
		function do_start {
			sudo-helper --reason="Starting the service $1 requires your sudo/root/login password." \
				-- rc-service "$1" start
		}
		function do_stop {
			sudo-helper --reason="Stopping the service $1 requires your sudo/root/login password." \
				-- rc-service "$1" stop
		}
		function do_restart {
			sudo-helper --reason="Restarting the service $1 requires your sudo/root/login password." \
				-- rc-service "$1" restart
		}
		function do_enable {
			sudo-helper --reason="Enabling the service $1 requires your sudo/root/login password." \
				-- rc-update add "$1"
		}
		function do_enable_now {
			sudo-helper --reason="Adding the service $1 requires your sudo/root/login password." \
				-- rc-update add "$1"
			sudo-helper --reason="Starting the service $1 requires your sudo/root/login password." \
				-- rc-service "$1" start
		}
		function do_disable {
			sudo-helper --reason="Disabling the service $1 requires your sudo/root/login password." \
				-- rc-update del "$1"
		}
		function do_disable_now {
			sudo-helper --reason="Stopping the service $1 requires your sudo/root/login password." \
				-- rc-service "$1" stop
			sudo-helper --reason="Removing the service $1 requires your sudo/root/login password." \
				-- rc-update del "$1"
		}
		function do_reenable {
			sudo-helper --reason="Reenabling the service $1 requires your sudo/root/login password." \
				-- rc-update add "$1"
		}
		function do_status {
			# return code based on service running, so ignore, save for running and exists
			sudo-helper --reason="Checking the status of the service $1 requires your sudo/root/login password." \
				-- rc-service "$1" status || :
		}
		function do_logs {
			# @todo
			return 78 # ENOSYS 78 Function not implemented
		}
		function do_running {
			# return code based on service running, hide output
			sudo-helper --reason="Checking the run status of the service $1 requires your sudo/root/login password." \
				-- rc-service "$1" status &>/dev/null
		}
		function do_remove {
			return 78 # ENOSYS 78 Function not implemented
		}
		function __do_exists {
			# return code based on service existence
			# sudo-helper -- rc-service --list | grep --ignore-case --regexp="$1"
			# https://wiki.alpinelinux.org/wiki/OpenRC
			# despite docs, it is actually /etc/init.d/ and not /lib/rc/init.d
			local id="$1" paths
			paths=(
				/etc/init.d/*"$id"*
			)
			test "${#paths[@]}" -ne 0
		}
	else
		if test "$supported" = 'yes'; then
			# if --supported, no error message
			return 1
		else
			echo-error 'Services are not supported on this platform.'
			return 19 # ENODEV 19 Operation not supported by device
		fi
	fi

	# if --supported, then we are done
	if test "$supported" = 'yes'; then
		return 0
	fi

	# =====================================
	# Act

	# https://docs.syncthing.net/users/autostart.html#using-supervisord

	# brew services restart syncthing
	# ^ for brew, not cask

	# @todo can use this to check if it is already working
	# if ! systemctl status "$this_service" --no-pager >/dev/null; then

	# https://man.archlinux.org/man/systemctl.1.en
	# https://wiki.gentoo.org/wiki/OpenRC_to_systemd_Cheatsheet
	function handle {
		local this_service="$1" this_unmask="$unmask" this_load="$load" this_unload="$unload" this_start="$start" this_stop="$stop" this_restart="$restart" this_enable="$enable" this_disable="$disable" this_reenable="$reenable" this_status="$status" this_logs="$logs" this_running="$running" this_remove="$remove" this_exists="$exists" this_edit="$edit"

		# ignore?
		if test "$ignore" = 'yes' && ! __do_exists "$this_service"; then
			# is missing, and desire to ignore, so skip this one
			if test "$option_quiet" = 'no'; then
				echo-style \
					--dim="Skipping non-existent service: " \
					--code="$this_service"
			fi
			return 0
		fi

		# exists?
		if test "$this_exists" = 'yes'; then
			this_exists=''
			__do_exists "$this_service"
		fi

		# edit?
		if test "$this_edit" = 'yes'; then
			this_edit=''
			do_edit "$this_service"
		fi

		# remove?
		if test "$this_remove" = 'yes'; then
			this_remove=''
			do_remove "$this_service"
		fi

		# status
		if test "$this_status" = 'yes'; then
			this_status='maybe'
			do_status "$this_service"
		fi

		# unmask, do before load
		if test "$this_unmask"; then
			this_unmask=''
			do_unmask "$this_service"

			# renable status
			if test "$this_status" = 'maybe'; then
				this_status='yes'
			fi
		fi

		# load
		if test "$this_load"; then
			this_load=''
			do_load "$this_service"

			# renable status
			if test "$this_status" = 'maybe'; then
				this_status='yes'
			fi
		fi

		# split restart if autostart is being modified
		if test "$this_restart" = 'yes' && test "$this_reenable" = 'yes' -o "$this_enable" = 'yes' -o "$this_disable" = 'yes'; then
			this_restart=''
			this_stop='yes'
			this_start='yes'
		fi

		# stop
		if test "$this_stop" = 'yes'; then
			this_stop=''
			do_stop "$this_service"

			# renable status
			if test "$this_status" = 'maybe'; then
				this_status='yes'
			fi
		fi

		# autostart
		if test "$this_reenable" = 'yes'; then
			this_reenable=''
			do_reenable "$this_service"

			# renable status
			if test "$this_status" = 'maybe'; then
				this_status='yes'
			fi
		elif test "$this_enable" = 'yes'; then
			this_enable=''
			if test "$this_start" = 'yes'; then
				this_start=''
				do_enable_now "$this_service"
			else
				do_enable "$this_service"
			fi

			# renable status
			if test "$this_status" = 'maybe'; then
				this_status='yes'
			fi
		elif test "$this_disable" = 'yes'; then
			this_disable=''
			if test "$this_stop" = 'yes'; then
				this_stop=''
				do_disable_no "$this_service"
			else
				do_disable "$this_service"
			fi

			# renable status
			if test "$this_status" = 'maybe'; then
				this_status='yes'
			fi
		fi

		# start / restart
		if test "$this_start" = 'yes'; then
			this_start=''
			do_start "$this_service"

			# renable status
			if test "$this_status" = 'maybe'; then
				this_status='yes'
			fi
		fi
		if test "$this_restart" = 'yes'; then
			this_restart=''
			do_restart "$this_service"

			# renable status
			if test "$this_status" = 'maybe'; then
				this_status='yes'
			fi
		fi

		# unload
		if test "$this_unload" = 'yes'; then
			this_unload=''
			do_unload "$this_service"
		fi

		# status
		if test "$this_status" = 'yes'; then
			this_status=''
			do_status "$this_service"
		fi

		# logs
		if test "$this_logs" = 'yes'; then
			this_logs=''
			do_logs "$this_service"
		fi

		# running
		if test "$this_running" = 'yes'; then
			this_running=''
			do_running "$this_service"
		fi
	}

	# cycle through
	local service
	for service in "${services[@]}"; do
		handle "$service"
	done
)

# fire if invoked standalone
if test "$0" = "${BASH_SOURCE[0]}"; then
	fs_own "$@"
fi
