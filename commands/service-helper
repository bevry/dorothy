#!/usr/bin/env bash

function fs-own() (
	source "$DOROTHY/sources/strict.bash"
	source "$DOROTHY/sources/nullglob.bash"
	source "$DOROTHY/sources/arrays.bash"

	# =====================================
	# Arguments

	function help {
		cat <<-EOF >/dev/stderr
			ABOUT:
			Cross-platform service management.

			USAGE:
			service-helper [...options] -- <...service>

			OPTIONS:
			--quiet
			    Whether to output the executed commands.

			--ignore-missing | --ignore
			    Only run on registered services, skipping and ignoring services that aren't yet registered / do not exist.

			--supported
			    Exit immediately with a status code reflecting whether services are supported on this platform.

			[--] <...service>
			    The service(s) to manage.

			SERVICE OPTIONS:
			--start
			    Start the <service>.

			--stop
			    Stop the <service>.

			--restart
			    Restart the <service>.

			--unmask
			    Unmask the <service>.

			--load
			    Load the <service>.

			--unload
			    Unload the <service>.

			--enable
			    Enable the <service>.

			--disable
			    Disable the <service>.

			--reenable
			    Reenable the <service>.

			--status
			    Output the <service> status, ignores exit code for cross-platform consistency.

			--logs
			    Output the <service> logs, ignores exit code for cross-platform consistency.

			--running
			    Returns failure exit code if the <service> is not running. No output.

			--exists
			    REturns failure exit code if the <service> does not exist.
		EOF
		if test "$#" -ne 0; then
			echo-error "$@"
		fi
		return 22 # Invalid argument
	}

	# process
	# don't use empty quiet, as that only outputs wraps
	local item services=() quiet='no' ignore='no' supported='' start='' stop='' restart='' unmask='' load='' unload='' enable='' disable='' reenable='' status='' logs='' running='' exists=''
	quiet="$(echo-quiet "$quiet" -- "$@")"
	while test "$#" -ne 0; do
		item="$1"
		shift
		case "$item" in
		'--help' | '-h') help ;;
		'--no-quiet'* | '--quiet'* | '--no-verbose'* | '--verbose'*) ;; # handled by echo-quiet
		'--supported') supported='yes' ;;
		'--ignore-missing' | '--ignore') ignore='yes' ;;
			# service options
		'--no-start'* | '--start'*) start="$(
			get-flag-value start --missing="$start" -- "$item" | echo-affirmative
		)" ;;
		'--no-stop'* | '--stop'*) stop="$(
			get-flag-value stop --missing="$stop" -- "$item" | echo-affirmative
		)" ;;
		'--no-restart'* | '--restart'*) restart="$(
			get-flag-value restart --missing="$restart" -- "$item" | echo-affirmative
		)" ;;
		'--no-unmask'* | '--unmask'*) unmask="$(
			get-flag-value unmask --missing="$unmask" -- "$item" | echo-affirmative
		)" ;;
		'--no-load'* | '--load'*) load="$(
			get-flag-value load --missing="$load" -- "$item" | echo-affirmative
		)" ;;
		'--no-unload'* | '--unload'*) unload="$(
			get-flag-value unload --missing="$unload" -- "$item" | echo-affirmative
		)" ;;
		'--no-enable'* | '--enable'*) enable="$(
			get-flag-value enable --missing="$enable" -- "$item" | echo-affirmative
		)" ;;
		'--no-disable'* | '--disable'*) disable="$(
			get-flag-value disable --missing="$disable" -- "$item" | echo-affirmative
		)" ;;
		'--no-reenable'* | '--reenable'*) reenable="$(
			get-flag-value reenable --missing="$reenable" -- "$item" | echo-affirmative
		)" ;;
		'--no-status'* | '--status'*) status="$(
			get-flag-value status --missing="$status" -- "$item" | echo-affirmative
		)" ;;
		'--no-logs'* | '--logs'*) logs="$(
			get-flag-value logs --missing="$logs" -- "$item" | echo-affirmative
		)" ;;
		'--no-running'* | '--running'*) running="$(
			get-flag-value running --missing="$running" -- "$item" | echo-affirmative
		)" ;;
		'--no-exists'* | '--exists'*) exists="$(
			get-flag-value exists --missing="$exists" -- "$item" | echo-affirmative
		)" ;;
		'--')
			services+=("$@")
			shift $#
			break
			;;
		'--'*) help "An unrecognised flag was provided: $item" ;;
		*) services+=("$item") ;;
		esac
	done

	# =====================================
	# Services

	# @todo support translation between files and identifiers
	# SERVICE_DIR='/Library/LaunchDaemons' # macos
	# SERVICE_DIR='/etc/systemd/system' # linux

	if command-exists launchctl; then
		# quirks about macos/launchctl
		# - service identifiers can have a `system/`, `user/`, `pid/`, and `session/` prefix, such as `system/com.apple.smbd`
		# - service identifiers can also have extensions it seems, such as `system/com.apple.smb.preferences`
		function do_unmask {
			return 0 # not needed
		}
		function do_load {
			# Usage: launchctl load <service-path, service-path2, ...>
			# -w      If the service is disabled, it will be enabled. In previous
			# 		versions of launchd, being disabled meant that a service was
			# 		not loaded. Now, services are always loaded. If a service is
			# 		disabled, launchd does not advertise its service endpoints
			# 		(sockets, Mach ports, etc.).
			eval-helper --quiet="$quiet" -- sudo-helper -- launchctl load -w "$1"
		}
		function do_unload {
			# Usage: launchctl unload <service-path, service-path2, ...>
			# -w      Additionally disables the service such that future load
			# 		operations will result in a service which launchd tracks but
			# 		cannot be launched or discovered in any way.
			# ...
			eval-helper --quiet="$quiet" -- sudo-helper -- launchctl unload -w "$1"
		}
		function do_start {
			eval-helper --quiet="$quiet" -- sudo-helper -- launchctl start "$1"
		}
		function do_stop {
			eval-helper --quiet="$quiet" -- sudo-helper -- launchctl stop "$1"
		}
		function do_restart {
			eval-helper --quiet="$quiet" -- sudo-helper -- launchctl restart "$1"
		}
		function do_enable {
			eval-helper --quiet="$quiet" -- sudo-helper -- launchctl enable "$1"
		}
		function do_enable_now {
			eval-helper --quiet="$quiet" -- sudo-helper -- launchctl enable "$1"
			eval-helper --quiet="$quiet" -- sudo-helper -- launchctl start "$1"
		}
		function do_disable {
			eval-helper --quiet="$quiet" -- sudo-helper -- launchctl disable "$1"
		}
		function do_disable_now {
			eval-helper --quiet="$quiet" -- sudo-helper -- launchctl disable "$1"
			eval-helper --quiet="$quiet" -- sudo-helper -- launchctl stop "$1"
		}
		function do_reenable {
			eval-helper --quiet="$quiet" -- sudo-helper -- launchctl disable "$1"
			eval-helper --quiet="$quiet" -- sudo-helper -- launchctl enable "$1"
		}
		function do_status {
			# return code based on service existence, so ignore, save for running and exists
			eval-helper --quiet="$quiet" -- sudo-helper -- launchctl print "$1" || :
		}
		function do_logs {
			# @todo
			# https://stackoverflow.com/a/29926482/130638
			# https://stackoverflow.com/a/6887421/130638
			# https://stackoverflow.com/a/46004497/130638
			# https://apple.stackexchange.com/a/435504/15131
			return 78 # ENOSYS 78 Function not implemented
		}
		function do_running {
			# return code based on service pid existing / running, hide outpu
			eval-helper --quiet="$quiet" -- sudo-helper -- launchctl list | grep "$1" | grep -q '^[^-]'
		}
		function do_exists {
			# /Library/LaunchAgents/*"$id"*   # user
			# /Library/LaunchDaemons/*"$id"*  # everyone

			# return code based on service existence
			sudo-helper -- launchctl print "$1" &>/dev/null
		}
	elif command-exists systemctl; then
		function do_unmask {
			eval-helper --quiet="$quiet" -- sudo-helper -- systemctl unmask "$1"
		}
		function do_load {
			eval-helper --quiet="$quiet" -- sudo-helper -- systemctl daemon-reload
		}
		function do_unload {
			eval-helper --quiet="$quiet" -- sudo-helper -- systemctl daemon-reload
		}
		function do_start {
			eval-helper --quiet="$quiet" -- sudo-helper -- systemctl start "$1"
		}
		function do_stop {
			eval-helper --quiet="$quiet" -- sudo-helper -- systemctl stop "$1"
		}
		function do_restart {
			eval-helper --quiet="$quiet" -- sudo-helper -- systemctl restart "$1"
		}
		function do_enable {
			eval-helper --quiet="$quiet" -- sudo-helper -- systemctl enable "$1"
		}
		function do_enable_now {
			eval-helper --quiet="$quiet" -- sudo-helper -- systemctl enable --now "$1"
		}
		function do_disable {
			eval-helper --quiet="$quiet" -- sudo-helper -- systemctl disable "$1"
		}
		function do_disable_now {
			eval-helper --quiet="$quiet" -- sudo-helper -- systemctl disable --now "$1"
		}
		function do_reenable {
			eval-helper --quiet="$quiet" -- sudo-helper -- systemctl reenable "$1"
		}
		function do_status {
			# return code based on service running, so ignore, save for running and exists
			eval-helper --quiet="$quiet" -- sudo-helper -- systemctl status "$1" --no-pager || :
		}
		function do_logs {
			eval-helper --quiet="$quiet" -- sudo-helper -- sudo journalctl -u "$1" || :
		}
		function do_running {
			# return code based on service running, hide output
			eval-helper --quiet="$quiet" -- sudo-helper -- systemctl status "$1" --no-pager &>/dev/null
		}
		function do_exists {
			# return code based on service existence
			# sudo-helper -- service "$1" | rg ' * Usage:'
			# sudo-helper -- service --status-all | rg "$1"
			# @todo this fails for virtual ids, e.g. `syncthing@ubuntu`
			local id="$1" paths
			paths=(
				/etc/init.d/*"$id"*
				/usr/lib/systemd/system/*"$id"*
				/etc/systemd/system/*"$id"*
			)
			test "${#paths[@]}" -ne 0
		}
	elif command-exists rc-service; then
		function do_unmask {
			return 0 # not needed
		}
		function do_load {
			return 0 # not needed
		}
		function do_unload {
			return 0 # not needed
		}
		function do_start {
			eval-helper --quiet="$quiet" -- sudo-helper -- rc-service "$1" start
		}
		function do_stop {
			eval-helper --quiet="$quiet" -- sudo-helper -- rc-service "$1" stop
		}
		function do_restart {
			eval-helper --quiet="$quiet" -- sudo-helper -- rc-service "$1" restart
		}
		function do_enable {
			eval-helper --quiet="$quiet" -- sudo-helper -- rc-update add "$1"
		}
		function do_enable_now {
			eval-helper --quiet="$quiet" -- sudo-helper -- rc-update add "$1"
			eval-helper --quiet="$quiet" -- sudo-helper -- rc-service "$1" start
		}
		function do_disable {
			eval-helper --quiet="$quiet" -- sudo-helper -- rc-update del "$1"
		}
		function do_disable_now {
			eval-helper --quiet="$quiet" -- sudo-helper -- rc-service "$1" stop
			eval-helper --quiet="$quiet" -- sudo-helper -- rc-update del "$1"
		}
		function do_reenable {
			eval-helper --quiet="$quiet" -- sudo-helper -- rc-update add "$1"
		}
		function do_status {
			# return code based on service running, so ignore, save for running and exists
			eval-helper --quiet="$quiet" -- sudo-helper -- rc-service "$1" status || :
		}
		function do_logs {
			# @todo
			return 78 # ENOSYS 78 Function not implemented
		}
		function do_running {
			# return code based on service running, hide output
			eval-helper --quiet="$quiet" -- sudo-helper -- rc-service "$1" status &>/dev/null
		}
		function do_exists {
			# return code based on service existence
			# sudo-helper -- rc-service --list | grep -i "$1"
			# https://wiki.alpinelinux.org/wiki/OpenRC
			# despite docs, it is actually /etc/init.d/ and not /lib/rc/init.d
			local id="$1" paths
			paths=(
				/etc/init.d/*"$id"*
			)
			test "${#paths[@]}" -ne 0
		}
	else
		if test "$supported" = 'yes'; then
			# if --supported, no error message
			return 1
		else
			echo-error "Services are not supported on this platform."
			return 19 # ENODEV 19 Operation not supported by device
		fi
	fi

	# if --supported, then we are done
	if test "$supported" = 'yes'; then
		return 0
	fi

	# =====================================
	# Act

	# https://docs.syncthing.net/users/autostart.html#using-supervisord

	# brew services restart syncthing
	# ^ for brew, not cask

	# @todo can use this to check if it is already working
	# if ! systemctl status "$this_service" --no-pager >/dev/null; then

	# https://man.archlinux.org/man/systemctl.1.en
	# https://wiki.gentoo.org/wiki/OpenRC_to_systemd_Cheatsheet
	function handle {
		local this_service="$1" this_unmask="$unmask" this_load="$load" this_unload="$unload" this_start="$start" this_stop="$stop" this_restart="$restart" this_enable="$enable" this_disable="$disable" this_reenable="$reenable" this_status="$status" this_logs="$logs" this_running="$running" this_exists="$exists"

		# ignore?
		if test "$ignore" = 'yes' && ! do_exists "$this_service"; then
			# is missing, and desire to ignore, so skip this one
			if test "$quiet" = 'no'; then
				echo-style \
					--dim="Skipping non-existent service: " \
					--code="$this_service"
			fi
			return 0
		fi

		# exists?
		if test "$this_exists" = 'yes'; then
			this_exists=''
			do_exists "$this_service"
		fi

		# status
		if test "$this_status" = 'yes'; then
			this_status='maybe'
			do_status "$this_service"
		fi

		# unmask, do before load
		if test "$this_unmask"; then
			this_unmask=''
			do_unmask "$this_service"

			# renable status
			if test "$this_status" = 'maybe'; then
				this_status='yes'
			fi
		fi

		# load
		if test "$this_load"; then
			this_load=''
			do_load "$this_service"

			# renable status
			if test "$this_status" = 'maybe'; then
				this_status='yes'
			fi
		fi

		# split restart if autostart is being modified
		if test "$this_restart" = 'yes' && test "$this_reenable" = 'yes' -o "$this_enable" = 'yes' -o "$this_disable" = 'yes'; then
			this_restart=''
			this_stop='yes'
			this_start='yes'
		fi

		# stop
		if test "$this_stop" = 'yes'; then
			this_stop=''
			do_stop "$this_service"

			# renable status
			if test "$this_status" = 'maybe'; then
				this_status='yes'
			fi
		fi

		# autostart
		if test "$this_reenable" = 'yes'; then
			this_reenable=''
			do_reenable "$this_service"

			# renable status
			if test "$this_status" = 'maybe'; then
				this_status='yes'
			fi
		elif test "$this_enable" = 'yes'; then
			this_enable=''
			if test "$this_start" = 'yes'; then
				this_start=''
				do_enable_now "$this_service"
			else
				do_enable "$this_service"
			fi

			# renable status
			if test "$this_status" = 'maybe'; then
				this_status='yes'
			fi
		elif test "$this_disable" = 'yes'; then
			this_disable=''
			if test "$this_stop" = 'yes'; then
				this_stop=''
				do_disable_no "$this_service"
			else
				do_disable "$this_service"
			fi

			# renable status
			if test "$this_status" = 'maybe'; then
				this_status='yes'
			fi
		fi

		# start / restart
		if test "$this_start" = 'yes'; then
			this_start=''
			do_start "$this_service"

			# renable status
			if test "$this_status" = 'maybe'; then
				this_status='yes'
			fi
		fi
		if test "$this_restart" = 'yes'; then
			this_restart=''
			do_restart "$this_service"

			# renable status
			if test "$this_status" = 'maybe'; then
				this_status='yes'
			fi
		fi

		# unload
		if test "$this_unload" = 'yes'; then
			this_unload=''
			do_unload "$this_service"
		fi

		# status
		if test "$this_status" = 'yes'; then
			this_status=''
			do_status "$this_service"
		fi

		# logs
		if test "$this_logs" = 'yes'; then
			this_logs=''
			do_logs "$this_service"
		fi

		# running
		if test "$this_running" = 'yes'; then
			this_running=''
			do_running "$this_service"
		fi
	}

	# cycle through
	local service
	for service in "${services[@]}"; do
		handle "$service"
	done
)

# fire if invoked standalone
if test "$0" = "${BASH_SOURCE[0]}"; then
	fs-own "$@"
fi
