#!/usr/bin/env bash

function echo_quote_test() (
	source "$DOROTHY/sources/bash.bash"
	echo-style --h1="TEST: $0"

	eval-tester --stdout="'this string does not have any quotes'" \
		-- echo-quote -- 'this string does not have any quotes'

	eval-tester --stdout="'this string does not have any quotes'" \
		-- echo-quote --single -- 'this string does not have any quotes'

	eval-tester --stdout="\"this string does not have any quotes\"" \
		-- echo-quote --double -- 'this string does not have any quotes'

	eval-tester --stdout="\"this string has a single quote ' in it\"" \
		-- echo-quote -- "this string has a single quote ' in it"

	eval-tester --stdout="'this string has a single quote \' in it'" \
		-- echo-quote --single -- "this string has a single quote ' in it"

	eval-tester --stdout="\"this string has a single quote ' in it\"" \
		-- echo-quote --double -- "this string has a single quote ' in it"

	eval-tester --stdout="'this string has a double quote \" in it'" \
		-- echo-quote -- 'this string has a double quote " in it'

	eval-tester --stdout="'this string has a double quote \" in it'" \
		-- echo-quote --single -- 'this string has a double quote " in it'

	eval-tester --stdout="\"this string has a double quote \\\" in it\"" \
		-- echo-quote --double -- 'this string has a double quote " in it'

	eval-tester --stdout="'this string has a single \' and double quote \" in it'" \
		-- echo-quote -- "this string has a single ' and double quote \" in it"

	eval-tester --stdout="'this string has a single \' and double quote \" in it'" \
		-- echo-quote --single -- "this string has a single ' and double quote \" in it"

	eval-tester --stdout="\"this string has a single ' and double quote \\\" in it\"" \
		-- echo-quote --double -- "this string has a single ' and double quote \" in it"

	eval-tester --stdout="\"this string has an escaped single \' and non-escaped double quote \\\" in it\"" \
		-- echo-quote -- "this string has an escaped single \' and non-escaped double quote \" in it"

	eval-tester --status=5 --ignore-stderr \
		-- echo-quote --single -- "this string has an escaped single \' and non-escaped double quote \" in it"

	eval-tester --stdout="\"this string has an escaped single \' and non-escaped double quote \\\" in it\"" \
		-- echo-quote --double -- "this string has an escaped single \' and non-escaped double quote \" in it"

	eval-tester --stdout="'this string has a non-escaped single \' and an escaped double quote \\\" in it'" \
		-- echo-quote -- "this string has a non-escaped single ' and an escaped double quote \\\" in it"

	eval-tester --stdout="'this string has a non-escaped single \' and an escaped double quote \\\" in it'" \
		-- echo-quote --single -- "this string has a non-escaped single ' and an escaped double quote \\\" in it"

	eval-tester --status=5 --ignore-stderr \
		-- echo-quote --double -- "this string has a non-escaped single ' and an escaped double quote \\\" in it"

	# can't test these, as eval-tester itself fails, as it uses echo-quote

	# eval-tester --status=5 --ignore-stderr \
	# 	-- echo-quote -- "this string has an escaped single \' and an escaped double quote \\\" in it"

	# eval-tester --status=5 --ignore-stderr \
	# 	-- echo-quote --single -- "this string has an escaped single \' and an escaped double quote \\\" in it"

	# eval-tester --status=5 --ignore-stderr \
	# 	-- echo-quote --double -- "this string has an escaped single \' and an escaped double quote \\\" in it"

	echo-style --g1="TEST: $0"
	return 0
)
function echo_quote() (
	source "$DOROTHY/sources/stdinargs.bash"

	# =====================================
	# Arguments

	function help {
		cat <<-EOF >/dev/stderr
			ABOUT:
			For each <input>, output it as a quoted string.

			USAGE:
			echo-quote [...options] [--] ...<input>
			echo-lines ...<input> | echo-quote [...options]

			OPTIONS:
			--double
			    If specified, output the <input> as a double quoted string.

			--single
			    If specified, output the <input> as a single quoted string.

			$(stdinargs_options_help --)
		EOF
		if test "$#" -ne 0; then
			echo-error "$@"
		fi
		return 22 # EINVAL 22 Invalid argument
	}

	# process our own arguments, delegate everything else to stdinargs
	local item option_quote_desired=''
	while test "$#" -ne 0; do
		item="$1"
		shift
		case "$item" in
		'--help' | '-h') help ;;
		'--double') option_quote_desired='double' ;;
		'--single') option_quote_desired='single' ;;
		# forward to stdinargs, however support mixing and matching of our options, with stdinarg options
		'--')
			option_args+=("$item" "$@")
			shift $#
			break
			;;
		*) option_args+=("$item") ;;
		esac
	done

	# =====================================
	# Action

	# this is not the same as ${var@Q}, which handles single quotes differently
	function on_input {
		local item="$1"
		if [[ $item != *"'"* ]] && test "$option_quote_desired" != 'double'; then
			# does not contain single quotes
			__print_lines "'$item'"
			return 0
		elif [[ $item != *'"'* ]] && test "$option_quote_desired" != 'single'; then
			# does not contain double quotes
			__print_lines "\"$item\""
			return 0
		elif [[ $item != *"\\'"* ]] && test "$option_quote_desired" != 'double'; then
			# does not contain escaped single quotes
			__print_lines "'${item//\'/\\\'}'"
			return 0
		elif [[ $item != *"\\\""* ]] && test "$option_quote_desired" != 'single'; then
			# does not contain escaped double quotes
			__print_lines "\"${item//\"/\\\"}\""
			return 0
		fi

		# handle failure case, where it contains both escaped single and escaped double quotes: echo-quote -- "a\\'s\\\"a\\\"a\\'d"

		# using the bash builtin quote mechanism does not work, as it escapes special characters, AND escaped quotes, and sometimes injects leading $

		# using deno does not work, as it wraps in backtick
		# deno eval 'console.log(Deno.inspect(Deno.args[0]))' -- "a\\'s\\\"a\\\"a\\'d"

		echo-style --error='echo-quote is unable to handle single and double quotes in the same string:' >/dev/stderr
		__print_lines "$item" >/dev/stderr
		return 5 # EIO 5 Input/output error
	}

	stdinargs "${option_args[@]}"
)

# fire if invoked standalone
if test "$0" = "${BASH_SOURCE[0]}"; then
	if test "$*" = '--test'; then
		echo_quote_test
	else
		echo_quote "$@"
	fi
fi
