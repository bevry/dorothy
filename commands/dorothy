#!/usr/bin/env bash

# NOTE:
# Help handling is implemented, however it is done specially, due to the following considerations.
# This script may be run directly, eval'd, or even sourced
# DOROTHY may or may not even exist yet
# Dorothy clone may or may not exist yet
# Bash v4 is not guaranteed
#
# Once dorothy is asserted to exist, we want to load environment, such that:
# Environment configuration wouldn't have loaded if:
#   in trial mode,
#   or invoked by a shell that was not yet configured for Dorothy.
# Environment configuration includes:
#   homebrew path, homebrew architecture, ecosystem paths, etc.
# Environment configuration is necessary so that:
#   dependencies can be detected and installed, such as sd for config-helper
#   test dependencies can correctly infer their environment's capabilities

# =====================================
# Command

# do not use the cmd_ convention, as that would interefere with the dorothy worker
function dorothy_() (
	# sanity check that we are running in bash
	# sanity check, as [function .. () (], [elif], [&>], [local] are all bashisms, so other shells should have failed by now
	if test -z "${BASH_VERSION-}"; then
		printf '%s\n' "Dorothy requires bash to run. Refer to the installation instructions: $dorothy_install" >/dev/stderr
		exit 6 # ENXIO 6 Device not configured
	fi

	# set only -e, as -u and pipefail not necessary right now, later we will load bash.bash
	set -e

	# vars that should be exported to subshells, which may or may not be inherited, as setup-environment-commands has not run yet
	local self
	export DOROTHY ZDOTDIR PATH XDG_CONFIG_HOME XDG_CACHE_HOME XDG_BIN_HOME XDG_DATA_HOME XDG_STATE_HOME
	if test -z "${DOROTHY-}"; then
		# handle cron situation (dorothy is installed, however environment is empty)
		# `env -i "$(which dorothy)" run env` <-- whoami returns user who has dorothy installed:
		# `sudo env -i "$(which dorothy)" run env` <-- whoami returns root, who does not have dorothy installed
		# @todo consider if this runs on zsh and bash v3
		self="${BASH_SOURCE:-"$0"}"
		if [[ $self == *'.local/share/dorothy/commands/dorothy' ]] && test -f "$self"; then
			DOROTHY="${self%/commands/dorothy*}"
			if test -z "${HOME-}"; then
				export HOME
				HOME="${self%/.local/share/dorothy/commands/dorothy*}"
			fi
			if test -z "${USER-}"; then
				export USER
				USER="$(basename "$HOME")"
			fi
		else
			# handle fresh install situation
			DOROTHY=''
		fi
	fi
	if test -z "${ZDOTDIR-}"; then
		ZDOTDIR=''
	fi
	if test -z "${XDG_CONFIG_HOME-}"; then
		XDG_CONFIG_HOME="$HOME/.config"
	fi
	if test -z "${XDG_CACHE_HOME-}"; then
		XDG_CACHE_HOME="$HOME/.cache"
	fi
	if test -z "${XDG_BIN_HOME-}"; then
		XDG_BIN_HOME="$HOME/.local/bin"
	fi
	if test -z "${XDG_DATA_HOME-}"; then
		XDG_DATA_HOME="$HOME/.local/share"
	fi
	if test -z "${XDG_STATE_HOME-}"; then
		XDG_STATE_HOME="$HOME/.local/state"
	fi
	mkdir -p "$XDG_CONFIG_HOME" "$XDG_CACHE_HOME" "$XDG_BIN_HOME" "$XDG_DATA_HOME" "$XDG_STATE_HOME"

	# =====================================
	# Variables

	# vars that are local to this script and shared between functions
	local dorothy_slug='bevry/dorothy'
	local dorothy_upstream_git_https="https://github.com/$dorothy_slug.git"
	local dorothy_upstream_branch='master'
	local dorothy_upstream_remote_name='bevry'
	local dorothy_homepage="https://github.com/$dorothy_slug"
	local dorothy_install="$dorothy_homepage#install"
	local dorothy_worker='https://dorothy.bevry.me'
	local dorothy_worker_run="$dorothy_worker/run"

	# =====================================
	# Arguments

	function help {
		cat <<-EOF >/dev/stderr
			ABOUT:
			Helpers for interacting with the Dorothy dotfile ecosystem.

			USAGE:
			dorothy [...options] <action> [...arguments]

			OPTIONS:
			--help, -h
			    Show this help information.

			--branch=<branch>
			    If Dorothy needs to be installed, checkout this branch.

			--commit=<commit>
			    If Dorothy needs to be installed, checkout this commit.

			--xdg | --no-xdg

			    If [--xdg] is used, DOROTHY will be relocated to the XDG location.
			    If [--no-xdg] is used, a custom DOROTHY will be permitted.
			    If neither is provided, autodetection is used. This is the default.

			ACTIONS:

			dorothy install
			  [--clean]
			  [--skip-install]
			  [--user=<user>]

			    Installs Dorothy interactively, with configuration for dotfile modifications.

			    Unless [--clean] is provided, Dorothy will only extend your shell configuration.
			    If [--clean] is provided, Dorothy will prompt you if you would like to remove your default shell configuration for a lighter installation experience.

			dorothy uninstall

			    Removes the Dorothy sourcing from your dotfile configuration files.

			dorothy repl
			  [--shell=<shell>]
			  [--theme=<theme>]

			    Invoke a Dorothy-configured REPL, where you can run as many commands within the Dorothy environment as you'd like.
			    If a shell is provided, invoke Dorothy within that shell, otherwise prompt for which REPL-supported shell to use.

			dorothy run
				-- <command> [...]

				Invoke the <command> within the Dorothy environment, without the need to isntall Dorothy to access the command.

			dorothy update

			    Updates Dorothy to the latest version.

			dorothy permissions

			    Correct permissions of new Dorothy commands, ensuring they are executable, and that git is aware of them.

			dorothy edit

			    Correct permissions, then open Dorothy's installation and user configuration in your desired editor.

			dorothy review

			    Correct permissions, then open Dorothy's installation and user configuration in your desired git reviewer.

			dorothy theme

			    Interactively configure your desired theme for Dorothy configured shells.

			dorothy dev

			    Automatically install Dorothy' development dependencies.

			dorothy format

			    Automatically format Dorothy's source code to its conventions.

			dorothy check

			    Automatically check Dorothy's source code to its conventions.

			dorothy lint

			    Automatically format and check Dorothy's source code to its conventions.

			dorothy test

			    Run tests on Dorothy's source code.

			dorothy todos

			    Output information about possible improvements to make to Dorothy.

		EOF
		if test "$#" -ne 0; then
			# use printf, as __print_line not loaded yet
			printf '%s' "ERROR: $*" >/dev/stderr
		fi
		return 22 # EINVAL 22 Invalid argument
	}

	# process action arguments
	# @todo prevent double-action overwrite
	local item action='' option_xdg='' option_branch='' option_reference='HEAD' option_slug="$dorothy_slug" option_args=()
	while test "$#" -ne 0; do
		item="$1"
		shift
		case "$item" in
		'--help' | '-h') help ;;
		'--xdg' | '--xdg=yes') option_xdg='yes' ;;
		'--no-xdg' | '--xdg=no') option_xdg='no' ;;
		'--branch='*)
			option_branch="${item#*=}"
			option_reference="$option_branch"
			;;
		'--commit='* | '--ref='* | '--reference='*) option_reference="${item#*=}" ;;
		'--slug='*) option_slug="${item#*=}" ;;
		'repl')
			action='repl'
			option_args+=("$@")
			shift $#
			;;
		'run')
			action='run'
			option_args+=("$@")
			shift $#
			;;
		'i' | 'install')
			action='install'
			option_args+=("$@")
			shift $#
			;;
		'uninstall')
			action='uninstall'
			;;
		'u' | 'up' | 'update')
			action='update'
			;;
		'p' | 'perm' | 'perms' | 'permissions')
			action='permissions'
			;;
		'e' | 'edit')
			action='edit'
			option_args+=("$@")
			shift $#
			;;
		'r' | 'review')
			action='review'
			;;
		'theme')
			action='theme'
			;;
		'd' | 'dev')
			action='dev'
			;;
		'f' | 'format')
			action='format'
			;;
		'c' | 'check')
			action='check'
			;;
		'l' | 'lint')
			action='lint'
			;;
		't' | 'test')
			action='test'
			option_args+=("$@")
			shift $#
			;;
		'todo' | 'todos')
			action='todos'
			;;
		'--'*) help "An unrecognised flag was provided: $item" ;;
		*) help "An unrecognised argument was provided: $item" ;;
		esac
	done

	if test -z "$action"; then
		help "<action> must be provided."
	fi

	# =====================================
	# Sourcing

	# source [bash.bash] for sensible defaults if it exists
	if test -n "$DOROTHY" -a -f "$DOROTHY/sources/bash.bash"; then
		source "$DOROTHY/sources/bash.bash"
	else
		eval "$(curl -fsSL "https://raw.githubusercontent.com/$option_slug/$option_reference/sources/bash.bash")"
	fi

	# =====================================
	# Substitutions

	# see commands/command-missing for details
	function __command_missing {
		local command commands=("$@")
		for command in "${commands[@]}"; do
			if type -P "$command" &>/dev/null; then
				continue
			else
				return 0 # command missing
			fi
		done
		return 1 # all commands are present
	}

	# see commands/command_exists for details
	function __command_exists {
		local command commands=("$@")
		for command in "${commands[@]}"; do
			if type -P "$command" &>/dev/null; then
				continue
			else
				return 1 # command missing
			fi
		done
		return 0 # all commands are present
	}

	# see commands/is-mac for details
	function __is_mac {
		test "$(uname -s)" = 'Darwin'
	}

	# see commands/is-linux for details
	function __is_linux {
		test "$(uname -s)" = 'Linux'
	}

	# see commands/is-manjaro for details
	function __is_manjaro {
		uname -r | grep --quiet --ignore-case --fixed-strings --regexp='manjaro'
	}

	# see commands/fs-realpath for details
	function __fs_realpath {
		# options
		local item paths=()
		while test "$#" -ne 0; do
			item="$1"
			shift
			case "$item" in
			'--help' | '-h')
				help
				return
				;;
			'--')
				paths+=("$@")
				shift $#
				break
				;;
			'--'*)
				help "An unrecognised flag was provided: $item"
				return
				;;
			*) paths+=("$item") ;;
			esac
		done

		local gnu_realpath=''
		if __command_exists grealpath; then
			gnu_realpath='grealpath'
		elif __command_exists realpath && __is_linux; then
			gnu_realpath='realpath'
		fi

		local gnu_readlink=''
		if __command_exists greadlink; then
			gnu_readlink='greadlink'
		elif __command_exists readlink && __is_linux; then
			gnu_readlink='readlink'
		fi

		local macos_readlink=''
		if __command_exists readlink && __is_mac; then
			macos_readlink='readlink'
		fi

		local macos_realpath=''
		if __command_exists realpath && __is_mac; then
			macos_realpath='realpath'
		fi

		# --resolve=yes --validate=yes --relative=no
		local path
		for path in "${paths[@]}"; do
			if test -n "$gnu_realpath"; then
				"$gnu_realpath" --canonicalize-existing "$path"
				return
			elif test -n "$gnu_readlink"; then
				"$gnu_readlink" --canonicalize-existing "$path"
				return
			elif test -n "$macos_readlink"; then
				"$macos_readlink" -f "$path"
				return
			elif test -n "$macos_realpath"; then
				"$macos_realpath" "$path"
				return
			elif __command_exists fish; then
				# this isn't --validate, but it is a last resort
				# trunk-ignore(shellcheck/SC2016)
				fish -c 'builtin realpath "$argv[1]"' -- "$path"
				return
			else
				__print_line "Dorothy requires readlink or realpath to be installed. $dorothy_install" >/dev/stderr
				return 6 # ENXIO 6 Device not configured
			fi
		done
	}

	# see commands/sudo-helper for details
	function __try_sudo {
		if __command_exists sudo; then
			# check if password is required
			if ! sudo --non-interactive true &>/dev/null; then
				# password is required, let the user know what they are being prompted for
				__print_line 'Your sudo/root/login password is required to execute the command:' >/dev/stderr
				__print_line "sudo $*" >/dev/stderr
				sudo "$@"
			else
				# session still active, password not required
				sudo "$@"
			fi
		elif __command_exists doas; then
			set -x # <inform the user of why they are being prompted for a doas password>
			doas "$@"
			set +x # </inform>
		else
			"$@"
		fi
	}

	# =====================================
	# Helpers

	function ensure_prereq_dependencies {
		# dorothy has yet to be installed
		# extras: tput/ncurses, ps/procps, moreutils
		# don't check for [sponge from moreutils, and realpath/readlink from coreutils] as no way to install that on macos without brew, however install them if installing other things
		# this should somewhat coincide with:
		# [commands/dorothy] - preference sorted, doesn't do updates, don't do noconfirm
		# [dorothy-workflow.yml] - preference sorted, does updates, does noconfirm, skips extras
		# [readme.md] - popularity sorted, does updates, don't do noconfirm, skips extras (ncurses, moreutils, procps)
		# https://repology.org/project/gawk/versions
		if __command_missing bash curl grep git tput ps awk; then
			# preference sort
			if __command_exists apt-get; then
				# for ubuntu/debian/kali
				# E: Unable to locate package ncurses
				__try_sudo apt-get install -y bash curl git procps coreutils moreutils gawk
			elif __command_exists zypper; then
				# for opensuse
				__try_sudo zypper --non-interactive install bash curl git-core ncurses coreutils moreutils gawk
			elif __command_exists apk; then
				# for alpine
				__try_sudo apk add bash curl grep git ncurses coreutils moreutils gawk
			elif __command_exists pamac; then
				# for manjaro that has pamac installed
				__try_sudo pamac install --no-confirm bash curl git ncurses procps-ng coreutils moreutils gawk
			elif __command_exists pacman; then
				# for manjaro and arch
				__try_sudo pacman --noconfirm --refresh --sync --needed bash curl git ncurses procps-ng coreutils moreutils gawk
			elif __command_exists urpmi; then
				# for mageia, prefer over fedora as mageia contains dnf
				# No package named moreutils
				__try_sudo urpmi --auto bash curl git ncurses gawk
			elif __command_exists dnf; then
				# for fedora
				__try_sudo dnf --assumeyes --refresh --best --allowerasing install bash curl git ncurses procps coreutils moreutils gawk
			elif test -n "${HOMEBREW_PREFIX-}" -a -x "${HOMEBREW_PREFIX-}/bin/brew"; then
				# this is here for consistency only, as it is unnecessary, all the commands already exist on macos without any need for homebrew
				"$HOMEBREW_PREFIX/bin/brew" install bash curl git ncurses coreutils moreutils gawk
			elif __command_exists xbps-install; then
				# for void
				__try_sudo xbps-install --sync --yes bash curl git ncurses coreutils moreutils gawk
			elif __command_exists nix-env; then
				# for nix
				__try_sudo nix-env --install --attr nixpkgs.coreutils nixpkgs.bash nixpkgs.curl nixpkgs.git nixpkgs.ncurses nixpkgs.coreutils nixpkgs.moreutils nixpkgs.gawk
			elif __command_exists emerge; then
				# for gentoo
				__try_sudo emerge app-shells/bash net-misc/curl dev-vcs/git sys-libs/ncurses sys-apps/coreutils sys-apps/moreutils sys-apps/gawk
			else
				# for everything else
				cat <<-EOF >/dev/stderr
					One of these installation dependencies are missing:
					bash:  $(bash --version | head -1 || :)
					curl:  $(curl --version | head -1 || :)
					grep:  $(grep --version || :)
					git:   $(git --version || :)
					tput:  $(tput -V || :)
					ps:    $(type -P ps || :)
					awk:   $(awk --version || :)

					Refer to the manual: $dorothy_homepage
				EOF
				return 19 # ENODEV 19 Operation not supported by device
			fi
		fi
	}

	function ensure_minimal_dependencies {
		# dorothy has been installed
		echo-style --h2='Ensure required dependencies'

		# macos tooling
		if __is_mac; then
			setup-util-apple-rosetta --quiet
			setup-util-apple-cli-tools --quiet
			source "$DOROTHY/sources/environment.sh"
		fi

		# upgrade bash if necessary
		setup-util-bash --quiet

		# [github-download] sometimes requires [jq]
		# [set-hostname] requires [sd]
		# [config-helper] requires [rg], [sd], [teip]
		if __command_missing jq rg sd sd teip; then
			if __command_exists apt-get; then
				__try_sudo apt-get -qq update # -qq: quiet
			fi
			setup-util-jq --quiet
			setup-util-ripgrep --quiet
			setup-util-sd --quiet
			setup-util-teip --quiet
		fi

		# ensure nushell always has the config files it needs
		if __command_exists nu; then
			setup-util-nu --quiet
		fi

		# log
		echo-style --g2='Ensure required dependencies'
	}

	function ensure_development_dependencies {
		echo-style --h2='Ensure development dependencies'
		setup-util-bash --quiet "$@"
		setup-util-ripgrep --quiet "$@"
		setup-util-prettier --quiet "$@"
		setup-util-shellcheck --quiet "$@"
		setup-util-shfmt --quiet "$@"
		setup-util-trunk --quiet "$@"
		echo-style --g2='Ensure development dependencies'
	}

	function assert_dorothy_configured {
		# DOROTHY is determined earlier, so this checks it is installed
		if test ! -d "$DOROTHY"; then
			echo-style \
				--error='Dorothy is not installed.' $'\n' \
				'Nothing was found at: ' --code="$DOROTHY" $'\n' \
				--warning='Run' --code=' dorothy install ' --warning='to install, then you can run' --code=" dorothy $action"
			return 2 # ENOENT 2 No such file or directory
		fi
		# no need to source bash.bash here, as we did it earlier via source and curl
		source "$DOROTHY/sources/environment.sh"

		# ensure state exists
		mkdir -p "$XDG_STATE_HOME/dorothy"
		relocate_then_symlink_if_necessary "$DOROTHY/state" "$XDG_STATE_HOME/dorothy"
		mkdir -p "$DOROTHY/state/config.local"
		mkdir -p "$DOROTHY/state/config"
		mkdir -p "$DOROTHY/state/sources"
	}

	function assert_user_cloned {
		if test ! -d "$DOROTHY/user/commands.local" -o ! -d "$DOROTHY/user/commands" -o ! -d "$DOROTHY/user/config.local" -o ! -d "$DOROTHY/user/config"; then
			echo-style \
				--error='Dorothy user configuration is not configured correctly.' $'\n' \
				--warning='Run' --code=' dorothy install ' --warning='to install, then you can run' --code=" dorothy $action"
			return 2 # ENOENT 2 No such file or directory
		fi
	}

	function assert_dorothy_and_user_cloned {
		assert_dorothy_configured
		assert_user_cloned
	}

	function git_init {
		local path="$1"
		mkdir -p "$path"
		(
			cd "$path"
			git init
		)
	}

	function rm_deprecated {
		local file
		for file in "$@"; do
			# -s (file exists and is not empty)
			if test -s "$file"; then
				echo-file -- "$file"
				if confirm --positive --ppid=$$ -- 'Unless you are an experienced user who has already made modifications to this shell configuration file, it can be safely removed for a lighter installation. Remove this file?'; then
					rm "$file"
				fi
				__print_line
			fi
		done
	}

	function make_executable {
		# makes sure chmod isn't running on nothing, which can happen upon initial user installs
		if test "$#" -ne 0; then
			chmod -f +x "$@"
		fi
	}

	# relocate and remove symlinks
	function relocate_if_necessary {
		local source="$1" destination="$2" temp

		# if source is a symlink, resolve it and remove it
		if test -L "$source"; then
			temp="$source"
			# resolve where the source actually is
			if test -e "$destination"; then
				source="$(__fs_realpath -- "$source")"
			else
				source=''
			fi
			# remove the source symlink
			rm -f "$temp"
		fi

		# if destination is a symlink, resolve it, move it, and remove it
		if test -L "$destination"; then
			if test -e "$destination"; then
				temp2="$(__fs_realpath -- "$destination")"
				# remove the destination symlink
				rm -f "$destination"
				# relocate the target to the destination
				mv -fv "$temp2" "$destination"
			else
				# remove the destination symlink
				rm -f "$destination"
			fi
		fi

		# do we need to move and merge the source with the destination?
		if test -n "$source" -a -n "$destination" -a "$source" != "$destination" -a -e "$source"; then
			mv -fv "$source" "$destination"
		fi

		# all done
		return 0
	}

	# relocate and recreate symlink
	function relocate_then_symlink_if_necessary {
		local symlink="$1" destination="$2"
		relocate_if_necessary "$symlink" "$destination"
		ln -sfF "$destination" "$symlink"
		# cleanup accidents
		symlink="$symlink/$(basename "$destination")"
		if test -L "$symlink"; then
			rm -f "$symlink"
		fi
	}

	function relocate_dorothy_if_necessary {
		# move if necessary
		if test -d "$DOROTHY" -o -d "$XDG_DATA_HOME/dorothy"; then
			if test "$option_xdg" = 'yes'; then
				relocate_then_symlink_if_necessary "$DOROTHY" "$XDG_DATA_HOME/dorothy"
			elif test "$option_xdg" = 'no'; then
				relocate_then_symlink_if_necessary "$XDG_DATA_HOME/dorothy" "$DOROTHY"
				relocate_then_symlink_if_necessary "$HOME/.local/share/dorothy" "$DOROTHY"
			else
				# invalid option_xdg value
				return 76 # EPROCUNAVAIL 76 Bad procedure for program
			fi

			# ensure correct permissions
			make_executable "$DOROTHY/commands/"* "$DOROTHY/commands.beta/"*
		fi # else fresh install and no prior clones exist
	}

	function relocate_user_if_necessary {
		# move if necessary
		if test -d "$DOROTHY/user" -o -d "$XDG_CONFIG_HOME/dorothy"; then
			if test "$option_xdg" = 'yes'; then
				# ensure $DOROTHY/user always exists
				relocate_then_symlink_if_necessary "$DOROTHY/user" "$XDG_CONFIG_HOME/dorothy"
			elif test "$option_xdg" = 'no'; then
				relocate_then_symlink_if_necessary "$XDG_CONFIG_HOME/dorothy" "$DOROTHY/user"
			else
				# invalid option_xdg value
				return 76 # EPROCUNAVAIL 76 Bad procedure for program
			fi

			# ensure correct permissions
			if test -d "$DOROTHY/user/commands"; then
				make_executable "$DOROTHY/user/commands/"*
			fi
			if test -d "$DOROTHY/user/commands.local"; then
				make_executable "$DOROTHY/user/commands.local/"*
			fi
		fi # else fresh install and no prior clones exist
	}

	function relocate_zsh_if_necessary {
		# https://zsh.sourceforge.io/Intro/intro_3.html
		# determine ZDOTDIR
		if test "$option_xdg" = 'yes'; then
			if test -z "$ZDOTDIR"; then
				ZDOTDIR="$XDG_CONFIG_HOME/zsh"
			fi
		elif test "$option_xdg" = 'no'; then
			if test -z "$ZDOTDIR"; then
				ZDOTDIR="$HOME"
			fi
		else
			# invalid option_xdg value
			return 76 # EPROCUNAVAIL 76 Bad procedure for program
		fi
		# move config files
		# zshenv needs to be in $HOME - all other goes in ZDOT.
		mkdir -p "$ZDOTDIR" # required for opensuse
		relocate_if_necessary "$ZDOTDIR/.zshenv" "$HOME/.zshenv"
		relocate_if_necessary "$HOME/.zprofile" "$ZDOTDIR/.zprofile"
		relocate_if_necessary "$HOME/.zshrc" "$ZDOTDIR/.zshrc"
		relocate_if_necessary "$HOME/.zlogin" "$ZDOTDIR/.zlogin"
		relocate_if_necessary "$HOME/.zlogout" "$ZDOTDIR/.zlogout"
	}

	function prepare_dorothy {
		# if no DOROTHY env override, attempt DOROTHY from possible existing installations
		if test -z "$DOROTHY"; then
			if test -d "$XDG_DATA_HOME/dorothy"; then
				DOROTHY="$XDG_DATA_HOME/dorothy"
			elif test -d "$HOME/.local/share/dorothy"; then
				DOROTHY="$HOME/.local/share/dorothy"
			elif test -x ./commands/dorothy; then
				DOROTHY="$(pwd)" # github actions, cron, etc
			else
				# no existing installation
				# no custom $DOROTHY
				# so use XDG
				DOROTHY="$XDG_DATA_HOME/dorothy"
			fi
		fi

		# adjust XDG based on determination above
		if test "$DOROTHY" = "$XDG_DATA_HOME/dorothy"; then
			option_xdg='yes'
		else
			option_xdg='no'
		fi

		# adjust path for determined (including user defined) DOROTHY, as well as standard DOROTHY XDG location (in case user ever changes DOROTHY location)
		PATH="$DOROTHY/user/commands:$XDG_CONFIG_HOME/dorothy/commands:$DOROTHY/commands:$XDG_CONFIG_HOME/dorothy/commands:$XDG_BIN_HOME:$PATH"

		# if dorothy exists, ensure DOROTHY is in correct location
		relocate_dorothy_if_necessary

		# if user configuration exists, ensure user configuration is in correct location
		relocate_user_if_necessary

		# ensure shell config files are in correct location
		relocate_zsh_if_necessary
		# fish uses xdg by default
		# bash does not support xdg
	}

	function stage_new_files {
		__require_globstar
		local path="$1"
		# The following paths are ignored by one of your .gitignore files: ...
		# hint: Use -f if you really want to add them.
		# hint: Turn this message off by running
		# hint: "git config advice.addIgnoredFile false"
		(
			cd "$path"
			git add --ignore-errors ./** || :
		)
	}

	function stage_changed_files {
		local path="$1"
		(
			cd "$path"
			git add -u || :
		)
	}

	function correct_permissions {
		# make everything readable and writable, make directories accessible
		fs-own --changes --optional --permissions='+rwX' \
			-- "$DOROTHY"
		# make commands executable
		local commands
		commands=(
			"$DOROTHY/commands/"*
			"$DOROTHY/commands.beta/"*
			"$DOROTHY/user/commands/"*
			"$DOROTHY/user/commands.local/"*
			"$DOROTHY/themes/oz"
		)
		fs-own --changes --no-recursive --permissions='+x' \
			-- "${commands[@]}"
	}

	function ensure_permissions_configured {
		source "$(type -P eval-helper)"

		eval_helper --quiet --no-wrap \
			--pending="$(echo-style --bold='Correcting permissions...')" \
			--success="$(echo-style --success='Corrected permissions.')" \
			--failure="$(echo-style --error='Failed to correct permissions.')" \
			-- correct_permissions

		eval_helper --quiet --no-wrap \
			--pending="$(echo-style --bold='Staging new files...')" \
			--success="$(echo-style --success='Staged new files.')" \
			--failure="$(echo-style --error='Failed to stage new files.')" \
			-- stage_new_files "$DOROTHY"

		eval_helper --quiet --no-wrap \
			--pending="$(echo-style --bold='Staging changed files...')" \
			--success="$(echo-style --success='Staged changed files.')" \
			--failure="$(echo-style --error='Failed to stage changed files.')" \
			-- stage_changed_files "$DOROTHY"

		eval_helper --quiet --no-wrap \
			--pending="$(echo-style --bold='Removing junk files...')" \
			--success="$(echo-style --success='Removed junk files.')" \
			--failure="$(echo-style --error='Failed to remove junk files.')" \
			-- rm-junk "$DOROTHY"
	}

	function ensure_dorothy_configured {
		# sanity check
		if ! [[ $action =~ ^(install|update|repl|run)$ ]]; then
			return 29 # ESPIPE 29 Illegal seek
		fi

		# helpers
		function install_dorothy {
			local clone_args=('--no-tags') # don't do [--depth 1] and [--single-branch] as a full history is required to do any checkouts
			__print_line "Installing Dorothy into $DOROTHY"
			if test -n "$option_branch"; then
				clone_args+=(
					'--branch'
					"$option_branch"
				)
			fi
			git clone "${clone_args[@]}" "https://github.com/$option_slug.git" "$DOROTHY"
			if test -n "$option_reference"; then
				(
					cd "$DOROTHY"
					git checkout --quiet "$option_reference" # --quiet to suppress "detached HEAD" feedback
				)
			fi
		}
		function __update_modern_dorothy {
			if __command_exists echo-style git-helper; then
				echo-style --h2="Updating the Dorothy installation at $DOROTHY" || return
				# update origin first
				git-helper update --path="$DOROTHY" || return
				# update upstream second
				git-helper update --path="$DOROTHY" -- --remote-name="$dorothy_upstream_remote_name" --remote-url="$dorothy_upstream_git_https" || return
				echo-style --g2="Updating the Dorothy installation at $DOROTHY" || return
			else
				return 1
			fi
		}
		function __update_legacy_dorothy {
			(
				__print_line "Updating Dorothy installation at $DOROTHY" || return
				cd "$DOROTHY" || return
				git config pull.ff only || return # avoid merge conflicts
				# in case they have forked dorothy, we need to pull from the upstream
				# we do not have the intelligence yet to update origin and upstream, so we will just update upstream
				git remote remove "$dorothy_upstream_remote_name" 2>/dev/null || : # don't care if doesn't exist, and remove to ensure desired URL is applied
				git remote add --fetch "$dorothy_upstream_remote_name" "$dorothy_upstream_git_https" || return
				git pull "$dorothy_upstream_remote_name" "$dorothy_upstream_branch" || return
				__print_line "Successfully updated Dorothy installation at $DOROTHY" || return
			) || return
		}
		function update_dorothy {
			# https://github.com/bevry/dorothy/issues/215
			__update_modern_dorothy || __update_legacy_dorothy || {
				__print_line '...Dorothy was unable to be automatically updated. Please manually update Dorothy and try again.'
				return 1
			}
		}

		# check
		if [[ $action =~ ^(repl|run)$ ]]; then
			# in trial mode, only install dorothy if necessary, do not update
			if test ! -d "$DOROTHY"; then
				install_dorothy
			fi
		else
			# in install and update mode, do whatever is appropriate
			if test -d "$DOROTHY"; then
				update_dorothy
			else
				install_dorothy
			fi
		fi

		# move if necessary, and fix permissions
		relocate_dorothy_if_necessary
	}

	function ensure_machine_configured {
		# sanity check
		if ! [[ $action =~ ^(install)$ ]]; then
			return 29 # ESPIPE 29 Illegal seek
		fi

		# act
		local hostname
		hostname="$(get-hostname)"
		if is-interactive && is-generic -- "$hostname"; then
			if confirm --bool --ppid=$$ -- "This machine's hostname is currently generic [$hostname], would you like to change it?"; then
				hostname="$(
					ask --linger --question='What should the new hostname be?'
				)"
				if test -n "$hostname"; then
					set-hostname "$hostname"
				else
					__print_line "Proceeding with the existing hostname: $hostname"
				fi
			fi
		fi
	}

	function ensure_user_configured {
		local user="${1-}"

		# sanity check
		if ! [[ $action =~ ^(install|update)$ ]]; then
			return 29 # ESPIPE 29 Illegal seek
		fi

		# helpers
		function install_user {
			# sanity check
			if test -d "$DOROTHY/user"; then
				# should have called update
				return 29 # ESPIPE 29 Illegal seek
			fi

			# prepare
			local question='' where='' cli='' repo_git='' repo_url='' repo_name repo_description local_ip
			repo_name='dotfiles'
			repo_description="My user configuration for the Dorothy dotfile ecosystem: $dorothy_homepage"

			# handle github and gitlab prefixes, local value, custom urls, and default github usernames
			if test -n "$user"; then
				if [[ $user =~ ^(gh|github): ]]; then
					where='github'
					user="${user#*:}"
				elif [[ $user =~ ^(gitlab|gl): ]]; then
					where='github'
					user="${user#*:}"
				elif [[ $user =~ ^(local|none)$ ]]; then
					where='local'
					user=''
				elif [[ $user == *:* ]]; then
					where='custom'
				else
					where='github'
				fi
			fi
			if test -z "$where"; then
				if is-interactive; then
					where="$(
						choose --linger --required --label \
							--question='Where do you want to store your Dorothy user configuration?' \
							-- \
							github \
							'Use a GitHub repository for your user configuration.' \
							gitlab \
							'Use a GitLab repository for your user configuration.' \
							custom \
							'Manually specify a repository URL for your user configration.' \
							'local' \
							"Don't use a repository for your user configuration, just store it locally for now."
					)"
				else
					where='local'
				fi
			fi
			if test "$where" = 'github' && __command_exists gh; then
				cli='gh'
			elif test "$where" = 'gitlab' && __command_exists glab; then
				cli='glab'
			fi
			if test "$where" = 'github' -o "$where" = 'gitlab'; then
				# prepare username default, and clear generic usernames
				if test -z "$user"; then
					user="$(get-profile username || :)"
					if test -n "$user" && is-generic -- "$user"; then
						user=''
					fi
					user="$(
						ask --required --linger \
							--question="Enter your $where username." \
							--default="$user"
					)"
				fi

				# check what they want to call the repository
				repo_name="$(
					ask --required --linger \
						--question="Enter the $where repository name for your Dorothy user configuration." \
						--default="$repo_name"
				)"
				repo_url="https://$where.com/$user/$repo_name"

				# confirm it exists
				if fetch --ok "$repo_url"; then
					if test -n "$cli"; then
						if "$cli" repo view "$repo_name" | grep --quiet --ignore-case --fixed-strings --regexp="$dorothy_homepage" || :; then
							echo-style --green+bold="$repo_url" --green=' verified as a Dorothy user configuration repository.'
						elif confirm --bool --ppid=$$ -- "$repo_url exists, but does not yet seem to be a Dorothy user configuration repository, would you like to use it anyway (Y), or select an alternative (N)?"; then
							echo-style --blue='^ manually confirmed to use as the Dorothy user configuration repository.'
						else
							echo-style --yellow='^ manually elected to use an alternative.'
							repo_url=''
						fi
					fi
				else
					echo-style --yellow+bold="$repo_url" --yellow=' does not yet exist, let us create it...'
					if test "$cli" = 'gh'; then
						if ! gh repo create "$repo_name" --description "$repo_description" --homepage "$dorothy_homepage" --public --confirm --enable-wiki=false; then
							repo_url=''
						fi
					elif test "$cli" = 'glab'; then
						# @todo untested
						if ! glab repo create "$repo_name" --description "$repo_description" --public; then
							repo_url=''
						fi
					fi
				fi
			fi

			# if the repo doesn't exist, get the user to manually create it
			if test -z "$repo_url" -a "$where" != 'local'; then
				if test "$where" = 'github'; then
					open 'https://github.com/new'
				elif test "$where" = 'gitlab'; then
					open 'https://gitlab.com/projects/new#blank_project'
				fi
				question="$(
					cat <<-EOF
						Create a repository for your Dorothy user configuration using the following details.

						Repository name:
						${repo_name}

						Description:
						${repo_description}

						Visibility:
						Public

						Initialize with:
						keep everything unchecked

						Once you have created the repository to house your Dorothy user configuration, type its URL below.
					EOF
				)"
				repo_url="$(
					ask --linger --question="$question"
				)"
			fi

			# if we have a repo url, then clone it
			if test -n "$repo_url"; then
				# check if it is strongbox
				if fetch --ok "$(git-helper protocol-format "$repo_url" https | sed -E 's#.git$#/raw/HEAD/.strongbox-keyid#')"; then
					echo-style --notice='Strongbox repository detected.'
					setup-util-strongbox
					local_ip="$(what-is-my-ip local | echo-first-line || :)"
					question="$(
						cat <<-EOF
							You will now be prompted to update your $(echo-style --code="~/.strongbox_keyring") file.

							If VNC is enabled, run the following on your primary machine to copy the contents:

							$(echo-style --code='cat ~/.strongbox_keyring')
							$(echo-style --code="open vnc://${local_ip}")

							If SSH is enabled, run the following on your primary machine to write the contents:

							$(echo-style --code="cpr -- \"\$HOME/.strongbox_keyring\" \"$(whoami)@${local_ip}:$HOME/.strongbox_keyring\"")

							To enable SSH, do the following on this machine:

							macOS via: System Preferences > Sharing > Remote Login.
							Linux via: $(echo-style --code="bash -ic \"\$(curl -fsSL '$dorothy_worker_run')\" -- setup-util-sshd")

						EOF
					)"
					if test ! -f "$HOME/.strongbox_keyring" && confirm --ppid=$$ -- "$question"; then
						edit --wait -- "$HOME/.strongbox_keyring"
					fi
				fi

				# do the clone
				repo_git="$(git-helper protocol-format "$repo_url")"
				if git clone "$repo_git" "$DOROTHY/user"; then
					echo-style --green+bold="$repo_git" --green=" successfully cloned to " --green+bold="$DOROTHY/user"
				else
					echo-style --yellow+bold="$repo_git" --yellow=" failed to clone to " --yellow+bold="$DOROTHY/user"
					echo-style --yellow='We will manually initialise instead.'
				fi
			else
				echo-style --yellow='No git repository URL provided, we will manually initialise instead.'
			fi

			# if we haven't initialised, then manually initialise
			if test ! -d "$DOROTHY/user"; then
				git_init "$DOROTHY/user"
				echo-style --yellow='Manually initialised git repository at ' --yellow+bold="$DOROTHY/user"
			fi
		}
		function update_user {
			echo-style --h2="Updating the Dorothy user configuration at $DOROTHY/user"
			if ! git-helper update --path="$DOROTHY/user"; then
				__print_line '...Dorothy user configuration was unable to be updated, you will have to figure this out later...'
			fi
			echo-style --g2="Updating the Dorothy user configuration at $DOROTHY/user"
		}

		# update or install the user configuration based on its presence
		if test -d "$DOROTHY/user"; then
			# it already exists, so update it
			update_user
		else
			# it doesn't exist, so install it
			install_user
		fi

		# move if necessary, and fix permissions
		relocate_user_if_necessary

		# ensure structure is correct
		adjust_user_configuration
	}

	function adjust_user_configuration {
		local file who name url header content

		# create essential directories
		mkdir -p \
			"$DOROTHY/user/commands.local" \
			"$DOROTHY/user/commands" \
			"$DOROTHY/user/config.local" \
			"$DOROTHY/user/config"

		# ensure README.md mentions dorothy
		file="$DOROTHY/user/README.md"
		if ! (test -f "$file" && grep --quiet --ignore-case --fixed-strings --regexp="$dorothy_homepage" "$file"); then
			# README.md does not mention dorothy, time to add it
			name="$(get-profile name || get-profile username || :)"
			url="$(get-profile url || :)"
			if test -n "$name" -a -n "$url"; then
				who="[${name}'s](${url})"
			elif test -n "$name"; then
				who="${name}'s"
			else
				who='my'
			fi
			header="$(
				cat <<-EOF
					# Dorothy User Configuration

					This is ${who} user configuration for the [Dorothy](${dorothy_homepage}) dotfile ecosystem.
				EOF
			)"
			if test ! -f "$file"; then
				__print_line "$header" >"$file"
			else
				content="$(cat "$file")"
				printf '%s\n\n%s' "$header" "$content" >"$file"
			fi
		fi

		# gitignore
		config-helper --file="$DOROTHY/user/.gitignore" -- \
			--find='commands.local[/]' --replace='commands.local/' \
			--find='config.local[/]' --replace='config.local/'
	}

	function ensure_shell_configured {
		# process arguments
		local item option_clean='no' option_uninstall='no' default_shells=() use_shells=() fodder=''
		local supported_shells=(
			bash
			dash
			elvish
			fish
			ksh
			nu
			xonsh
			zsh
		)
		local supported_shells_with_labels=(
			bash Bash
			dash Dash
			elvish Elvish
			fish Fish
			ksh KSH
			nu Nu
			xonsh Xonsh
			zsh Zsh
		)
		while test "$#" -ne 0; do
			item="$1"
			shift
			case "$item" in
			'--clean' | '--clean=yes') option_clean='yes' ;;
			'--no-clean' | '--clean=no') option_clean='no' ;;
			'--uninstall') option_uninstall='yes' ;;
			'--'*) help "An unrecognised flag was provided: $item" ;;
			*) help "An unrecognised argument was provided: $item" ;;
			esac
		done

		echo-style --h2='Dorothy Shell Configuration'

		# if not uninstalling
		if test "$option_uninstall" = 'no'; then
			# configure default selected shells by checking for their existence
			local cmd
			for cmd in "${supported_shells[@]}"; do
				if __command_exists "$cmd"; then
					default_shells+=("$cmd")
				fi
			done

			eval_capture --stdoutvar=fodder -- \
				choose \
				--defaults="$(__print_lines "${default_shells[@]}")" \
				--question="Which shells to use Dorothy?" \
				--multi \
				--label \
				-- "${supported_shells_with_labels[@]}"
			mapfile -t use_shells <<<"$fodder"
		fi
		use_shells+=('bash v3 compat workaround')

		# cleanup
		if test "$option_clean" = 'yes'; then
			rm_deprecated "$HOME/.profile" "$HOME/.bash_profile" "$HOME/.bashrc" "$XDG_CONFIG_HOME/fish/config.fish" "$ZDOTDIR/.zshrc" "$ZDOTDIR/.zprofile"
		fi

		# bash
		if is-needle --needle=bash -- "${use_shells[@]}"; then
			echo-style --h3='Configuring Bash'
			setup-util-bash

			# mac and raspi ubuntu
			config-helper --file="$HOME/.bash_profile" -- \
				--find='.+? # Dorothy' --replace="source \"$DOROTHY/init.sh\" # Dorothy"

			# vm ubuntu
			config-helper --file="$HOME/.bashrc" -- \
				--find='.+? # Dorothy' --replace="source \"$DOROTHY/init.sh\" # Dorothy"

			echo-style --g3='Configuring Bash'
		else
			config-helper --file="$HOME/.bash_profile" -- \
				--find='.+? # Dorothy' --replace=''
			config-helper --file="$HOME/.bashrc" -- \
				--find='.+? # Dorothy' --replace=''
		fi

		# dash
		if is-needle --needle=dash -- "${use_shells[@]}"; then
			echo-style --h3='Configuring Dash'
			setup-util-dash

			# configure
			config-helper --file="$HOME/.profile" -- \
				--find='.+? # Dorothy' --replace=". \"$DOROTHY/init.sh\" # Dorothy"

			echo-style --g3='Configuring Dash'
		elif ! is-needle --needle=bash -- "${use_shells[@]}" && ! is-needle --needle=ksh -- "${use_shells[@]}"; then
			config-helper --file="$HOME/.profile" -- \
				--find='.+? # Dorothy' --replace=''
		fi

		# elvish
		if is-needle --needle=elvish -- "${use_shells[@]}"; then
			# https://elv.sh/ref/command.html#rc-file
			# https://elv.sh/ref/runtime.html
			# https://github.com/elves/elvish/issues/1726
			echo-style --h3='Configuring Elvish'
			setup-util-elvish
			mkdir -p "$XDG_CONFIG_HOME/elvish"

			# configure
			config-helper --file="$XDG_CONFIG_HOME/elvish/rc.elv" -- \
				--find='.+? # Dorothy' --replace="eval (cat '$DOROTHY/init.elv' | slurp) # Dorothy"

			echo-style --h3='Configuring Elvish'
		else
			mkdir -p "$XDG_CONFIG_HOME/elvish"
			config-helper --file="$XDG_CONFIG_HOME/elvish/rc.elv" -- \
				--find='.+? # Dorothy' --replace=''
		fi

		# fish
		if is-needle --needle=fish -- "${use_shells[@]}"; then
			echo-style --h3='Configuring Fish'
			setup-util-fish
			mkdir -p "$XDG_CONFIG_HOME/fish"

			# configure
			config-helper --file="$XDG_CONFIG_HOME/fish/config.fish" -- \
				--find='.+? # Dorothy' --replace="source '$DOROTHY/init.fish' # Dorothy"

			echo-style --g3='Configuring Zsh'
		else
			mkdir -p "$XDG_CONFIG_HOME/fish"
			config-helper --file="$XDG_CONFIG_HOME/fish/config.fish" -- \
				--find='.+? # Dorothy' --replace=''
		fi

		# ksh
		if is-needle --needle=ksh -- "${use_shells[@]}"; then
			echo-style --h3='Configuring KSH'
			setup-util-ksh

			# configure
			config-helper --file="$HOME/.profile" -- \
				--find='.+? # Dorothy' --replace=". '$DOROTHY/init.sh' # Dorothy"

			echo-style --g3='Configuring KSH'
		elif ! is-needle --needle=bash -- "${use_shells[@]}" && ! is-needle --needle=dash -- "${use_shells[@]}"; then
			config-helper --file="$HOME/.profile" -- \
				--find='.+? # Dorothy' --replace=''
		fi

		# nu
		if is-needle --needle=nu -- "${use_shells[@]}"; then
			echo-style --h3='Configuring Nu'
			setup-util-nu

			# trunk-ignore(shellcheck/SC2016)
			config-helper --file="$(nu -c 'echo $nu.loginshell-path')" -- \
				--find='.+? # Dorothy' --replace="source '$DOROTHY/init.nu' # Dorothy"

			echo-style --g3='Configuring Nu'
		elif __command_exists nu; then
			# trunk-ignore(shellcheck/SC2016)
			config-helper --file="$(nu -c 'echo $nu.loginshell-path')" -- \
				--find='.+? # Dorothy' --replace=''
		fi

		# xonsh
		if is-needle --needle=xonsh -- "${use_shells[@]}"; then
			# https://xon.sh/xonshrc.html
			echo-style --h3='Configuring Xonsh'
			setup-util-xonsh
			mkdir -p "$XDG_CONFIG_HOME/xonsh/rc.d"

			# configure
			config-helper --file="$XDG_CONFIG_HOME/xonsh/rc.xsh" -- \
				--find='.+? # Dorothy' --replace="execx(compilex(open('$DOROTHY/init.xsh').read())) # Dorothy"

			echo-style --g3='Configuring Xonsh'
		else
			mkdir -p "$XDG_CONFIG_HOME/xonsh/rc.d"
			config-helper --file="$XDG_CONFIG_HOME/xonsh/rc.xsh" -- \
				--find='.+? # Dorothy' --replace=''
		fi

		# zsh
		# https://zsh.sourceforge.io/Intro/intro_3.html
		if is-needle --needle=zsh -- "${use_shells[@]}"; then
			echo-style --h3='Configuring Zsh'
			setup-util-zsh
			mkdir -p "$ZDOTDIR"

			# configure
			config-helper --file="$ZDOTDIR/.zshrc" -- \
				--find='.+? # Dorothy' --replace="source '$DOROTHY/init.sh' # Dorothy"

			config-helper --file="$ZDOTDIR/.zprofile" -- \
				--find='.+? # Dorothy' --replace="source '$DOROTHY/init.sh' # Dorothy"

			config-helper --file="$HOME/.zshenv" -- \
				--find='ZDOTDIR=.+' --replace="ZDOTDIR='$ZDOTDIR'"

			echo-style --g3='Configuring Zsh'
		else
			mkdir -p "$ZDOTDIR"
			config-helper --file="$ZDOTDIR/.zshrc" -- \
				--find='.+? # Dorothy' --replace=''
			config-helper --file="$ZDOTDIR/.zprofile" -- \
				--find='.+? # Dorothy' --replace=''
			config-helper --file="$HOME/.zshenv" -- \
				--find='ZDOTDIR=.+' --replace="ZDOTDIR='$ZDOTDIR'"
		fi

		echo-style --g2='Dorothy Shell Configuration'
	}

	# =====================================
	# Actions: Install, Update, Trial

	function act_install {
		# process arguments
		local item option_clean='no' option_skip_install='no' option_user=''
		while test "$#" -ne 0; do
			item="$1"
			shift
			case "$item" in
			'--clean' | '--clean=yes') option_clean='yes' ;;
			'--no-clean' | '--clean=no') option_clean='no' ;;
			'--skip-install') option_skip_install='yes' ;;
			'--user='*) option_user="${item#*=}" ;;
			'--'*) help "An unrecognised flag was provided: $item" ;;
			*) help "An unrecognised argument was provided: $item" ;;
			esac
		done

		# pre-requisites
		if test "$option_skip_install" = 'no'; then
			ensure_dorothy_configured
		fi
		assert_dorothy_configured

		# action
		echo-style --h1='Install Dorothy'
		if test "$option_skip_install" = 'no'; then
			ensure_minimal_dependencies
			ensure_machine_configured
			ensure_user_configured "$option_user"
		fi
		ensure_shell_configured --clean="$option_clean"

		# log success
		echo-style --g1='Install Dorothy'
		echo-style --success='Dorothy is now setup.' ' ' --notice='Restart your terminal.'
	}

	function act_uninstall {
		# pre-requisites
		ensure_dorothy_configured
		assert_dorothy_configured

		# action
		echo-style --h1='Uninstall Dorothy'
		ensure_minimal_dependencies
		ensure_shell_configured --uninstall

		# log success and instructions for removal
		echo-style --g1='Uninstall Dorothy'
		echo-style --success='Dorothy is now uninstalled.' ' ' --notice='Restart your terminal.'
		local paths=()
		if test -d "$DOROTHY"; then
			paths+=("$DOROTHY")
		fi
		if test -d "$DOROTHY/user"; then
			paths+=("$(__fs_realpath -- "$DOROTHY/user")")
		fi
		if test "${#paths[@]}" -ne 0; then
			__print_line 'Once you have restarted your terminal, you can delete Dorothy by removing the following paths:'
			__print_lines "${paths[@]}"
		fi
	}

	function act_update {
		# pre-requisites
		assert_dorothy_configured

		# action
		echo-style --h1='Update Dorothy'
		ensure_minimal_dependencies
		ensure_dorothy_configured
		ensure_user_configured
		echo-style --h2='Correct Dorothy Permissions'
		ensure_permissions_configured # needed as new commands wouldn't be executable otherwise
		echo-style --g2='Correct Dorothy Permissions'
		echo-style --g1='Update Dorothy'
	}

	# don't use [sh], as [sh] is [dash] on ubuntu, and [dash] doesn't support the [--...] args
	function act_repl {
		# process arguments
		local item shell='' theme=''
		while test "$#" -ne 0; do
			item="$1"
			shift
			case "$item" in
			'--shell='*) shell="${item#*=}" ;;
			'--theme='*) theme="${item#*=}" ;;
			'--'*) help "An unrecognised flag was provided: $item" ;;
			*) help "An unrecognised argument was provided: $item" ;;
			esac
		done

		# pre-requisites
		ensure_dorothy_configured
		assert_dorothy_configured

		# action
		ensure_minimal_dependencies

		# ask
		if test -z "$shell"; then
			shell="$(
				choose --linger --required \
					--question='Which shell to use?' \
					-- bash fish nu
			)"
		fi

		# act, installing the shell if it is missing
		if test "$shell" = 'bash'; then
			setup-util-bash --quiet
			# [bash --rcfile] works but not within a [--rcfile]
			# [--login] ignores [--rcfile]
			# this is not a true login shell, as [$0] is not [-bash], as such loading [init.sh] is incompatible
			# without [env -i] which would wipe [USER/HOME/DOROTHY], then this shell will inherit exports from the current environment
			"$shell" --rcfile <(
				cat <<-EOF
					#!/usr/bin/env bash
					DOROTHY_FORCE_LOAD=yes
					DOROTHY_THEME_OVERRIDE='$theme'
					. '$DOROTHY/init.sh'
					echo-style 'Your are now using the ' --invert='$ACTIVE_POSIX_SHELL' ' shell with Dorothy loaded from ' --code='$DOROTHY' \$'\n' 'Use the ' --code='exit' ' command to return to your parent shell.' \$'\n' 'Use ' --code='ls $DOROTHY/commands' ' to see available commands.'
				EOF
			)
			return
		elif test "$shell" = 'nu'; then
			setup-util-nu --quiet
			"$shell" --interactive --login --no-config-file --execute "$(
				cat <<-EOF
					#!/usr/bin/env nu
					\$env.DOROTHY_THEME_OVERRIDE = '$theme'
					source '$DOROTHY/init.nu'
					echo-style 'Your are now using the ' --invert='nu' ' shell with Dorothy loaded from ' --code='$DOROTHY' "\n" 'Use the ' --code='exit' ' command to return to your parent shell.' "\n" 'Use ' --code='ls $DOROTHY/commands' ' to see available commands.'
				EOF
			)"
			return
		elif test "$shell" = 'fish'; then
			setup-util-fish --quiet
			"$shell" --interactive --login --no-config --init-command="$(
				cat <<-EOF
					#!/usr/bin/env fish
					set DOROTHY_THEME_OVERRIDE '$theme'
					source '$DOROTHY/init.fish'
					echo-style 'Your are now using the ' --invert='fish' ' shell with Dorothy loaded from ' --code='$DOROTHY' \n 'Use the ' --code='exit' ' command to return to your parent shell.' \n 'Use ' --code='ls $DOROTHY/commands' ' to see available commands.'
				EOF
			)"
			return
		else
			echo-error 'Cannot use ' --invert="$shell" ' as that shell does not support REPLs with custom configuration.'
			return 93 # EPROTONOSUPPORT 93 Protocol not supported
		fi
	}

	function act_run {
		# process arguments
		local item args=()
		while test "$#" -ne 0; do
			item="$1"
			shift
			case "$item" in
			'--')
				args+=("$@")
				shift $#
				break
				;;
			'--'*) help "An unrecognised flag was provided: $item" ;;
			*) help "An unrecognised argument was provided: $item" ;;
			esac
		done

		# pre-requisites
		{
			ensure_dorothy_configured
			assert_dorothy_configured
			ensure_minimal_dependencies
		} >/dev/stderr # don't conflate stdout, don't use /dev/tty as tty doesn't exist on CI

		# now that our environment is setup, run the command
		command "${args[@]}" # eval builtins and commands, but not functions
		return
	}

	# =====================================
	# Actions: ...

	function act_permissions {
		# pre-requisites
		assert_dorothy_configured

		# action
		echo-style --h1='Correct Dorothy Permissions'
		ensure_minimal_dependencies
		ensure_permissions_configured
		echo-style --g1='Correct Dorothy Permissions'
	}

	function act_edit {
		# pre-requisites
		assert_dorothy_and_user_cloned

		# action
		echo-style --h1='Edit Dorothy'
		# ensure_minimal_dependencies <-- if they are editing, then we assume they are already setup
		ensure_permissions_configured
		if test "$(edit --dry --only-editor)" == 'code'; then
			edit -- "$DOROTHY/.vscode/workspace.code-workspace"
		else
			edit -- "$DOROTHY"
		fi
		echo-style --g1='Edit Dorothy'
	}

	function act_review {
		# pre-requisites
		assert_dorothy_and_user_cloned

		# action
		echo-style --h1='Review Dorothy'
		ensure_minimal_dependencies
		ensure_permissions_configured
		git-helper review "$DOROTHY/user" || :
		git-helper review "$DOROTHY" || :
		echo-style --g1='Review Dorothy'
	}

	function act_theme {
		# pre-requisites
		assert_dorothy_and_user_cloned

		# action
		echo-style --h1='Select Dorothy Theme'
		ensure_minimal_dependencies

		# features
		local themes theme files
		source "$DOROTHY/sources/config.sh"
		__require_array 'mapfile'

		# prepare
		mapfile -t files < <(__print_lines "$DOROTHY/themes/"*.* "$DOROTHY/user/themes/"*.* | echo-filenames --stdin | uniq)
		themes=(
			system
			"${files[@]}"
		)

		# ask
		theme="$(
			choose --linger --required \
				--question='Which theme to use?' \
				-- "${themes[@]}"
		)"

		# apply
		source "$DOROTHY/sources/config.sh"
		dorothy-config 'interactive.sh' -- \
			--find='export DOROTHY_THEME=(.*)' --replace="export DOROTHY_THEME=$(echo-quote -- "$theme")"
		if test -f "$DOROTHY/user/config/interactive.nu"; then
			# dorothy-config 'interactive.nu' -- --string-find="\$env.DOROTHY_THEME" --string-replace="\$env.DOROTHY_THEME = $(echo-quote -- "$theme")"
			# ^ don't use that, as theming will always be in the config not config.local
			# ^ at some point, [dorothy-config] should use [config-edit]
			config-edit --file="$DOROTHY/user/config/interactive.nu" --needle="\$env.DOROTHY_THEME" --line="\$env.DOROTHY_THEME = $(echo-quote -- "$theme")" --add
		fi
		if test -f "$DOROTHY/user/config/interactive.xsh"; then
			config-edit --file="$DOROTHY/user/config/interactive.xsh" --needle="\$DOROTHY_THEME" --line="\$DOROTHY_THEME = $(echo-quote -- "$theme")" --add
		fi
		if test -f "$DOROTHY/user/config/interactive.elv"; then
			config-edit --file="$DOROTHY/user/config/interactive.elv" --needle="DOROTHY_THEME" --line="set-env DOROTHY_THEME $(echo-quote -- "$theme")" --add
		fi

		# log
		echo-style --success='Configuration change applied, ' --notice='restart your terminal for the change to take effect.'
		echo-style --g1='Select Dorothy Theme'
	}

	function act_dev {
		# pre-requisites
		assert_dorothy_configured

		# action
		echo-style --h1='Dorothy Development'
		if is-ci; then
			ensure_development_dependencies --no-quiet
		else
			# local dev, upgrade and add git hook
			ensure_development_dependencies --no-quiet --upgrade
			printf 'trunk check --ci --no-progress --trigger=git-push\n' >"$DOROTHY/.git/hooks/pre-push"
		fi

		# versions
		eval-helper --no-quiet -- bash --version || :
		eval-helper --no-quiet -- prettier --version || :
		eval-helper --no-quiet -- rg --version || :
		eval-helper --no-quiet -- shellcheck --version || :
		eval-helper --no-quiet -- shfmt --version || :
		eval-helper --no-quiet -- trunk --version || :

		# log
		echo-style --g1='Dorothy Development'
	}

	function act_format {
		# pre-requisites
		assert_dorothy_configured

		# action
		echo-style --h1='Dorothy Format'
		ensure_development_dependencies

		# adjust for ci
		local args=()
		if test -n "${CI-}"; then
			args+=('--no-progress') # don't use [--ci] as it doesn't apply fixes, and our CI suite expects fixes
		fi

		# on dorothy
		echo-style --h3="$DOROTHY"
		(
			cd "$DOROTHY"
			# format
			trunk fmt --all "${args[@]}"
		)
		echo-style --g3="$DOROTHY"

		# on user configuration
		if test -d "$DOROTHY/user/.trunk"; then
			echo-style --h3="$DOROTHY/user"
			(
				cd "$DOROTHY/user"
				# format
				trunk fmt --all "${args[@]}"
			)
			echo-style --g3="$DOROTHY/user"
		fi

		echo-style --g1='Dorothy Format'
	}

	function act_check {
		# pre-requisites
		assert_dorothy_configured

		# action
		echo-style --h1='Dorothy Checks'
		ensure_development_dependencies

		# adjust for ci
		local args=()
		if test -n "${CI-}"; then
			args+=('--ci' '--no-progress')
		fi

		# on dorothy
		echo-style --h3="$DOROTHY"
		(
			cd "$DOROTHY"
			# check
			trunk check --all "${args[@]}"
		)
		echo-style --g3="$DOROTHY"

		# on user configuration
		if test -d "$DOROTHY/user/.trunk"; then
			echo-style --h3="$DOROTHY/user"
			(
				cd "$DOROTHY/user"
				# check
				trunk check --all "${args[@]}"
			)
			echo-style --g3="$DOROTHY/user"
		fi

		echo-style --g1='Dorothy Checks'
	}

	function act_lint {
		# pre-requisites
		assert_dorothy_configured

		# action
		echo-style --h1='Dorothy Lint'
		ensure_development_dependencies

		# adjust for ci
		local args=()
		if test -n "${CI-}"; then
			args+=('--ci' '--no-progress')
		fi

		# upgrade trunk?
		local upgrade_linting='no'
		if confirm --negative --ppid=$$ -- 'Upgrade lint tooling?'; then
			upgrade_linting='yes'
		fi

		# on dorothy
		echo-style --h3="$DOROTHY"
		(
			cd "$DOROTHY"
			# upgrade
			if test "$upgrade_linting" = 'yes'; then
				if __command_exists npx npm; then
					npx npm-check-updates -u
					npm install
				fi
				trunk upgrade
			fi
			# format and check
			trunk fmt --all "${args[@]}"
			trunk check --all "${args[@]}"
			# update meta, only do this for balupton, as we can't guarantee up to date Node.js, as this requires Node.js 20
			# https://github.com/bevry/dorothy/actions/runs/7636822585/job/20804540714#step:13:14
			if __command_exists npm && test "$USER" = 'balupton'; then
				# if balupton, update meta with auth
				# github-auth -- npm run our:meta # @todo currently broken
				# update the readme formatting to be consistent again
				npx prettier --write README.md
			fi
		)
		echo-style --g3="$DOROTHY"

		# on user configuration
		if test -d "$DOROTHY/user/.trunk"; then
			echo-style --h3="$DOROTHY/user"
			(
				cd "$DOROTHY/user"
				# upgrade
				if test "$upgrade_linting" = 'yes'; then
					if __command_exists npx npm; then
						npx npm-check-updates -u
						npm install
					fi
					trunk upgrade
				fi
				# format and check
				trunk fmt --all "${args[@]}"
				trunk check --all "${args[@]}"
			)
			echo-style --g3="$DOROTHY/user"
		fi

		echo-style --g1='Dorothy Lint'
	}

	function act_test {
		# pre-requisites
		assert_dorothy_configured
		# ^ no need for user config for tests

		# action
		echo-style --h1='Dorothy Tests'
		source "$DOROTHY/sources/ripgrep.bash"

		# able to test on bash v3?
		local bash has_macos_bashv3='no'
		bash="$(type -P bash)"
		if __is_mac && test "$bash" != '/bin/bash' && [[ "$(/bin/bash --version || :)" == 'GNU bash, version 3.'* ]]; then
			has_macos_bashv3=yes
		fi

		# prepre scan paths
		local commands filepath filename failures=() scan_paths=(
			"$DOROTHY/commands/"
			"$DOROTHY/commands.beta/"
		)
		if test -d "$DOROTHY/user"; then
			if test -d "$DOROTHY/user/commands"; then
				scan_paths+=("$DOROTHY/user/commands/")
			fi
			if test -d "$DOROTHY/user/commands.local"; then
				scan_paths+=("$DOROTHY/user/commands.local/")
			fi
		fi

		# check for __ convention
		# ((if|[&][&]|[|][|]|[!])\s)[a-z]+_[a-z_]+
		# \s[a-z]+_[a-z_]+( ([&][&]|[|][|]))

		# check for unsafe function calls
		# todo, improve upon this by checking if the function also calls function, as any calling of a function must also be safe
		local unsafe_regexp='((if|[&][&]|[|][|]|[!])\s)[a-z]+_[a-z_]+|\s[a-z]+_[a-z_]+( ([&][&]|[|][|]))'
		mapfile -t commands < <(rg --files-with-matches --regexp="$unsafe_regexp" "${scan_paths[@]}" | sort)
		if test "${#commands[@]}" -ne 0; then
			echo-style --error='The following commands have unsafe function calls:'
			for filepath in "${commands[@]}"; do
				echo-style --element="$filepath"
				rg --regexp="$unsafe_regexp" "$filepath"
				echo-style --/element="$filepath"
			done
			echo-style --e1='Dorothy Tests'
			return 1
		fi

		# run tests on commands that have them
		mapfile -t commands < <(rg --files-with-matches --fixed-strings --regexp='--test' "${scan_paths[@]}" | sort)
		for filepath in "${commands[@]}"; do
			filename="$(basename "$filepath")"

			# skip tests on these
			if test "$filename" = 'dorothy' -o "$filename" = 'bash.bash'; then
				continue
			fi

			# run only specific tests
			if test "$#" -ne 0; then
				if ! is-needle --needle="$filename" -- "$@"; then
					continue
				fi
			fi

			# run the bash test
			eval-helper --no-quiet --wrap -- "$bash" "$filepath" --test || {
				failures+=("$bash $filepath --test")
			}

			# skip bash v3 test on these
			if [[ $filename =~ ^(get-installer|dorothy-config)$ ]]; then
				continue
			fi

			# run the bash v3 test
			if test "$has_macos_bashv3" = 'yes'; then
				env EVAL_TESTER_BASH=/bin/bash PATH="/bin:$PATH" eval-helper --no-quiet --wrap -- /bin/bash "$filepath" --test || {
					failures+=("/bin/bash '$filepath' --test")
				}
			fi
		done

		# check for failures
		if test "${#failures[@]}" -ne 0; then
			echo-style --error='The following tests were failures:'
			__print_lines "${failures[@]}"
			echo-style --e1='Dorothy Tests'
			return 1
		fi

		# log
		echo-style --g1='Dorothy Tests'
	}

	function act_todos {
		# pre-requisites
		assert_dorothy_configured
		# ^ no need for user config for todos

		# action
		echo-style --h1='Dorothy Todos'
		source "$DOROTHY/sources/ripgrep.bash"

		# verbose about command conventions and support
		local matches file_good file_bad file_status
		commands=("$DOROTHY/commands/"*)
		for filepath in "${commands[@]}"; do
			filename="$(basename "$filepath")"
			file_good=()
			file_bad=()
			file_status=0

			# skip tests on these
			if test "$filename" = 'dorothy'; then
				continue
			fi

			# does the file have tests
			if rg --quiet --fixed-strings --regexp='--test' "$filepath"; then
				file_good+=(
					' '
					--success='has tests.'
				)
			fi

			# does the file yuse a subshell
			if ! rg --quiet --regexp="${filename//-/_}[_]?[(][)] [(]" "$filepath"; then
				file_bad+=(
					' '
					--cyan='no subshell wrapper.'
				)
			fi

			# does the file have help
			if ! rg --quiet --fixed-strings --regexp='function help {' "$filepath"; then
				file_bad+=(
					' '
					--blue='no help.'
				)
			fi

			# is the file used by other commands?
			matches="$(rg --files-with-matches --fixed-strings --regexp="$filename" "${scan_paths[@]}" || :)"
			if test "$matches" = "$filepath" -o -z "$matches"; then
				file_bad+=(
					' '
					--magenta='is not used anywhere besides itself.'
				)
			fi

			# does the file have todos?
			if rg --quiet --fixed-strings --regexp='@todo' "$filepath"; then
				file_bad+=(
					' '
					--yellow='has todos.'
				)
			fi

			# log
			if test "${#file_bad[@]}" -ne 0; then
				file_status=1
			fi
			echo-style --element/="$filename" --status="$file_status" "${file_good[@]}" "${file_bad[@]}"
		done

		# log
		echo-style --g1='Dorothy Todos'
	}

	# =====================================
	# Act

	# ensure the prerequisites are installed in case the user skipped them
	ensure_prereq_dependencies >/dev/stderr # don't conflate stdout, don't use /dev/tty as tty doesn't exist on CI

	# all helpers are defined, and argument overrides are handled
	# so prepare the local environment context with what is necessary for dorothy
	# such that the following [choose] will be found
	prepare_dorothy >/dev/stderr # don't conflate stdout, don't use /dev/tty as tty doesn't exist on CI

	if test "$(type -t "act_$action")" = 'function'; then
		if test "${#option_args[@]}" -eq 0; then # bash v3 compat
			"act_$action"
			return
		else
			"act_$action" "${option_args[@]}"
			return
		fi
	else
		echo-style --error="Action [$action] not yet implemented." >/dev/stderr
		return 78 # ENOSYS 78 Function not implemented
	fi
)

# fire if invoked standalone
if test "$0" = "${BASH_SOURCE[0]}"; then
	dorothy_ "$@"
fi
