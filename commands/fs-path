#!/usr/bin/env bash

function fs_path_test() (
	source "$DOROTHY/sources/bash.bash"

	# simple case with no parent

	eval-tester --stdout='a.b.c' -- \
		fs-path -- 'a.b.c'

	eval-tester --stdout='a.b' -- \
		fs-path --no-extension -- 'a.b.c'

	eval-tester --stdout='a' -- \
		fs-path --no-extensions -- 'a.b.c'

	eval-tester --stdout='c' -- \
		fs-path --extension -- 'a.b.c'

	eval-tester --stdout='b.c' -- \
		fs-path --extensions -- 'a.b.c'

	# simple case with parent

	eval-tester --stdout='.dorothy/a.b.c' -- \
		fs-path -- '.dorothy/a.b.c'

	eval-tester --stdout='.dorothy/a.b' -- \
		fs-path --no-extension -- '.dorothy/a.b.c'

	eval-tester --stdout='.dorothy/a' -- \
		fs-path --no-extensions -- '.dorothy/a.b.c'

	eval-tester --stdout='c' -- \
		fs-path --extension -- '.dorothy/a.b.c'

	eval-tester --stdout='b.c' -- \
		fs-path --extensions -- '.dorothy/a.b.c'

	eval-tester --stdout='a.b.c' -- \
		fs-path --no-parents -- '.dorothy/a.b.c'

	eval-tester --stdout='a.b' -- \
		fs-path --no-parents --no-extension -- '.dorothy/a.b.c'

	eval-tester --stdout='a' -- \
		fs-path --no-parents --no-extensions -- '.dorothy/a.b.c'

	eval-tester --stdout='c' -- \
		fs-path --no-parents --extension -- '.dorothy/a.b.c'

	eval-tester --stdout='b.c' -- \
		fs-path --no-parents --extensions -- '.dorothy/a.b.c'

	# return parents

	# we don't resolve
	eval-tester --stdout=. -- \
		fs-path --parents -- 'd.e.f'

	eval-tester --stdout='a.b.c' -- \
		fs-path --parents -- 'a.b.c/d.e.f'

	eval-tester --status=22 --ignore-stderr -- \
		fs-path --parents --extension -- 'a.b.c/d.e.f'

	eval-tester --status=22 --ignore-stderr -- \
		fs-path --parents --extensions -- 'a.b.c/d.e.f'

	eval-tester --stdout='c' -- \
		fs-path --parent --extension -- 'a.b.c/d.e.f'

	eval-tester --stdout='b.c' -- \
		fs-path --parent --extensions -- 'a.b.c/d.e.f'

	# extension edge cases

	eval-tester --stdout='.dorothy' -- \
		fs-path -- '.dorothy'

	eval-tester --stdout='' -- \
		fs-path --no-extension -- '.dorothy'

	eval-tester --stdout='' -- \
		fs-path --no-extensions -- '.dorothy'

	eval-tester --stdout='dorothy' -- \
		fs-path --extension -- '.dorothy'

	eval-tester --stdout='dorothy' -- \
		fs-path --extensions -- '.dorothy'

	eval-tester --stdout='.dorothy' -- \
		fs-path --parent -- '.dorothy/a.b.c'

	eval-tester --stdout='.dorothy' -- \
		fs-path --parents -- '.dorothy/a.b.c'

	eval-tester --status=22 --ignore-stderr -- \
		fs-path --parents --no-extension -- '.dorothy/a.b.c'

	eval-tester --status=22 --ignore-stderr -- \
		fs-path --parents --no-extensions -- '.dorothy/a.b.c'

	eval-tester --status=22 --ignore-stderr -- \
		fs-path --parents --extension -- '.dorothy/a.b.c'

	eval-tester --status=22 --ignore-stderr -- \
		fs-path --parents --extensions -- '.dorothy/a.b.c'

	eval-tester --stdout='dorothy' -- \
		fs-path --parent --extension -- '.dorothy/a.b.c'

	eval-tester --stdout='dorothy' -- \
		fs-path --parent --extensions -- '.dorothy/a.b.c'

	eval-tester --stdout='..dorothy.a.b.c' -- \
		fs-path -- '..dorothy.a.b.c'

	eval-tester --stdout='c' -- \
		fs-path --extension -- '..dorothy.a.b.c'
	eval-tester --stdout='..dorothy.a.b' -- \
		fs-path --no-extension -- '..dorothy.a.b.c'

	# this edge case aligns with the fact that joining --no-extension and --extensions by . should result in the original
	eval-tester --stdout='dorothy.a.b.c' -- \
		fs-path --extensions -- '..dorothy.a.b.c'
	eval-tester --stdout='.' -- \
		fs-path --no-extensions -- '..dorothy.a.b.c'

	eval-tester --stdout='..dorothy.a.b.' -- \
		fs-path -- '..dorothy.a.b.'

	eval-tester --stdout='' -- \
		fs-path --extension -- '..dorothy.a.b.'
	eval-tester --stdout='..dorothy.a.b' -- \
		fs-path --no-extension -- '..dorothy.a.b.'

	# this edge case aligns with the fact that joining --no-extension and --extensions by . should result in the original
	eval-tester --stdout='dorothy.a.b.' -- \
		fs-path --extensions -- '..dorothy.a.b.'
	eval-tester --stdout='.' -- \
		fs-path --no-extensions -- '..dorothy.a.b.'

	# directory slash edge cases

	eval-tester --stdout='a/b' -- \
		fs-path -- 'a/b/'

	eval-tester --stdout='b' -- \
		fs-path --no-parents -- 'a/b/'

	eval-tester --stdout='a' -- \
		fs-path --parents -- 'a/b/'

	eval-tester --stdout='a/b' -- \
		fs-path -- 'a/b//'

	eval-tester --stdout='b' -- \
		fs-path --no-parents -- 'a/b//'

	eval-tester --stdout='a' -- \
		fs-path --parents -- 'a/b//'

	# root edge cases

	eval-tester --stdout='/a' -- \
		fs-path -- '/a/'

	eval-tester --stdout='/a' -- \
		fs-path -- '/a'

	eval-tester --stdout='/' -- \
		fs-path -- '/'

	eval-tester --stdout='/a' -- \
		fs-path -- '/a//'

	eval-tester --stdout='/a' -- \
		fs-path -- '/a'

	eval-tester --stdout='/' -- \
		fs-path -- '//..///..////./////'
	eval-tester --stdout='/' -- \
		fs-path --no-parents -- '//..///..////./////'
	eval-tester --stdout='/' -- \
		fs-path --parents -- '//..///..////./////'

	eval-tester --stdout='/' -- \
		fs-path -- /
	eval-tester --stdout='/' -- \
		fs-path --no-parents -- /
	eval-tester --stdout='/' -- \
		fs-path --parents -- /

	# parent edge cases
	# parents and no-parents should join to form the correct location
	# hence why unspecified parent is just . as that it what it is

	# ./.
	eval-tester --stdout='.' -- \
		fs-path --no-parents -- '.'
	eval-tester --stdout='.' -- \
		fs-path --parents -- '.'

	# ./..
	eval-tester --stdout='..' -- \
		fs-path --no-parents -- '..'
	eval-tester --stdout='.' -- \
		fs-path --parents -- '..'

	# ./..
	eval-tester --stdout='..' -- \
		fs-path --no-parents -- '..////./////'
	eval-tester --stdout='.' -- \
		fs-path --parents -- '..////./////'

	# ./../..
	eval-tester --stdout='..' -- \
		fs-path --no-parents -- '..///..////./////'
	eval-tester --stdout='..' -- \
		fs-path --parents -- '..///..////./////'

	# ./.
	eval-tester --stdout='.' -- \
		fs-path --no-parents -- './//.////./////'
	eval-tester --stdout='.' -- \
		fs-path --parents -- './//.////./////'

	# we don't resolve

	eval-tester --stdout='a' -- \
		fs-path --no-parents -- '/a/'

	eval-tester --stdout='a' -- \
		fs-path --no-parents -- '/a//'

	eval-tester --stdout='a' -- \
		fs-path --no-parents -- '/a'

	eval-tester --stdout='/' -- \
		fs-path --no-parents -- '/'

	eval-tester --stdout='/' -- \
		fs-path --parents -- '/a/'

	eval-tester --stdout='/' -- \
		fs-path --parents -- '/a'

	eval-tester --stdout='/' -- \
		fs-path --parents -- '/'

	eval-tester --stdout='/' -- \
		fs-path --parents -- '/a//'

	eval-tester --stdout='/' -- \
		fs-path --parents -- '/a'

	# @todo add symlink edge cases

	return 0
)
function fs_path() (
	source "$DOROTHY/sources/is-fs.bash"

	# =====================================
	# Arguments

	function __help {
		local fodder
		fodder="$(__is_fs__options '13')" || return
		__print_help "$@" <<-EOF || return
			ABOUT:
			Get a specific path variation of a <path>.

			USAGE:
			fs-path [...options] [--] ...<path>

			OPTIONS:
			--resolve | --resolve=follow | --follow
			    Transform the symlinks into their target paths. Implies <absolute>.
			    If set to <follow>, then continue following resolutions until the target is no longer a symlink. As a comparison, \`realpath\` follows, \`readlink\` does not.
			--absolute | --relative
			    If the path was relative, then <absolute> will resolve it to an absolute path, and [--relative] will persist it as a relative path.
			--relative-from=<relative_from> | --relative-to=<relative_from>
			    If provided, make the result <path> relative from <relative_from>.
			--relative-base=<relative_base>
			    If provided, make the result <path> relative within <relative_base>.

			--validate
			    If enabled, then fail if any part of the path was not resolvable, that is missing, inaccessible, or broken.

			--no-extensions
			    Remove all extensions from the basename.
			--extensions
			    Only output the extensions of the basename.
			    If no extensions, an empty result will be returned.

			--no-extension
			    Remove the last extension from the basename.
			--extension
			    Only output the last extension of the basename.
			    If no last extension, an empty result will be returned.

			--no-parents | --no-parent
			    Only return the basename of the path, without a containing path.
			--parents
			    Only return the containing path and not the basename.
			    Incompatible with <extension> and <extensions>.
			--parent
			    Only return the basename of the parent path.

			$fodder
		EOF
		return 22 # EINVAL 22 Invalid argument
	}

	# process
	local item args=() option_absolute='' option_resolve='' option_follow='' option_validate='' option_relative_from='' option_relative_base='' option_extensions='' option_extension='' option_parents='' option_parent=''
	while [[ $# -ne 0 ]]; do
		item="$1"
		shift
		case "$item" in
		'--help' | '-h') __help || return ;;
		'--relative-to='* | '--relative-from='*) option_relative_from="${item#*=}" ;;
		'--relative-base='*) option_relative_base="${item#*=}" ;;
		'--no-relative'* | '--relative'*)
			# this must be after --relative-{to,base} otherwise it will capture them
			__flag --source={item} --target={option_absolute} --non-affirmative || return
			;;
		'--no-absolute'* | '--absolute'*) __flag --source={item} --target={option_absolute} --affirmative || return ;;
		'--no-resolve'* | '--resolve'*) __flag --source={item} --target={option_resolve} --affirmative || return ;;
		'--no-follow'* | '--follow'*) __flag --source={item} --target={option_follow} --affirmative || return ;;
		'--no-validate'* | '--validate'*) __flag --source={item} --target={option_validate} --affirmative || return ;;
		'--no-extensions'* | '--extensions'*) __flag --source={item} --target={option_extensions} --affirmative || return ;;
		'--no-extension'* | '--extension'*) __flag --source={item} --target={option_extension} --affirmative || return ;;
		'--no-parents'* | '--parents'*) __flag --source={item} --target={option_parents} --affirmative || return ;;
		'--no-parent'* | '--parent'*) __flag --source={item} --target={option_parent} --affirmative || return ;;
		'--dirname') option_parents='yes' ;;
		'--basename') option_parents='no' ;;
		# <elevate>
		'--elevated='*) option_elevated="${item#*=}" ;;
		'--no-elevate'* | '--elevate'*) __flag --source={item} --target={option_elevate} --affirmative || return ;;
		'--user='*) option_user="${item#*=}" ;;
		'--group='*) option_group="${item#*=}" ;;
		'--reason='*) option_reason="${item#*=}" ;;
		# </elevate>
		*) args+=("$item") ;;
		esac
	done
	__is_fs__args "${args[@]}" || return

	# check
	if [[ $option_parent == 'no' ]]; then
		option_parents='no'
	elif [[ $option_parent == 'yes' ]]; then
		option_parents='no'
	fi
	if [[ $option_follow == 'yes' ]]; then
		option_resolve='follow'
	fi
	if [[ $option_parents == 'yes' && (-n $option_extensions || -n $option_extension) ]]; then
		__help "Cannot use --parents with --[no-]extension/--[no-]extensions, as that doesn't make sense. Use --parent instead." || return
	fi
	if [[ -n $option_extensions && -n $option_extension ]]; then
		__help 'Cannot use --[no-]extension with --[no-]extensions, as they are mutually exclusive' || return
	fi
	if [[ -n $option_relative_from && -n $option_relative_base ]]; then
		# grealpath will discard both if both are provided
		__help 'Cannot use --relative-from with --relative-base, as they are mutually exclusive' || return
	fi

	# =====================================
	# Act

	local option_input path stem leaf prefix
	function __expand {
		local EXPAND__variable_name
		if [[ $# -ne 1 && $1 != --source+target={*} ]]; then
			__help 'Internal Error: ' --code='__expand' --bold=' requires ' --code='--source+target=<var>' || return
		fi
		__dereference --source="${1#*=}" --name={EXPAND__variable_name} || return
		__is_fs__invoke --elevate=13 --redirect-stdout="{$EXPAND__variable_name}" -- \
			fs-path.bash --resolve="$option_resolve" --validate="$option_validate" -- "${!EXPAND__variable_name}" || return
		__is_fs__error || return
		return "$fs_status"
	}
	for path in "${option_inputs[@]}"; do
		# trunk-ignore(shellcheck/SC2034)
		option_input="$path"

		# `dirname` and `basename` operate on the last forward-slash, back-slashes are not relevant as even in WSL which is our only supported Windows target, there forward-slashes are enforced/emulated.

		# remove all duplicates slashes, and self-references
		__replace --source+target={path} --fallback \
			--value-all='//' --with='/' \
			--suffix-all='/./' \
			--suffix-all='/.' || return

		# if not root
		if [[ $path != '/' ]]; then
			# remove all trailing slashes now that we know we aren't root
			__replace --source+target={path} --fallback \
				--suffix-all='/' || return

			# resolve the path
			if [[ $option_resolve =~ ^(yes|follow)$ || $option_validate == 'yes' ]]; then
				# we need it to be resolved, or validated
				__expand --source+target={path} || return
			elif [[ $path != /* && (-n $option_relative_from || -n $option_relative_base || $option_absolute == 'yes') ]]; then
				# we need to it to be absolute, in cases where it is not
				__expand --source+target={path} || return
			fi

			# compress .. and . where possible
			local parts=() i v
			__split --source={path} --target={parts} --delimiter='/' --no-zero-length || return
			if [[ $path == /* ]]; then
				parts=('/' "${parts[@]}")
			fi
			for ((i = 1; i < ${#parts[@]}; i++)); do
				case "${parts[i]}" in
				'' | '.')
					# remove the current part
					__evict --source+target={parts} --each --all --index="$i" || return
					i=$((i - 1))
					;;
				'..')
					if [[ $i -ge 1 ]]; then
						v="${parts[i - 1]}"
						if [[ $v == '/' ]]; then
							# prior part is root, so remove the current part
							__evict --source+target={parts} --each --all --index="$i" || return
							i=$((i - 1))
						elif [[ $v != '..' ]]; then
							# prior part is neither root nor an unresolvable parent
							# remove the prior part and the current part
							__evict --source+target={parts} --each --all --index="$((i - 1))" --index="$i" || return
							i=$((i - 2))
						fi
					fi
					;;
				esac
			done
			__join --source={parts} --delimiter=/ --target={path} || return
			# if it was an absolute path, of multiple segments, then the first segment would be `/` and the join operation will join the first segment of `/` with the second segment, resulting in `//<second-segment>`, so repair that to `/<second-segment>`
			__replace --source+target={path} --fallback --prefix='//' --with='/' || return
		fi

		# handle relative-to and relative-base
		if [[ -n $option_relative_from ]]; then
			# find the common ancestor
			local from_parts=() to_parts=() from_n from_slice to_slice relative_slice relative_path
			__expand --source+target={option_relative_from} || return
			# /0/1/2/a/b/c
			# /0/1/2/x/y/z
			# --relative-from=/0/1/2/a/b/c -- /0/1/2/x/y/z
			# should return ../../../x/y/z
			__split --source={option_relative_from} --target={from_parts} --delimiter='/' || return
			__split --source={path} --target={to_parts} --delimiter='/' || return
			from_n="${#from_parts[@]}"
			for ((from_index = from_n - 1; from_index >= 0; from_index--)); do
				__join --delimiter='/' --target={from_slice} -- "${from_parts[@]:0:from_index}" || return
				__join --delimiter='/' --target={to_slice} -- "${to_parts[@]:0:from_index}" || return
				# __print_lines "$from_index: $from_slice == $to_slice"
				if [[ $from_slice == "$to_slice" ]]; then
					__array --target={relative_slice} --size=$((from_n - from_index)) --fill='..' || return
					relative_slice+=("${to_parts[@]:from_index}")
					__join --source={relative_slice} --delimiter='/' --target={relative_path} || return
					break
				fi
			done
			path="$relative_path"
		elif [[ -n $option_relative_base ]]; then
			# make the path relative within the base
			__expand --source+target={option_relative_base} || return
			option_relative_base+='/' # add a trailing slash
			if [[ $path == $option_relative_base* ]]; then
				# the path is within the base, so we can return it relative from the base
				local -i size="${#option_relative_base}"
				path="${path:size}"
			fi
		fi

		# --parents -- .
		#   should return ..
		# --parents -- ..
		#   should return ..
		# --parents -- ../../..
		#   should return ../..
		# --parent -- .
		#   should return ..
		# --parent -- ..
		#   should return ..
		# --no-parents -- .
		#   should return .
		# --no-parents -- ..
		#   should return ..
		# --no-parents -- ../../..
		#   should return ..

		# get the stem/dirname/parents, falling back to the current directory if no slash was found
		if [[ $path == */* ]]; then
			# get the stem/dirname/parents, e.g. a/b/c => a/b
			__replace --source={path} --target={stem} --keep-before-last='/' || return
			if [[ -z $stem ]]; then
				# the only stem was root, i.e. `/`, `/leaf`
				stem='/'
			fi
		else
			# no slash, so we return the current directory
			stem=.
		fi

		# do we only want the stem/parents?
		if [[ $option_parents == 'yes' ]]; then
			__print_lines "$stem" || return
			continue
		elif [[ $option_parent == 'yes' ]]; then
			# separate the path and stem
			path="$stem"
			if [[ $stem != / ]]; then
				# get the stem/dirname/parents
				# `a/b/c` => `a/b`
				# `a` => `.`
				__replace --source+target={stem} --fallback='.' --keep-before-last='/' || return
			fi
		fi

		# get the leaf/filename/basename, falling back to itself if no slash was found, e.g. a/b/c => c
		if [[ $path == '/' ]]; then
			# root is a special case, make the leaf also /
			leaf='/'
		elif [[ $path == *'/'* ]]; then
			__replace --source={path} --target={leaf} --keep-after-last='/' || return
		else
			leaf="$path"
		fi

		# do we want to trim extension? with workaround when starting with a dot
		if [[ -n $option_extensions || -n $option_extension ]]; then
			if [[ $leaf == '.' || $leaf == '..' ]]; then
				__help 'Cannot use --extensions/--extension on a reference path (., ..). You must combine with either [--resolve] or [--absolute]' || :
				__dump {option_input} {path} {stem} {leaf} >&2 || :
				return 22 # EINVAL 22 Invalid argument
			fi
			# trim leading dots
			prefix=''
			while [[ ${leaf:0:1} == '.' ]]; do
				prefix+='.'
				leaf="${leaf:1}"
			done
			# extensions
			if [[ $option_extensions == 'no' ]]; then
				# trim all extensions
				# `a.b.c` => `a`
				# `.a.b.c` => ``
				# `..a.b.c` => `.`
				# `.a` => ``
				# `a` => `a`
				# `/` => `/`
				# `...` => `...`
				if [[ -n $prefix ]]; then
					# all the leaf is the extension, but perhaps part of it is also a filename
					leaf=''
					__slice --source+target={prefix} 0 -1 || return
				elif [[ -n $leaf ]]; then
					__replace --source+target={leaf} --fallback --keep-before-first='.' || return
				fi
			elif [[ $option_extension == 'no' ]]; then
				# trim last extension
				# `a.b.c` => `a.b`
				# `.a.b.c` => `.a.b`
				# `..a.b.c` => `..a.b`
				# `.a` => ``
				# `a` => `a`
				# `/` => `/`
				# `...` => `...`
				if [[ -n $prefix ]]; then
					# all the leaf is the extension, so trim everything if there isn't another extension
					if [[ $leaf == *.* ]]; then
						__replace --source+target={leaf} --keep-before-last='.' || return
					else
						prefix=''
						leaf=''
					fi
				elif [[ -n $leaf ]]; then
					__replace --source+target={leaf} --fallback --keep-before-last='.' || return
				fi
			elif [[ $option_extensions == 'yes' ]]; then
				# output all extensions
				# `a.b.c` => `b.c`
				# `.a.b.c` => `a.b.c`
				# `..a.b.c` => `a.b.c`
				# `.a` => `a`
				# `a` => ``
				# `/` => ``
				# `...` => ``
				if [[ -n $prefix ]]; then
					# all the leaf is the extension, leave it untouched
					prefix=''
				else
					# the leaf is not an extension, so just keep that which is the extension
					__replace --source+target={leaf} --fallback='' --keep-after-first='.' || return
				fi
			elif [[ $option_extension == 'yes' ]]; then
				# output last extension
				# `a.b.c` => `c`
				# `.a.b.c` => `c`
				# `..a.b.c` => `c`
				# `.a` => `a`
				# `a` => ``
				# `/` => ``
				# `...` => ``
				if [[ -n $prefix ]]; then
					# all the leaf is the extension, keep the last one
					__replace --source+target={leaf} --fallback --keep-after-last='.' || return
					prefix=''
				else
					# all the leaf is not an extension, so keep the last extension if it is present
					__replace --source+target={leaf} --fallback='' --keep-after-last='.' || return
				fi
			fi
			# re-add the trimmed leading dots if they were kept
			leaf="$prefix$leaf"
		fi

		# do we want to exclude parents? or are there no parents?
		if [[ $option_parents == 'no' || $option_extension == 'yes' || $option_extensions == 'yes' || $stem == '.' ]]; then
			stem=''
		fi

		# we want stem/dirname/parents and leaf/filename/basename
		if [[ $path == / ]]; then
			# was root, output only our modifications to the leaf
			__print_lines "$leaf" || return
		elif [[ -z $stem || $stem == / ]]; then
			# if stem is root, then it already has the slash
			__print_lines "$stem$leaf" || return
		else
			__print_lines "$stem/$leaf" || return
		fi
		continue
	done
)

# fire if invoked standalone
if [[ $0 == "${BASH_SOURCE[0]}" ]]; then
	if [[ $* == '--test' ]]; then
		fs_path_test
	else
		fs_path "$@"
	fi
fi
