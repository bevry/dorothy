#!/usr/bin/env bash

function fs_path_test() (
	source "$DOROTHY/sources/bash.bash"
	echo-style --h1="TEST: $0"

	# simple case with no parent

	eval-tester --stdout='a.b.c' -- \
		fs-path -- 'a.b.c'

	eval-tester --stdout='a.b' -- \
		fs-path --no-extension -- 'a.b.c'

	eval-tester --stdout='a' -- \
		fs-path --no-extensions -- 'a.b.c'

	eval-tester --stdout='c' -- \
		fs-path --extension -- 'a.b.c'

	eval-tester --stdout='b.c' -- \
		fs-path --extensions -- 'a.b.c'

	# simple case with parent

	eval-tester --stdout='.dorothy/a.b.c' -- \
		fs-path -- '.dorothy/a.b.c'

	eval-tester --stdout='.dorothy/a.b' -- \
		fs-path --no-extension -- '.dorothy/a.b.c'

	eval-tester --stdout='.dorothy/a' -- \
		fs-path --no-extensions -- '.dorothy/a.b.c'

	eval-tester --stdout='c' -- \
		fs-path --extension -- '.dorothy/a.b.c'

	eval-tester --stdout='b.c' -- \
		fs-path --extensions -- '.dorothy/a.b.c'

	eval-tester --stdout='a.b.c' -- \
		fs-path --no-parents -- '.dorothy/a.b.c'

	eval-tester --stdout='a.b' -- \
		fs-path --no-parents --no-extension -- '.dorothy/a.b.c'

	eval-tester --stdout='a' -- \
		fs-path --no-parents --no-extensions -- '.dorothy/a.b.c'

	eval-tester --stdout='c' -- \
		fs-path --no-parents --extension -- '.dorothy/a.b.c'

	eval-tester --stdout='b.c' -- \
		fs-path --no-parents --extensions -- '.dorothy/a.b.c'

	# return parents

	# we don't resolve
	eval-tester --stdout='.' -- \
		fs-path --parents -- 'd.e.f'

	eval-tester --stdout='a.b.c' -- \
		fs-path --parents -- 'a.b.c/d.e.f'

	eval-tester --status=22 --ignore-stderr -- \
		fs-path --parents --extension -- 'a.b.c/d.e.f'

	eval-tester --status=22 --ignore-stderr -- \
		fs-path --parents --extensions -- 'a.b.c/d.e.f'

	eval-tester --stdout='c' -- \
		fs-path --parent --extension -- 'a.b.c/d.e.f'

	eval-tester --stdout='b.c' -- \
		fs-path --parent --extensions -- 'a.b.c/d.e.f'

	# extension edge cases

	eval-tester --stdout='.dorothy' -- \
		fs-path -- '.dorothy'

	eval-tester --stdout='.dorothy' -- \
		fs-path --no-extension -- '.dorothy'

	eval-tester --stdout='.dorothy' -- \
		fs-path --no-extensions -- '.dorothy'

	eval-tester --stdout='' -- \
		fs-path --extension -- '.dorothy'

	eval-tester --stdout='' -- \
		fs-path --extensions -- '.dorothy'

	eval-tester --stdout='.dorothy' -- \
		fs-path --parents -- '.dorothy/a.b.c'

	eval-tester --stdout='.dorothy' -- \
		fs-path --parents --no-extension -- '.dorothy/a.b.c'

	eval-tester --stdout='.dorothy' -- \
		fs-path --parents --no-extensions -- '.dorothy/a.b.c'

	eval-tester --status=22 --ignore-stderr -- \
		fs-path --parents --extension -- '.dorothy/a.b.c'

	eval-tester --status=22 --ignore-stderr -- \
		fs-path --parents --extensions -- '.dorothy/a.b.c'

	eval-tester --stdout='' -- \
		fs-path --parent --extension -- '.dorothy/a.b.c'

	eval-tester --stdout='' -- \
		fs-path --parent --extensions -- '.dorothy/a.b.c'

	eval-tester --stdout='..dorothy.a.b.c' -- \
		fs-path -- '..dorothy.a.b.c'

	eval-tester --stdout='..dorothy.a.b' -- \
		fs-path --no-extension -- '..dorothy.a.b.c'

	eval-tester --stdout='..dorothy' -- \
		fs-path --no-extensions -- '..dorothy.a.b.c'

	eval-tester --stdout='..dorothy.a.b.' -- \
		fs-path -- '..dorothy.a.b.'

	eval-tester --stdout='..dorothy.a.b' -- \
		fs-path --no-extension -- '..dorothy.a.b.'

	eval-tester --stdout='..dorothy' -- \
		fs-path --no-extensions -- '..dorothy.a.b.'

	# directory slash edge cases

	eval-tester --stdout='a/b' -- \
		fs-path -- 'a/b/'

	eval-tester --stdout='b' -- \
		fs-path --no-parents -- 'a/b/'

	eval-tester --stdout='a' -- \
		fs-path --parents -- 'a/b/'

	eval-tester --stdout='a/b' -- \
		fs-path -- 'a/b//'

	eval-tester --stdout='b' -- \
		fs-path --no-parents -- 'a/b//'

	eval-tester --stdout='a' -- \
		fs-path --parents -- 'a/b//'

	# root edge cases

	eval-tester --stdout='/a' -- \
		fs-path -- '/a/'

	eval-tester --stdout='/a' -- \
		fs-path -- '/a'

	eval-tester --stdout='/' -- \
		fs-path -- '/'

	eval-tester --stdout='/a' -- \
		fs-path -- '/a//'

	eval-tester --stdout='/a' -- \
		fs-path -- '/a'

	# we don't resolve
	eval-tester --stdout='/../../.' -- \
		fs-path -- '//..///..////./////'

	eval-tester --stdout='a' -- \
		fs-path --no-parents -- '/a/'

	eval-tester --stdout='a' -- \
		fs-path --no-parents -- '/a'

	eval-tester --stdout='/' -- \
		fs-path --no-parents -- '/'

	eval-tester --stdout='a' -- \
		fs-path --no-parents -- '/a//'

	eval-tester --stdout='a' -- \
		fs-path --no-parents -- '/a'

	# we don't resolve
	eval-tester --stdout='.' -- \
		fs-path --no-parents -- '//..///..////./////'

	eval-tester --stdout='/' -- \
		fs-path --parents -- '/a/'

	eval-tester --stdout='/' -- \
		fs-path --parents -- '/a'

	eval-tester --stdout='/' -- \
		fs-path --parents -- '/'

	eval-tester --stdout='/' -- \
		fs-path --parents -- '/a//'

	eval-tester --stdout='/' -- \
		fs-path --parents -- '/a'

	# we don't resolve
	eval-tester --stdout='/../..' -- \
		fs-path --parents -- '//..///..////./////'

	# @todo add symlink edge cases

	echo-style --g1="TEST: $0"
	return 0
)
function fs_path() (
	source "$DOROTHY/sources/bash.bash"

	# =====================================
	# Arguments

	function help {
		cat <<-EOF >&2
			ABOUT:
			Get a specific path variation of a <path>.

			USAGE:
			fs-path [...options] [--] ...<path>

			OPTIONS:
			--absolute
			    Resolve the path, but do not follow symlinks.
			--resolve
			    Resolve the path, and follow symlinks.
			    Enforces [--absolute].

			--no-extensions
			    Remove all extensions from the basename.
			--extensions
			    Only output the extensions of the basename.
			    If no extensions, an empty result will be returned.

			--no-extension
			    Remove the last extension from the basename.
			--extension
			    Only output the last extension of the basename.
			    If no last extension, an empty result will be returned.

			--no-parents | --no-parent
			    Only return the basename of the path, without a containing path.
			--parents
			    Only return the containing path and not the basename.
			    Incompatible with --extension/--extensions.
			--parent
			    Only return the basename of the parent path.
		EOF
		if [[ $# -ne 0 ]]; then
			echo-error "$@"
		fi
		return 22 # EINVAL 22 Invalid argument
	}

	# process
	local item option_paths=() option_absolute='' option_resolve='' option_extensions='' option_extension='' option_parents='' option_parent=''
	while [[ $# -ne 0 ]]; do
		item="$1"
		shift
		case "$item" in
		'--help' | '-h') help ;;
		'--no-absolute'* | '--absolute'*)
			option_absolute="$(get-flag-value --affirmative --fallback="$option_absolute" -- "$item")"
			;;
		'--no-resolve'* | '--resolve'*)
			option_resolve="$(get-flag-value --affirmative --fallback="$option_resolve" -- "$item")"
			;;
		'--no-extensions'* | '--extensions'*)
			option_extensions="$(get-flag-value --affirmative --fallback="$option_extensions" -- "$item")"
			;;
		'--no-extension'* | '--extension'*)
			option_extension="$(get-flag-value --affirmative --fallback="$option_extensions" -- "$item")"
			;;
		'--no-parents'* | '--parents'*)
			option_parents="$(get-flag-value --affirmative --fallback="$option_parents" -- "$item")"
			;;
		'--no-parent'* | '--parent'*)
			option_parent="$(get-flag-value --affirmative --fallback="$option_parent" -- "$item")"
			;;
		'--path='*) option_paths+=("${item#*=}") ;;
		'--')
			option_paths+=("$@")
			shift $#
			break
			;;
		'--'*) help "An unrecognised flag was provided: $item" ;;
		*) option_paths+=("$item") ;;
		esac
	done

	# check
	if [[ ${#option_paths[@]} -eq 0 ]]; then
		help 'No <path>s provided.'
	fi
	if [[ $option_parent == 'no' ]]; then
		option_parents='no'
	elif [[ $option_parent == 'yes' ]]; then
		option_parents='no'
	fi
	if [[ $option_parents == 'yes' && ($option_extensions == 'yes' || $option_extension == 'yes') ]]; then
		help "--parents cannot be used with --extension/--extensions, as that doesn't make sense"
	fi
	if [[ -n $option_extensions && -n $option_extension ]]; then
		help '--extension and --extensions are mutually exclusive'
	fi

	# =====================================
	# Act

	local path stem leaf prefix
	for path in "${option_paths[@]}"; do
		# `dirname` and `basename` operate on the last forward-slash, back-slashes are not relevant as even in WSL which is our only supported Windows target, then forward-slashes are enforced/emulated.

		# resolve the path
		if [[ $option_resolve == 'yes' ]]; then
			path="$(fs-absolute --resolve -- "$path")"
		elif [[ $option_absolute == 'yes' ]]; then
			path="$(fs-absolute -- "$path")"
		fi

		# trim trailing / or .
		while [[ ($path == *'/' && $path != '/') || ($path == *'/.' && $path != '.') ]]; do
			path="$(__get_substring "$path" 0 -1)"
		done
		# trim 2+ slashes, as they are ignored
		while [[ $path == *'//'* ]]; do
			path="${path//\/\//\/}"
		done

		# if root, then return root
		if [[ $path == '/' ]]; then
			__print_lines '/'
			continue
		fi

		# get the stem/dirname/parents, falling back to the current directory if no slash was found
		stem="$(__get_substring_before_last "$path" '/' '.')"
		# workaround if / was the first character, in which we have returned to root
		if [[ -z $stem ]]; then
			stem='/'
		fi

		# do we only want the stem/parents?
		if [[ $option_parents == 'yes' ]]; then
			__print_lines "$stem"
			continue
		elif [[ $option_parent == 'yes' ]]; then
			if [[ $stem == '/' ]]; then
				__print_lines '/'
				continue
			fi
			path="$stem"
			stem="$(__get_substring_before_last "$path" '/' '.')"
			if [[ -z $stem ]]; then
				stem='/'
			fi
		fi

		# get the leaf/filename/basename, falling back to itself if no slash was found
		leaf="$(__get_substring_after_last "$path" '/' "$path")"

		# do we want to trim extension? with workaround when starting with a dot
		if [[ -n $option_extensions || -n $option_extension ]]; then
			if [[ $leaf == '.' || $leaf == '..' ]]; then
				help 'Cannot use --extensions/--extension on a [.] [..] path, resolve it first with [fs-absolute] or [fs-realpath]'
			fi
			# trim leading dots
			prefix=''
			while [[ $leaf == .* ]]; do
				prefix="$prefix."
				leaf="$(__get_substring "$leaf" 1)"
			done
			if [[ -z $leaf ]]; then
				help "Cannot use --extensions/--extension on an invalid path: $path"
			fi
			# extensions
			if [[ $option_extensions == 'no' ]]; then
				# trim all extensions
				leaf="$(__get_substring_before_first "$leaf" '.' "$leaf")"
			elif [[ $option_extension == 'no' ]]; then
				# trim last extension
				leaf="$(__get_substring_before_last "$leaf" '.' "$leaf")"
			elif [[ $option_extensions == 'yes' ]]; then
				# trim leading dots
				while [[ $leaf == .* ]]; do
					leaf="$(__get_substring "$leaf" 1)"
				done
				# output all extensions and exit
				__get_substring_after_first "$leaf" '.' ''
				continue
			elif [[ $option_extension == 'yes' ]]; then
				# trim leading dots
				while [[ $leaf == .* ]]; do
					leaf="$(__get_substring "$leaf" 1)"
				done
				# output last extension and exit
				__get_substring_after_last "$leaf" '.' ''
				continue
			fi
			# re-add the trimmed leading dots
			leaf="$prefix$leaf"
		fi

		# do we want to exclude parents? or are there no parents?
		if [[ $option_parents == 'no' || $stem == '.' ]]; then
			__print_lines "$leaf"
			continue
		fi

		# we want stem/dirname/parents and leaf/filename/basename
		if [[ $stem == '/' ]]; then
			# if stem is root, then it already has the slash
			__print_lines "$stem$leaf"
		else
			__print_lines "$stem/$leaf"
		fi
		continue
	done
)

# fire if invoked standalone
if [[ $0 == "${BASH_SOURCE[0]}" ]]; then
	if [[ $* == '--test' ]]; then
		fs_path_test
	else
		fs_path "$@"
	fi
fi
