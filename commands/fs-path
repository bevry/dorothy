#!/usr/bin/env bash

function fs_path_test() (
	source "$DOROTHY/sources/bash.bash"

	# simple case with no parent

	eval-tester --stdout='a.b.c' -- \
		fs-path -- 'a.b.c'

	eval-tester --stdout='a.b' -- \
		fs-path --no-extension -- 'a.b.c'

	eval-tester --stdout='a' -- \
		fs-path --no-extensions -- 'a.b.c'

	eval-tester --stdout='c' -- \
		fs-path --extension -- 'a.b.c'

	eval-tester --stdout='b.c' -- \
		fs-path --extensions -- 'a.b.c'

	# simple case with parent

	eval-tester --stdout='.dorothy/a.b.c' -- \
		fs-path -- '.dorothy/a.b.c'

	eval-tester --stdout='.dorothy/a.b' -- \
		fs-path --no-extension -- '.dorothy/a.b.c'

	eval-tester --stdout='.dorothy/a' -- \
		fs-path --no-extensions -- '.dorothy/a.b.c'

	eval-tester --stdout='c' -- \
		fs-path --extension -- '.dorothy/a.b.c'

	eval-tester --stdout='b.c' -- \
		fs-path --extensions -- '.dorothy/a.b.c'

	eval-tester --stdout='a.b.c' -- \
		fs-path --no-parents -- '.dorothy/a.b.c'

	eval-tester --stdout='a.b' -- \
		fs-path --no-parents --no-extension -- '.dorothy/a.b.c'

	eval-tester --stdout='a' -- \
		fs-path --no-parents --no-extensions -- '.dorothy/a.b.c'

	eval-tester --stdout='c' -- \
		fs-path --no-parents --extension -- '.dorothy/a.b.c'

	eval-tester --stdout='b.c' -- \
		fs-path --no-parents --extensions -- '.dorothy/a.b.c'

	# return parents

	# we don't resolve
	eval-tester --stdout=. -- \
		fs-path --parents -- 'd.e.f'

	eval-tester --stdout='a.b.c' -- \
		fs-path --parents -- 'a.b.c/d.e.f'

	eval-tester --status=22 --ignore-stderr -- \
		fs-path --parents --extension -- 'a.b.c/d.e.f'

	eval-tester --status=22 --ignore-stderr -- \
		fs-path --parents --extensions -- 'a.b.c/d.e.f'

	eval-tester --stdout='c' -- \
		fs-path --parent --extension -- 'a.b.c/d.e.f'

	eval-tester --stdout='b.c' -- \
		fs-path --parent --extensions -- 'a.b.c/d.e.f'

	# extension edge cases

	eval-tester --stdout='.dorothy' -- \
		fs-path -- '.dorothy'

	eval-tester --stdout='.dorothy' -- \
		fs-path --no-extension -- '.dorothy'

	eval-tester --stdout='.dorothy' -- \
		fs-path --no-extensions -- '.dorothy'

	eval-tester --stdout='' -- \
		fs-path --extension -- '.dorothy'

	eval-tester --stdout='' -- \
		fs-path --extensions -- '.dorothy'

	eval-tester --stdout='.dorothy' -- \
		fs-path --parents -- '.dorothy/a.b.c'

	eval-tester --stdout='.dorothy' -- \
		fs-path --parents --no-extension -- '.dorothy/a.b.c'

	eval-tester --stdout='.dorothy' -- \
		fs-path --parents --no-extensions -- '.dorothy/a.b.c'

	eval-tester --status=22 --ignore-stderr -- \
		fs-path --parents --extension -- '.dorothy/a.b.c'

	eval-tester --status=22 --ignore-stderr -- \
		fs-path --parents --extensions -- '.dorothy/a.b.c'

	eval-tester --stdout='' -- \
		fs-path --parent --extension -- '.dorothy/a.b.c'

	eval-tester --stdout='' -- \
		fs-path --parent --extensions -- '.dorothy/a.b.c'

	eval-tester --stdout='..dorothy.a.b.c' -- \
		fs-path -- '..dorothy.a.b.c'

	eval-tester --stdout='..dorothy.a.b' -- \
		fs-path --no-extension -- '..dorothy.a.b.c'

	eval-tester --stdout='..dorothy' -- \
		fs-path --no-extensions -- '..dorothy.a.b.c'

	eval-tester --stdout='..dorothy.a.b.' -- \
		fs-path -- '..dorothy.a.b.'

	eval-tester --stdout='..dorothy.a.b' -- \
		fs-path --no-extension -- '..dorothy.a.b.'

	eval-tester --stdout='..dorothy' -- \
		fs-path --no-extensions -- '..dorothy.a.b.'

	# directory slash edge cases

	eval-tester --stdout='a/b' -- \
		fs-path -- 'a/b/'

	eval-tester --stdout='b' -- \
		fs-path --no-parents -- 'a/b/'

	eval-tester --stdout='a' -- \
		fs-path --parents -- 'a/b/'

	eval-tester --stdout='a/b' -- \
		fs-path -- 'a/b//'

	eval-tester --stdout='b' -- \
		fs-path --no-parents -- 'a/b//'

	eval-tester --stdout='a' -- \
		fs-path --parents -- 'a/b//'

	# root edge cases

	eval-tester --stdout='/a' -- \
		fs-path -- '/a/'

	eval-tester --stdout='/a' -- \
		fs-path -- '/a'

	eval-tester --stdout='/' -- \
		fs-path -- '/'

	eval-tester --stdout='/a' -- \
		fs-path -- '/a//'

	eval-tester --stdout='/a' -- \
		fs-path -- '/a'

	eval-tester --stdout='/' -- \
		fs-path -- '//..///..////./////'

	eval-tester --stdout='/' -- \
		fs-path --parents -- '//..///..////./////'

	eval-tester --stdout=. -- \
		fs-path --no-parents -- '//..///..////./////'

	# we don't resolve

	eval-tester --stdout='a' -- \
		fs-path --no-parents -- '/a/'

	eval-tester --stdout='a' -- \
		fs-path --no-parents -- '/a//'

	eval-tester --stdout='a' -- \
		fs-path --no-parents -- '/a'

	eval-tester --stdout='/' -- \
		fs-path --no-parents -- '/'

	eval-tester --stdout='/' -- \
		fs-path --parents -- '/a/'

	eval-tester --stdout='/' -- \
		fs-path --parents -- '/a'

	eval-tester --stdout='/' -- \
		fs-path --parents -- '/'

	eval-tester --stdout='/' -- \
		fs-path --parents -- '/a//'

	eval-tester --stdout='/' -- \
		fs-path --parents -- '/a'

	# @todo add symlink edge cases

	return 0
)
function fs_path() (
	source "$DOROTHY/sources/is-fs.bash"

	# =====================================
	# Arguments

	function help {
		cat <<-EOF >&2
			ABOUT:
			Get a specific path variation of a <path>.

			USAGE:
			fs-path [...options] [--] ...<path>

			OPTIONS:
			--resolve | --resolve=follow | --follow
			    Transform the symlinks into their target paths. Implies [--absolute].
			    If set to [--follow] / [--resolve=follow], then continue following resolutions until the target is no longer a symlink. As a comparison, [realpath] follows, [readlink] does not.
			--absolute | --relative
			    If the path was relative, then [--absolute] will resolve it to an absolute path, and [--relative] will persist it as a relative path.
			--relative-from=<relative_from> | --relative-to=<relative_from>
			    If provided, make the result <path> relative from <relative_from>.
			--relative-base=<relative_base>
			    If provided, make the result <path> relative within <relative_base>.

			--validate
			    If [--validate] then fail if any part of the path was not resolvable, that is missing, inaccessible, or broken.
			$(is_fs_options '13')

			--no-extensions
			    Remove all extensions from the basename.
			--extensions
			    Only output the extensions of the basename.
			    If no extensions, an empty result will be returned.

			--no-extension
			    Remove the last extension from the basename.
			--extension
			    Only output the last extension of the basename.
			    If no last extension, an empty result will be returned.

			--no-parents | --no-parent
			    Only return the basename of the path, without a containing path.
			--parents
			    Only return the containing path and not the basename.
			    Incompatible with [--extension] and [--extensions].
			--parent
			    Only return the basename of the parent path.
		EOF
		if [[ $# -ne 0 ]]; then
			echo-error "$@"
		fi
		return 22 # EINVAL 22 Invalid argument
	}

	# process
	local item args=() option_absolute='' option_resolve='' option_follow='' option_validate='' option_relative_from='' option_relative_base='' option_extensions='' option_extension='' option_parents='' option_parent=''
	while [[ $# -ne 0 ]]; do
		item="$1"
		shift
		case "$item" in
		'--help' | '-h') help ;;
		'--relative-to='* | '--relative-from='*) option_relative_from="${item#*=}" ;;
		'--relative-base='*) option_relative_base="${item#*=}" ;;
		'--no-relative'* | '--relative'*)
			# this must be after --relative-{to,base} otherwise it will capture them
			__flag {option_absolute} --non-affirmative -- "$item"
			;;
		'--no-absolute'* | '--absolute'*) __flag {option_absolute} --affirmative -- "$item" ;;
		'--no-resolve'* | '--resolve'*) __flag {option_resolve} --affirmative -- "$item" ;;
		'--no-follow'* | '--follow'*) __flag {option_follow} --affirmative -- "$item" ;;
		'--no-validate'* | '--validate'*) __flag {option_validate} --affirmative -- "$item" ;;
		'--no-extensions'* | '--extensions'*) __flag {option_extensions} --affirmative -- "$item" ;;
		'--no-extension'* | '--extension'*) __flag {option_extension} --affirmative -- "$item" ;;
		'--no-parents'* | '--parents'*) __flag {option_parents} --affirmative -- "$item" ;;
		'--no-parent'* | '--parent'*) __flag {option_parent} --affirmative -- "$item" ;;
		'--dirname') option_parents='yes' ;;
		'--basename') option_parents='no' ;;
		# <elevate>
		'--elevated='*) option_elevated="${item#*=}" ;;
		'--no-elevate'* | '--elevate'*) __flag {option_elevate} --affirmative -- "$item" ;;
		'--user='*) option_user="${item#*=}" ;;
		'--group='*) option_group="${item#*=}" ;;
		'--reason='*) option_reason="${item#*=}" ;;
		# </elevate>
		*) args+=("$item") ;;
		esac
	done
	is_fs_args "${args[@]}"

	# check
	if [[ $option_parent == 'no' ]]; then
		option_parents='no'
	elif [[ $option_parent == 'yes' ]]; then
		option_parents='no'
	fi
	if [[ $option_follow == 'yes' ]]; then
		option_resolve='follow'
	fi
	if [[ $option_parents == 'yes' && ($option_extensions == 'yes' || $option_extension == 'yes') ]]; then
		help "--parents cannot be used with --extension/--extensions, as that doesn't make sense"
	fi
	if [[ -n $option_extensions && -n $option_extension ]]; then
		help '--extension and --extensions are mutually exclusive'
	fi
	if [[ -n $option_relative_from && -n $option_relative_base ]]; then
		help '--relative-from and --relative-base are mutually exclusive' # grealpath will discard both if both are provided
	fi

	# =====================================
	# Act

	local path stem leaf prefix
	function __expand {
		local var="$1"
		is_fs_invoke --elevate=13 --redirect-stdout="{$var}" -- fs-path.bash --resolve="$option_resolve" --validate="$option_validate" -- "${!var}"
		# if verbose and failure, output contextual failure
		if [[ $option_quiet == 'no' && $fs_status -ne 0 ]]; then
			is_fs_error "$fs_status"
		fi
		return "$fs_status"
	}
	for path in "${option_inputs[@]}"; do
		# `dirname` and `basename` operate on the last forward-slash, back-slashes are not relevant as even in WSL which is our only supported Windows target, then forward-slashes are enforced/emulated.

		# trim trailing / or .
		while [[ ($path == *'/' && $path != '/') || ($path == *'/.' && $path != '.') ]]; do
			__slice --source+target={path} -- 0 -1
		done
		# trim 2+ slashes, as they are ignored
		while [[ $path == *'//'* ]]; do
			path="${path//\/\//\/}"
		done
		# if root, then return root
		if [[ $path == '/' ]]; then
			__print_lines '/'
			continue
		fi

		# resolve the path
		if [[ $option_resolve =~ ^(yes|follow)$ || $option_validate == 'yes' ]]; then
			# we need it to be resolved, or validated
			__expand path
		elif [[ $path != /* && (-n $option_relative_from || -n $option_relative_base || $option_absolute == 'yes') ]]; then
			# we need to it to be absolute, in cases where it is not
			__expand path
		fi

		# compress .. and . where possible
		local parts=() i v
		__split --source={path} --target={parts} --delimiter='/' --no-zero-length
		if [[ $path == /* ]]; then
			parts=('/' "${parts[@]}")
		fi
		for ((i = 1; i < ${#parts[@]}; i++)); do
			case "${parts[i]}" in
			'' | '.')
				# remove the current part
				__slice --source+target={parts} -- 0 "$i" "$((i + 1))"
				i=$((i - 1))
				;;
			'..')
				if [[ $i -ge 1 ]]; then
					v="${parts[i - 1]}"
					if [[ $v == '/' ]]; then
						# prior part is root, so remove the current part
						__slice --source+target={parts} -- 0 "$i" "$((i + 1))"
						i=$((i - 1))
					elif [[ $v != '..' ]]; then
						# prior part is neither root nor an unresolvable parent
						# remove the prior part and the current part
						__slice --source+target={parts} -- 0 "$((i - 1))" "$((i + 1))"
						i=$((i - 2))
					fi
				fi
				;;
			esac
		done
		__join --source={parts} --delimiter=/ --target={path}
		if [[ ${#path} -gt 1 && ${path:0:1} == '/' ]]; then
			path="${path:1}" # remove the leading slash that was added by the above
		fi

		# handle relative-to and relative-base
		if [[ -n $option_relative_from ]]; then
			# find the common ancestor
			local from_parts=() to_parts=() from_n from_slice to_slice relative_slice relative_path
			__expand option_relative_from
			# /0/1/2/a/b/c
			# /0/1/2/x/y/z
			# --relative-from=/0/1/2/a/b/c -- /0/1/2/x/y/z
			# should return ../../../x/y/z
			__split --source={option_relative_from} --target={from_parts} --delimiter='/'
			__split --source={path} --target={to_parts} --delimiter='/'
			from_n="${#from_parts[@]}"
			for ((from_index = from_n - 1; from_index >= 0; from_index--)); do
				__join --delimiter='/' {from_slice} -- "${from_parts[@]:0:from_index}"
				__join --delimiter='/' {to_slice} -- "${to_parts[@]:0:from_index}"
				__print_lines "$from_index: $from_slice == $to_slice"
				if [[ $from_slice == "$to_slice" ]]; then
					__array --target={relative_slice} --size=$((from_n - from_index)) --fill='..'
					relative_slice+=("${to_parts[@]:from_index}")
					__join --source={relative_slice} --delimiter='/' --target={relative_path}
					break
				fi
			done
			path="$relative_path"
		elif [[ -n $option_relative_base ]]; then
			# make the path relative within the base
			__expand option_relative_base
			option_relative_base+='/' # add a trailing slash
			if [[ $path == $option_relative_base* ]]; then
				# the path is within the base, so we can return it relative from the base
				__slice --source+target={path} -- "${#option_relative_base}"
			fi
		fi

		# --parents -- .
		#   should return ..
		# --parents -- ..
		#   should return ..
		# --parents -- ../../..
		#   should return ../..
		# --parent -- .
		#   should return ..
		# --parent -- ..
		#   should return ..
		# --no-parents -- .
		#   should return .
		# --no-parents -- ..
		#   should return ..
		# --no-parents -- ../../..
		#   should return ..

		# get the stem/dirname/parents, falling back to the current directory if no slash was found
		if [[ $path == *'/'* ]]; then
			# get the stem/dirname/parents
			__evict --source={path} --target={stem} --keep-before-last='/'
		else
			# no slash, so we return the current directory
			stem=.
		fi
		# workaround if / was the first character, in which we have returned to root
		if [[ -z $stem ]]; then
			stem='/'
		fi

		# do we only want the stem/parents?
		if [[ $option_parents == 'yes' ]]; then
			__print_lines "$stem"
			continue
		elif [[ $option_parent == 'yes' ]]; then
			if [[ $stem == '/' ]]; then
				__print_lines '/'
				continue
			fi
			# separate the path and stem
			path="$stem"
			if [[ $stem == *'/'* ]]; then
				# get the stem/dirname/parents
				__evict --source+target={stem} --keep-before-last='/'
				if [[ -z $stem ]]; then
					# if stem is empty, then the parent is root
					stem='/'
				fi
			else
				# no slash, so we return the current directory
				stem=.
			fi
		fi

		# get the leaf/filename/basename, falling back to itself if no slash was found
		if [[ $path == *'/'* ]]; then
			__evict --source={path} --target={leaf} --keep-after-last='/'
		else
			leaf="$path"
		fi

		# do we want to trim extension? with workaround when starting with a dot
		if [[ -n $option_extensions || -n $option_extension ]]; then
			if [[ $leaf == '.' || $leaf == '..' ]]; then
				help 'Cannot use --extensions/--extension on a [.] [..] path; you must combine with either [--resolve] or [--absolute]'
			fi
			# trim leading dots
			prefix=''
			while [[ $leaf == .* ]]; do
				prefix="$prefix."
				leaf="${leaf:1}"
			done
			if [[ -z $leaf ]]; then
				help "Cannot use --extensions/--extension on an invalid path: $path"
			fi
			# extensions
			if [[ $option_extensions == 'no' ]]; then
				# trim all extensions
				if [[ $leaf == *'.'* ]]; then
					__evict --source+target={leaf} --keep-before-first=.
				fi
			elif [[ $option_extension == 'no' ]]; then
				# trim last extension
				if [[ $leaf == *'.'* ]]; then
					__evict --source+target={leaf} --keep-before-last=.
				fi
			elif [[ $option_extensions == 'yes' ]]; then
				# trim leading dots
				while [[ $leaf == .* ]]; do
					leaf="${leaf:1}"
				done
				# output all extensions and exit
				if [[ $leaf == *'.'* ]]; then
					__evict --source+target={leaf} --keep-after-first=.
				else
					leaf=''
				fi
				continue
			elif [[ $option_extension == 'yes' ]]; then
				# trim leading dots
				while [[ $leaf == .* ]]; do
					leaf="${leaf:1}"
				done
				# output last extension and exit
				if [[ $leaf == *'.'* ]]; then
					__evict --source+target={leaf} --keep-after-last=.
				else
					leaf=''
				fi
				continue
			fi
			# re-add the trimmed leading dots
			leaf="$prefix$leaf"
		fi

		# do we want to exclude parents? or are there no parents?
		if [[ $option_parents == 'no' || $stem == '.' ]]; then
			__print_lines "$leaf"
			continue
		fi

		# we want stem/dirname/parents and leaf/filename/basename
		if [[ $stem == '/' ]]; then
			# if stem is root, then it already has the slash
			__print_lines "$stem$leaf"
		else
			__print_lines "$stem/$leaf"
		fi
		continue
	done
)

# fire if invoked standalone
if [[ $0 == "${BASH_SOURCE[0]}" ]]; then
	if [[ $* == '--test' ]]; then
		fs_path_test
	else
		fs_path "$@"
	fi
fi
