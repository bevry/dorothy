#!/usr/bin/env bash

# https://unix.stackexchange.com/a/364496/50703
# https://unix.stackexchange.com/a/364458/50703
# https://en.wikipedia.org/wiki/Smartmontools
# https://help.ubuntu.com/community/Smartmontools

# These support UASP:
# Seagate Expansion Desktop Drive (STEB4000300)

# These do not support UASP:
# Western Digital My Book 12TB (WDBBGB0120HBK-NA,WDBBGB0120HBK-NB)

# What is UASP
# https://youtu.be/t0kYcM1E5fY
# https://www.startech.com/en-us/blog/all-you-need-to-know-about-uasp
# Despite what Pluggable states: https://support.plugable.com/t/6491/2?u=balupton
# UASP supported is needed by the USB Hubs for UASP boost, as stated by StarTech in a support chat:
# > All hubs support the use of UASP enabled devices, but hubs that do not have the feature built in will not operate at the boosted speed that UASP devices can function at. If you require the UASP boosted speed, then look for a hub that has it built in. If the speed is not crucial and the standard 5Gbps that USB 3.0 offers will suffice, it won't matter the hub you use as long as its a USB 3.0 hub.

# Other useful commands that we didn't use:
# df -T "$filesystem" # macos
# df --type="$filesystem" # linux
# blkid -L "$label"

function get_devices_test() (
	source "$DOROTHY/sources/bash.bash"
	__require_array 'associative' || return 0
	eval-tester --ignore-stderr --status=22 -- get-devices --help
)

function get_devices() (
	source "$DOROTHY/sources/bash.bash"
	source "$(type -P eval-helper)"

	# prepare
	local field_keys boolean_keys=(mountable)
	if __is_macos; then
		field_keys=(
			node
			uuid
			raid_uuid # UUID of the RAID set
			raid_slice
			model
			serial
			type
			id
			apfs_physical_store
			apfs_container
			# ...
			filesystem
			label
			mountable
			mount
			# ...
			location
			virtual
			# ...
			size
			volume_used_space
			container_free_space
			container_size
			block
		)
	else
		field_keys=(
			node
			size
			model
			filesystem
			label
			mount
			count
			count_available
			uuid
			serial
			product
			vendor
			revision
			block
		)
	fi

	# =====================================
	# Arguments

	function help {
		__print_help "$@" <<-EOF || return $?
			ABOUT:
			Get devices and their information.

			USAGE:
			\`get-devices [...options] [-- ...<node>]\`

			OPTIONS:
			--question=<question> | --required | --multi
			    If provided, these are forwarded to \`choose\`, which will be used to show a prompt to make a selection of devices.
			    Implies \`--return=node\`. If you want other fields, be sure to specify them.
			    If not provided, and no <return-field-name> is provided, then an interactive table will be displayed.

			--return=<return-field-name>
			    If provided, limit the returned fields to only these. Supports separated values. Result will be tabbed separated.

			--display=<display-field-name>
			    If provided, limit the displayed fields to only these. Supports separated values.

			--missing=<missing>
			    If provided, and no results were found, then output this <missing> message instead of the default one.
			    If empty, then no warning message will be shown.

			--terminal-lines=<terminal-lines> | --terminal-columns=<terminal-columns>
			    Forwarded to commands that support them.

			--debug
			    Output debug information.

			--<field-name> | --no-<field-name>
			    Filter devices to only those which <field-name> applies or not.
			--<field-name>=<field-value>
			    Filter devices to only those that the <field-name> specified as <field-value>.

			FIELDS:
			Field availability and value format is dependent on device, filesystem, and operating system.
			* \`node\`        Get device node, e.g. \`/dev/sda\`
			* \`size\`        Get device size, e.g. \`10.91 TiB\`
			* \`label\`       Get device label, e.g. \`TANKER\`
			* \`filesystem\`  Get device filesystem/type, e.g. \`btrfs|ext4\`
			* \`mount\`       Get device mount point, e.g. \`/boot/firmware\`
			* \`count\`       Get how many devices are attached to the filesystem (btrfs only), e.g. \`1\`
			* \`vendor\`      Get device vendor, e.g. \`Seagate\`
			* \`model\`       Get device model, e.g. \`My Book 25EE\`
			* \`product\`     Get device product, e.g. \`Expansion Desk\`
			* \`revision\`    Get device revision, e.g. \`0915\`
			* \`serial\`      Get device serial number, e.g. \`1AA1AA11\`
			* \`uuid\`        Get device uuid, e.g. \`1aa1aa11-1aa1-aa11-1aa1-aa1aa1aa1aa1\`
			* \`block\`       Get device block size, e.g. \`4096\`

			FIELDS AVAILABLE ON THIS OPERATING SYSTEM:
			$(__join --source={field_keys} --style=code --between=', ')
		EOF
		return 22 # EINVAL 22 Invalid argument
	}

	# do help prior to compatibility requirement
	if [[ $* == *'--help'* || $* == '-h'* ]]; then
		help
	fi

	# check compatibility
	__require_array 'associative' || return $?

	# process
	declare -A matches exists
	local item option_quiet='' option_debug='no' option_return=() option_display=() option_choose_args=() option_missing='No matching devices found.' option_terminal_lines='' option_terminal_columns=''
	function parse_arg {
		# matches examples:
		# --count=3
		# exists examples:
		# --no-mount
		# --mount
		# --no-mount=yes
		# --mount=yes
		local item="$1" key value
		__replace --source={item} --target={key} --keep-after-first='--' --keep-before-first='=' --leading='no-' --require=any
		__flag --source={item} --target={value} --affirmative
		if __has --source={boolean_keys} -- "$key"; then
			matches["$key"]="$value"
		elif [[ $value == 'yes' || $value == 'no' ]]; then
			exists["$key"]="$value"
		else
			matches["$key"]="$value"
		fi
	}
	while [[ $# -ne 0 ]]; do
		item="$1"
		shift
		case "$item" in
		'--help' | '-h') help ;;
		'--no-verbose'* | '--verbose'*) __flag --source={item} --target={option_quiet} --non-affirmative ;;
		'--no-quiet'* | '--quiet'*) __flag --source={item} --target={option_quiet} --affirmative ;;
		'--no-debug'* | '--debug'*) __flag --source={item} --target={option_debug} --affirmative ;;

		'--return='* | '--result='*)
			__split --target={option_return} --append --no-zero-length --delimiters=$'\n\t ,:|' -- "${item#*=}"
			;;
		'--display='*)
			__split --target={option_display} --append --no-zero-length --delimiters=$'\n\t ,:|' -- "${item#*=}"
			;;
		'--missing='*) option_missing="${item#*=}" ;;

		'--select') option_choose_args+=('Select a device.') ;;        # b/c
		'--select='*) option_choose_args+=("--question=${item#*=}") ;; # b/c
		'--question'* | '--no-multi'* | '--multi'* | '--no-required'* | '--required'*) option_choose_args+=("$item") ;;

		'--terminal-lines='*) option_terminal_lines="${item#*=}" ;;
		'--terminal-columns='*) option_terminal_columns="${item#*=}" ;;

		'--'*) parse_arg "$item" ;;

		*) help 'An unrecognised argument was provided: ' --variable-value={item} ;;
		esac
	done

	# adjustments
	local quiet="${option_quiet:-"yes"}" check_keys=("${!matches[@]}" "${!exists[@]}")
	if [[ ${#option_display[@]} -eq 0 ]]; then
		option_display=("${field_keys[@]}")
	fi
	if [[ ${#option_choose_args[@]} -ne 0 && ${#option_return[@]} -eq 0 ]]; then
		option_return=('node')
	fi

	# terminal size: constrain to arguments if provided
	local terminal_lines="$option_terminal_lines" terminal_columns="$option_terminal_columns"
	function __refresh_terminal_size {
		if [[ -z $option_terminal_lines || -z $option_terminal_columns ]]; then
			local terminal_size=()
			__split --target={terminal_size} --no-zero-length --invoke=try -- \
				get-terminal-lines-and-columns || return $?
			if [[ ${#terminal_size[@]} -eq 2 ]]; then
				if [[ -z $option_terminal_lines ]]; then
					terminal_lines="${terminal_size[0]}"
				fi
				if [[ -z $option_terminal_columns ]]; then
					terminal_columns="${terminal_size[1]}"
				fi
			fi
		fi
	}
	__refresh_terminal_size

	local root
	root="$(fs-temp --cache --directory='dorothy' --directory='get-devices')"

	# =====================================
	# Helpers

	# dependencies
	setup-util-devices --quiet

	# prepare
	declare -A fields
	local result_lines=() devices=() devices_count=0

	# wrap
	function __wrap {
		eval_helper --terminal-lines="$terminal_lines" --terminal-columns="$terminal_columns" --quiet="$quiet" --persist=STDOUT --wrap --revolving-max-lines=5 "$@"
	}

	# progress bar
	# local message_segment=0
	function __progress {
		local count="$1" total="$2" comment="${3-}" message
		message="Fetching device information: $((count * 100 / total))% [$count/$total] $comment"
		__do --redirect-output=TTY -- printf $'\r'"%-${terminal_columns}s" "$message" || return $?
		# local progress_decimal progress_size progress_step i message_size progress_segment progress_bar='['
		# message_size="${#message}"
		# if [[ $message_segment -eq 0 ]]; then
		# 	message_segment="$(echo-math --integer -- "$message_size + 8")"
		# elif [[ $message_size -gt $message_segment ]]; then
		# 	message_segment="$(echo-math --integer -- "$message_size + 4")"
		# fi
		# progress_segment="$(echo-math --integer -- "$option_terminal_columns - $message_segment")"
		# progress_decimal="$(echo-math -- "$count / $total")"
		# progress_size="$((progress_segment - 3))"
		# progress_step="$(echo-math --integer -- "$progress_size * $progress_decimal")"
		# for ((i = 0; i < progress_step; i++)); do
		# 	progress_bar+='#'
		# done
		# for ((i = progress_step; i < progress_size; i++)); do
		# 	progress_bar+='-'
		# done
		# progress_bar+=']'
		# __do --redirect-output=TTY -- printf $'\r'"%-${message_segment}s%-${progress_segment}s" "$message" "$progress_bar"
	}

	# checking fields
	# __check_key <key> <value>
	function __check_field {
		local key="$1" field_value='' exists_value
		if [[ -v fields["$key"] ]]; then
			field_value="${fields["$key"]}"
		fi
		if [[ -v matches["$key"] && ${matches["$key"]} != "$field_value" ]]; then
			return 1
		fi
		if [[ -v exists["$key"] ]]; then
			exists_value="${exists["$key"]}"
			if [[ ($exists_value == 'yes' && -z $field_value) || ($exists_value == 'no' && -n $field_value) ]]; then
				return 1
			fi
		fi
		return 0
	}
	# __correct_fields
	function __correct_fields {
		local key value
		for key in "${boolean_keys[@]}"; do
			if ! [[ -v matches["$key"] ]]; then
				matches["$key"]='no'
			fi
			value="${matches["$key"]}"
			if ! [[ $value =~ ^(yes|no)$ ]]; then
				__print_error 'Encountered invalid boolean value for:' --newline --variable={key} --newline --variable={value} || return $?
				return 22 # EINVAL 22 Invalid argument
			fi
		done
	}
	# __check_fields
	function __check_fields {
		local key
		for key in "${check_keys[@]}"; do
			__check_field "$key" || return $?
		done
		return 0
	}

	# fetching fields
	# __get_key <key> <haystack>
	function __get_key {
		# could be multiple keys per line
		local key="$1" haystack="$2"
		# echo-regexp -o --regexp="${key}=\"([^\"\n]+)" --replace='$1' -- "$haystack" || return $?
		__replace --source={haystack} --target={value} --keep-after-first="$key=" || return $?
		if [[ -z $value ]]; then
			return 0
		fi
		# trim leading whitespace and quotes
		while [[ $value =~ ^[\n\ \'\"] ]]; do
			value="${value:1}"
		done
		# get everything until the first whitespace or quote
		local content=''
		while ! [[ $value =~ ^[\n\'\"] ]]; do
			content+="${value:0:1}"
			value="${value:1}"
		done
		value="$content"
		__replace --optional --source+target={value} --trailing-whitespace || return $?
		__print_string "$value" || return $?
	}
	# __get_property <key> <haystack>
	function __get_property {
		# one property per line
		local key="$1" haystack="$2" value # rk rv
		# rk="$(echo-escape-regexp -- "$key")"
		# rv="$(echo-regexp -o --regexp="${rk}:[ '\"]+([^'\"\n]+)" --replace='$1' -- "$haystack" | echo-trim-each-line --stdin || :)"
		[[ $haystack == *"$key: "* ]] || return 0
		__replace --source={haystack} --target={value} --keep-after-first="$key: " || return $?
		if [[ $value == *$'\n'* ]]; then
			__replace --source+target={value} --keep-before-first=$'\n' || return $? # can be the last line
		fi
		# trim leading and trailing whitespace and quotes
		while [[ $value =~ ^[\ \'\"] ]]; do
			value="${value:1}"
		done
		while [[ $value =~ [\ \'\"]$ ]]; do
			__slice --source+target={value} -- 0 -1 || return $?
		done
		# if [[ $value != "$rv" ]]; then
		# 	__print_error "[$value] != [$rv] with [$key] on [$haystack]"
		# 	exit 9
		# fi
		__print_string "$value" || return $?
	}
	# __get_size <size>
	function __get_size {
		local size="$1"
		# 5.0 TB (5034252828672 Bytes) (exactly 9832525056 512-Byte-Units)
		# to
		# 5.0 TB
		if [[ $size == *' ('* ]]; then
			__replace --source+target={size} --keep-before-first=' (' || return $?
		fi
		__print_lines "$size" || return $?
	}
	# __get_size_property <key> <haystack>
	function __get_size_property {
		local key="$1" haystack="$2" value
		value="$(__get_property "$key" "$haystack")" || return $?
		__get_size "$value" || return $?
	}

	# adding and rendering fields: macos vs linux
	if [[ ${#option_choose_args[@]} -ne 0 ]]; then
		# choose and return for a program
		__load_styles --save -- bold code # dim foreground_black foreground_red foreground_green foreground_yellow foreground_blue foreground_magenta foreground_cyan foreground_white
		# local open_colors=(
		# 	"$STYLE__foreground_black"
		# 	"$STYLE__foreground_red"
		# 	"$STYLE__foreground_green"
		# 	"$STYLE__foreground_yellow"
		# 	"$STYLE__foreground_blue"
		# 	"$STYLE__foreground_magenta"
		# 	"$STYLE__foreground_cyan"
		# 	"$STYLE__foreground_white"
		# ) close_colors=(
		# 	"$STYLE__END__foreground_black"
		# 	"$STYLE__END__foreground_red"
		# 	"$STYLE__END__foreground_green"
		# 	"$STYLE__END__foreground_yellow"
		# 	"$STYLE__END__foreground_blue"
		# 	"$STYLE__END__foreground_magenta"
		# 	"$STYLE__END__foreground_cyan"
		# 	"$STYLE__END__foreground_white"
		# )
		local return_lines=()
		function __add_fields_to_results {
			local values=() key value line return_values=() # color_index=0 color_open color_close
			for key in "${option_display[@]}"; do
				# if [[ $color_index -lt ${#open_colors[@]} ]]; then
				# 	color_open="${open_colors[color_index]}"
				# 	color_close="${close_colors[color_index]}"
				# 	color_index="$((color_index + 1))"
				# else
				# 	color_open="${open_colors[0]}"
				# 	color_close="${close_colors[0]}"
				# 	color_index=1
				# fi
				if [[ -v fields["$key"] ]]; then
					value="${fields["$key"]}"
					if [[ -n $value ]]; then
						# line="$key=[$value]"
						# line="$(__print_style --bold="$key " --code="$value")"
						line="${STYLE__bold}${key}${STYLE__END__bold} ${STYLE__code}${value}${STYLE__END__code}"
						# line="${color_open}${line}${color_close}"
						values+=("$line")
					fi
				fi
			done
			for key in "${option_return[@]}"; do
				if [[ -v fields["$key"] ]]; then
					return_values+=("${fields["$key"]}")
				else
					return_values+=('')
				fi
			done
			__join --source={values} --between='  ' --append --target={result_lines} || return $?
			__join --source={return_values} --between=$'\t' --append --target={return_lines} || return $?
		}
		function __render_results {
			local index
			index="$(choose --index "${option_choose_args[@]}" -- "${result_lines[@]}")" || return $?
			if [[ -z $index ]]; then
				__print_error "$option_missing" || return $?
				return 1
			fi
			if [[ $index -lt 0 || $index -ge ${#return_lines[@]} ]]; then
				__print_error "Invalid index [$index] for [0, ${#return_lines[@]}]" || return $?
			fi
			local return_line="${return_lines[index]}"
			__print_lines "$return_line" || return $?
		}
	elif [[ ${#option_return[@]} -ne 0 ]]; then
		# return for a program
		function __add_fields_to_results {
			local return_values=() key
			for key in "${option_result[@]}"; do
				if [[ -v fields["$key"] ]]; then
					return_values+=("${fields["$key"]}")
				else
					return_values+=('')
				fi
			done
			__join --source={return_values} --between=$'\t' --append --target={result_lines} || return $?
		}
		function __render_results {
			__print_lines "${result_lines[@]}" || return $?
		}
	else
		# render for the user
		local devices_tsv_file
		devices_tsv_file="$(fs-temp --root="$root" --file='tsv')"
		__command_required -- 'csvlens' || return $?
		function __add_fields_to_results {
			local values=() key
			for key in "${option_display[@]}"; do
				if [[ -v fields["$key"] ]]; then
					values+=("${fields["$key"]}")
				else
					values+=('')
				fi
			done
			__join --source={values} --between=$'\t' --append --target={result_lines} || return $?
		}
		function __render_results {
			# prepend option_display values joined by tab to result_lines
			__join --source={option_display} --between=$'\t' --prepend --target={result_lines} || return $?
			# join result_lines and output to devices_tsv_file
			__join --source={result_lines} --between=$'\n' >"$devices_tsv_file" || return $?
			csvlens -t "$devices_tsv_file" || return $?

			# https://github.com/alexhallam/tv?tab=readme-ov-file#tools-to-pair-with-tv
			# brew install tidy-viewer
			# tv --color-always  --no-dimensions  --no-row-numbering --force-all-rows --delimiter $'\t' devices.tsv
			# ^ no ability to disable NA
			# no ability to disable margin padding
			# no ability to disable footer status bar
			# otherwise really good, truncates automatically

			# column fails to render the long columns properly
			# bash-5.2$ column -c 50 -xts $'\t' devices.tsv
			# column: line too long

			# https://github.com/johnkerl/miller
		}
	fi

	# =====================================
	# Action

	# debug
	if [[ $option_debug == 'yes' ]]; then
		{
			if [[ -n $option_node ]]; then
				# model, serial, uuid, filesystem, size, block, label
				eval_helper --wrap -- \
					diskutil info "$option_node" || :

				# label, uuid, block, filesystem
				eval_helper --elevate --wrap -- \
					blkid "$option_node" || :

				# serial, vendor, product, revision
				eval_helper --elevate --wrap -- \
					sginfo -a "$option_node" || :

				eval_helper --elevate --wrap -- \
					hdparm -I "$option_node" || :

				eval_helper --elevate --wrap -- \
					sdparm -i "$option_node" || :

				# -i: model, serial, firmware, pci id, ieee id, controller id, nvme version, etc.
				# -a: same as -i, but includes SMART specific details that we don't care for
				# eval_helper --elevate --wrap \
				# 	-- smartctl -a "$option_node" ''

				#  btrfs filesystem show [options] [<path>|<uuid>|<device>|label]
				eval_helper --elevate --wrap -- \
					btrfs filesystem show "$option_node"
			else
				if __is_linux; then
					# macos doesn't support fdisk for listing
					eval_helper --elevate --wrap -- \
						fdisk -l || :

					# Gets all the details for the drives, including the vendor, model, serial, driver capabilities, etc.
					# UASP unsupported: configuration: driver=usb-storage
					# UASP supported: configuration: driver=uas maxpower=... speed=...
					eval_helper --elevate --wrap -- \
						lshw -class disk -class storage || :

					# Fetch filesystems and mounts for all drives
					eval_helper --elevate --wrap -- \
						lsblk -f || :
				else
					eval_helper --wrap -- \
						diskutil list || :
				fi

				#  btrfs filesystem show [options]
				eval_helper --elevate --wrap -- \
					btrfs filesystem show

				# trail
				__print_line
			fi
		} >&2
	fi

	# fetch
	if __is_macos; then
		# get all devices
		local delimiter='**********' devices_list='' devices_list_file devices_info='' devices_info_file
		devices_list_file="$(fs-temp --root="$root" --file='list')"
		devices_info_file="$(fs-temp --root="$root" --file='info')"
		devices_list="$(__wrap --pending='Checking devices list from diskutil...' --success='Checked devices list from diskutil.' -- diskutil list)"
		if [[ -s $devices_info_file && -s $devices_list_file ]]; then
			if [[ $devices_list == "$(<"$devices_list_file")" ]]; then
				echo is same
				devices_info="$(<"$devices_info_file")"
			# else
			# 	fs-diff -- "$devices_list_file" <(__print_string "$devices_list") || :
			fi
		fi
		if [[ -z $devices_info ]]; then
			devices_info="$(__wrap --pending='Refreshing devices from diskutil...' --success='Refreshing devices from diskutil.' -- diskutil info -all)"
			__print_string "$devices_info" >"$devices_info_file"
			__print_string "$devices_list" >"$devices_list_file"
		fi
		__split --source={devices_info} --target={devices} --delimiter="$delimiter" --no-zero-length
		devices_count="${#devices[@]}"
		__print_style --tty --bold="Found $devices_count devices"

		# get all serial numbers
		# ioreg -d 1 -ar -c  IOBlockStorageDevice <-- good xml output, includes serial of mac ssd, but not the usb devices
		# ioreg -l | grep -i serialnumber <-- garbled xml output, includes serials but difficult to work with
		# system_profiler -listDataTypes
		# system_profiler SPUSBDataType -json <-- all usb devices and serials
		# system_profiler SPNVMeDataType -json <-- mac ssd info and serial
		# system_profiler SPStorageDataType -json <-- good summary of storage volumes, no serials
		# fields[serial]="$(__get_property 'Disk / Partition UUID' "$device")"
		# local serials_json_query='reduce (.. | select(.serial_num? and .Media?)) as $item ({};
		# 	reduce $item.Media[] as $media (.;
		# 		. + {($media.bsd_name): $item.serial_num}
		# 	)
		# )'
		local usb_serials_tsv_query='reduce (.. | select(.serial_num? and .Media?)) as $item ({};
			reduce $item.Media[] as $media (.;
				. + {($media.bsd_name): $item.serial_num}
			)
		) | to_entries | map("\(.key)\t\(.value)") | join("\n")'
		local nvme_serials_tsv_query='.SPNVMeDataType[] | .. | select(.bsd_name? and .device_serial?) | "\(.bsd_name)\t\(.device_serial)"'
		declare -A serials
		while IFS=$'\t' read -r device serial; do
			serials["$device"]="$serial"
		done < <(system_profiler SPUSBDataType -json | jq -r "$usb_serials_tsv_query")
		while IFS=$'\t' read -r device serial; do
			serials["$device"]="$serial"
		done < <(system_profiler SPNVMeDataType -json | jq -r "$nvme_serials_tsv_query")

		# partition type: raid, boot, efi, volume (apfs volume, multiple per apfs container)
		# device type: physical (apfs physical container), virtual (apfs virtual container), partition
		# local temp node="$1" size="${2-}" model="${3-}" label='' uuid='' block='' filesystem='' mount='' count='' count_available='' count_info='' serial='' vendor='' product='' revision='' device_type='' partition_type=''

		# https://en.wikipedia.org/wiki/Apple_Partition_Map
		declare -A type_map
		type_map['EF57347C-0000-11AA-AA11-00306543ECAC']='APFS Container' # Content (IOContent)
		type_map['7C3457EF-0000-11AA-AA11-00306543ECAC']='RAID Set'       # Content (IOContent) also a APFS Physical Store
		type_map[GUID_partition_scheme]='Drive'                           # Content (IOContent)
		type_map[Apple_Boot]='Apple BootX Partition'                      # Content (IOContent)
		type_map[Apple_APFS_Recovery]='APFS Recovery Partition'           # Content (IOContent)
		type_map[Apple_APFS_ISC]='APFS iBoot System Container'            # Content (IOContent)
		type_map[Apple_RAID]='RAID Slice'                                 # Partition Type
		type_map[Apple_APFS]='APFS Physical Store'                        # Partition Type
		type_map['41504653-0000-11AA-AA11-00306543ECAC']='APFS Volume'    # Partition Type

		# cycle through each device
		local index device device id size label model type filesystem
		for index in "${!devices[@]}"; do
			# checks
			# __progress "$i" "$devices_count"
			device="${devices[index]}"
			if is-whitespace -- "$device"; then
				continue
			fi

			# reset
			fields=()

			# fetch id
			id="$(__get_property 'Device Identifier' "$device")" # disk7
			__progress "$i" "$devices_count" "$id"
			if [[ -z $id ]]; then
				return 1
			fi
			# __print_style --tty --bold='Getting device: ' --="$(__join --between=$'\t' --style=code -- "$id" "$model")"
			# __print_style --tty --bold='Getting device: ' --code="%s"
			fields[id]="$id"
			fields[node]="$(__get_property 'Device Node' "$device")" # /dev/disk7
			fields[uuid]="$(__get_property 'Disk / Partition UUID' "$device")"

			# serial only exists on devices that have a model
			model="$(__get_property 'Device / Media Name' "$device")"
			fields[model]="$model"
			if [[ -n $model && -v serials["$id"] ]]; then # avoids: bad array subscript
				fields[serial]="${serials["$id"]}"
			fi

			# type information
			# each physical disk, has a GUID_partition_scheme
			# each apfs physical store (includes apfs filesystem - can be physical partition or virtual-partition/raid)
			# each apfs physical store, has an apfs container (excludes filesystem)
			# each apfs container, has an apfs volume (includes apfs filesystem - this is what is mounted)
			fields[virtual]="$(__get_property 'Virtual' "$device")"
			fields[location]="$(__get_property 'Device Location' "$device")"
			type="$(__get_property 'Content (IOContent)' "$device")"
			if [[ -z $type ]]; then
				type="$(__get_property 'Partition Type' "$device")"
			fi
			if [[ -n $type && -v type_map["$type"] ]]; then # avoids: bad array subscript
				type="${type_map["$type"]}"
			fi
			fields[type]="$type"

			# size information
			# Disk Size:                 3.5 TB (3499678826496 Bytes) (exactly 6835310208 512-Byte-Units)
			# Volume Used Space:         2.1 TB (2130515156992 Bytes) (exactly 4161162416 512-Byte-Units)
			# Container Total Space:     3.5 TB (3499678826496 Bytes) (exactly 6835310208 512-Byte-Units)
			# Container Free Space:      1.4 TB (1368724865024 Bytes) (exactly 2673290752 512-Byte-Units)
			fields[size]="$(__get_size_property 'Disk Size' "$device")"
			fields[block]="$(__get_property 'Device Block Size' "$device")" # 512 Byte
			fields[apfs_container]="$(__get_property 'APFS Container' "$device")"
			fields[apfs_physical_store]="$(__get_property 'APFS Physical Store' "$device")"
			if [[ $type == 'RAID Set' ]]; then
				label="$(__get_property 'Set Name' "$device")"
				fields[raid_uuid]="$(__get_property 'RAID Set UUID' "$device")"
			elif [[ $type == 'RAID Slice' ]]; then
				label="$(__get_property 'Parent Set Name' "$device")"
				fields[raid_uuid]="$(__get_property 'Parent RAID Set UUID' "$device")"
				fields[raid_slice]="$(__get_property 'Slice' "$device")"
			else
				label="$(__get_property 'Volume Name' "$device")"
				if [[ $label == 'Not applicable (no file system)' ]]; then
					label=''
				fi
			fi
			fields[label]="$label"
			fields[mountable]='no'
			if [[ -n $label ]]; then
				# filesystem only exists on devices that have a label
				filesystem="$(__get_property 'Type (Bundle)' "$device")"
				fields[filesystem]="$filesystem"
				if [[ -n $filesystem ]]; then
					# mountable only exists on devices that have a filesystem
					# [Yes|No|Not applicable (no file system)]
					if [[ "$(__get_property 'Mounted' "$device")" =~ ^(Yes|No)$ ]]; then
						fields[mountable]='yes'
						# these only exist on devices that are mountable
						fields[mount]="$(__get_property 'Mount Point' "$device")"
						fields[volume_used_space]="$(__get_size_property 'Volume Used Space' "$device")"
						fields[container_free_space]="$(__get_size_property 'Container Free Space' "$device")"
						fields[container_size]="$(__get_size_property 'Container Total Space' "$device")"
					else
						help "Mountable was fetched for an invalid context: $id"$'\n'"$device"
					fi
				fi
			fi

			# check and add
			__correct_fields || return $?
			__check_fields || continue
			__add_fields_to_results
		done
		echo-clear-lines --lines=0
	else
		# btrfs prep
		local mount_haystack
		mount_haystack="$(mount)"
		if [[ $option_filesystem == 'btrfs' ]] || echo-regexp -q --regexp='btrfs' -- "$mount_haystack"; then
			# if you attach a btrfs cluster to a new machine
			# it may not be completely discovered until the btrfs agent scans for the devices
			# and btrfs supports mounting partial filesystems, which cause innumerable errors
			__wrap --pending='Getting devices from btrfs' -- btrfs-helper discover
			mount_haystack="$(mount)"
		fi

		# get devices
		function __get_devices {
			__wrap --elevate --pending='Getting devices from fdisk...' --success='Got devices from fdisk.' -- fdisk -l |
				echo-regexp -fongm --regexp='Disk (/dev/.+): (.+?),.+\nDisk model: (.+)' --replace=$'$1\t$2\t$3'
		}
		__split --target={devices} --no-zero-length --invoke -- \
			__get_devices
		devices_count="${#devices[@]}"
		__print_style --tty --bold="Found $devices_count devices"

		# cycle devices
		declare -A fields
		local index device node size model filesystem temp
		for index in "${!devices[@]}"; do
			device="${devices[index]}"
			IFS=$'\t' read -r node size model <<<"$device"
			if [[ -z $node ]]; then
				continue
			fi
			__progress "$i" "$devices_count" "$node"
			if [[ -n $model ]]; then
				model="$(echo-trim-each-line -- "$model")"
			fi
			fields=()
			fields[node]="$node"
			fields[size]="$size"
			fields[model]="$model"

			# fetch blkid properties
			temp="$(__wrap --elevate -- blkid "$node" || :)" # can fail if recently removed from a btrfs cluster
			if [[ -n $temp ]]; then
				filesystem="$(__get_key 'TYPE' "$temp")"
				fields[filesystem]="$filesystem"
				fields[label]="$(__get_key 'LABEL' "$temp")"
				fields[uuid]="$(__get_key 'UUID' "$temp")"
				fields[block]="$(__get_key 'BLOCK_SIZE' "$temp")"
				if [[ $filesystem == 'btrfs' ]]; then
					# fetch count
					temp="$(__wrap --elevate -- btrfs filesystem show "$node")"
					fields[count]="$(echo-regexp -o --regexp='Total devices ([0-9]+)' --replace='$1' -- "$temp")"
					fields[count_available]="$(echo-regexp -c --regexp='devid' -- "$temp")"
				fi
			fi

			# fetch sginfo properties
			temp="$(__wrap --elevate -- sginfo -a "$node")"
			fields[serial]="$(get_property 'Serial Number' "$temp")"
			fields[vendor]="$(get_property 'Vendor' "$temp")"
			fields[product]="$(get_property 'Product' "$temp")"
			fields[revision]="$(get_property 'Revision level' "$temp")"

			# fetch mount
			# @todo figure out mountable
			fields[mount]="$(echo-regexp -o --regexp="$node on (.+?) type $filesystem" --replace='$1' -- "$mount_haystack")"

			# check and add
			__correct_fields || return $?
			__check_fields || continue
			__add_fields_to_results
		done
		echo-clear-lines --lines=0
	fi

	# validate
	# local result_status=0
	# if [[ -n $count ]]; then
	# 	if [[ $count != "$count_available" ]] || echo-regexp -qi --regexp='(warning|error|missing)' -- "$count_info"; then
	# 		__print_style --stderr \
	# 			--error="$node: $count_available/$count devices found" --newline \
	# 			--="$(echo-lines --indent=$'\t' --stdin <<<"$count_info")"
	# 		result_status=5 # EIO 5 Input/output error
	# 	fi
	# 	if [[ -n $option_count && $option_label == "$label" && $option_count != "$count" ]]; then
	# 		__print_style --stderr \
	# 			--error="$node: $count_available/$count devices found, however we expected $option_count devices" --newline \
	# 			--="$(echo-lines --indent=$'\t' --stdin <<<"$count_info")"
	# 		result_status=5 # EIO 5 Input/output error
	# 	fi
	# fi

	# render
	__render_results
)

# fire if invoked standalone

if [[ $0 == "${BASH_SOURCE[0]}" ]]; then
	if [[ $* == '--test' ]]; then
		get_devices_test
	else
		get_devices "$@"
	fi
fi
