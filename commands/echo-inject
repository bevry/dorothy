#!/usr/bin/env bash

function echo_inject_test() (
	source "$DOROTHY/sources/bash.bash"

	__print_lines a b | eval-tester --trailing-newlines --status=22 --ignore-stderr -- echo-inject --inject=c --line=0 --stdin
	__print_lines a b | eval-tester --trailing-newlines --stdout=$'c\na\nb\n' -- echo-inject --inject=c --line=1 --stdin
	__print_lines a b | eval-tester --trailing-newlines --stdout=$'a\nc\nb\n' -- echo-inject --inject=c --line=2 --stdin
	__print_lines a b | eval-tester --trailing-newlines --status=33 --ignore-stderr -- echo-inject --inject=c --line=3 --stdin
	__print_lines a b | eval-tester --trailing-newlines --status=33 --ignore-stderr -- echo-inject --inject=c --line=3 --stdin --missing=required
	__print_lines a b | eval-tester --trailing-newlines --status=33 --ignore-stderr -- echo-inject --inject=c --line=3 --stdin --required
	__print_lines a b | eval-tester --trailing-newlines --stdout=$'a\nb\nc\n' -- echo-inject --inject=c --line=3 --stdin --missing=inject-at-end
	__print_lines a b | eval-tester --trailing-newlines --stdout=$'a\nb\n' -- echo-inject --inject=c --line=3 --stdin --optional

	__print_join a b | eval-tester --trailing-newlines --stdout=$'a\nb\nc' -- echo-inject --inject=c --line=3 --stdin --inject-at-end
	__print_lines a b | eval-tester --trailing-newlines --stdout=$'a\nb\nc\n' -- echo-inject --inject=c --line=3 --stdin --inject-at-end
	__print_join a b | eval-tester --trailing-newlines --stdout=$'a\nb\nc' -- echo-inject --no-trailing-newline --inject=c --line=3 --stdin --inject-at-end
	__print_lines a b | eval-tester --trailing-newlines --stdout=$'a\nb\nc' -- echo-inject --no-trailing-newline --inject=c --line=3 --stdin --inject-at-end
	__print_join a b | eval-tester --trailing-newlines --stdout=$'a\ncb' -- echo-inject --no-trailing-newline --inject=c --line=2 --stdin --inject-at-end
	__print_lines a b | eval-tester --trailing-newlines --stdout=$'a\ncb\n' -- echo-inject --no-trailing-newline --inject=c --line=2 --stdin --inject-at-end

	return 0
)
function echo_inject() (
	source "$DOROTHY/sources/stdinargs.bash"

	# =====================================
	# Arguments

	function help {
		cat <<-EOF >&2
			ABOUT:
			Inject the <inject-content> at the <line-number> of <stdin>.

			USAGE:
			echo-lines ...<input> | echo-inject-at-line [...options]

			OPTIONS:
			--inject=<inject-content>
			    The content to be injected

			--line=<line-number>
			    The line number to inject the <inject-content> at.

			--no-trailing-newline | --no-trailing-newlines
			    Do not add a trailing newline to the <inject-content>.
			    If <inject-at-end>, the trailing newline will only be added if the last line of <stdin> had a trailing newline.

			--missing=<required|inject-at-end|optional> | --required | --inject-at-end | --optional
			    The strategy to use if the <line-number> is not found. Defaults to <fail>.

			$(stdinargs_options_help --stdin)
		EOF
		if [[ $# -ne 0 ]]; then
			echo-error "$@"
		fi
		return 22 # EINVAL 22 Invalid argument
	}

	# process our own arguments, delegate everything else to stdinargs
	local -i option_line
	local item option_inject='' option_args=() option_trailing_newline=yes option_missing=required
	while [[ $# -ne 0 ]]; do
		item="$1"
		shift
		case "$item" in
		--help | -h) help ;;
		--missing=required | --required) option_missing=required ;;
		--missing=inject-at-end | --inject-at-end) option_missing='inject-at-end' ;;
		--missing=ignore | --optional) option_missing=optional ;;
		--no-trailing-newline* | --trailing-newline*) __flag --source={item} --target={option_trailing_newline} --affirmative --coerce ;;
		--inject=*) option_inject="${item#*=}" ;;
		--line=*) option_line="${item#*=}" ;;
		# forward to stdinargs, however support mixing and matching of our options, with stdinargs options
		--)
			option_args+=("$item" "$@")
			shift $#
			break
			;;
		--*) option_args+=("$item") ;;
		*) option_args+=("$item") ;;
		esac
	done

	__affirm_value_is_defined "$option_inject" '<inject-content>' || return
	__affirm_value_is_positive_integer "$option_line" '<line-number>' || return
	if [[ $option_line -eq 0 ]]; then
		echo-error "The <line-number> must be greater than 0, as line numbers start at 1." || return
		return 22 # EINVAL 22 Invalid argument
	fi

	# =================================
	# Action

	local found=no inline=no result=''
	local -i lines=0
	function __on_line {
		local input="$1"$'\n' inject="$option_inject"
		lines=$((lines + 1))
		if [[ $lines -eq option_line ]]; then
			if [[ $option_trailing_newline == 'yes' ]]; then
				inject="$inject"$'\n'
			fi
			input="$inject$input"
			found=yes
		fi
		result+="$input"
	}
	function __on_inline {
		local input="$1" inject="$option_inject"
		inline=yes
		lines=$((lines + 1))
		if [[ $lines -eq option_line ]]; then
			if [[ $option_trailing_newline == 'yes' ]]; then
				inject="$inject"$'\n'
			fi
			input="$inject$input"
			found=yes
		fi
		result+="$input"
	}
	function __on_finish {
		if [[ $found == 'no' ]]; then
			if [[ $option_missing == 'required' ]]; then
				echo-error "The <line-number> $option_line was not found in the input." || return
				return 33 # EDOM 33 Numerical argument out of domain
			elif [[ $option_missing == 'inject-at-end' ]]; then
				local inject="$option_inject"
				if [[ $inline == 'yes' ]]; then
					inject=$'\n'"$inject"
				elif [[ $option_trailing_newline == 'yes' ]]; then
					inject="$inject"$'\n'
				fi
				result+="$inject"
			fi
		fi
		__print_string "$result" || return
	}

	stdinargs "${option_args[@]}"
)

# fire if invoked standalone
if [[ $0 == "${BASH_SOURCE[0]}" ]]; then
	if [[ $* == '--test' ]]; then
		echo_inject_test
	else
		echo_inject "$@"
	fi
fi
