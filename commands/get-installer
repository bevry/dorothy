#!/usr/bin/env bash

function get_installer_test() (
	source "$DOROTHY/sources/bash.bash"
	echo-style --h1="TEST: $0"

	eval-tester -- get-installer --verify --quiet

	echo-style --g1="TEST: $0"
	return 0
)
function get_installer() (
	source "$DOROTHY/sources/bash.bash"

	# =====================================
	# Arguments

	function help {
		cat <<-EOF >&2
			ABOUT:
			Output the command(s) necessary to install the <utility>.

			USAGE:
			get-installer [...options] -- ...<utility>

			RETURNS:
			Success if all <utility> had an installer.
			Failure if any <utility> did not have an installer.

			OPTIONS:
			--invoke
			    Rather than output the installer, invoke it, such that installation occurs.

			--first-success
			    Exit on the first success, ignoring earlier failures.

			--first-failure
			    Exit on the first failure, skipping later utilities.

			--quiet
			    If invoke, forwarded to installer.
			    Otherwise, used to suppress missing installer error.

			--verify
			    Verify that the installers exist for the aliases. Useful only for testing.
		EOF
		if [[ $# -ne 0 ]]; then
			echo-error "$@"
		fi
		return 22 # EINVAL 22 Invalid argument
	}

	# process
	local item option_quiet='' option_verify='no' option_utils=() option_invoke='no' option_first_success='no' option_first_failure='no'
	while [[ $# -ne 0 ]]; do
		item="$1"
		shift
		case "$item" in
		'--help' | '-h') help ;;
		'--no-verbose'* | '--verbose'*)
			option_quiet="$(get-flag-value --non-affirmative --fallback="$option_quiet" -- "$item")"
			;;
		'--no-quiet'* | '--quiet'*)
			option_quiet="$(get-flag-value --affirmative --fallback="$option_quiet" -- "$item")"
			;;
		'--no-invoke'* | '--invoke'*)
			option_invoke="$(get-flag-value --affirmative --fallback="$option_invoke" -- "$item")"
			;;
		'--no-verify'* | '--verify'*)
			option_verify="$(get-flag-value --affirmative --fallback="$option_verify" -- "$item")"
			;;
		'--first-success'*) option_first_success='yes' ;;
		'--first-failure'*) option_first_failure='yes' ;;
		'--')
			option_utils+=("$@")
			shift "$#"
			break
			;;
		'--'*) help "An unrecognised flag was provided: $item" ;;
		*) option_utils+=("$item") ;;
		esac
	done

	# =====================================
	# Configuration

	# dependencies
	setup-util-jq --quiet

	# load aliases
	local database="$DOROTHY/config/installers.json" aliases=() installers=() alias installer
	while IFS=$'\t' read -r alias installer; do
		if [[ -z $alias || -z $installer ]]; then
			echo-style --stderr --code="$alias" ' => ' --code="$installer" ' ❌ ' --error='invalid database entry'
			continue
		fi
		aliases+=("$alias")
		installers+=("$installer")
	done < <(jq -r '.aliases | to_entries[] | [.key, .value] | @tsv' "$database")

	# =====================================
	# Testing

	# testing
	if [[ $option_verify == 'yes' ]]; then
		# test that the installers for the aliases actually exist
		# queue the log entries into echo-style to output all at once, as it turns it from like a minute into a second
		local index result=0 logs=()
		for index in "${!aliases[@]}"; do
			alias="${aliases[index]}"
			installer="${installers[index]}"
			if [[ "setup-util-$alias" == "$installer" ]]; then
				logs+=(--code="$alias" ' => ' --code="$installer" ' ❌ ' --error='no need for the alias' --newline)
				result=1
			elif __command_missing -- "$installer"; then
				logs+=(--code="$alias" ' => ' --code="$installer" ' ❌ ' --error='missing' --newline)
				result=1
			elif [[ $option_quiet == 'no' ]]; then
				logs+=(--code="$alias" ' => ' --code="$installer" ' ✅ ' --newline)
			fi
		done
		if [[ ${#logs[@]} -ne 0 ]]; then
			echo-style --no-trail --stderr "${logs[@]}"
		fi

		# sort all keys in the installers.json configuration file
		if __command_exists -- jq; then
			jq --sort-keys . "$database" | echo-write --atomic -- "$database"
		fi

		# return result
		return "$result"
	fi

	# =====================================
	# Action

	# check
	if [[ ${#option_utils[@]} -eq 0 ]]; then
		help 'No <utility>s specified.'
	fi

	# helpers
	function __get_alias {
		local util="$1"
		# trim version suffix
		# ruby@3 => ruby
		util="${util%%@*}"
		# trim tap prefix
		# clementtsang/bottom/bottom => bottom
		util="${util##*/}"
		# if util has a space character, then it must have flags or superfluous spaces, trim them
		if [[ $util == *' '* ]]; then
			# --classic code --classic => code
			# (^| ) matches either start of the line, or a space character
			# -[^ ]+ matches a dash followed by one or more non-space characters
			# so this is what converts the `--classic` flag into ``
			# then we trim whitespace at the start and end
			util="$(echo-regexp -g '(^| )-[^ ]+' '' -- "$util" | echo-trim-each-line --stdin)"
		fi
		# done
		__print_lines "$util"
		return
	}

	function __get_installer {
		local alias="$1" index
		for index in "${!aliases[@]}"; do
			if [[ $alias == "${aliases[index]}" ]]; then
				__print_lines "${installers[index]}"
				return
			fi
		done
		# alias not found, check if it exists normally
		echo-if-command-exists -- "setup-util-$alias"
		return
	}

	# handle each utility
	local util alias installer any_failure='no'
	for util in "${option_utils[@]}"; do
		# get the alias
		alias="$(__get_alias "$util")"
		if [[ -z $alias ]]; then
			continue
		fi

		# get the installer
		installer="$(__get_installer "$alias" || :)"
		if [[ -z $installer ]]; then
			any_failure='yes'
			if [[ $option_quiet != 'yes' ]]; then
				echo-style --stderr --notice1='No installer found for: ' --code-notice1="$util"
			fi
			if [[ $option_first_failure == 'yes' ]]; then
				return 1
			fi
		elif [[ $option_invoke == 'no' ]]; then
			__print_lines "$installer"
			if [[ $option_first_success == 'yes' ]]; then
				return 0
			fi
		elif "$installer" --quiet="$option_quiet"; then
			if [[ $option_first_success == 'yes' ]]; then
				return 0
			fi
		else
			any_failure='yes'
			if [[ $option_first_failure == 'yes' ]]; then
				return 1
			fi
		fi
	done

	# check for failures
	[[ $any_failure == 'no' ]] || return
)

# fire if invoked standalone
if [[ $0 == "${BASH_SOURCE[0]}" ]]; then
	if [[ $* == '--test' ]]; then
		get_installer_test
	else
		get_installer "$@"
	fi
fi
