#!/usr/bin/env bash

function get_installer_test() (
	source "$DOROTHY/sources/bash.bash"
	eval-tester --ignore-stderr --status=22 -- get-installer --help

	eval-tester -- get-installer --verify --quiet

	return 0
)
function get_installer() (
	source "$DOROTHY/sources/bash.bash"

	# =====================================
	# Arguments

	function help {
		__print_help "$@" <<-EOF || return $?
			ABOUT:
			Output the command(s) necessary to install the <utility>.

			USAGE:
			\`get-installer [...options] -- ...<utility>\`

			RETURNS:
			Success if all <utility> had an installer.
			Failure if any <utility> did not have an installer.

			OPTIONS:
			--invoke
			    Rather than output the installer, invoke it, such that installation occurs.

			--first-success
			    Exit on the first success, ignoring earlier failures.

			--first-failure
			    Exit on the first failure, skipping later utilities.

			--quiet
			    If invoke, forwarded to installer.
			    Otherwise, used to suppress missing installer error.

			--verify
			    Verify that the installers exist for the aliases. Useful only for testing.
		EOF
		return 22 # EINVAL 22 Invalid argument
	}

	# process
	local item option_quiet='' option_verify='no' option_utils=() option_invoke='no' option_first_success='no' option_first_failure='no'
	while [[ $# -ne 0 ]]; do
		item="$1"
		shift
		case "$item" in
		'--help' | '-h') help ;;
		'--no-verbose'* | '--verbose'*) __flag --source={item} --target={option_quiet} --non-affirmative ;;
		'--no-quiet'* | '--quiet'*) __flag --source={item} --target={option_quiet} --affirmative ;;
		'--no-invoke'* | '--invoke'*) __flag --source={item} --target={option_invoke} --affirmative ;;
		'--no-verify'* | '--verify'*) __flag --source={item} --target={option_verify} --affirmative ;;
		'--first-success'*) option_first_success='yes' ;;
		'--first-failure'*) option_first_failure='yes' ;;
		'--')
			option_utils+=("$@")
			shift "$#"
			break
			;;
		'--'*) help 'An unrecognised flag was provided: ' --variable-value={item} ;;
		*) option_utils+=("$item") ;;
		esac
	done

	# =====================================
	# Configuration

	# load aliases
	local database="$DOROTHY/config/installers.dat" aliases=() installers=() alias installer
	while IFS=' ' read -rd $'\n' alias installer; do
		if [[ -z $alias && -z $installer ]]; then
			# skip empty lines
			continue
		fi
		if [[ -z $alias || -z $installer ]]; then
			# if one of them is missing, then it's an invalid line
			__print_style --stderr --code="$alias" ' => ' --code="$installer" ' ❌ ' --error='invalid database entry'
			continue
		fi
		# both are present, it is a valid line
		aliases+=("$alias")
		installers+=("$installer")
	done <"$database"

	# =====================================
	# Testing

	# testing
	if [[ $option_verify == 'yes' ]]; then
		# test that the installers for the aliases actually exist
		# queue the log entries to output all at once, as it turns it from like a minute into a second
		local index result=0 logs=()
		for index in "${!aliases[@]}"; do
			alias="${aliases[index]}"
			installer="${installers[index]}"
			if [[ "setup-util-$alias" == "$installer" ]]; then
				logs+=(--code="$alias" ' => ' --code="$installer" ' ❌ ' --error='no need for the alias' --newline)
				result=1
			elif __command_missing -- "$installer"; then
				logs+=(--code="$alias" ' => ' --code="$installer" ' ❌ ' --error='missing' --newline)
				result=1
			elif [[ $option_quiet == 'no' ]]; then
				logs+=(--code="$alias" ' => ' --code="$installer" ' ✅ ' --newline)
			fi
		done
		if [[ ${#logs[@]} -ne 0 ]]; then
			__print_style --no-trail --stderr "${logs[@]}"
		fi

		# return result
		return "$result"
	fi

	# =====================================
	# Action

	# check
	if [[ ${#option_utils[@]} -eq 0 ]]; then
		help --help='No <utility>s specified.'
	fi

	# helpers
	function __get_alias {
		local util="$1"
		# trim version suffix
		# ruby@3 => ruby
		util="${util%%@*}"
		# trim tap prefix
		# clementtsang/bottom/bottom => bottom
		util="${util##*/}"
		# if util has a space character, then it must have flags or superfluous spaces, trim them
		if [[ $util == *' '* ]]; then
			# --classic code --classic => code
			# (^| ) matches either start of the line, or a space character
			# -[^ ]+ matches a dash followed by one or more non-space characters
			# so this is what converts the `--classic` flag into ``
			# then we trim whitespace at the start and end
			util="$(echo-regexp -g '(^| )-[^ ]+' '' -- "$util" | echo-trim-each-line --stdin)" || return $?
		fi
		# done
		__print_lines "$util" || return $?
	}

	function __get_installer {
		local alias="$1" index
		for index in "${!aliases[@]}"; do
			if [[ $alias == "${aliases[index]}" ]]; then
				__print_lines "${installers[index]}" || return $?
				return 0
			fi
		done
		# alias not found, check if it exists normally
		echo-if-command-exists -- "setup-util-$alias" || return $?
	}

	# handle each utility
	local util alias installer any_failure='no'
	for util in "${option_utils[@]}"; do
		# get the alias
		alias="$(__get_alias "$util")" || return $?
		if [[ -z $alias ]]; then
			continue
		fi

		# get the installer
		installer="$(__get_installer "$alias" || :)"
		if [[ -z $installer ]]; then
			any_failure='yes'
			if [[ $option_quiet != 'yes' ]]; then
				__print_style --stderr --notice1='No installer found for: ' --code-notice1="$util" || return $?
			fi
			if [[ $option_first_failure == 'yes' ]]; then
				return 1
			fi
		elif [[ $option_invoke == 'no' ]]; then
			__print_lines "$installer" || return $?
			if [[ $option_first_success == 'yes' ]]; then
				return 0
			fi
		elif "$installer" --quiet="$option_quiet"; then
			if [[ $option_first_success == 'yes' ]]; then
				return 0
			fi
		else
			any_failure='yes'
			if [[ $option_first_failure == 'yes' ]]; then
				return 1
			fi
		fi
	done

	# check for failures
	[[ $any_failure == 'no' ]] || return $?
)

# fire if invoked standalone
if [[ $0 == "${BASH_SOURCE[0]}" ]]; then
	if [[ $* == '--test' ]]; then
		get_installer_test
	else
		get_installer "$@"
	fi
fi
