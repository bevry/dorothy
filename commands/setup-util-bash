#!/usr/bin/env bash

# https://repology.org/project/bash/versions
# https://ftp.gnu.org/gnu/bash/?C=M;O=D

function setup_util_bash() (
	source "$DOROTHY/sources/bash.bash"
	# imports:
	# IS_BASH_VERSION_OUTDATED
	# BASH_VERSION_CURRENT
	# BASH_VERSION_LATEST
	# BASH_VERSIONS_SUPPORTED

	local item versions=() util_options=()
	while [[ $# -ne 0 ]]; do
		item="$1"
		shift
		case "$item" in
		--all | --av | --all-versions | --all-bash-versions) versions+=("${BASH_VERSIONS_SUPPORTED[@]}") ;;
		--v=* | --version=* | --versions=* | --bash-version=* | --bash-versions=*) __split --target={versions} --append --no-zero-length --delimiters=$'\n\t ,|' -- "${item#*=}" ;;
		*) util_options+=("$item") ;;
		esac
	done
	set -- "${util_options[@]}"

	# setup bash
	if [[ ${#versions[@]} -ne 0 ]]; then
		# convert short versions into preferred versions
		local index
		for index in "${!versions[@]}"; do
			item="${versions[index]}"
			versions[index]="$(__get_coerced_bash_version "$item")" || return
		done

		# this block offers no benefit as it is already fast enough
		# # improve performance for detectable utilities with conditional assets
		# # don't use setup_util as it is conditional
		# local check_all=yes
		# for version in "${versions[@]}"; do
		# 	if ! setup-util --check --cli="bash-$version" "$@"; then
		# 		check_all=no
		# 	fi
		# done
		# if [[ $check_all == yes ]]; then
		# 	return 0
		# fi

		# enable DOWNLOAD_BUILD_INSTALL
		source "$(type -P setup-util)"

		# @todo support uninstall

		# https://www.gnu.org/prep/ftp.html
		# try mirrors first as they are faster, then fallback to main site
		function __download_bash_version_patch {
			local version="$1" patch="$2"
			down --url="https://ftpmirror.gnu.org/gnu/bash/bash-${version}-patches/${patch}" --file="$patch" || \
				down --url="https://ftp.gnu.org/gnu/bash/bash-${version}-patches/${patch}" --file="$patch" || return
		}
		function __fetch_bash_version_patches {
			local version="$1"
			fetch "https://ftpmirror.gnu.org/gnu/bash/bash-${version}-patches/" || \
				fetch "https://ftp.gnu.org/gnu/bash/bash-${version}-patches/" || return
		}
		function __get_bash_version_patches {
			# https://github.com/bevry/dorothy/actions/runs/18237950922/job/51935016858#step:2:1816
			# some mirrors have two <a> tags:
			# https://ftp.wayne.edu/gnu/bash/bash-5.0-patches/
            # <td valign="top">
            #     <a href="bash50-001">
            #         <img src="/icons/text.gif" alt="[TXT]">
            #     </a>
            # </td>
            # <td>
            #     <a href="bash50-001">bash50-001</a>
            # </td>
			# https://ftp.gnu.org/gnu/bash/bash-5.0-patches/
			# <td valign="top">
            #     <img src="/icons/unknown.gif" alt="[   ]">
            # </td>
            # <td>
            #     <a href="bash50-001">bash50-001</a>
            # </td>
			# so send to `echo-unique` rather than complicating our filter
			# also send to `sort`, as depending on the mirror, a different sort order will be returned, and they must be sorted by ascending name
			local version="$1"
			__fetch_bash_version_patches "$version" | echo-regexp -gno --regexp='href="(bash[^"]+)' --replace='$1' | grep --invert-match --regexp='\.sig$' | echo-unique --stdin | sort || return
		}
		function do_install {
			# dependencies
			setup-util-devel --quiet
			setup-util --quiet --cli='yacc' APT='byacc' BREW='byacc'
			source "$DOROTHY/sources/environment.sh"
			# patches
			local version
			# don't look to ./configure as that is only minor version, and we want the patch version, which should be in the path
			# version="$(echo-regexp -o --regexp='BASHVERS=(.+)' --replace='$1' <./configure)" || return
			version="$(pwd | echo-regexp -o --regexp='/bash-([^/]+)/' --replace='$1' || :)"
			# if it isn't in the path, then it we aren't doing a versioned download, and just getting the latest, so use that
			if [[ -z $version ]]; then
				version="$BASH_VERSION_LATEST"
			fi
			# if the version has a patch, we don't need to patch
			if [[ $version == *.*.* ]]; then
				__print_style --stderr --bold='Bash version ' --code="$version" --bold=' is already patched.'
			else
				# use ftp.gnu.org for fetching the listing, then use mirrors for fetching the mirrors
				# mirrors sometimes are not reliable with duplicate data or missing items
				local patches=() patch patch_content
				__split --target={patches} --no-zero-length --invoke=try -- \
					__get_bash_version_patches "$version" || return
				for patch in "${patches[@]}"; do
					# if the mirror fails, then fallback to the main site, and if that fails, then give up
					__download_bash_version_patch "$version" "$patch" || return
					patch --input="$patch" -p0 # p0 is necessary for linux builds
				done
			fi
			# compile
			./configure CFLAGS="-DSSH_SOURCE_BASHRC ${CFLAGS-}" CPPFLAGS="-w -Wno-error=all ${CPPFLAGS-}" LDFLAGS="-s ${LDFLAGS-}"
			make
		}
		for version in "${versions[@]}"; do
			options=(
				--cli="bash-$version"
				--order='download'
				"$@"
				DOWNLOAD="https://ftpmirror.gnu.org/gnu/bash/bash-${version}.tar.gz"
				DOWNLOAD_ARCHIVE_FORMAT='tar'
				DOWNLOAD_ARCHIVE_GLOB='bash-*/*'
				DOWNLOAD_BUILD_INSTALL='do_install'
				DOWNLOAD_BUILD_GLOB='bash'
			)
			setup_util --optional "${options[@]}"
		done
		return 0
	fi

	# improve performance for detectable utilities with conditional assets
	# don't use setup_util as it is conditional
	if [[ $IS_BASH_VERSION_OUTDATED == 'no' && ${RELOADED_IN_SYSTEM_BASH-} != 'yes' ]] && setup-util --check --cli=bash "$@"; then
		return 0
	fi

	# enable DOWNLOAD_BUILD_INSTALL
	source "$(type -P setup-util)"

	# check if we are macos, in which we need special handling
	if [[ ${RELOADED_IN_SYSTEM_BASH-} != 'yes' ]]; then
		if __has --any --needle='--upgrade' --needle='--uninstall' -- "$@"; then
			# upgrading or uninstalling
			if is-mac && [[ -x '/bin/bash' ]] && brew-installed --formula --quiet -- bash; then
				# reload in system bash to prevent brew's upgrade/uninstall from crashing us
				env RELOADED_IN_SYSTEM_BASH=yes /bin/bash "${BASH_SOURCE[0]}" "$@"
				return
			fi
		else
			# not upgrading nor uninstalling
			if [[ $IS_BASH_VERSION_OUTDATED == 'yes' ]]; then
				# bash is terribly outdated
				if is-mac && [[ -x '/bin/bash' ]]; then
					# run in system bash to prevent possible upgrade crash
					env RELOADED_IN_SYSTEM_BASH=yes /bin/bash "${BASH_SOURCE[0]}" --upgrade "$@"
					return
				else
					# run ourself again with upgrade
					env RELOADED_IN_SYSTEM_BASH=yes "${BASH_SOURCE[0]}" --upgrade "$@"
					return
				fi
			fi
		fi
	fi

	# process
	local bottle_url='' macos_release arch options=(
		--cli='bash'
		"$@"
		APK='bash' # ALPINE
		APT='bash' # UBUNTU
		AUR='bash' # ARCH
		BREW='bash'
		EMERGE='app-shells/bash' # GENTOO
		NIX='nixpkgs.bash'
		RPM='bash'    # FEDORA
		URPMI='bash'  # MAGEIA
		XBPS='bash'   # VOID
		ZYPPER='bash' # SUSE
	)
	function do_install {
		# dependencies
		if ! is-mac; then
			setup-util-devel --quiet
			source "$DOROTHY/sources/environment.sh"
		fi

		# install for all users
		# support unbounded flags, as empty from [setup-environment-commands] then it will remain unbounded
		# https://www.gnu.org/software/bash/manual//html_node/Installation-Names.html
		# https://www.gnu.org/software/bash/manual//html_node/Compilers-and-Options.html
		./configure CFLAGS="-DSSH_SOURCE_BASHRC ${CFLAGS-}" CPPFLAGS="-w -Wno-error=all ${CPPFLAGS-}" LDFLAGS="-s ${LDFLAGS-}"
		make install prefix="$XDG_PREFIX"
	}
	function do_uninstall {
		# the configure is necessary to make [make uninstall] available
		if ! is-mac; then
			setup-util-devel --quiet
			source "$DOROTHY/sources/environment.sh"
		fi
		./configure CFLAGS="-DSSH_SOURCE_BASHRC ${CFLAGS-}" CPPFLAGS="-w -Wno-error=all ${CPPFLAGS-}" LDFLAGS="-s ${LDFLAGS-}"
		make uninstall prefix="$XDG_PREFIX"
	}
	arch="$(get-arch)"
	if is-mac; then
		# fetch the bottle urls via: brew info --json bash | jq -r '.[].bottle.stable.files'
		macos_release="$(get-macos-release-name)"
		if [[ $arch == 'a64' ]]; then
			if [[ $macos_release == 'sequoia' ]]; then
				bottle_url='https://ghcr.io/v2/homebrew/core/bash/blobs/sha256:066b7eba204091b70860d2f17d0dd65201900b3e3ca32de87a746ed1baf13332'
			elif [[ $macos_release == 'sonoma' ]]; then
				bottle_url='https://ghcr.io/v2/homebrew/core/bash/blobs/sha256:bd484090760c2736fa30e29a7861aaf115330bfb10178ce398e1f927a056a047'
			elif [[ $macos_release == 'ventura' ]]; then
				bottle_url='https://ghcr.io/v2/homebrew/core/bash/blobs/sha256:f3a42b9282e6779504034485634a2f3e6e3bddfc70b9990e09e66e3c8c926b7d'
			elif [[ $macos_release == 'monterey' ]]; then
				bottle_url='https://ghcr.io/v2/homebrew/core/bash/blobs/sha256:5e7e3e3387fc60e907683b437ac6e64879e117a3c5c1421fe6e6257f6aaa3c69'
			elif [[ $macos_release == 'big_sur' ]]; then
				bottle_url='https://ghcr.io/v2/homebrew/core/bash/blobs/sha256:d19858831275271cc8aa9a1a28de6223faa44c6ebbc88e83898fd559de5b627e'
			fi
		elif [[ $arch == 'x64' ]]; then
			if [[ $macos_release == 'sonoma' ]]; then
				bottle_url='https://ghcr.io/v2/homebrew/core/bash/blobs/sha256:354e107695c01f1b970174487d0f5e501774c485b60e13f95141884b31ba883d'
			elif [[ $macos_release == 'ventura' ]]; then
				bottle_url='https://ghcr.io/v2/homebrew/core/bash/blobs/sha256:fd01a9dbdc56f6313a725cb345a3b991cfdaa9e1a91b08fd9791a0e695b55723'
			elif [[ $macos_release == 'monterey' ]]; then
				bottle_url='https://ghcr.io/v2/homebrew/core/bash/blobs/sha256:05a5f9435c9e9ffe8377b03e0ca6b27bbb32cc01aff47dd1692cd8d7e735ab3a'
			elif [[ $macos_release == 'big_sur' ]]; then
				bottle_url='https://ghcr.io/v2/homebrew/core/bash/blobs/sha256:680dd3b37e17cc4fa1af6dd8c51c774dd0c9aa3e594e96527020845516b1ea77'
			fi
		fi
	fi # don't use linux bottle, as linux is too varied, and doesn't work on opensuse/leap: https://github.com/bevry/dorothy/actions/runs/6048593518/job/16414257095
	if [[ -n $bottle_url ]] && fetch --bearer-token='QQ==' --ok "$bottle_url"; then
		options+=(
			DOWNLOAD="$bottle_url"
			DOWNLOAD_BEARER_TOKEN='QQ=='
			DOWNLOAD_ARCHIVE_FORMAT='tar'
			DOWNLOAD_ARCHIVE_GLOB='bash/*/bin/bash'
		)
	else
		options+=(
			DOWNLOAD="https://ftpmirror.gnu.org/gnu/bash/bash-${BASH_VERSION_LATEST}.tar.gz"
			DOWNLOAD_ARCHIVE_FORMAT='tar'
			DOWNLOAD_ARCHIVE_GLOB='bash-*/*'
			DOWNLOAD_TARGET_PATH="$XDG_PREFIX/bin/bash"
			DOWNLOAD_BUILD_INSTALL='do_install'
			DOWNLOAD_BUILD_UNINSTALL='do_uninstall'
		)
	fi
	setup_util "${options[@]}"

	# check if the updated bash outdated, if so, install via building instead
	# this works as it is new invocation so has refreshed env vars inside it
	if is-bash-version-outdated --quiet; then
		options+=(
			--upgrade
			--order='download ...'
		)
		setup_util "${options[@]}"
	fi

	# setup bash completions
	# https://github.com/scop/bash-completion
	options=(
		--optional
		--no-fallback
		--name='Bash Completions'
		"$@"
		APK='bash-completion' # ALPINE
		APT='bash-completion' # UBUNTU
		AUR='bash-completion' # ARCH
		BREW='bash-completion'
		RPM='bash-completion'    # FEDORA
		ZYPPER='bash-completion' # SUSE
	)
	setup_util "${options[@]}"

	# if we are reactive, allow shell modification
	if [[ $IS_STDIN_OPENED_ON_TERMINAL == 'yes' ]]; then
		# if the login shell is outdated bash, and if the new bash is installed, then update the login shell to the newer bash
		# @todo figure out how this works if login shell is the now uninstall bash
		local login_shell bash_shell
		login_shell="${SHELL-}"
		bash_shell="$(type -P bash)"
		if [[ -n $login_shell ]]; then
			login_shell_name="$(basename -- "$login_shell")"
			if [[ $login_shell_name == 'bash' && $login_shell != "$bash_shell" ]]; then
				login_shell_version="$("$login_shell" -c -- 'printf "%s\n" "$BASH_VERSION"')"
				bash_shell_version="$("$bash_shell" -c -- 'printf "%s\n" "$BASH_VERSION"')"
				if [[ $login_shell_version != "$bash_shell_version" ]]; then
					if confirm --positive --ppid=$$ -- "Upgrade your login shell from bash $login_shell $login_shell_version to $bash_shell $bash_shell_version ?"; then
						setup-shell "$bash_shell"
					fi
				fi
			fi
		fi
	fi
)

# fire if invoked standalone
if [[ $0 == "${BASH_SOURCE[0]}" ]]; then
	setup_util_bash "$@"
fi
