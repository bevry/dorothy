#!/usr/bin/env bash

# perl implementation at: https://gist.github.com/balupton/3fb310653b9c9b727c896c631093c4b7
# removed as it requires a JSON module to be bundled:
# Can't locate JSON.pm in @INC (you may need to install the JSON module) (@INC entries checked: /opt/homebrew/opt/perl/lib/perl5/site_perl/5.40/darwin-thread-multi-2level /opt/homebrew/opt/perl/lib/perl5/site_perl/5.40 /opt/homebrew/opt/perl/lib/perl5/5.40/darwin-thread-multi-2level /opt/homebrew/opt/perl/lib/perl5/5.40 /opt/homebrew/lib/perl5/site_perl/5.40/darwin-thread-multi-2level /opt/homebrew/lib/perl5/site_perl/5.40) at /Users/runner/.local/share/dorothy/commands/echo-json.pl line 5.
# BEGIN failed--compilation aborted at /Users/runner/.local/share/dorothy/commands/echo-json.pl line 5.

function echo_json_test() (
	source "$DOROTHY/sources/bash.bash"

	local inputs=(
		'hello'
		'hello world'
		'true'
		'{"key":  true}'
		'{"key":  true} asd'
	)
	local strings=(
		'"hello"'
		'"hello world"'
		'"true"'
		'"{\"key\":  true}"'
		'"{\"key\":  true} asd"'
	)
	local encodes=(
		'"hello"'
		'"hello world"'
		'true'
		'{"key":true}'
		'"{\"key\":  true} asd"'
	)
	local decodes=(
		'hello'
		'hello world'
		'true'
		'{"key":true}'
		'{"key":  true} asd'
	)

	local all_tools=('' deno nu jq ruby) tool index input string encode decode
	for tool in "${all_tools[@]}"; do
		for index in "${!inputs[@]}"; do
			input="${inputs[index]}"
			string="${strings[index]}"
			encode="${encodes[index]}"
			decode="${decodes[index]}"
			eval-tester --stdout="$string" --ignore-tty --ignore-stderr -- \
				echo-json --stringify --tool="$tool" -- "$input"
			eval-tester --stdout="$encode" -- \
				echo-json --encode --tool="$tool" -- "$input"
			eval-tester --stdout="$decode" -- \
				echo-json --decode --tool="$tool" -- "$input"
		done
	done

	return 0
)
function echo_json() (
	source "$DOROTHY/sources/stdinargs.bash"
	local all_tools=(deno nu jq ruby) actions=(make stream stringify encode decode json pretty table csv tsv)

	# =====================================
	# Arguments

	function __help {
		__print_help "$@" <<-EOF || return $?
			ABOUT:
			For each input, stringify, encode or decode JSON.

			USAGE:
			\`echo-json <action> [--] ...<input>\`
			\`echo-lines ...<input> | echo-json <action>\`

			OPTIONS:
			make | --make | --action=make -- ...[<key> <value>]
			    Render a minified JSON object out of the ...[<key> <value>] arguments.
			    Rejects STDIN.
			    - \`...[<key> <value>]\` becomes \`{"key":"value",...}\`

			stream | --stream | --action=stream
			    Parse STDIN <input> as individual JSON-encoded values, and output as a minified JSON-encoded array.
			    Rejects arguments. Enforces <tool:jq>.
			    - \`'{"a": 1}'\` then \`'{"b": 2}'\` becomes \`{"a":1,"b":2}\`

			stringify | --stringify | --action=stringify
			    Render <input> as a JSON-encoded JSON-string.
			    - \`true\` becomes \`"true"\`
			    - \`hello\` becomes \`"hello"\`
			    - \`"hello"\` becomes \`"\\"hello\\""\`
			    - \`{"key":  "value"}\` becomes \`"{\\"key\\":  \\"value\\"}"\`

			encode | --encode | --action=encode
			    Render <input> as a minified JSON-encoded value.
			    <input> that were already JSON-encoded, will remain JSON-encoded.
			    - \`true\` remains \`true\` (was JSON-encoded, so is retained)
			    - \`hello\` becomes \`"hello"\`
			    - \`"hello"\` remains \`"hello"\` (was JSON-encoded, so is retained)
			    - \`{"key":  "value"}\` becomes \`{"key":"value"}\` (was JSON-coded, so is retained however minified)

			decode | --decode | --action=decode
			    Render <input> as a minified JSON-decoded value.
			    <input> that were already not JSON-encoded, will remain JSON-decoded.
			    - \`true\` remains \`true\`
			    - \`hello\` remains \`hello\` (was not JSON-encoded, so is retained)
			    - \`"hello"\` becomes \`hello\`
			    - \`{"key":  "value"}\` becomes \`{"key":"value"}\` (minified)

			json | --json | --action=json
			    Parse JSON-encoded <input> and render as minified JSON.
			pretty | --pretty | --action=pretty
			    Parse JSON-encoded <input> and render prettily in a format native to the <tool>.
			table | --table | --action=table
			    Parse JSON-encoded <input> and render as a table.
			    Enforces <tool:nu>.
			csv | --csv | --action=csv
			    Parse JSON-encoded <input> and render as CSV.
			    Enforces <tool:nu>.
			tsv | --tsv | --action=tsv
			    Parse JSON-encoded <input> and render as TSV.
			    Enforces <tool:nu>.

			--tool=<tool:$(__join --source={all_tools} --delimiter='|')|?>
			    The tool to use. Use \`?\` to prompt. Default is the first available tool.

			$(__stdinargs__help_options --)
		EOF
		return 22 # EINVAL 22 Invalid argument
	}

	# process our own arguments, delegate everything else to stdinargs
	local item option_action='' option_tool=''
	while [[ $# -ne 0 ]]; do
		item="$1"
		shift
		case "$item" in
		--help | -h) __help ;;
		--action=* | --operation=*) option_action="${item#*=}" ;;
		--tool=*) option_tool="${item#*=}" ;;
		# forward to stdinargs, however support mixing and matching of our options, with stdinargs options
		--)
			option_args+=("$item" "$@")
			shift $#
			break
			;;
		*)
			local potential_action
			if [[ $item == --* ]]; then
				potential_action="${item#*--}"
			else
				potential_action="$item"
			fi
			if [[ $potential_action == '?' ]] || __has --source={potential_action} --any -- "${actions[@]}"; then
				option_action="$potential_action"
			elif [[ $item == --* ]]; then
				option_args+=("$item")
			else
				__help 'You must provide a valid <action>' --newline --variable={item} --newline --variable={actions}
			fi
			;;
		esac
	done

	# ensure action
	if [[ $option_action == '?' ]]; then
		option_action="$(choose --required 'Which action to perform?' -- "${actions[@]}")"
	elif [[ -z $option_action ]] || ! __has --source={option_action} --any -- "${actions[@]}"; then
		__help 'You must provide a valid <action>' --newline --variable={option_action} --newline --variable={actions}
	fi

	# tool aliases
	case $option_tool in
	'typescript' | 'ts' | 'js' | 'javascript') option_tool='deno' ;;
	'rb') option_tool='ruby' ;;
	'nushell') option_tool='nu' ;;
	esac

	# enforce tool
	case "$option_action" in
	stream) option_tool='jq' ;;
	table | csv | tsv) option_tool='nu' ;;
	esac

	# ensure tool
	__tool --tool={option_tool} --tools={all_tools} --help={__help} || return $?

	# tool to script
	local script
	case "$option_tool" in
	deno) script="$(type -P echo-json.ts)" ;;
	nu) script="$(type -P echo-json.nu)" ;;
	jq) script='jq' ;; # for jq, we'll handle it specially in the on_line function
	ruby) script="$(type -P echo-json.rb)" ;;
	*) __help 'An unrecognised tool was provided: ' --variable-value={option_tool} || return $? ;;
	esac

	# =====================================
	# Action

	# For jq stringify, treat input as raw string and output as JSON string
	# -R: Read raw input (don't parse as JSON)
	# -s: Slurp entire input into a single string
	# -M: Monochrome output (no colors)
	# @json: Format as JSON string
	if [[ $script == 'jq' ]]; then
		case "$option_action" in
		make)
			# Render a JSON object out of the ...[<key> <value>] arguments.
			local inputs=()
			function on_stdin { __help '<stdin> is not supported with <make>' || return $?; }
			function on_argument { inputs+=("$1"); }
			function on_finish {
				if [[ $script == 'jq' ]]; then
					jq -n --args 'reduce (range(0; ($ARGS.positional | length); 2)) as $i ({}; . + { ($ARGS.	positional[$i]): $ARGS.positional[$i+1] })' -- "${inputs[@]}" || return $?
				else
					"$script" "$option_action" -- "${inputs[@]}"
				fi
			}
			;;
		stream)
			# Parse STDIN <input> as individual JSON-encoded values, and output as a JSON-encoded array.
			# supporting streaming json is difficult, as it actually supports multiline JSON strings, so requires a proper parser that can handle it
			function on_stdin { jq -s '.' || return $?; }
			function on_argument { __help '<stdin> is not supported for <stream> with <jq>' || return $?; }
			;;
		stringify) function on_whole {
			__print_string "$1" | jq -RsM '.' || return $?
		} ;;
		encode) function on_whole {
			local stdout status
			__do --redirect-status={status} --redirect-stdout={stdout} --discard-stderr -- \
				jq -rM '@json' < <(__print_string "$1") # use process substitution to not create a pipe subshell
			if [[ $status == 0 ]]; then
				__print_lines "$stdout"
			else
				__print_string "$1" | jq -RsM '.'
			fi
		} ;;
		decode) function on_whole {
			local stdout status
			__do --redirect-status={status} --redirect-stdout={stdout} --discard-stderr -- \
				jq -crM '.' < <(__print_string "$1") # use process substitution to not create a pipe subshell
			if [[ $status == 0 ]]; then
				__print_string "$stdout" # it was valid JSON
			else
				__print_string "$1" # it's was just a string
			fi
		} ;;
		json) function on_whole {
			__print_string "$1" | jq -r '.' || return $?
		} ;;
		pretty) function on_whole {
			__print_string "$1" | jq '.' || return $?
		} ;;
		esac
	elif [[ $option_tool == 'nu' ]]; then
		# nushell doesn't support doubledash and args that start with a dash, so prefix each arg with a colon
		local inputs=()
		function on_whole { inputs+=(":$1"); }
		function on_finish { "$script" "$option_action" "${inputs[@]}" || return $?; }
	else
		local inputs=()
		function on_whole { inputs+=("$1"); }
		function on_finish { "$script" "$option_action" -- "${inputs[@]}" || return $?; }
	fi

	stdinargs "${option_args[@]}"
)

# fire if invoked standalone
if [[ $0 == "${BASH_SOURCE[0]}" ]]; then
	if [[ $* == '--test' ]]; then
		echo_json_test
	else
		echo_json "$@"
	fi
fi
