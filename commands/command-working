#!/usr/bin/env bash

function command_working_test() (
	source "$DOROTHY/sources/bash.bash"
	eval-tester --ignore-stderr --status=22 -- command-working --help

	eval-tester --status=3 --stderr="< this-is-a-non-existent-command />[3] not working because it is missing" -- \
		command-working --no-color -- this-is-a-non-existent-command

	eval-tester --status=3 --stderr="< this-is-a-non-existent-command />[3] not working because it is missing" -- \
		command-working --no-color -- this-is-a-non-existent-command command-missing

	eval-tester -- \
		command-working -- command-exists

	eval-tester -- \
		command-working -- command-exists command-missing

	return 0
)
function command_working() (
	source "$DOROTHY/sources/bash.bash"

	# exceptions are all commands that do not respond to a version or help query
	# https://github.com/greymd/teip/issues/29
	# https://trunkcommunity.slack.com/archives/C0205B6KK8X/p1661601215325159
	# @todo consider searching instead of `Usage: ` as most of the time they give back usage errors
	local exceptions=(
		dash
		find
		gsed
		ksh
		mount.fuse
		rmtrash
		rpi-update
		sed
		sginfo
		ssh
		ssh-askpass
		sshd
		teip
		trash
		trunk
		xargs
	)

	# =====================================
	# Arguments

	function help {
		__print_help "$@" <<-EOF || return $?
			ABOUT:
			Check if <command>s are available and working.

			USAGE:
			\`command-working [...options] [--] ...<command>\`

			OPTIONS:
			--elevated=<elevated>
			--elevate=<elevate>
			--user=<user>
			--group=<group>
			--reason=<reason>
			    Forwarded to \`eval-helper\`.

			RETURNS:
			Returns on first failure.
			[0] if ALL commands are working
			[1] if the first failure was due to the command not working
			[3] if the first failure was due to the command not existing

			QUIRKS:
			Working check is done via checking for success cases of:
			* \`<command> --version\`
			* \`<command> version\`
			* \`<command> --help\`
			* \`<command> -h\`

			Not all commands support such checks, such as those known below, in which case such checks will be avoided and only an executable check will occur:
			$(__join --source={exceptions} --between=', ' --style=code)

			Some commands require special handling, as detailed below:
			* \`ffmpeg\` checks with \`-version\`
		EOF
		return 22 # EINVAL 22 Invalid argument
	}

	# process
	local item option_commands=() option_elevated='' option_elevate='' option_user='' option_group='' option_reason='Your password is required to momentarily grant privileges to validate that this command is available and working:'
	while [[ $# -ne 0 ]]; do
		item="$1"
		shift
		case "$item" in
		'--help' | '-h') help ;;
		'--no-color'* | '--color'*) __flag --source={item} --target={COLOR} --affirmative --export ;;
		# <elevate>
		'--elevated='*) option_elevated="${item#*=}" ;;
		'--no-elevate'* | '--elevate'*) __flag --source={item} --target={option_elevate} --affirmative --no-coerce ;;
		'--user='*) option_user="${item#*=}" ;;
		'--group='*) option_group="${item#*=}" ;;
		'--reason='*) option_reason="${item#*=}" ;;
		# </elevated>
		'--')
			option_commands+=("$@")
			shift "$#"
			break
			;;
		'--'*) help 'An unrecognised flag was provided: ' --variable-value={item} ;;
		*) option_commands+=("$item") ;;
		esac
	done

	# ensure elevate is a valid value
	if [[ -n $option_user || -n $option_group ]]; then
		option_elevate='yes'
	fi

	# check
	if [[ ${#option_commands[@]} -eq 0 ]]; then
		help --help='No <command>s provided.'
	fi

	# =====================================
	# Helpers

	local failures=()
	function __check_status {
		local cmd=() cmd_string cmd_exit_status cmd_output
		# ensure sbin commands work
		if [[ $* == *sbin* || $option_elevate == 'yes' ]]; then
			cmd+=(
				eval-helper
				--elevated="$option_elevated"
				--elevate="$option_elevate"
				--user="$option_user"
				--group="$option_group"
				--reason="$option_reason"
				--
			)
		fi
		# continue with the command
		cmd+=("$@")
		# run the command hiding the output
		__do --redirect-status={cmd_exit_status} --redirect-output={cmd_output} -- command "${cmd[@]}" || return $? # eval
		# check for correct failure codes
		if [[ $cmd_exit_status -eq 22 || $cmd_exit_status -eq 200 ]]; then
			return 0
		else
			# @todo check for wrong architecture code, in which all the other checks will fail, e.g.
			# `cannot execute binary file: Exec format error`
			# exit status: 126

			# otherwise return success or failure code
			cmd_string="$(echo-escape-command -- "${cmd[@]}")" || return $?
			if [[ -n $cmd_output ]]; then
				cmd_output+=$'\n'
			fi
			local styled
			styled="$(__print_style --element+red="$cmd_string" $'\n' "$cmd_output" --/element+red="$cmd_string" --status="$cmd_exit_status")" || return $?
			failures+=("$styled")
			return "$cmd_exit_status"
		fi
	}
	function __check_cmd {
		local cmd_path="$1"
		if [[ $cmd_path == */ffmpeg ]]; then
			__check_status "$cmd_path" -version || return $?
		else
			__check_status "$cmd_path" --version ||
				__check_status "$cmd_path" version ||
				__check_status "$cmd_path" --help ||
				__check_status "$cmd_path" -h || return $?
		fi
	}
	function __check_working {
		# reset debug
		failures=()

		# check it exists first
		local cmd_path cmd_string
		cmd_string="$(echo-escape-command -- "$1")" || return $?
		cmd_path="$(type -P "$1" 2>/dev/null || :)"
		if [[ -z $cmd_path ]]; then
			# we must at least find it
			__print_style --stderr --element/+red="$cmd_string" --status=3 ' ' --error='not working because it is missing' || return $?
			return 3 # ESRCH 3 No such process
		fi

		# it exists, check if it is executable
		local -i __executable_status=0
		is-executable --quiet -- "$cmd_path" || __executable_status=$?
		if [[ $__executable_status -ne 0 ]]; then
			case "$__executable_status" in
			2) __print_style --stderr --element/+red="$cmd_string" --status="$__executable_status" ' ' --error='not working because it is missing.' || return $? ;;
			9) __print_style --stderr --element/+red="$cmd_string" --status="$__executable_status" ' ' --error='not working because it is a broken symlink.' || return $? ;;
			13) __print_style --stderr --element/+red="$cmd_string" --status="$__executable_status" ' ' --error='not working because it is not accessible.' || return $? ;;
			22) __print_style --stderr --element/+red="$cmd_string" --status="$__executable_status" ' ' --error='not working because it is not a valid argument.' || return $? ;;
			93) __print_style --stderr --element/+red="$cmd_string" --status="$__executable_status" ' ' --error='not working because it is not executable.' || return $? ;;
			*) __print_style --stderr --element/+red="$cmd_string" --status="$__executable_status" ' ' --error='not working because of unknown failure.' || return $? ;;
			esac
			return "$__executable_status"
		fi

		# check if presence is enough for this cmd
		local exception
		for exception in "${exceptions[@]}"; do
			if [[ $cmd_path == */"$exception" ]]; then
				return 0
			fi
		done

		# it does exist, now check its return code
		__check_cmd "$cmd_path" || {
			__print_style --stderr \
				--element+red="$cmd_string" --newline \
				--="$(__print_lines "${failures[@]}")" --newline \
				--/element+red="$cmd_string" --status=1 ' ' --error='not working because it is failing' || return $?
			return 1 # command not working
		}
	}

	# =====================================
	# Action

	local command
	for command in "${option_commands[@]}"; do
		__check_working "$command" || return $?
	done
	return 0 # all commands are working
)

# fire if invoked standalone
if [[ $0 == "${BASH_SOURCE[0]}" ]]; then
	if [[ $* == '--test' ]]; then
		command_working_test
	else
		command_working "$@"
	fi
fi
