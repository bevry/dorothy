#!/usr/bin/env bash

# @todo it may be possible in this to detect an unsupported shapeshifter code, and then output the clear, then the stored lines in an alterative screen buffer, then upon exit, default screen buffer - this won't support stdin captures though, but will be better than using alternative screen buffers even when not needed

function echo_revolving_door() (
	source "$DOROTHY/sources/bash.bash"

	# =====================================
	# Arguments

	function help {
		cat <<-EOF >&2
			ABOUT:
			Continuously clear the output of a command, showing only the latest output, then clearing it upon completion.

			USAGE:
			{ sleep 1; echo-lines -- 1 2; sleep 1; echo-style --green=3; sleep 1; echo-style --red=4; sleep 1; echo-style --blue=5; sleep 1; } 2>&1 | echo-revolving-door --lines=3

			OPTIONS:
			--lines=<lines> | --lines=terminal
			    The number of lines to display, defaults to the terminal line size if possible, otherwise becomes 0.
			    If set to a negative number, then will use the terminal line size minus this offset.
			    If set to 0, revolving door functionality is disabled.

			--columns=<columns> | --columns=terminal
			    The number of columns to display, defaults to the terminal column size if possible, otherwise becomes 0.
			    If set to a negative number, then will use the terminal column size minus this offset.
			    If set to 0, revolving door functionality is disabled.

			--target=<target:file-path|file-descriptor|device-file>
			    The target to write to, defaults to TTY.
			    A target can be a file path (e.g. out.txt), a file descriptor (e.g. 1 for STDOUT, 2 for STDERR), or a device file (e.g. /dev/stdout, /dev/stderr, /dev/tty). These are sent to [bash.bash:__do] for processing.

			QUIRKS:
			Shapeshifting ANSI escape codes will be escaped.
			If a line exceeded <columns>, only the rightmost <columns> of the line will be shown, with frontmost content being truncated.
			If you don't want empty lines being output, pipe to [echo-trim-empty-lines] or [echo-trim-zero-length] before piping to [echo-revolving-door].

			TODOS:
			If multiple <lines> is supported, usage of gfold may be possible to allow for wrapped lines.
		EOF
		if [[ $# -ne 0 ]]; then
			__print_error "$@"
		fi
		return 22 # EINVAL 22 Invalid argument
	}

	# process
	local item option_target='TTY' option_ignore_pattern=() option_lines='' option_columns='' option_max_lines='' option_max_columns='' option_min_lines='' option_min_columns='' option_terminal_lines='' option_terminal_columns=''
	while [[ $# -ne 0 ]]; do
		item="$1"
		shift
		case "$item" in
		'--help' | '-h') help ;;
		'--target='*) option_target="${item#*=}" ;;
		'--ignore-pattern='*) option_ignore_pattern+=("${item#*=}") ;;
		'--lines='*) option_lines="${item#*=}" ;;
		'--columns='*) option_columns="${item#*=}" ;;
		'--max-lines='*) option_max_lines="${item#*=}" ;;
		'--max-columns='*) option_max_columns="${item#*=}" ;;
		'--min-lines='*) option_min_lines="${item#*=}" ;;
		'--min-columns='*) option_min_columns="${item#*=}" ;;
		'--terminal-lines='*) option_terminal_lines="${item#*=}" ;;
		'--terminal-columns='*) option_terminal_columns="${item#*=}" ;;
		'--'*) help "An unrecognised flag was provided: $item" ;;
		*) help "An unrecognised argument was provided: $item" ;;
		esac
	done

	# ensure min and max are, if specified, valid positive numbers
	if [[ -n $option_max_lines && ! ($option_max_lines =~ ^[0-9]+$) ]]; then
		help --="<max-lines=$option_max_lines> must be 0 or above"
	fi
	if [[ -n $option_min_lines && ! ($option_min_lines =~ ^[0-9]+$) ]]; then
		help --="<min-lines=$option_min_lines> must be 0 or above"
	fi
	if [[ -n $option_max_lines && -n $option_min_lines && $option_max_lines -lt $option_min_lines ]]; then
		help --="<max-lines=$option_min_lines> must be greater than <min-lines=$option_min_lines>"
	fi
	if [[ -n $option_max_columns && ! ($option_max_columns =~ ^[0-9]+$) ]]; then
		help --="<max-columns=$option_max_columns> must be 0 or above"
	fi
	if [[ -n $option_min_columns && ! ($option_min_columns =~ ^[0-9]+$) ]]; then
		help --="<min-columns=$option_min_columns> must be 0 or above"
	fi
	if [[ -n $option_max_columns && -n $option_min_columns && $option_max_columns -lt $option_min_columns ]]; then
		help --="<max-columns=$option_min_columns> must be greater than <min-columns=$option_min_columns>"
	fi

	# adjust lines and columns to terminal lines and columns
	if [[ -z $option_terminal_lines || -z $option_terminal_columns ]]; then
		local terminal_size=()
		__split --target={terminal_size} --no-zero-length --invoke=try -- \
			get-terminal-lines-and-columns
		if [[ ${#terminal_size[@]} -eq 2 ]]; then
			if [[ -z $option_terminal_lines ]]; then
				option_terminal_lines="${terminal_size[0]}"
			fi
			if [[ -z $option_terminal_columns ]]; then
				option_terminal_columns="${terminal_size[1]}"
			fi
		fi
	fi
	if [[ -n $option_terminal_lines ]]; then
		if [[ -z $option_lines || $option_lines == 'terminal' ]]; then
			option_lines="$option_terminal_lines"
		elif [[ $option_lines -lt 0 ]]; then
			option_lines="$((option_terminal_lines + option_lines))"
		elif [[ $option_lines -gt $option_terminal_lines ]]; then
			option_lines="$option_terminal_lines"
		fi
	elif [[ -z $option_lines || $option_lines == 'terminal' || $option_lines -lt 0 ]]; then
		option_lines="${option_max_lines:-"$option_min_lines"}"
	fi
	if [[ -n $option_terminal_columns ]]; then
		if [[ -z $option_columns || $option_columns == 'terminal' ]]; then
			option_columns="$option_terminal_columns"
		elif [[ $option_columns -lt 0 ]]; then
			option_columns="$((option_terminal_columns + option_columns))"
		elif [[ $option_columns -gt $option_terminal_columns ]]; then
			option_columns="$option_terminal_columns"
		fi
	elif [[ -z $option_columns || $option_columns == 'terminal' || $option_columns -lt 0 ]]; then
		option_columns="${option_max_columns:-"$option_min_columns"}"
	fi

	# ensure lines and columns are within the range
	if [[ -z $option_lines || -z $option_columns ]]; then
		cat
		return
	fi
	if [[ -n $option_max_lines && $option_lines -gt $option_max_lines ]]; then
		option_lines="$option_max_lines"
		for (( ; option_lines < option_min_lines; option_lines++)); do
			:
		done
	elif [[ -n $option_min_lines && $option_lines -lt $option_min_lines ]]; then
		for (( ; option_lines < option_min_lines; option_lines++)); do
			:
		done
	fi

	# =====================================
	# Action

	# trap 'trap - SIGINT; return 130' SIGINT

	if [[ $option_lines -eq 0 || $option_columns -eq 0 ]]; then
		cat &>/dev/null
	else
		local negative_columns prior_lines_count=0 last_modifier='' last_input_ignored='no'
		negative_columns="$((option_columns * -1))"
		function __target {
			__do --redirect-stdout="$option_target" -- "$@"
			# "$@"
		}
		function __clear_all {
			if [[ $prior_lines_count -eq 0 ]]; then
				:
			elif [[ $prior_lines_count -eq 1 ]]; then
				# clear the line
				__target printf '\e[G\e[K'
			else
				# delete the lines
				__target printf '\e[%dF\e[J' "$((prior_lines_count - 1))"
			fi
		}
		function __flush {
			# get the new input
			local input="$1"
			# handle prefix
			if [[ $last_modifier == $'\r' ]]; then
				# apply \r
				__target printf '\r%s' "$input"
				last_modifier=''
			else
				# trim the first item from the old inputs
				if [[ $option_lines -eq 1 ]]; then
					prior_lines_count=1
					# erase this line, injecting the new input at the start of the line
					__target printf '\e[G\e[K%s' "$input"
				elif [[ $prior_lines_count -eq $option_lines ]]; then
					# delete the top line, then inject our new line at the start of the line
					__target printf '\e[%dF\e[M\e[%dE%s' "$((prior_lines_count - 1))" "$((prior_lines_count - 1))" "$input"
				elif [[ $prior_lines_count -eq 0 ]]; then
					# add our new line
					__target printf '%s' "$input"
					prior_lines_count="$((prior_lines_count + 1))"
				else
					# add our new line after the prior line
					__target printf '\n%s' "$input"
					prior_lines_count="$((prior_lines_count + 1))"
				fi
			fi
		}
		function __process {
			local input="$1"
			input="$(__ansi_keep_right "$input" 'echo-revolving-door')"
			input_size="${#input}"
			# is ignored?
			last_input_ignored='no'
			local pattern
			for pattern in "${option_ignore_pattern[@]}"; do
				if [[ $input =~ $pattern ]]; then
					last_input_ignored='yes'
					return 0
				fi
			done
			# get only the last columns
			if [[ $input_size -gt $option_columns ]]; then
				# trim the front
				input="${input:negative_columns}"
			fi
			# flush this input
			__flush "$input"
		}
		# process with support for shapeshifting
		local character last_character='' backspace_index=0 input=''
		# only bash v5: while IFS= read -rN1 character || [[ -n $character ]]; do
		# what we implemented works on all bash: https://unix.stackexchange.com/a/626655/50703
		while LC_ALL=C IFS= read -rd '' -n1 character || [[ -n $character ]]; do
			if [[ $character == $'\b' ]]; then
				# \b has no effect on \n and \r
				if [[ $last_character == $'\n' || $last_character == $'\r' ]]; then
					backspace_index=0
					continue
				elif [[ $last_character == $'\b' ]]; then
					backspace_index="$((backspace_index - 1))"
				else
					backspace_index=-1
				fi
				last_character=$'\b'
				continue
			elif [[ $character == $'\r' ]]; then
				# if \r would be a no-op, then skip it
				if [[ -z $last_character || $last_character == $'\n' || $last_character == $'\r' ]]; then
					last_character=$'\r'
					continue
				fi
				# no need to apply backspace, as \r discards \b
				# flush the prior input
				__process "$input"
				input=''
				last_character=$'\r'
				if [[ $last_input_ignored == 'no' ]]; then
					last_modifier=$'\r'
				fi
			elif [[ $character == $'\n' ]]; then
				# no need to apply backspace, as \n discards \b
				# flush the prior input
				__process "$input"
				input=''
				last_character=$'\n'
				last_modifier=$'\n'
			else
				if [[ $last_character == $'\b' ]]; then
					# apply the backspace
					local prefix suffix
					prefix="${input:0:backspace_index}"
					suffix="${input:backspace_index+1}"
					input="$prefix$character$suffix"
				else
					input+="$character"
				fi
				last_character="$character"
			fi
		done
		__process "$input"
		__clear_all
	fi
)

# fire if invoked standalone
if [[ $0 == "${BASH_SOURCE[0]}" ]]; then
	echo_revolving_door "$@"
fi
