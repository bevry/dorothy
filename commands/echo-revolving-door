#!/usr/bin/env bash

# @todo it may be possible in this to detect an unsupported shapeshifter code, and then output the clear, then the stored lines in an alterative screen buffer, then upon exit, default screen buffer - this won't support stdin captures though, but will be better than using alternative screen buffers even when not needed

function echo_revolving_door() (
	source "$DOROTHY/sources/bash.bash"

	# =====================================
	# Arguments

	function help {
		cat <<-EOF >&2
			ABOUT:
			Continuously clear the output of a command, showing only the latest output, then clearing it upon completion.

			USAGE:
			{ sleep 1; echo-lines -- 1 2; sleep 1; echo-style --green=3; sleep 1; echo-style --red=4; sleep 1; echo-style --blue=5; sleep 1; } 2>&1 | echo-revolving-door --lines=3

			OPTIONS:
			--lines=<lines> | --lines=terminal
			    The number of lines to display, defaults to the terminal line size if possible, otherwise becomes 0.
			    If set to a negative number, then will use the terminal line size minus this offset.
			    If set to 0, revolving door functionality is disabled.

			--columns=<columns> | --columns=terminal
			    The number of columns to display, defaults to the terminal column size if possible, otherwise becomes 0.
			    If set to a negative number, then will use the terminal column size minus this offset.
			    If set to 0, revolving door functionality is disabled.

			--target=<target:file-path|file-descriptor|device-file>
			    The target to write to, defaults to TTY.
			    A target can be a file path (e.g. out.txt), a file descriptor (e.g. 1 for STDOUT, 2 for STDERR), or a device file (e.g. /dev/stdout, /dev/stderr, /dev/tty). These are sent to [bash.bash:__do] for processing.

			QUIRKS:
			Shapeshifting ANSI escape codes will be escaped.
			If a line exceeded <columns>, only the rightmost <columns> of the line will be shown, with frontmost content being truncated.
			If you don't want empty lines being output, pipe to [echo-trim-empty-lines] or [echo-trim-zero-length] before piping to [echo-revolving-door].

			TODOS:
			If multiple <lines> is supported, usage of gfold may be possible to allow for wrapped lines.
		EOF
		if [[ $# -ne 0 ]]; then
			echo-error "$@"
		fi
		return 22 # EINVAL 22 Invalid argument
	}

	# process
	local item option_shapeshifter='' option_lines='' option_columns='' option_target='TTY' option_terminal_lines='' option_terminal_columns='' option_ignore_pattern=()
	while [[ $# -ne 0 ]]; do
		item="$1"
		shift
		case "$item" in
		'--help' | '-h') help ;;
		'--no-shapeshifter'* | '--shapeshifter'*)
			option_shapeshifter="$(get-flag-value --affirmative --fallback="$option_shapeshifter" -- "$item")"
			;;
		'--lines='* | '--max-lines='*) option_lines="${item#*=}" ;;
		'--columns='* | '--max-columns='*) option_columns="${item#*=}" ;;
		'--terminal-lines='*) option_terminal_lines="${item#*=}" ;;
		'--terminal-columns='*) option_terminal_columns="${item#*=}" ;;
		'--target='*) option_target="${item#*=}" ;;
		'--ignore-pattern='*) option_ignore_pattern+=("${item#*=}") ;;
		'--'*) help "An unrecognised flag was provided: $item" ;;
		*) help "An unrecognised argument was provided: $item" ;;
		esac
	done

	# ensure lines and columns
	if [[ -z $option_lines ]]; then
		option_lines='terminal'
	fi
	if [[ -z $option_columns ]]; then
		option_columns='terminal'
	fi

	# adjust lines and columns to terminal lines and columns
	local terminal_size=() terminal_lines=0
	if [[ -z $option_terminal_lines || -z $option_terminal_columns ]]; then
		mapfile -t terminal_size < <(get-terminal-lines-and-columns || :)
		if [[ ${#terminal_size[@]} -eq 2 ]]; then
			option_terminal_lines="${terminal_size[0]}"
			option_terminal_columns="${terminal_size[1]}"
		fi
	fi
	if [[ -n $option_terminal_lines ]]; then
		if [[ $option_lines == 'terminal' ]]; then
			option_lines="$option_terminal_lines"
		elif [[ $option_lines -lt 0 ]]; then
			option_lines="$((option_terminal_lines + option_lines))"
		elif [[ $option_lines -gt $option_terminal_lines ]]; then
			option_lines="$option_terminal_lines"
		fi
	elif [[ $option_lines == 'terminal' ]]; then
		option_lines=0
	fi
	if [[ -n $option_terminal_columns ]]; then
		if [[ $option_columns == 'terminal' ]]; then
			option_columns="$option_terminal_columns"
		elif [[ $option_columns -lt 0 ]]; then
			option_columns="$((option_terminal_columns + option_columns))"
		elif [[ $option_columns -gt $terminal_columns ]]; then
			option_columns="$option_terminal_columns"
		fi
	elif [[ $option_columns == 'terminal' ]]; then
		option_columns=0
	fi

	# sanity check
	# this can happen if the negative value is greater than the terminal value
	if ! [[ $option_lines =~ ^[0-9]+$ ]]; then
		help "<lines> failed to determine a valid value: $option_lines"
	fi
	if ! [[ $option_columns =~ ^[0-9]+$ ]]; then
		help "<columns> failed to determine a valid value: $option_columns"
	fi

	# =====================================
	# Action

	# trap 'trap - SIGINT; return 130' SIGINT

	if [[ $option_lines -eq 0 || $option_columns -eq 0 ]]; then
		cat
	else
		local negative_columns prior_lines_count=0 last_modifier='' last_input_ignored='no' # lines=()
		negative_columns="$((option_columns * -1))"
		function __target {
			__do --redirect-stdout="$option_target" -- "$@"
			# "$@"
		}
		function __clear_all {
			if [[ $prior_lines_count -eq 0 ]]; then
				:
			elif [[ $prior_lines_count -eq 1 ]]; then
				# clear the line
				__target printf '\e[G\e[K'
			else
				# delete the lines
				__target printf '\e[%dF\e[J' "$((prior_lines_count - 1))"
			fi
		}
		function __flush {
			# get the new input
			local input="$1"
			# handle prefix
			if [[ $last_modifier == $'\r' ]]; then
				# apply \r
				__target printf '\r%s' "$input"
				# \r moves the cursor to the start, and overwrites, so if this line is smaller than the last, then we need to update the last line
				# if [[ $prior_lines_count -ne 0 ]]; then
				# 	local last_line="${lines[prior_lines_count-1]}"
				# 	if [[ ${#last_line} -gt ${#input} ]]; then
				# 		input+="$(__get_substring "$last_line" "${#input}")"
				# 	fi
				# 	lines[prior_lines_count-1]="$input"
				# fi
				# if we don't do the \r application earlier, then we can do this
				# __target printf '\e[G\e[J%s' "$input"
				last_modifier=''
			else
				# trim the first item from the old inputs
				if [[ $option_lines -eq 1 ]]; then
					prior_lines_count=1
					# lines=()
					# erase this line, injecting the new input at the start of the line
					__target printf '\e[G\e[K%s' "$input"
				elif [[ $prior_lines_count -eq $option_lines ]]; then
					# lines=("${lines[@]:1}")
					# delete the top line, then inject our new line at the start of the line
					__target printf '\e[%dF\e[M\e[%dE%s' "$((prior_lines_count - 1))" "$((prior_lines_count - 1))" "$input"
				elif [[ $prior_lines_count -eq 0 ]]; then
					# add our new line
					__target printf '%s' "$input"
					prior_lines_count="$((prior_lines_count + 1))"
				else
					# add our new line after the prior line
					__target printf '\n%s' "$input"
					prior_lines_count="$((prior_lines_count + 1))"
				fi

				# add the new input to the end of the old inputs
				# lines+=("$input")
				# prior_lines_count="${#lines[@]}"
			fi
		}
		function __process {
			local input="$1"
			# escape shapeshifting
			input="$(__split_shapeshifting -- "$input")"
			if [[ $input == *$'\n'* ]]; then
				input="$(__get_substring_after_last "$input" $'\n')"
			fi
			# is ignored?
			last_input_ignored='no'
			for pattern in "${option_ignore_pattern[@]}"; do
				if [[ $input =~ $pattern ]]; then
					last_input_ignored='yes'
					return 0
				fi
			done
			# get only the last columns
			input="$(__get_substring "$input" "$negative_columns")"
			# flush this input
			__flush "$input"
		}
		if [[ $option_shapeshifter != 'yes' ]]; then
			local input=''
			while IFS= read -r input || [[ -n $input ]]; do
				__process "$input"
			done
		else
			# @todo there is a bug here, where [aaa] is becoming [aa]
			# printf 'aaa\b\naaa\b\bA\n\r\bccc\b\r\bd\r\n' | echo-revolving-door --shapeshifter
			local character last_character='' backspace_index=0 input=''
			# only bash v5: while IFS= read -rN1 character || [[ -n $character ]]; do
			# what we implemented works on all bash: https://unix.stackexchange.com/a/626655/50703
			while LC_ALL=C IFS= read -rd '' -n1 character || [[ -n $character ]]; do
				if [[ $character == $'\b' ]]; then
					# \b has no effect on \n and \r
					if [[ $last_character == $'\n' || $last_character == $'\r' ]]; then
						backspace_index=0
						continue
					elif [[ $last_character == $'\b' ]]; then
						backspace_index="$((backspace_index - 1))"
					else
						backspace_index=-1
					fi
					last_character=$'\b'
					continue
				elif [[ $character == $'\r' ]]; then
					# if \r would be a no-op, then skip it
					if [[ -z $last_character || $last_character == $'\n' || $last_character == $'\r' ]]; then
						last_character=$'\r'
						continue
					fi
					# no need to apply backspace, as \r discards \b
					# flush the prior input
					__process "$input"
					input=''
					last_character=$'\r'
					if [[ $last_input_ignored == 'no' ]]; then
						last_modifier=$'\r'
					fi
				elif [[ $character == $'\n' ]]; then
					# no need to apply backspace, as \n discards \b
					# flush the prior input
					__process "$input"
					input=''
					last_character=$'\n'
					last_modifier=$'\n'
				else
					if [[ $last_character == $'\b' ]]; then
						# apply the backspace
						input="$(__get_substring "$input" 0 "$backspace_index")$character$(__get_substring "$input" "$((backspace_index + 1))")"
					else
						input+="$character"
					fi
					last_character="$character"
				fi
			done
			__process "$input"
		fi
		__clear_all
	fi
)

# fire if invoked standalone
if [[ $0 == "${BASH_SOURCE[0]}" ]]; then
	echo_revolving_door "$@"
fi
