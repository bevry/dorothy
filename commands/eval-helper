#!/usr/bin/env bash

# NOTE:

# [sudo] and [doas] asks for your own password, not the target users password
# [su] asks for the target user password
# [sudo] and [doas] can be configured via their configuration files to target other users, not just [root]

# EXAMPLE:

# with this sudoers configuration file
# developer ALL=(root,webuser) /a-special-echo arg1 arg2

# and with /a-special-echo only being executable to [root] and [webuser]:
# sudo chown root:webuser /a-special-echo
# sudo chmod 750 /a-special-echo

# if you are [webuser], you can run this without escalation (not because of sudoers, but because of the file-system permissions):
# /a-special-echo arg1 arg2

# if you are [someuser], you will be denied ability to run this (not because of sudoers, but because of the file-system permissions):
# /a-special-echo arg1 arg2
# and if that was the only configuration in sudoers, you would also be denied escalation to [root] or [webuser]

# if you are [developer], you will be denied ability to run this (not because of sudoers, but because of the file-system permissions):
# /a-special-echo arg1 arg2
# however, sudoers will allow [developer] to elevate to [root] or [webuser]:
# sudo /a-special-echo arg1 arg2
# sudo -u webuser /a-special-echo arg1 arg2

# TERMINOLOGY

# "privilege escalation" is a bad thing: https://en.wikipedia.org/wiki/Privilege_escalation
# use elevation/grant/authorise when it is good thing: https://en.wikipedia.org/wiki/Privilege_elevation

# SUDO

# https://man.openbsd.org/doas
# https://man.archlinux.org/man/doas.1.en

# https://manpages.ubuntu.com/manpages/xenial/man8/sudo.8.html
# -E, --preserve-env
#    preserve user environment when running command
# -H, --set-home
#    set HOME variable to target user's home dir
# -i, --login
#    Run the shell specified by the target user's password database entry as a login shell.

function eval_helper_test() (
	source "$DOROTHY/sources/bash.bash"

	eval-tester -- \
		eval-helper -- \
		waiter --timeout=0

	eval-tester --stdout=my-stdout --stderr=my-stderr --tty=$'my-pending\nmy-success' -- \
		eval-helper --pending=my-pending --failure=my-failure --success=my-success -- \
		waiter --timeout=0 --stdout=my-stdout --stderr=my-stderr

	eval-tester --stdout=my-stdout --stderr=my-stderr --tty=$'my-pending\nmy-failure' --status=123 -- \
		eval-helper --pending=my-pending --failure=my-failure --success=my-success -- \
		waiter --timeout=0 --status=123 --stdout=my-stdout --stderr=my-stderr

	# wrapped, so ignore tty as there is too much stuff
	eval-tester --stdout=my-stdout --stderr=my-stderr --ignore-tty -- \
		eval-helper --wrap --pending=my-pending --failure=my-failure --success=my-success -- \
		waiter --timeout=0 --stdout=my-stdout --stderr=my-stderr

	eval-tester --stdout=my-stdout --stderr=my-stderr --ignore-tty -- \
		eval-helper --no-color --wrap --pending=my-pending --failure=my-failure --success=my-success -- \
		waiter --timeout=0 --stdout=my-stdout --stderr=my-stderr

	eval-tester --stdout=my-stdout --stderr=$'my-pending\n<w>\nmy-stderr\n</w>[0]\nmy-success' --ignore-tty -- \
		eval-helper --no-color --message-target=STDERR --command-string=w --wrap --pending=my-pending --failure=my-failure --success=my-success -- \
		waiter --timeout=0 --stdout=my-stdout --stderr=my-stderr

	# --alternative-screen-buffer does not affect verbosity and results
	eval-tester --stdout=my-stdout --stderr=$'my-pending\n<w>\nmy-stderr\n</w>[0]\nmy-success' --ignore-tty -- \
		eval-helper --no-color --alternative-screen-buffer --message-target=STDERR --command-string=w --wrap --pending=my-pending --failure=my-failure --success=my-success -- \
		waiter --timeout=0 --stdout=my-stdout --stderr=my-stderr

	return 0
)
function eval_helper() ( # to use this as a function, it needs to change from a subshell, and become __eval_helper, but that is a significant [|| return] effort for now
	source "$DOROTHY/sources/bash.bash"

	# =====================================
	# Arguments

	function help {
		cat <<-EOF >&2
			ABOUT:
			Helpers for working with commands.

			USAGE:
			eval-helper [...options] -- ...<command>

			QUIRKS:
			Unless [--no-quiet] aka [--failure-verbosity=full --success=mode=full] is used, then the command's STDOUT and STDERR will be merged into STDERR.
			Messages (pending, success, failure) are output to TTY if available, otherwise STDERR.


			OPTIONS:
			--[no-]quiet | --[no-]verbose
			    If --verbose or --no-quiet, becomes:
			        --failure-verbosity=full --success-verbosity=full
			    If --quiet or --no-verbose, becomes:
			        --failure-verbosity=full --success-verbosity=conclusion
			    If missing or empty, defaults to result of [get-terminal-quiet-support].
			    As such, if you require STDOUT of the command, be sure to to provide --verbose.
			--verbosity=<verbosity>
			    Becomes --failure-verbosity=<verbosity> --success-verbosity=<verbosity>
			--failure-verbosity=<failure-verbosity>
			    If full: message for pending, message for wrap open, command output, message for wrap close and status, message for failure.
			    If summary: message for pending, message for wrap and status, message for failure.
			    If conclusion: message for failure.
			    If summary or conclusion, must be used alongside either --truncate or --screen.
			--success-verbosity=<success-verbosity>
			    If full: message for pending, message for wrap open, command output, message for wrap close and status, message for success.
			    If summary: message for pending, message for wrap and status, message for success.
			    If conclusion: message for success.
			    If summary or conclusion, must be used alongside either --truncate or --screen.

			--message-target=<message-target>
			    By default, messages are output to TTY.
			--[no-]wrap
			    If enabled, the output of the command will be wrapped in a message detailing the command itself, e.g.: < command arg >...</ command arg >
			    Disabled by default, such that TTY/STDERR/STDOUT are not altered.
			--command=<command-string>
			    If provided, use this string instead of the escaped <command>, when wrapping.
			--pending=<pending>
			    If provided, will output the <pending> message before and while the command executes.
			--failure=<failure>
			    If provided, will output the <failure> message if the command failed.
			--success=<success>
			    If provided, will output the <success> message if the command succeeded.

			--[no-]trim
			    If enabled, trim padding at the start and end of the command output. See [echo-trim-padding] for details.

			--truncate-lines=<lines:integer|terminal>
			    If enabled, the command output to STDOUT, STDERR (and TTY by attempt) will be truncated during execution to this amount of revolving lines (if enabled, <lines> defaults to [1]). Shapeshifting ANSI Escape Codes will be escaped. This inhibits accurate capturing of command output, as such this transforms command output into a message, as such it will go to <message-target>. If set to [0] all command output will be attempted to be hidden. See [echo-revolving-door] for details.
			--[no-]alternative-screen-buffer | --[no-]shapeshifter
			    If enabled, the command will run in an alternative terminal buffer. Use this if the command is a shapeshifter (uses ANSI escape codes to modify lines and cursor).
			    By default, this is disabled unless invoking a known shapeshifter.
			    This option isn't that useful if you are not doing [summary] or [conclusion] verbosities.

			--terminal-lines=<terminal-lines> | --terminal-columns=<terminal-columns>
			    Forwarded to commands that support them.

			--[no-]confirm
			    Confirm execution of the command before its first execution (--until usage could mean multiple executions).
			    Disabled by default.

			--until=<forever|success|failure|<exit-status>>
			    If forever, keep (re-)running the command forever.
			    If success, keep (re-)running the command until a successful exit status.
			    If failure, keep (re-)running the command until a failure exit status.
			    If <exit-status>, keep (re-)running the command until the specified exit status. Can only be specified once.
			    Disabled byy default.
			--until-interval=<seconds>
			    Specify the interval between attempts.
			    Defaults to 10 seconds.
			    This is only used if [--until] is specified.

			--elevated=<file-path|file-descriptor|device-file>
			    If specified, if the <command> required elevation, the <command> alongside a trailing newline will be appended to this target.
			    Can be specified multiple times, and targets can be newline separated.
			--elevate=<yes|no|failure|<exit-status>>
			    If specified as [yes], then the command will execute with elevated privileges, be it via sudo or doas, or neither if not needed.
			    If <user> or <group> is specified, it will be elevated and the remaining alternatives are discarded:
			    If specified as [no], then the command will be run without elevation.
			    If specified as [failure], then the command will be run without elevation, and if it fails, it will be run again with elevation.
			    If specified as an integer, then the command will be run without elevation, and if it fails with that exit status, it will be run again with elevation.
			    Can be specified multiple times, and can be [\n\t ,|] separated. [yes] and [no] values will reset prior values.
			    Empty values will be ignored. If this is not specified at all, or is only empty strings, it will default to [no].
			--user=<user>
			    Specify a user to run the command as. Forces [--elevate=yes].
			--group=<group>
			    Specify a group to run the command as. Forces [--elevate=yes].
			--reason=<reason>
			    If a prompt is required to momentarily grant privileges, this reason will be used to explain why elevation was required.
			--inherit
			    If enabled, when elevating, the PATH will be inherited to the executing command.
			--home
			    If disabled, do not ensure the HOME is correct for the elevated user. If the HOME does exist, it will be used.
			    If the elevate <user> is [root], this will default to disabled.
			--invalidate-elevation
			    If specified, any active elevation will be invalidated. All other arguments are discarded.
		EOF
		if [[ $# -ne 0 ]]; then
			echo-error "$@"
		fi
		return 22 # EINVAL 22 Invalid argument
	}

	# process
	local item option_cmd=() \
	option_quiet='' option_persist='' option_wrap='' option_time='no' option_pending='' option_success='' option_failure='' \
	option_do_args=() option_revolving_args=() option_alternative_screen_buffer='' \
	option_terminal_lines='' option_terminal_columns='' \
	option_confirm='' \
	option_until='' option_until_interval='' option_until_attempts='' \
	option_elevated=() option_elevate=() option_user='' option_group='' option_reason='' option_inherit='no' option_home='' # option_copy_status='' option_redirect_status=''
	while [[ $# -ne 0 ]]; do
		item="$1"
		shift
		case "$item" in
		'--help' | '-h') help ;;
		# ...
		'--no-color'* | '--color'*) __flag --source={item} --target={COLOR} --affirmative --export ;;
		'--no-verbose'* | '--verbose'*) __flag --source={item} --target={option_quiet} --non-affirmative ;;
		'--no-quiet'* | '--quiet'*) __flag --source={item} --target={option_quiet} --affirmative ;;
		'--persist='*) option_persist="${item#*=}" ;;
		'--no-wrap'* | '--wrap'*) __flag --source={item} --target={option_wrap} --affirmative ;;
		'--no-time'* | '--time'*) __flag --source={item} --target={option_time} --affirmative --coerce ;;
		'--pending='*) option_pending="${item#*=}" ;;
		'--success='*) option_success="${item#*=}" ;;
		'--failure='*) option_failure="${item#*=}" ;;
		# ...
		# '--copy-status='*) option_copy_status="${item#*=}" ;; <-- until eval-helper is __eval_helper this won't work
		# '--redirect-status='*) option_redirect_status="${item#*=}" ;; <-- ^^
		'--discard-'*={* | '--copy-'*={* | '--redirect-'*={*) help "Until eval-helper can be sourced as __eval_helper variable assignments will not work:, write to a file then read from it instead: $item" ;;
		'--discard-'* | '--copy-'* | '--redirect-'*) option_do_args+=("$item") ;;
		'--no-alternative-screen-buffer'* | '--alternative-screen-buffer'*) __flag --source={item} --target={option_alternative_screen_buffer} --affirmative ;;
		'--revolving-'*) option_revolving_args+=("--${item#--revolving-}") ;;
		# ...
		'--terminal-lines='*) option_terminal_lines="${item#*=}" ;;
		'--terminal-columns='*) option_terminal_columns="${item#*=}" ;;
		# ...
		'--no-confirm'* | '--confirm'*) __flag --source={item} --target={option_confirm} --affirmative ;;
		# ...
		'--until='*) option_until="${item#*=}" ;;
		'--until-interval='* | '--until-delay='*) option_until_interval="${item#*=}" ;;
		'--until-attempts='*) option_until_attempts="${item#*=}" ;;
		# <elevate>
		'--elevated='*)
			__split --target={option_elevated} --append --delimiters=$'\n\t' --no-zero-length -- "${item#*=}"
			;;
		'--no-elevate'* | '--elevate'*)
			__flag --source+target={item} --affirmative
			__split --source={item} --target={option_elevate} --append --delimiters=$'\n\t ,|' --no-zero-length
			;;
		'--user='*) option_user="${item#*=}" ;;
		'--group='*) option_group="${item#*=}" ;;
		'--reason='*) option_reason="${item#*=}" ;;
		'--no-inherit'* | '--inherit'*) __flag --source={item} --target={option_inherit} --affirmative ;;
		'--no-home'* | '--home'*) __flag --source={item} --target={option_home} --affirmative ;;
		'--invalidate-elevation')
			if __command_exists -- sudo; then
				sudo --reset-timestamp || :
			elif __command_exists -- doas; then
				doas -L || :
			fi
			return 0
			;;
		# </elevate>
		# command
		'--')
			option_cmd+=("$@")
			shift $#
			break
			;;
		'--'*) help "An unrecognised flag was provided: $item" ;;
		*) help "An unrecognised argument was provided: $item" ;;
		esac
	done

	# quiet
	if [[ -z $option_quiet || $option_quiet == 'auto' ]]; then
		if [[ $IS_STDIN_OPENED_ON_TERMINAL == 'yes' ]]; then
			option_quiet="$(get-terminal-quiet-support --fallback=no)"
		else
			option_quiet='no'
		fi
	fi

	# home
	if [[ -z $option_home ]]; then
		if [[ $option_user == 'root' ]]; then
			option_home='no'
		else
			option_home='yes'
		fi
	fi

	# require command
	if [[ ${#option_cmd[@]} -eq 0 ]]; then
		help 'No <command> was provided.'
	fi

	# ensure valid until
	if [[ -n $option_until ]]; then
		if [[ $option_until =~ ^(forever|success|failure)$ ]] || __is_integer "$option_until"; then
			: # valid
		else
			help "An unrecognised <until> was provided: $option_until"
		fi
	fi

	# default do args and persist
	local persist=''
	if [[ -n $option_persist ]]; then
		option_persist="$(__get_lowercase_string -- "$option_persist")"
		if ! [[ $option_persist =~ ^(stdout|stderr|output)$ ]]; then
			help "An unrecognised <persist> was provided: $option_persist"
		fi
	fi

	# default reason
	if [[ -z $option_reason ]]; then
		option_reason='Your password is required to momentarily grant privileges to execute the command:'
	fi

	# convert 0 attempts to empty string aka unlimited
	if [[ $option_until_attempts == 0 ]]; then
		option_until_attempts=''
	fi

	# ensure shapeshifters that write to TTY are cleared correctly
	if [[ -z $option_alternative_screen_buffer ]]; then
		case "${option_cmd[*]}" in
		'ssh '*) option_alternative_screen_buffer='yes' ;;
		'sudo '*) option_alternative_screen_buffer='yes' ;;
		'doas '*) option_alternative_screen_buffer='yes' ;;
		*) option_alternative_screen_buffer='no' ;;
		esac
	fi

	# ensure sudo is a valid value
	local elevate='' elevate_on_statuses=() elevate_technique=''
	if [[ -n $option_user || -n $option_group ]]; then
		# validate user and group, user is important, as otherwise we will be creating directories for users that don't exist
		if [[ -n $option_user ]] && ! is-user -- "$option_user"; then
			echo-style --stderr --error1='Cannot elevate privileges to a non-existent user: ' --code-error1="$option_user"
			return 2 # ENOENT 2 No such file or directory
		fi
		if [[ -n $option_group ]] && ! is-group -- "$option_group"; then
			echo-style --stderr --error1='Cannot elevate privileges to a non-existent group: ' --code-error1="$option_group"
			return 2 # ENOENT 2 No such file or directory
		fi
		elevate='yes'
	elif [[ ${#option_elevate[@]} -eq 0 || -z ${option_elevate[*]} ]]; then
		elevate='no'
	else
		elevate='no'
		for item in "${option_elevate[@]}"; do
			case "$item" in
			'') : ;; # discard, it's already served its purpose in now defaulting to disabled
			'yes')
				elevate='yes'
				elevate_on_statuses=()
				;;
			'no')
				elevate='no'
				elevate_on_statuses=()
				;;
			'failure')
				elevate='failure'
				elevate_on_statuses=()
				;;
			[0-9]*)
				__affirm_value_is_positive_integer "$item" 'elevate on exit status' || return
				elevate='status'
				elevate_on_statuses+=("$item")
				;;
			*)
				help "An unrecognised value was provided for --elevate: $item"
				;;
			esac
		done
	fi
	if [[ $elevate != 'no' ]]; then
		if __command_exists -- sudo; then
			elevate_technique='sudo'
		elif __command_exists -- doas; then
			elevate_technique='doas'
		else
			elevate_technique='none'
		fi
	fi

	# quiet, verbose, modes
	# if [[ -n $option_success_verbosity ]]; then
	# fi
	# if [[ -n $option_failure_verbosity ]]; then
	# fi

	# =====================================
	# Action

	# messages
	local messages=''
	function __clear_messages {
		messages=''
	}
	function __flush_messages {
		if [[ -n $messages ]]; then
			__do --redirect-stdout=TTY -- __print_string "$messages" || return
			__clear_messages || return
		fi
	}

	# terminal size: constrain to arguments if provided
	local terminal_lines="$option_terminal_lines" terminal_columns="$option_terminal_columns"
	function __refresh_terminal_size {
		if [[ -z $option_terminal_lines || -z $option_terminal_columns ]]; then
			local terminal_size=()
			__split --target={terminal_size} --no-zero-length --invoke=try -- \
				get-terminal-lines-and-columns
			if [[ ${#terminal_size[@]} -eq 2 ]]; then
				if [[ -z $option_terminal_lines ]]; then
					terminal_lines="${terminal_size[0]}"
				fi
				if [[ -z $option_terminal_columns ]]; then
					terminal_columns="${terminal_size[1]}"
				fi
			fi
		fi
	}

	# revolving door
	function __revolving {
		echo-revolving-door "${option_revolving_args[@]}" --lines="-$header_lines" --terminal-lines="$terminal_lines" --terminal-columns="$terminal_columns" --target=TTY "$@" || return
	}

	# run
	# never execute [run_] in a conditional, as if command is an function, its behaviour will be altered
	local run_status cmd_elevate=() next_attempt=1 elevate_prompt styled_standard_command_string styled_elevate_command_string styled_command_string
	# styled_standard_command_string="$(echo-escape-command -- "${option_cmd[@]}")"
	styled_standard_command_string="$(echo-style --bold="$(echo-escape-command -- "${option_cmd[@]}")")"
	function run_args {
		# reset
		run_status=''
		persist=''

		# headers
		local command='' cmd=("$@") do_args=() style_time_args=()

		# pending
		if [[ -n $option_pending ]]; then
			messages+="$option_pending"$'\n'
		fi

		# confirm
		command="$(echo-style --element="$styled_command_string")"$'\n'
		if [[ $elevate_prompt == 'yes' ]]; then
			# has a reason
			messages+="$(echo-style --notice="$option_reason")"$'\n'
		elif [[ $option_confirm == 'yes' ]] && __flush_messages && ! confirm --positive --ppid=$$ -- 'Confirm execution of the command:' "$command"; then
			# cancelled
			run_status=125
			messages+="$(echo-style --element/="$styled_command_string" --status="$run_status")"$'\n'
			if [[ -n $option_failure ]]; then
				messages+="$option_failure"$'\n'
			fi
			__flush_messages
			return 0
		fi

		# command
		if [[ $option_wrap == 'yes' || $elevate_prompt == 'yes' ]]; then
			messages+="$command"
		fi

		# refresh terminal size
		__refresh_terminal_size

		# output everything if in verbose mode
		if [[ $option_quiet == 'no' || $terminal_lines -eq 0 || $terminal_columns -eq 0 ]]; then
			if [[ -n $option_persist ]]; then
				do_args+=("--copy-$option_persist=TTY")
			fi

			# flush
			__flush_messages

			# if time, fetch start time
			if [[ $option_time == 'yes' ]]; then
				local time_before time_after time_delta
				time_before="$(__get_epoch_time)"
			fi

			# body
			__do --redirect-status={run_status} "${do_args[@]}" "${option_do_args[@]}" -- \
				"${cmd[@]}"

			# close wrap
			if [[ $option_wrap == 'yes' ]]; then
				if [[ $option_time == 'yes' ]]; then
					time_after="$(__get_epoch_time)"
					time_delta="$(echo-math -- "$time_after - $time_before")"
					style_time_args+=(' ' --code="in $time_delta seconds")
				fi
				messages+="$(echo-style --/element="$styled_command_string" --status="$run_status" "${style_time_args[@]}")"$'\n'
			fi

			# success or failure
			if [[ $run_status -eq 0 ]]; then
				if [[ -n $option_success ]]; then
					messages+="$option_success"$'\n'
				fi
			else
				if [[ -n $option_failure ]]; then
					messages+="$option_failure"$'\n'
				fi
			fi

			# flush
			__flush_messages
		else
			# direct STDOUT and STDERR to TTY, as they will be truncated and will be outputting clear ansi codes, which will confuse anything that is expecting legit STDOUT output, we cannot detect shapeshifting after the fact, as it occurs in the TTY, not STDOUT, nor STDERR
			local body
			if [[ -n $option_persist ]]; then
				do_args+=("--copy-$option_persist={persist}")
			fi

			if [[ $option_alternative_screen_buffer == 'yes' || $elevate_prompt == 'yes' ]]; then
				# start alternative screen buffer, and redo header inside of it
				echo-style --no-trail --tty --alternative-screen-buffer --="$messages"
				__clear_messages

				# run command, output to STDERR, capture, then to TTY
				__do --redirect-status={run_status} "${do_args[@]}" "${option_do_args[@]}" \
					--redirect-output=STDERR \
					--copy-stderr={body} \
					--redirect-output=TTY \
					-- \
					"${cmd[@]}"

				# restore the original screen buffer
				echo-style --no-trail --tty --default-screen-buffer
			else
				# update header lines
				if [[ -n $messages ]]; then
					header_lines="$(echo-wrap --columns="$terminal_columns" -- "$messages" | echo-count-lines --stdin)"
					__flush_messages
				else
					header_lines=0
				fi

				# trap '' SIGINT
				__do --redirect-status={run_status} "${do_args[@]}" "${option_do_args[@]}" \
					--redirect-output=STDERR \
					--copy-stderr={body} \
					--redirect-output="(__revolving)" \
					-- \
					"${cmd[@]}"
				# trap - SIGINT

				# clear header, we can re-add them later if needed
				if [[ $header_lines -ne 0 ]]; then
					echo-clear-lines --lines="$header_lines" --target=TTY
				fi
			fi

			# generate output
			if [[ $option_quiet == 'no' || $run_status -ne 0 ]]; then
				# verbose/failure: pending message, command output and status, and success or failure message

				# add pending
				if [[ -n $option_pending ]]; then
					messages+="$option_pending"$'\n'
				fi

				# add body
				if [[ $option_wrap == 'no' ]]; then
					if [[ -n $body ]]; then
						__flush_messages
						__print_lines "$body" >&2
					fi
				else
					if [[ -n $body ]]; then
						messages+="$(echo-style --element="$styled_command_string")"$'\n'
						__flush_messages
						__print_lines "$body" >&2
						messages+="$(echo-style --/element="$styled_command_string" --status="$run_status")"$'\n'
					else
						messages+="$(echo-style --element="$styled_command_string" --/fragment='' --status="$run_status")"$'\n'
					fi
				fi

				# add success or failure
				if [[ $run_status -eq 0 ]]; then
					if [[ -n $option_success ]]; then
						messages+="$option_success"$'\n'
					fi
				else
					if [[ -n $option_failure ]]; then
						messages+="$option_failure"$'\n'
					fi
				fi

			else
				# if wrap: pending message, command status, and success message
				# if no wrap: success message

				# truncate body if wrapping
				if [[ $option_wrap == 'yes' ]]; then
					# add pending
					if [[ -n $option_pending ]]; then
						messages+="$option_pending"$'\n'
					fi

					# wrap
					if [[ -n $body ]]; then
						# close fragment of ellipses as we have truncated
						messages+="$(echo-style --element="$styled_command_string" --code=' â€¦ ' --/fragment --status="$run_status")"$'\n'
					else
						# self close, as no data
						messages+="$(echo-style --element/="$styled_command_string" --status="$run_status")"$'\n'
					fi
				fi

				# add success
				if [[ -n $option_success ]]; then
					messages+="$option_success"$'\n'
				fi
			fi

			# output
			__flush_messages
		fi
	}
	function run_args_with_optional_elevation {
		# increment attempt
		next_attempt=$((next_attempt + 1))

		# try without sudo if applicable
		if [[ $elevate == 'no' || $elevate_technique == 'none' ]]; then
			styled_command_string="$styled_standard_command_string"
			elevate_prompt='no'
			run_args "${option_cmd[@]}"
			return 0 # exit and delegate to run_status
		elif [[ $elevate == 'failure' ]]; then
			styled_command_string="$styled_standard_command_string"
			elevate_prompt='no'
			run_args "${option_cmd[@]}"
			if [[ $run_status -eq 0 ]]; then
				return 0 # exit and delegate to run_status
			fi
		elif [[ $elevate == 'status' ]]; then
			styled_command_string="$styled_standard_command_string"
			elevate_prompt='no'
			run_args "${option_cmd[@]}"
			for item in "${elevate_on_statuses[@]}"; do
				if [[ $run_status -eq $item ]]; then
					elevate='yes'
					break
				fi
			done
			if [[ $elevate != 'yes' ]]; then
				return 0 # exit and delegate to run_status
			fi
		fi

		# prepare elevation
		if [[ ${#cmd_elevate[@]} -eq 0 ]]; then
			local home='' non_interactive_flags=() suffix_flags=()
			if [[ $elevate_technique == 'sudo' ]]; then
				cmd_elevate+=(sudo)

				# if no-tty, then use the builtin sudo workaround which is the same as Dorothy's
				# cmd_elevate+=('--stdin') # note tha this outputs what they are typing unconcealed to terminal
				# alternative is this insecure option: export SUDO_ASKPASS=...; cmd_elevate+=('--askpass')
				# as this is an edge case in what is meant to be non-interactive environments, this is fine
				# ^ don't do this yet, until someone requests it, I don't know the implications

				# add the things specific to attestation, while prepping home
				# don't use is-directory, is-missing, __elevate_mkdirp, as they will cause infinite recursion
				if [[ -n $option_user ]]; then
					cmd_elevate+=(--user="$option_user")
					# should coincide with [setup-environment-commands]
					if [[ -d /Users ]]; then
						home="/Users/$option_user"
					elif [[ -d '/home' ]]; then
						home="/home/$option_user"
					elif [[ -d "/$option_user" ]]; then
						home="/$option_user"
					fi
				elif [[ -n $HOME ]]; then
					home="$HOME"
				fi
				if [[ -n $option_group ]]; then
					cmd_elevate+=(--group="$option_group")
				fi

				# ensure home is correctly configured for sudo
				if [[ -n $home ]]; then
					if [[ ! -e $home && ! -L $home ]]; then
						if [[ $option_home == 'no' ]]; then
							home='' # root user doesn't need home
						elif mkdir -p -- "$home" &>/dev/null || eval-helper --elevate --no-home -- mkdir -p -- "$home"; then
							fs-own --quiet --user="$option_user" --group="$option_group" --no-recursive -- "$home" || :
						else
							home=''
						fi
					fi
					if [[ -n $home ]]; then
						cmd_elevate+=(--set-home)
					fi
				fi

				# sudo supports passing environment variables
				if [[ $option_inherit == 'yes' ]]; then
					# if you want root `eval-helper --elevate --inherit -- bash -il` to work, then Dorothy's sourcing must be added to `/etc/bashrc` or `/etc/profile`
					cmd_elevate+=(--preserve-env PATH="$PATH") # this might be needed to cause a reload if desired: DOROTHY_LOADED_EXPORT_SCOPE=
					# if it is linux, [sudo PATH=$PATH] doesn't seem to work, but [env PATH=$PATH] does, so just duplicate it
					if is-linux; then
						suffix_flags+=(-- env PATH="$PATH")
					else
						suffix_flags+=(--)
					fi
				fi
				non_interactive_flags+=(--non-interactive -- true)
				# --validate doesn't support a command, so there seems there is no way to check if sudo prompt is required for a specific command:
				# non_interactive_flags+=(--validate -- "${option_cmd[@]}")
			elif [[ $elevate_technique == 'doas' ]]; then
				# https://man.archlinux.org/man/doas.1.en
				cmd_elevate+=(doas)
				if [[ -n $option_user ]]; then
					cmd_elevate+=(-u "$option_user")
				fi
				if [[ -n $option_group ]]; then
					help 'doas does not support --group'
				fi
				# doas doesn't support ENVVAR=value, nor --
				if [[ $option_inherit == 'yes' ]]; then
					suffix_flags+=(env DOROTHY="$DOROTHY" PATH="$PATH")
				fi
				non_interactive_flags+=(-n true)
			fi
			# prevent double -- in the styled command string on macos sudo
			styled_elevate_command_string="$(echo-escape-command -- "${cmd_elevate[@]}" "${suffix_flags[@]}")"
			if [[ $styled_elevate_command_string == *' --' ]]; then
				__replace --source+target={styled_elevate_command_string} --trailing=' --'
			fi
			# generate the styled command string
			styled_elevate_command_string="$(echo-style --elevate="$styled_elevate_command_string" ' ' --code=-- ' ' --="$styled_standard_command_string")"
		fi

		# check if password is required
		# [sudo --validate] doesn't work on multipass, so just use [true] as a no-op
		if [[ $elevate_technique == 'sudo' ]] && ! "${cmd_elevate[@]}" "${non_interactive_flags[@]}" &>/dev/null; then
			# password is required, let the user know what they are being prompted for
			elevate_prompt='yes'
		else
			elevate_prompt='no'
		fi

		# note the elevation
		if [[ ${#option_elevated[@]} -ne 0 && ${#cmd_elevate[@]} -ne 0 ]]; then
			__print_lines "${cmd_elevate[@]}" "${option_cmd[@]}" | echo-write -- "${option_elevated[@]}"
		fi

		# run the possibly elevated command
		styled_command_string="$styled_elevate_command_string"
		run_args "${cmd_elevate[@]}" "${suffix_flags[@]}" "${option_cmd[@]}"
	}

	run_args_with_optional_elevation "${cmd_elevate[@]}" "${option_cmd[@]}"
	function __should_exit {
		if [[ -z $option_until ]]; then
			return 0
		fi
		if [[ -n $option_until_attempts && $next_attempt -gt $option_until_attempts ]]; then
			return 0
		fi
		if [[ $option_until == 'forever' ]]; then
			return 1
		elif [[ $option_until == 'success' ]]; then
			if [[ $run_status -eq 0 ]]; then
				return 0
			else
				return 1
			fi
		elif [[ $option_until == 'failure' ]]; then
			if [[ $run_status -ne 0 ]]; then
				return 0
			else
				return 1
			fi
		elif [[ $option_until -eq $run_status ]]; then
			return 0
		else
			return 1
		fi
	}
	while ! __should_exit; do
		waiter "${option_until_interval:-"10"}" --message="$(echo-style --notice="Attempt #$next_attempt in %s...")"
		# if [[ $option_clear == 'yes' ]]; then
		# 	# clear the previous execution, re-adding the trailing newline
		# 	echo-clear-lines --target=TTY --here-string <<<"$attempt_output"
		# fi
		run_args_with_optional_elevation "${cmd_elevate[@]}" "${option_cmd[@]}"
	done
	if [[ -n $persist ]]; then
		__do --redirect-stdout="$option_persist" -- __print_string "$persist"
	fi
	return "$run_status"
)

# fire if invoked standalone
if [[ $0 == "${BASH_SOURCE[0]}" ]]; then
	if [[ $* == '--test' ]]; then
		eval_helper_test
	else
		eval_helper "$@"
	fi
fi
