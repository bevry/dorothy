#!/usr/bin/env bash

# NOTE:

# [sudo] and [doas] asks for your own password, not the target users password
# [su] asks for the target user password
# [sudo] and [doas] can be configured via their configuration files to target other users, not just [root]

# EXAMPLE:

# with this sudoers configuration file
# developer ALL=(root,webuser) /a-special-echo arg1 arg2

# and with /a-special-echo only being executable to [root] and [webuser]:
# sudo chown root:webuser /a-special-echo
# sudo chmod 750 /a-special-echo

# if you are [webuser], you can run this without escalation (not because of sudoers, but because of the file-system permissions):
# /a-special-echo arg1 arg2

# if you are [someuser], you will be denied ability to run this (not because of sudoers, but because of the file-system permissions):
# /a-special-echo arg1 arg2
# and if that was the only configuration in sudoers, you would also be denied escalation to [root] or [webuser]

# if you are [developer], you will be denied ability to run this (not because of sudoers, but because of the file-system permissions):
# /a-special-echo arg1 arg2
# however, sudoers will allow [developer] to elevate to [root] or [webuser]:
# sudo /a-special-echo arg1 arg2
# sudo -u webuser /a-special-echo arg1 arg2

# TERMINOLOGY

# "privilege escalation" is a bad thing: https://en.wikipedia.org/wiki/Privilege_escalation
# use elevation/grant/authorise when it is good thing: https://en.wikipedia.org/wiki/Privilege_elevation

# SUDO

# https://man.openbsd.org/doas
# https://man.archlinux.org/man/doas.1.en

# https://manpages.ubuntu.com/manpages/xenial/man8/sudo.8.html
# -E, --preserve-env
#    preserve user environment when running command
# -H, --set-home
#    set HOME variable to target user's home dir
# -i, --login
#    Run the shell specified by the target user's password database entry as a login shell.

# DOAS

function eval_helper_test() (
	source "$DOROTHY/sources/bash.bash"
	echo-style --h1="TEST: $0"

	eval-tester -- \
		eval-helper -- \
		waiter --timeout=0

	eval-tester --stdout=my-stdout --stderr=my-stderr -- \
		eval-helper --pending=my-pending --failure=my-failure --success=my-success -- \
		waiter --timeout=0 --stdout=my-stdout --stderr=my-stderr

	eval-tester --stdout=my-stdout --stderr=my-stderr --status=123 -- \
		eval-helper --pending=my-pending --failure=my-failure --success=my-success -- \
		waiter --timeout=0 --status=123 --stdout=my-stdout --stderr=my-stderr

	eval-tester --stdout=my-stdout --stderr=my-stderr -- \
		eval-helper --wrap --pending=my-pending --failure=my-failure --success=my-success -- \
		waiter --timeout=0 --stdout=my-stdout --stderr=my-stderr

	eval-tester --stdout=my-stdout --stderr=my-stderr -- \
		eval-no-color -- \
		eval-helper --wrap --pending=my-pending --failure=my-failure --success=my-success -- \
		waiter --timeout=0 --stdout=my-stdout --stderr=my-stderr

	eval-tester --stdout=my-stdout --stderr=$'my-pending\n<w>\nmy-stderr\n</w>[0]\nmy-success' -- \
		eval-no-color -- \
		eval-helper --message-target=STDERR --command-string=w --wrap --pending=my-pending --failure=my-failure --success=my-success -- \
		waiter --timeout=0 --stdout=my-stdout --stderr=my-stderr

	# --screen does not affect verbosity and results
	eval-tester --stdout=my-stdout --stderr=$'my-pending\n<w>\nmy-stderr\n</w>[0]\nmy-success' -- \
		eval-no-color -- \
		eval-helper- --screen --message-target=STDERR --command-string=w --wrap --pending=my-pending --failure=my-failure --success=my-success -- \
		waiter --timeout=0 --stdout=my-stdout --stderr=my-stderr

	echo-style --g1="TEST: $0"
	return 0
)
function eval_helper() (
	source "$DOROTHY/sources/bash.bash"

	# =====================================
	# Arguments

	function help {
		cat <<-EOF >&2
			ABOUT:
			Helpers for working with commands.

			USAGE:
			eval-helper [...options] -- ...<command>

			QUIRKS:
			Unless [--no-quiet] aka [--failure-verbosity=full --success=mode=full] is used, then the command's STDOUT and STDERR will be merged into STDERR.
			Messages (pending, success, failure) are output to TTY if available, otherwise STDERR.

			OPTIONS:
			--message-target=<message-target>
			    By default, messages are output to TTY.
			--[no-]wrap
			    If enabled, the output of the command will be wrapped in a message detailing the command itself, e.g.: < command arg >...</ command arg >
			    Disabled by default, such that TTY/STDERR/STDOUT are not altered.
			--command=<command-string>
			    If provided, use this string instead of the escaped <command>, when wrapping.
			--pending=<pending>
			    If provided, will output the <pending> message before and while the command executes.
			--failure=<failure>
			    If provided, will output the <failure> message if the command failed.
			--success=<success>
			    If provided, will output the <success> message if the command succeeded.

			--[no-]quiet | --[no-]verbose
			    If --verbose or --no-quiet, becomes:
			        --failure-verbosity=full --success-verbosity=full
			    If --quiet or --no-verbose, becomes:
			        --failure-verbosity=full --success-verbosity=conclusion
			    If missing or empty, defaults to result of [get-terminal-quiet-support].
			    As such, if you require STDOUT of the command, be sure to to provide --verbose.
			--verbosity=<verbosity>
			    Becomes --failure-verbosity=<verbosity> --success-verbosity=<verbosity>
			--failure-verbosity=<failure-verbosity>
			    If full: message for pending, message for wrap open, command output, message for wrap close and status, message for failure.
			    If summary: message for pending, message for wrap and status, message for failure.
			    If conclusion: message for failure.
			    If summary or conclusion, must be used alongside either --truncate or --screen.
			--success-verbosity=<success-verbosity>
			    If full: message for pending, message for wrap open, command output, message for wrap close and status, message for success.
			    If summary: message for pending, message for wrap and status, message for success.
			    If conclusion: message for success.
			    If summary or conclusion, must be used alongside either --truncate or --screen.

			--[no-]trim
			    If enabled, trim padding at the start and end of the command output. See [echo-trim-padding] for details.
			--[no-]truncate=<lines:integer|terminal>
			    If enabled, the command output to STDOUT, STDERR (and TTY by attempt) will be truncated during execution to this amount of revolving lines (if enabled, <lines> defaults to [1]). Shapeshifting ANSI Escape Codes will be escaped. This inhibits accurate capturing of command output, as such this transforms command output into a message, as such it will go to <message-target>. If set to [0] all command output will be attempted to be hidden. See [echo-revolving-door] for details.
			--[no-]screen | --[no-]shapeshifter
			    If enabled, the command will run in an alternative terminal buffer. Use this if the command is a shapeshifter (uses ANSI escape codes to modify lines and cursor).
			    By default, this is disabled unless invoking a known shapeshifter.
			    This option isn't that useful if you are not doing [summary] or [conclusion] verbosities.

			--[no-]confirm
			    Confirm execution of the command before its first execution (--until usage could mean multiple executions).
			    Disabled by default.

			--until=<forever|success|failure|<exit-status>>
			    If forever, keep (re-)running the command forever.
			    If success, keep (re-)running the command until a successful exit status.
			    If failure, keep (re-)running the command until a failure exit status.
			    If <exit-status>, keep (re-)running the command until the specified exit status. Can only be specified once.
			    Disabled byy default.
			--until-interval=<seconds>
			    Specify the interval between attempts.
			    Defaults to 10 seconds.
			    This is only used if [--until] is specified.

			--elevated=<file-path|file-descriptor|device-file>
			    If specified, if the <command> required elevation, appends <command> with a training newline to this target.
			    Can be specified multiple times, and targets can be newline separated.
			--elevate=<yes|no|''|failure|<exit-status>>
			    If specified as [yes], then the command will execute with elevated privileges, be it via sudo or doas, or neither if not needed.
			    If <user> or <group> is specified, it will be elevated and the remaining alternatives are discarded:
			    If specified as [no], then the command will be run without elevation.
			    If specified as [failure], then the command will be run without elevation, and if it fails, it will be run again with elevation.
			    If specified as an integer, then the command will be run without elevation, and if it fails with that exit status, it will be run again with elevation.
			    Can be specified multiple times, and can be [\n\t ,|] separated. [yes] and [no] values will reset prior values.
			    If this is not specified at all, or is only empty strings, it will default to [no].
			--user=<user>
			    Specify a user to run the command as. Forces --elevate=yes
			--group=<group>
			    Specify a group to run the command as. Forces --elevate=yes
			--reason=<reason>
			    If a prompt is required to momentarily grant privileges, this reason will be used to explain why elevation was required.
			--inherit
			    If enabled, when elevating, the PATH will be inherited to the executing command.

		EOF
		if [[ $# -ne 0 ]]; then
			echo-error "$@"
		fi
		return 22 # EINVAL 22 Invalid argument
	}

	# process
	local item \
		option_message_target='TTY' option_wrap='' option_cmd=() option_pending='' option_failure='' option_failure='' \
		option_quiet option_failure_verbosity='' option_success_verbosity='' \
		option_trim='' option_truncate='' option_screen='' \
		option_confirm='' \
		option_until='' option_until_interval='' \
		option_elevated=() option_elevate=() option_user='' option_group='' option_reason='' option_inherit='no'
	if get-terminal-reactivity-support; then
		option_quiet="$(get-terminal-quiet-support || :)"
	else
		option_quiet='no'
	fi
	function parse_elevated {
		local value="$1" values=()
		if [[ -n $value ]]; then
			mapfile -t values < <(
				echo-split --no-zero-length --characters=$'\n\t' -- "$value"
			)
			option_elevated+=("${values[@]}")
		fi
	}
	function parse_elevate {
		local value="$1" values=()
		if [[ -n $value ]]; then
			mapfile -t values < <(
				echo-split --no-zero-length --characters=$'\n\t ,|' -- "$value"
			)
			option_elevate+=("${values[@]}")
		fi
	}
	while [[ $# -ne 0 ]]; do
		item="$1"
		shift
		case "$item" in
		'--help' | '-h') help ;;
		'--no-verbose'* | '--verbose'*)
			option_quiet="$(get-flag-value --non-affirmative --fallback="$option_quiet" -- "$item")"
			;;
		'--no-quiet'* | '--quiet'*)
			option_quiet="$(get-flag-value --affirmative --fallback="$option_quiet" -- "$item")"
			;;
		'--until='*) option_until="${item#*=}" ;;
		'--until-interval='* | '--until-delay='*) option_until_interval="${item#*=}" ;;
		'--success-verbosity='*) option_success_verbosity="${item#*=}" ;;
		'--failure-verbosity='*) option_failure_verbosity="${item#*=}" ;;
		'--pending='*) option_pending="${item#*=}" ;;
		'--success='*) option_success="${item#*=}" ;;
		'--failure='*) option_failure="${item#*=}" ;;
		'--command='*) option_command_string="${item#*=}" ;;
		'--no-trim'* | '--trim'*)
			option_trim="$(get-flag-value --affirmative --fallback="$option_trim" -- "$item")"
			;;
		'--no-confirm'* | '--confirm'*)
			option_confirm="$(get-flag-value --affirmative --fallback="$option_confirm" -- "$item")"
			;;
		'--no-shapeshifter'* | '--shapeshifter'*)
			option_shapeshifter="$(get-flag-value --affirmative --fallback="$option_shapeshifter" -- "$item")"
			;;
		'--no-wrap'* | '--wrap'*)
			option_wrap="$(get-flag-value --affirmative --fallback="$option_wrap" -- "$item")"
			;;
		# elevation
		'--elevated='*)
			parse_elevated "${item#*=}"
			;;
		'--no-elevate'* | '--elevate'*)
			parse_elevate "$(get-flag-value --affirmative -- "$item")"
			;;
		'--user='*) option_user="${item#*=}" ;;
		'--group='*) option_group="${item#*=}" ;;
		'--reason='*) option_reason="${item#*=}" ;;
		'--no-inherit'* | '--inherit'*)
			option_inherit="$(get-flag-value --affirmative --fallback="$option_inherit" -- "$item")"
			;;
		# command
		'--')
			option_cmd+=("$@")
			shift $#
			break
			;;
		'--'*) help "An unrecognised flag was provided: $item" ;;
		*) help "An unrecognised argument was provided: $item" ;;
		esac
	done

	# check
	if [[ ${#option_cmd[@]} -eq 0 ]]; then
		help 'No <command> was provided.'
	fi

	# determine elevate technique
	local elevate_technique
	if __command_exists -- sudo; then
		elevate_technique='sudo'
	elif __command_exists -- doas; then
		elevate_technique='doas'
	else
		elevate_technique='none'
	fi

	# quiet, verbose, modes
	if [[ -n $option_success_verbosity ]]; then

	fi
	if [[ -n $option_failure_verbosity ]]; then
	fi

	# ensure items that write to TTY are cleared correctly
	if [[ -z $option_shapeshifter ]]; then
		case "${option_cmd[*]}" in
		'ssh '*) option_shapeshifter='yes' ;;
		*) option_shapeshifter='no' ;;
		esac
	fi

	# =====================================
	# Action

	# element
	local element_open='' command_style='code'
	if [[ -z $option_command_string ]]; then
		option_command_string="$(
			echo-style --"$command_style"="$(
				echo-escape-command -- "${option_cmd[@]}"
			)"
		)"
	fi
	if [[ $option_wrap == 'yes' ]]; then
		element_open="$(echo-style --element="$option_command_string")"
	else
		element_open="$(echo-style --code="$option_command_string")"
	fi

	# confirm
	if [[ $option_confirm == 'yes' ]] && ! confirm --positive --ppid=$$ -- 'Confirm execution of the command that is below:' "$element_open"; then
		echo-style --tty --notice1='Skipped execution of:' --code-notice1="$element_open"
		return 0
	fi

	# messages
	local messages=''
	function flush_messages {
		if [[ -n $messages ]]; then
			__do --redirect-stdout=TTY -- __print_string "$messages"
			messages=''
		fi
	}

	# headers
	local header=''
	if [[ -n $option_pending ]]; then
		header+="$option_pending"$'\n'
	fi
	if [[ $option_wrap == 'yes' ]]; then
		header+="$element_open"$'\n'
	fi
	if [[ -n $header ]]; then
		messages+="$header"
		flush_messages
	fi

	# output everything if already inside a revolving door, or if in verbose mode
	local cmd_status=0
	if [[ ${INSIDE_REVOLVING_DOOR-} == 'yes' || $option_quiet == 'no' ]]; then
		# body
		if [[ $option_trim == 'yes' ]]; then
			__do --redirect-status={cmd_status} --redirect-stdout='(echo-trim-padding --stdin)' --redirect-stderr='(echo-trim-padding --stdin >&2)' -- "${option_cmd[@]}"
		else
			__try {cmd_status} -- "${option_cmd[@]}"
		fi

		# add close
		if [[ $option_wrap == 'yes' ]]; then
			messages+="$(echo-style --/element="$option_command_string" --status="$cmd_status")"$'\n'
		fi

		# add success or failure
		if [[ $cmd_status -eq 0 ]]; then
			if [[ -n $option_success ]]; then
				messages+="$option_success"$'\n'
			fi
		else
			if [[ -n $option_failure ]]; then
				messages+="$option_failure"$'\n'
			fi
		fi

		# output
		flush_messages
	else
		# not inside a revolving door, and not in verbose mode
		local terminal_size terminal_columns=0
		mapfile -t terminal_size < <(get-terminal-lines-and-columns || :)
		if [[ ${#terminal_size[@]} -eq 2 ]]; then
			terminal_columns="${terminal_size[1]}"
		fi

		# body
		local body
		if [[ $option_shapeshifter == 'yes' ]]; then # no need for INSIDE_REVOLVING_DOOR check here as it happens earlier
			# this is used if the command writes to TTY, instead of stdout/stderr, or outputs ANSI escape codes that modify the cursor
			# in which case echo-revolving-door fails to clear
			echo-style --no-trail --tty --alternative-screen-buffer --="$header" # redo header inside alt tty while its active
			__do --redirect-status={cmd_status} --redirect-output=stderr --copy-stderr={body} --redirect-stderr=tty -- "${option_cmd[@]}"
			echo-style --no-trail --tty --default-screen-buffer
		else
			local INSIDE_REVOLVING_DOOR__original_for_restore="${INSIDE_REVOLVING_DOOR:-"no"}"
			export INSIDE_REVOLVING_DOOR='yes' # use export, as env doesn't work when option_cmd[0] was a function
			# direct stdout and stderr to TTY, as they will be truncated and will be outputting clear ansi codes, which will confuse anything that is expecting legit TTY output
			__do --redirect-status={cmd_status} --redirect-output=stderr --copy-stderr={body} --redirect-stderr="(echo-revolving-door --target=TTY --columns="$terminal_columns")" -- "${option_cmd[@]}"
			# we cannot detect shapeshifting after the fact, as it occurs in the TTY, not stdout, nor stderr
			export INSIDE_REVOLVING_DOOR="$INSIDE_REVOLVING_DOOR__original_for_restore"
		fi

		# clear header, we can re-add them later if needed
		echo-clear-lines --target=TTY --here-string <<<"$header"

		# generate output
		if [[ $option_quiet == 'no' || $cmd_status -ne 0 ]]; then
			# pending message, command output and status, and success or failure message

			# add pending
			if [[ -n $option_pending ]]; then
				messages+="$option_pending"$'\n'
			fi

			# add body
			if [[ -n $body && $option_trim == 'yes' ]]; then
				body="$(echo-trim-padding -- "$body")"
			fi
			if [[ $option_wrap == 'no' ]]; then
				if [[ -n $body ]]; then
					flush_messages
					__print_lines "$body" >&2
				fi
			else
				if [[ -n $body ]]; then
					messages+="$(echo-style --element="$option_command_string")"$'\n'
					flush_messages
					__print_lines "$body" >&2
					messages+="$(echo-style --/element="$option_command_string" --status="$cmd_status")"$'\n'
				else
					messages+="$(echo-style --element="$option_command_string" --/fragment='' --status="$cmd_status")"$'\n'
				fi
			fi

			# add success or failure
			if [[ $cmd_status -eq 0 ]]; then
				if [[ -n $option_success ]]; then
					messages+="$option_success"$'\n'
				fi
			else
				if [[ -n $option_failure ]]; then
					messages+="$option_failure"$'\n'
				fi
			fi

		elif [[ -z $option_quiet ]]; then
			# pending message, command status, and success message

			# add pending
			if [[ -n $option_pending ]]; then
				messages+="$option_pending"$'\n'
			fi

			# truncate body if wrapping
			if [[ $option_wrap == 'yes' ]]; then
				# trim
				if [[ -n $body && $option_trim == 'yes' ]]; then
					body="$(echo-trim-padding -- "$body")"
				fi
				# check if still has data after trim
				if [[ -n $body ]]; then
					# self close as we are truncating
					messages+="$(echo-style --/element="$option_command_string" --status="$cmd_status")"$'\n'
				else
					# close fragment as there is no data
					messages+="$(echo-style --element="$option_command_string" --/fragment --status="$cmd_status")"$'\n'
				fi
			fi

			# add success
			if [[ -n $option_success ]]; then
				messages+="$option_success"$'\n'
			fi
		elif [[ $option_quiet == 'yes' ]]; then
			# only success message

			# add success
			if [[ -n $option_success ]]; then
				messages+="$option_success"$'\n'
			fi
		fi

		# output
		flush_messages
	fi

	# done
	return "$cmd_status"
)


# fire if invoked standalone
if [[ $0 == "${BASH_SOURCE[0]}" ]]; then
	if [[ $* == '--test' ]]; then
		eval_helper_test
	else
		eval_helper "$@"
	fi
fi
