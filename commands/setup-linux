#!/usr/bin/env bash

function setup_linux_test() (
	source "$DOROTHY/sources/bash.bash"
	eval-tester --ignore-stderr --status=22 -- setup-linux --help
)

function setup_linux() (
	source "$DOROTHY/sources/bash.bash"
	source "$(type -P eval-helper)"

	# =====================================
	# Arguments

	function help {
		__print_help "$@" <<-EOF || return $?
			ABOUT:
			Configure Linux to our expectations.

			USAGE:
			\`setup-linux <install|update|clean>\`
		EOF
		return 22 # EINVAL 22 Invalid argument
	}

	# process
	local item action=''
	while [[ $# -ne 0 ]]; do
		item="$1"
		shift
		case "$item" in
		'--help' | '-h') help ;;
		'--'*) help 'An unrecognised flag was provided: ' --variable-value={item} ;;
		*)
			if [[ -z $action ]]; then
				action="$item"
			else
				help 'An unrecognised argument was provided: ' --variable-value={item}
			fi
			;;
		esac
	done

	# assert compatibility
	if ! __is_linux; then
		help 'This command is only purposeful on Linux systems, which you are not running.'
	fi

	# assert action
	if [[ -z $action ]]; then
		help --help='An <action> must be provided.'
	fi

	# generate log title
	local action_title
	action_title="$(__get_uppercase_first_letter -- "$action")"
	action_title+=' Linux'

	# =====================================
	# Configuration

	source "$DOROTHY/sources/config.sh"

	# setup.bash provides:
	local APK_INSTALL=()
	local APT_INSTALL=()
	local APT_UNINSTALL=()
	local AUR_INSTALL=()
	local FLATPAK_INSTALL=()
	local RPM_INSTALL=()
	local SNAP_INSTALL=()
	local ZYPPER_INSTALL=()
	local APT_ADD=()    # deprecated, use APT_INSTALL
	local APT_REMOVE=() # deprecated, use APT_UNINSTALL
	load_dorothy_config 'setup.bash'

	# deprecations
	if [[ ${#APT_ADD[@]} -ne 0 ]]; then
		APT_INSTALL+=("${APT_ADD[@]}")
		dorothy-config 'setup.bash' -- \
			--field='APT_ADD' --replace= \
			--field='APT_INSTALL' --array="$(echo-unique --ignore-case -- "${APT_INSTALL[@]}")"
	fi
	if [[ ${#APT_REMOVE[@]} -ne 0 ]]; then
		APT_UNINSTALL+=("${APT_REMOVE[@]}")
		dorothy-config 'setup.bash' -- \
			--field='APT_REMOVE' --replace= \
			--field='APT_UNINSTALL' --array="$(echo-unique --ignore-case -- "${APT_UNINSTALL[@]}")"
	fi

	# adjustments
	__split --target={APK_INSTALL} --no-zero-length --invoke -- \
		dorothy-config --packages-var='APK_INSTALL' -- "${APK_INSTALL[@]}"
	__split --target={APT_INSTALL} --no-zero-length --invoke -- \
		dorothy-config --packages-var='APT_INSTALL' -- "${APT_INSTALL[@]}"
	__split --target={APT_UNINSTALL} --no-zero-length --invoke -- \
		dorothy-config --packages-var='APT_UNINSTALL' -- "${APT_UNINSTALL[@]}"
	__split --target={AUR_INSTALL} --no-zero-length --invoke -- \
		dorothy-config --packages-var='AUR_INSTALL' -- "${AUR_INSTALL[@]}"
	__split --target={FLATPAK_INSTALL} --no-zero-length --invoke -- \
		dorothy-config --packages-var='FLATPAK_INSTALL' -- "${FLATPAK_INSTALL[@]}"
	__split --target={RPM_INSTALL} --no-zero-length --invoke -- \
		dorothy-config --packages-var='RPM_INSTALL' -- "${RPM_INSTALL[@]}"
	__split --target={SNAP_INSTALL} --no-zero-length --invoke -- \
		dorothy-config --packages-var='SNAP_INSTALL' -- "${SNAP_INSTALL[@]}"
	__split --target={ZYPPER_INSTALL} --no-zero-length --invoke -- \
		dorothy-config --packages-var='ZYPPER_INSTALL' -- "${ZYPPER_INSTALL[@]}"

	# =====================================
	# Helpers

	# APK
	# https://wiki.alpinelinux.org/wiki/Package_management#Upgrade_a_Running_System

	# DNF
	# https://linuxcommandlibrary.com/man/dnf.html

	# Flatpak
	# https://manpages.org/flatpak/1
	# https://manpages.org/flatpak-update
	# `full-upgrade` is the same as `dist-upgrade` apparently, which is a more automatic/comprehensive upgrade compared to `apt-get upgrade`

	# Pacman
	# https://archlinux.org/pacman/pacman.8.html

	# Pamac
	# https://linuxcommandlibrary.com/man/pamac

	# Snap
	# https://manpages.org/snap

	# Zypper
	# https://www.mankier.com/8/zypper

	# -------------------------------------
	# Update References

	# pamac/flatpak do not have update without upgrade
	local updates=(
		'apk'
		'apk'
		'dnf'
		'pacman'
		'urpmi'
		'yum'
		'zypper'
	)

	function do_apk_update {
		apk update
	}

	function do_apt_update {
		eval-helper --elevate -- apt-get update -y
	}

	function do_dnf_update {
		eval-helper --elevate -- dnf check-update --assumeyes
	}

	function do_pacman_update {
		# init the local database
		# this is needed on systems which pacman was installed
		eval-helper --elevate -- pacman-key --init
		# refresh the local database
		eval-helper --elevate -- pacman --noconfirm --refresh --sync
	}

	function do_urpmi_update {
		# https://wiki.mageia.org/en/URPMI#Basic_commands:_Install.2C_remove.2C_update
		eval-helper --elevate -- urpmi.update -a
	}

	function do_yum_update {
		eval-helper --elevate -- yum check-update -y || :
		# ^ it always returns exit code 100
	}

	function do_zypper_update {
		eval-helper --elevate -- zypper --non-interactive --gpg-auto-import-keys refresh
	}

	# -------------------------------------
	# Upgrade Packages

	# pacman can only upgrade specific packages, not all packages
	local upgrades=(
		'apk'
		'apt'
		'dnf'
		'flatpak'
		'pamac'
		'snap'
		'urpmi'
		'yum'
		'zypper'
	)

	function do_apk_upgrade {
		apk upgrade
	}

	function do_apt_upgrade {
		eval-helper --elevate -- apt-get full-upgrade -y
	}

	function do_urpmi_upgrade {
		eval-helper --elevate -- urpmi --auto-update --auto
	}

	function do_dnf_upgrade {
		# --refresh Set metadata as expired before running the command.
		# -y, --assumeyes Automatically answer yes for all questions.
		# -b, --best Try the best available package versions in transactions. Specifically during dnf upgrade, which by default skips over updates that can not be installed for dependency reasons, the switch forces DNF to only consider the latest packages. When running into packages with broken dependencies, DNF will fail giving a reason why the latest version can not be installed. Note that the use of the newest available version is only guaranteed for the packages directly requested (e.g. as a command line arguments), and the solver may use older
		# --allowerasing Allow erasing of installed packages to resolve dependencies. This option could be used as an alternative to the yum swap command where packages to remove are not explicitly defined.
		eval-helper --elevate -- dnf upgrade --assumeyes --refresh --best --allowerasing
	}

	function do_flatpak_upgrade {
		eval-helper --elevate -- flatpak update -y
		# ^ sudo with flatpak avoids gui sudo prompt
	}

	function do_pamac_upgrade {
		eval-helper --elevate -- pamac upgrade --no-confirm
		# ^ sudo with pamac avoids gui sudo prompt
		# ^ `pamac update` is an alias for `pamac upgrade`
	}

	function do_snap_upgrade {
		if ! is-system --snap; then
			return 0
		fi
		eval-helper --elevate -- snap refresh || : # if snap was just installed on fedora, this can fail initially
	}

	function do_yum_upgrade {
		eval-helper --elevate -- yum upgrade -y --best
	}

	function do_zypper_upgrade {
		eval-helper --elevate -- zypper --non-interactive --gpg-auto-import-keys update --no-confirm --best-effort
	}

	# -------------------------------------
	# Install Packages

	local packages=(
		'apk'
		'apt'
		'aur'
		'flatpak'
		'rpm'
		'snap'
		'zypper'
	)

	function do_apk_packages {
		setup-util --source=APK -- "${APK_INSTALL[@]}"
	}

	function do_apt_packages {
		# apt uninstall
		setup-util --source=APT --uninstall -- "${APT_UNINSTALL[@]}"

		# apt install
		setup-util --source=APT -- "${APT_INSTALL[@]}"
	}

	function do_aur_packages {
		setup-util --source=AUR -- "${AUR_INSTALL[@]}"
	}

	function do_flatpak_packages {
		setup-util --source=FLATPAK -- "${FLATPAK_INSTALL[@]}"
	}

	function do_rpm_packages {
		setup-util --source=RPM -- "${RPM_INSTALL[@]}"
	}

	function do_snap_packages {
		if ! is-system --snap; then
			return 0
		fi
		setup-util --source=SNAP -- "${SNAP_INSTALL[@]}"

		# configure with
		# snap list --color=never | "$bin_gsed" '1d' | cut -d' ' -f1 | grep --invert-match --extended-regexp --regexp='^(core|snapd)'
	}

	function do_zypper_packages {
		setup-util --source=ZYPPER -- "${ZYPPER_INSTALL[@]}"
	}

	# -------------------------------------
	# Clean System

	local clean=(
		'apt'
		'dnf'
		'pacman'
		'pamac'
		'yum'
		'zypper'
	)

	function do_apt_clean {
		eval-helper --elevate -- apt-get autoremove -y --purge
		eval-helper --elevate -- apt-get autoclean -y
		eval-helper --elevate -- apt-get clean -y
	}

	function do_dnf_clean {
		eval-helper --elevate -- dnf clean all
	}

	function do_pamac_clean {
		eval-helper --elevate -- pamac clean --no-confirm
		# ^ sudo with pamac avoids gui sudo prompt
	}

	function do_pacman_clean {
		# -c, --clean
		#   Remove packages that are no longer installed from the cache as well as currently unused sync databases to free up disk space.
		eval-helper --elevate -- pacman --sync --noconfirm --clean
	}

	function do_yum_clean {
		eval-helper --elevate -- yum clean all
	}

	function do_zypper_clean {
		eval-helper --elevate -- zypper --non-interactive --gpg-auto-import-keys clean --all
	}

	# -------------------------------------
	# Upgrade System

	function do_apt_system {
		if __command_missing -- do-release-upgrade; then
			return 0
		fi
		# check for a new distro release
		if do-release-upgrade -c; then
			# if there is one, then ask the user if they want to upgrade to it
			if confirm --linger --negative --ppid=$$ -- 'Upgrade the distribution release?'; then
				eval-helper --elevate -- do-release-upgrade
			fi
		fi
	}

	# =====================================
	# Action

	# prepare
	local item

	# action
	if [[ $action == 'clean' ]]; then
		# clean ecosystems
		for item in "${clean[@]}"; do
			if __command_exists -- "$item"; then
				eval_helper --no-wrap --shapeshifter \
					--pending="$(__print_style --bold="Cleaning $item...")" \
					--success="$(__print_style --success="Cleaned $item.")" \
					--failure="$(__print_style --error="Failed to clean $item.")" -- \
					"do_${item}_clean"
			fi
		done
	elif [[ $action =~ ^(install|update)$ ]]; then
		# log
		__print_style --h1="$action_title"

		# update references
		for item in "${updates[@]}"; do
			if __command_exists -- "$item"; then
				eval_helper --no-wrap --shapeshifter \
					--pending="$(__print_style --bold="Updating references of $item...")" \
					--success="$(__print_style --success="Updated references of $item.")" \
					--failure="$(__print_style --error="Failed to update references of $item.")" -- \
					"do_${item}_update"
			fi
		done

		# setup essential system utilities
		setup-util-devel
		setup-linux-raspi "$action"
		setup-linux-recovery

		# install package managers
		if [[ $action == 'install' ]]; then
			# in this order, based on dependency relationships
			setup-util-pamac --optional --confirm
			setup-util-snap --optional --confirm
			setup-util-flatpak --optional --confirm
			setup-util-gnome-software --optional --confirm
		fi

		# upgrade all packages
		# ask, because manjaro and other rolling releases can demand over 40GB for initial upgrades
		if confirm --linger --positive --ppid=$$ -- 'Upgrade existing packages?'; then
			for item in "${upgrades[@]}"; do
				if __command_exists -- "$item"; then
					eval_helper --no-wrap --shapeshifter \
						--pending="$(__print_style --bold="Upgrading packages of $item...")" \
						--success="$(__print_style --success="Upgraded packages of $item.")" \
						--failure="$(__print_style --error="Failed to upgrade packages of $item.")" -- \
						"do_${item}_upgrade"
				fi
			done
		fi

		# upgrade the entire system
		do_apt_system

		# setup user packages
		for item in "${packages[@]}"; do
			if __command_exists -- "$item"; then
				eval_helper --no-wrap --shapeshifter \
					--pending="$(__print_style --bold="Installing packages of $item...")" \
					--success="$(__print_style --success="Installed packages of $item.")" \
					--failure="$(__print_style --error="Failed to install packages of $item.")" -- \
					"do_${item}_packages"
			fi
		done

		# log
		__print_style --g1="$action_title"
	else
		# unknown action
		help --help='An unrecognised <action> was provided: ' --variable-value={action}
	fi

)

# fire if invoked standalone
if [[ $0 == "${BASH_SOURCE[0]}" ]]; then
	if [[ $* == '--test' ]]; then
		setup_linux_test
	else
		setup_linux "$@"
	fi
fi
