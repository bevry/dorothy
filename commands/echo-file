#!/usr/bin/env bash

# @todo support these:
# https://github.com/swsnr/mdcat
# https://github.com/efugier/smartcat

function echo_file() (
	source "$DOROTHY/sources/stdinargs.bash"

	# =====================================
	# Arguments

	function help {
		cat <<-EOF >/dev/stderr
			ABOUT:
			Output the contents of the passed file paths.

			USAGE:
			echo-file [...options] [--] ...<path>
			echo-lines ...<path> | echo-file [...options]

			OPTIONS:
			--[no-]bat
			    If affirmative, install and use [bat] if it doesn't exist.
				If missing, use [bat] if it exists.
				If negative, don't use [bat].

			--raw
			    No line numbers or filename, only file contents.
			--trim
			    Trim the padding at the start and end of the file. Requires --raw.

			--plain
			    No line numbers.

			$(stdinargs_options_help --)
		EOF
		if [[ $# -ne 0 ]]; then
			echo-error "$@"
		fi
		return 22 # EINVAL 22 Invalid argument
	}

	# process our own arguments, delegate everything else to stdinargs
	local item option_bat='' option_raw='no' option_plain='no' option_trim='' option_sudo='' option_args=()
	while [[ $# -ne 0 ]]; do
		item="$1"
		shift
		case "$item" in
		'--help' | '-h') help ;;
		'--no-bat'* | '--bat'*)
			option_bat="$(get-flag-value --affirmative --fallback="$option_bat" -- "$item")"
			;;
		'--no-raw'* | '--raw'*)
			option_raw="$(get-flag-value --affirmative --fallback="$option_raw" -- "$item")"
			;;
		'--no-plain'* | '--plain'*)
			option_plain="$(get-flag-value --affirmative --fallback="$option_plain" -- "$item")"
			;;
		'--no-trim'* | '--trim'*)
			option_trim="$(get-flag-value --affirmative --fallback="$option_trim" -- "$item")"
			;;
		'--no-sudo'* | '--sudo'*)
			option_sudo="$(get-flag-value --affirmative --fallback="$option_sudo" -- "$item")"
			;;
		# forward to stdinargs, however support mixing and matching of our options, with stdinargs options
		'--')
			option_args+=("$item" "$@")
			shift $#
			break
			;;
		*) option_args+=("$item") ;;
		esac
	done

	# install bat if yes
	if [[ $option_bat == 'yes' ]]; then
		setup-util-bat --quiet
	elif [[ -z $option_bat ]]; then
		if __command_exists -- bat; then
			option_bat='yes'
		else
			option_bat='no'
		fi
	fi

	if [[ $option_trim == 'yes' && $option_raw != 'yes' ]]; then
		help 'The --trim option requires --raw.'
	fi

	# =====================================
	# Action

	function eval_file {
		local file="$1" status=0 sudo="$option_sudo" eval=("${@:2}") reason
		if [[ -z $file ]]; then
			echo-style --error1='The file is an empty path: ' --code-error1="$file" >/dev/stderr
			return "$status"
		fi
		if [[ -z $sudo ]]; then
			eval_capture --statusvar=status -- is-readable --no-sudo -- "$file"
			if [[ $status -eq 93 ]]; then
				# sudo can write to anything
				sudo='yes'
				status=0
			elif [[ $status -eq 13 ]]; then
				eval_capture --statusvar=status -- is-readable --sudo -- "$file"
			fi
		elif [[ $sudo == 'yes' ]]; then
			eval_capture --statusvar=status -- is-readable --sudo -- "$file"
		else
			eval_capture --statusvar=status -- is-readable --no-sudo -- "$file"
		fi
		if [[ $status -eq 13 ]]; then
			echo-style --error1='The file is not accessible: ' --code-error1="$file" >/dev/stderr
			return "$status"
		elif [[ $status -eq 93 ]]; then
			echo-style --error1='The file is not readable: ' --code-error1="$file" >/dev/stderr
			return "$status"
		elif [[ $status -eq 2 ]]; then
			echo-style --error1='The file does not exist: ' --code-error1="$file" >/dev/stderr
			return "$status"
		elif [[ $status -eq 9 ]]; then
			echo-style --error1='The file is a broken symlink: ' --code-error1="$file" >/dev/stderr
			return "$status"
		elif [[ $status -ne 0 ]]; then
			echo-style --error1='The file encountered an error: ' --code-error1="$file" --error1=' ' --code-error="$status" >/dev/stderr
		fi
		if [[ $sudo == 'yes' ]]; then
			reason="Your sudo/root/login password is required to read the file: $file"
			if [[ ${eval[0]} == 'cat' ]]; then
				sudo-helper --reason="$reason" -- "${eval[@]}"
			else
				sudo-helper --reason="$reason" --inherit -- "${eval[@]}"
			fi
		else
			"${eval[@]}" # eval
		fi
	}

	function raw_file {
		local file="$1"
		if [[ $option_trim == 'yes' ]]; then
			eval_file "$file" cat "$file" | echo-trim-padding --stdin
		else
			eval_file "$file" cat "$file"
		fi
	}

	if [[ $option_raw == 'yes' ]]; then
		function echo_file {
			local file="$1"
			raw_file "$file"
		}
	elif [[ $option_bat == 'yes' ]]; then
		# plain/bat
		local terminal_theme='' bat_cmd=()
		bat_cmd+=(
			bat
			--paging=never
		)
		if [[ $option_plain == 'yes' ]]; then
			bat_cmd+=(
				--plain
			)
		else
			bat_cmd+=(
				--decorations=always
				--color=always
			)
		fi
		if [[ -z ${BAT_THEME-} ]]; then
			terminal_theme="$(get-terminal-theme --ignore-cache || :)"
			if [[ $terminal_theme == 'light' ]]; then
				bat_cmd+=(
					--theme=ansi
				)
			elif [[ $terminal_theme == 'dark' ]]; then
				bat_cmd+=(
					--theme=1337
				)
			fi # else bat is installed, but without knowing the terminal theme, we cannot be sure that the bat theme is readable
		fi
		function echo_file {
			local file="$1"
			if [[ $option_plain == 'yes' ]]; then
				content="$(eval_file "$file" "${bat_cmd[@]}" "$file")"
				echo-style --element="$file" --newline --="$content" --newline --/element="$file"
			else
				eval_file "$file" "${bat_cmd[@]}" "$file"
			fi
		}
	elif [[ $option_plain == 'yes' ]]; then
		function echo_file {
			local file="$1"
			content="$(raw_file "$file")"
			echo-style --element="$file" --newline --="$content" --newline --/element="$file"
		}
	else
		function echo_file {
			raw_file "$file"
		}
	fi

	function echo_files {
		local file
		while [[ $# -ne 0 ]]; do
			file="$1"
			shift
			echo_file "$file"
		done
	}

	local files=()
	function on_line {
		files+=("$1")
	}
	function on_finish {
		echo_files "${files[@]}"
	}

	stdinargs "${option_args[@]}"
)

# fire if invoked standalone
if [[ $0 == "${BASH_SOURCE[0]}" ]]; then
	echo_file "$@"
fi
