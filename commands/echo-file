#!/usr/bin/env bash

# @todo support these:
# https://github.com/swsnr/mdcat
# https://github.com/efugier/smartcat

function echo_file_test() (
	source "$DOROTHY/sources/bash.bash"

	eval-tester --name='no args' -- \
		echo-file --

	# CAT

	echo a | eval-tester --stdout=$'a\n' --trailing-newlines -- \
		echo-file --no-color --stdin --raw

	printf 'a \n\t\n\0b' | eval-tester --stdout=$'a \n\t\nb' --trailing-newlines -- \
		echo-file --no-color --stdin --raw

	printf 'a \n\t\n\0b' | eval-tester --stdout=$'a $\n^I$\n^@b' --trailing-newlines -- \
		echo-file --no-color --stdin --raw --hidden

	printf 'a \n\t\n\0b' | eval-tester --stdout=$'< /dev/stdin >\na $\n^I$\n^@b\n</ /dev/stdin >\n' --trailing-newlines -- \
		echo-file --no-color --stdin --raw --hidden --header

	printf 'a \n\t\n\0b' | eval-tester --stdout=$'< /dev/stdin >\n     1\ta $\n     2\t^I$\n     3\t^@b\n</ /dev/stdin >\n' --trailing-newlines -- \
		echo-file --no-color --stdin --raw --hidden --header --lines

	printf '\n\n\n' | eval-tester --stdout=$'< /dev/stdin >\n     1\t$\n     2\t$\n     3\t$\n</ /dev/stdin >\n' --trailing-newlines -- \
		echo-file --no-color --stdin --raw --hidden --header --lines

	printf '\n\n\n' | eval-tester --stdout=$'< /dev/stdin />\n' --trailing-newlines -- \
		echo-file --no-color --stdin --raw --hidden --header --lines --trim

	# BAT

	echo a | eval-tester --ignore-tty --stdout=$'a\n' --trailing-newlines -- \
		echo-file --no-color --stdin --raw --bat

	printf 'a \n\t\n\0b' | eval-tester --stdout=$'a \n\t\nb\n' --trailing-newlines -- \
		echo-file --no-color --stdin --raw --bat

	printf 'a \n\t\n\0b' | eval-tester --stdout=$'a·␊\n├──┤␊\n␀b\n' --trailing-newlines -- \
		echo-file --no-color --stdin --raw --bat --hidden

	printf 'a \n\t\n\0b' | eval-tester --stdout=$'   1 a·␊\n   2 ├──┤␊\n   3 ␀b\n' --trailing-newlines -- \
		echo-file --no-color --stdin --raw --bat --hidden --lines

	printf '\n\n\n' | eval-tester --stdout=$'   1 ␊\n   2 ␊\n   3 ␊\n' --trailing-newlines -- \
		echo-file --no-color --stdin --raw --bat --hidden --lines

	printf '\n\n\n' | eval-tester --stdout='' --trailing-newlines -- \
		echo-file --no-color --stdin --raw --bat --hidden --trim

	return 0
)
function echo_file() (
	source "$DOROTHY/sources/stdinargs.bash"
	source "$DOROTHY/sources/styles.bash"

	# =====================================
	# Arguments

	function __help {
		__print_help <<-EOF || return
			ABOUT:
			Output the contents of the each <path> or STDIN.

			USAGE:
			\`echo-file [...options] [--] ...<path>\`
			\`echo-lines ...<path> | echo-file [...options] --stdin\`

			OPTIONS:
			[--] ...<path>
			    Output the contents of each <path>.
			--stdin
			    Output the contents of STDIN.

			--[no-]bat
			    If enabled, install and use \`bat\` if it doesn't exist.
			    If disabled, don't use \`bat\`.
			    If omitted, use \`bat\` if it exists  or if <install>.
			--[no-]install
			    If enabled, prefer <bat> and install \`bat\` if necessary.
			    If disabled, disable <bat> and <highlight> if \`bat\` is missing.
			    If omitted, only install \`bat\` if <bat> or <highlight>.

			--[no-]header
			    Show the file content wrapped in a header that indicates its <path>.
			    If omitted, enabled.
			--[no-]highlight
			    If <bat>, show file content with syntax highlighting.
			    If enabled, implies <bat>.
			    If disabled, does not request <bat>.
			    If omitted, matches <bat>.
			--[no-]numbers | --[no-]lines
			    Show line numbers.
			--[no-]plain
			    Disables <number>, retains <header> and <highlight>. Shows enriched content that is unadultered when copy-pasted, however if used with <bat>, a trailing newline will be inserted if missing.
			--[no-]hidden
			    Show hidden characters.
			--[no-]trim
			    Trim the padding at the start and end of the file content. Requires <raw>.
			--[no-]raw
			    Enables <plain> and disables <header>, <highlight>, <number>, <bat>, <color>. Shows unadultered raw content, for piping to other commands. <bat> is disabled because otherwise a trailing newline will be inserted if missing.

			--[no-]ignore-missing
			    If enabled, do not return a failure nor show an error message when a <path> is missing.
			--[no-]ignore-unreadable
			    If enabled, do not return a failure nor show an error message when a <path> is unreadable.
			--[no-]optional | --[no-]required
			    Alias for setting both <ignore-missing> and <ignore-unreadable> accordingly.

			--elevated=<elevated>
			--elevate=<elevate>
			    Forwards as \`13 93 <elevate>\` which elevates privileges if necessary to read <path>.
			--user=<user>
			--group=<group>
			--reason=<reason>
			    Forwarded to \`eval-helper\`.

			$(stdinargs_options_help --)
		EOF
		if [[ $# -ne 0 ]]; then
			__print_error "$@" || return
		fi
		return 22 # EINVAL 22 Invalid argument
	}

	# process our own arguments, delegate everything else to stdinargs
	local item \
		option_bat='' option_install='' \
		option_header='' option_highlight='' option_numbers='' option_plain='' option_hidden='no' option_trim='no' \
		option_ignore_missing='' option_ignore_unreadable='' \
		option_elevated='' option_elevate='' option_user='' option_group='' option_reason='' \
		option_args=()
	# don't move 13 and 93 into option_elevate here, as then that means they apply on bat and cat, which we don't want
	while [[ $# -ne 0 ]]; do
		item="$1"
		shift
		case "$item" in
		--help | -h) __help ;;
		--no-color* | --color*) __flag --source={item} --target={COLOR} --affirmative --export ;;
		--no-bat* | --bat*) __flag --source={item} --target={option_bat} --affirmative --coerce ;;
		--no-install* | --install*) __flag --source={item} --target={option_bat} --affirmative --coerce ;;
		--no-header* | --header*) __flag --source={item} --target={option_header} --affirmative --coerce ;;
		--no-highlight* | --highlight*) __flag --source={item} --target={option_highlight} --affirmative --coerce ;;
		--no-number* | --number* | --no-lines* | --lines*) __flag --source={item} --target={option_numbers} --affirmative --coerce ;;
		--no-plain* | --plain*)
			__flag --source={item} --target={option_plain} --affirmative --coerce
			if [[ $option_plain == 'yes' ]]; then
				option_numbers='no'
			fi
			;;
		--no-hidden* | --hidden*) __flag --source={item} --target={option_hidden} --affirmative --coerce ;;
		--no-trim* | --trim*) __flag --source={item} --target={option_trim} --affirmative --coerce ;;
		--no-raw* | --raw*)
			__flag --source+target={item} --affirmative --coerce
			if [[ $item == 'yes' ]]; then
				option_header='no'
				option_highlight='no'
				option_numbers='no'
				option_plain='yes'
				option_bat='no'
				export COLOR
				COLOR='no'
			fi
			;;
		--no-ignore-missing* | --ignore-missing*) __flag --source={item} --target={option_ignore_missing} --affirmative --coerce ;;
		--no-ignore-unreadable* | --ignore-unreadable*) __flag --source={item} --target={option_ignore_unreadable} --affirmative --coerce ;;
		--no-required* | --required*)
			__flag --source+target={item} --non-affirmative --coerce
			if [[ -n $item ]]; then
				option_ignore_missing="$item"
				option_ignore_unreadable="$item"
			fi
			;;
		--no-optional* | --optional*)
			__flag --source+target={item} --affirmative --coerce
			if [[ -n $item ]]; then
				option_ignore_missing="$item"
				option_ignore_unreadable="$item"
			fi
			;;
		# <elevate>
		--elevated=*) option_elevated="${item#*=}" ;;
		--no-elevate* | --elevate*) __flag --source={item} --target={option_elevate} --affirmative ;;
		--user=*) option_user="${item#*=}" ;;
		--group=*) option_group="${item#*=}" ;;
		--reason=*) option_reason="${item#*=}" ;;
		# </elevate>
		# forward to stdinargs, however support mixing and matching of our options, with stdinargs options
		--)
			option_args+=("$item" "$@")
			shift $#
			break
			;;
		*) option_args+=("$item") ;;
		esac
	done

	# handle <bat>
	if [[ -z $option_bat ]]; then
		if __command_exists -- bat || [[ $option_highlight == 'yes' || $option_install == 'yes' ]]; then
			option_bat='yes'
		else
			option_bat='no'
		fi
	fi
	if [[ $option_bat == 'yes' ]]; then
		if ! __command_required --install="$option_install" -- bat; then
			option_bat='no'
		fi
	else
		option_bat='no'
	fi
	if [[ -z $option_header ]]; then
		option_header='yes'
	fi
	if [[ -z $option_highlight ]]; then
		option_highlight="$option_bat"
	fi
	if [[ -z $option_numbers ]]; then
		option_numbers='no'
	fi
	if [[ -z $option_plain ]]; then
		option_plain='no'
	fi
	if [[ -z $option_hidden ]]; then
		option_hidden='no'
	fi
	if [[ -z $option_trim ]]; then
		option_trim='no'
	fi

	# =====================================
	# Action

	# receive then act on all files
	local FILE REASON ELEVATE
	function __wrap {
		eval-helper --elevated="$option_elevated" --elevate="$ELEVATE" --user="$option_user" --group="$option_group" --reason="$REASON" -- "$@" || return
	}

	# bat
	if [[ $option_bat == 'yes' ]]; then
		local terminal_theme='' bat_styles=() bat_options=()
		bat_options+=(--paging=never)
		if [[ $option_hidden == 'yes' ]]; then
			bat_options+=(--show-all)
		fi
		# --color <when>: Specify when to use colored output. The automatic mode only enables colors if an interactive terminal is detected - colors are automatically disabled if the output goes to a pipe. Possible values: *auto*, never, always.
		#  --decorations <when>: Specify when to use the decorations that have been specified via '--style'. The automatic mode only enables decorations if an interactive terminal is detected. Possible values: *auto*, never, always.
		#
		# --style <components>:
		# By default, the following components are enabled:
		# changes, grid, header-filename, numbers, snip
		#
		# Possible values:
		# * default: enables recommended style components (default).
		# * full: enables all available components.
		# * auto: same as 'default', unless the output is piped.
		# * plain: disables all available components.
		# * changes: show Git modification markers.
		# * header: alias for 'header-filename'.
		# * header-filename: show filenames before the content.
		# * header-filesize: show file sizes before the content.
		# * grid: vertical/horizontal lines to separate side bar and the header from the content.
		# * rule: horizontal lines to delimit files.
		# * numbers: show line numbers in the side bar.
		# * snip: draw separation lines between distinct line ranges.
		bat_options+=(--decorations=always)
		if __get_terminal_color_support --quiet --fallback=yes; then
			bat_options+=(--color=always)
		else
			bat_options+=(--color=never)
		fi
		if [[ $option_header == 'yes' ]]; then
			bat_styles+=(+header)
		else
			bat_styles+=(-header)
		fi
		if [[ $option_numbers == 'yes' ]]; then
			bat_styles+=(+numbers)
		else
			bat_styles+=(-numbers)
		fi
		if [[ $option_plain == 'yes' ]]; then
			# rule is a divider when there is no grid, between multiple files - single file has no effect
			bat_styles+=(-changes,-grid,+rule)
			bat_options+=(--tabs 0) # don't convert tabs to spaces
		else
			# rule is a subset of grid, when grid is enabled, rule is irrelevant
			bat_styles+=(+changes,+grid)
		fi
		if [[ -z ${BAT_THEME-} ]]; then
			terminal_theme="$(get-terminal-theme || :)"
			if [[ $terminal_theme == 'light' ]]; then
				bat_options+=(--theme=ansi)
			elif [[ $terminal_theme == 'dark' ]]; then
				bat_options+=(--theme=1337)
			fi # else bat is installed, but without knowing the terminal theme, we cannot be sure that the bat theme is readable
		fi
		local bat_styles_string=''
		__join --source={bat_styles} --delimiter=',' --target={bat_styles_string} || return
		bat_options+=(--style="$bat_styles_string")
		# adding a suffix like ` (trimmed)` or ` | echo-trim-padding --stdin` to the file name disables syntax highlighting unfortunately
		function __read {
			if [[ $FILE == '/dev/stdin' ]]; then
				# STDIN
				if [[ $option_trim == 'yes' ]]; then
					echo-trim-padding --stdin | bat --file-name "$FILE" "${bat_options[@]}" - || return
				else
					bat --file-name "$FILE" "${bat_options[@]}" - || return
				fi
			else
				# FILE
				if [[ $option_trim == 'yes' ]]; then
					__wrap cat "$FILE" | echo-trim-padding --stdin | bat --file-name "$FILE" "${bat_options[@]}" - || return
				else
					__wrap cat "$FILE" | bat --file-name "$FILE" "${bat_options[@]}" - || return
				fi
			fi
		}
	else
		local cat_options=()
		if [[ $option_hidden == 'yes' ]]; then
			#  -e      Display non-printing characters (see the -v option), and display a dollar sign (‘$’) at the end of each line.
			# -t      Display non-printing characters (see the -v option), and display tab characters as ‘^I’.
			# -v      Display non-printing characters so they are visible.  Control characters print as ‘^X’ for control-X; the delete character (octal 0177) prints as ‘^?’.  Non-ASCII characters (with the high bit set) are printed as ‘M-’ (for meta) followed by the character for the low 7 bits.
			cat_options+=(-etv) # use -t to replace tabs as it may be desired in they are in vscode which transforms tabs to spaces, so useful to know it is actually a tab
		fi
		if [[ $option_numbers == 'yes' ]]; then
			# -b      Number the non-blank output lines, starting at 1.
			# -n      Number the output lines, starting at 1.
			cat_options+=(-n) # using -b does not count non-blank lines, use -n alone to count all lines
		fi
		function __read {
			if [[ $FILE == '/dev/stdin' ]]; then
				# STDIN
				if [[ $option_trim == 'yes' ]]; then
					function __cat {
						echo-trim-padding --stdin | cat "${cat_options[@]}" - || return
					}
				else
					function __cat {
						cat "${cat_options[@]}" - || return
					}
				fi
			else
				# FILE
				if [[ $option_trim == 'yes' ]]; then
					function __cat {
						__wrap cat -- "$FILE" | echo-trim-padding --stdin | cat "${cat_options[@]}" - || return
					}
				else
					function __cat {
						__wrap cat "${cat_options[@]}" -- "$FILE" || return
					}
				fi
			fi

			# this doesn't handle files without trailing newline well, and it doesn't color well
			# if [[ $option_header == 'yes' ]]; then
			# 	__print_style --element="$FILE" || return
			# fi
			# __cat || return
			# if [[ $option_header == 'yes' ]]; then
			# 	__print_style --/element="$FILE" || return
			# fi
			if [[ $option_header == 'yes' ]]; then
				local content
				content="$(__cat)" || return
				if [[ -n $content ]]; then
					__print_style --element="$FILE" --newline --code="$content" --newline --/element="$FILE" || return
				else
					# self close, as no data (consistent with eval-helper)
					__print_style --element/="$FILE" || return
				fi
			else
				__cat || return
			fi
		}
	fi

	# on_file
	function __on_stdin {
		FILE='/dev/stdin'
		__read || return
	}
	function __on_argument {
		# share
		FILE="$1"
		REASON="${option_reason:-"Your password is required to momentarily grant privileges to read the file: $FILE"}"
		# auto-elevation
		ELEVATE="$option_elevate"
		local target_elevated
		target_elevated="$(mktemp)" || return

		# check missing, with elevation if inaccessible (13)
		# ! [[ -e "$FILE" ]] &&
		if is-missing --quiet="$option_ignore_missing" --elevated="$(__print_lines "$target_elevated" "$option_elevated")" --elevate="$ELEVATE" --user="$option_user" --group="$option_group" --reason="$REASON" -- "$FILE"; then
			if [[ $option_ignore_unreadable == 'yes' ]]; then
				return 0
			else
				return 13 # EACCES 13 Permission denied
			fi
		fi
		if [[ -s $target_elevated ]]; then
			ELEVATE='yes'
		fi

		# check unreadable, with elevation if unreadable (93)
		# ! [[ -r "$FILE" ]] &&
		if ! is-readable --quiet="$option_ignore_unreadable" --elevated="$(__print_lines "$target_elevated" "$option_elevated")" --elevate="93 $ELEVATE" --user="$option_user" --group="$option_group" --reason="$REASON" -- "$FILE"; then
			if [[ $option_ignore_unreadable == 'yes' ]]; then
				return 0
			else
				return 13 # EACCES 13 Permission denied
			fi
		fi
		if [[ -s $target_elevated ]]; then
			ELEVATE='yes'
		fi

		# read the file
		__read || return
	}

	stdinargs "${option_args[@]}"
)

# fire if invoked standalone
if [[ $0 == "${BASH_SOURCE[0]}" ]]; then
	if [[ $* == '--test' ]]; then
		echo_file_test
	else
		echo_file "$@"
	fi
fi
