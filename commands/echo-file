#!/usr/bin/env bash

# @todo support these:
# https://github.com/swsnr/mdcat
# https://github.com/efugier/smartcat

function echo_file() (
	source "$DOROTHY/sources/stdinargs.bash"

	# =====================================
	# Arguments

	function help {
		cat <<-EOF >&2
			ABOUT:
			Output the contents of the passed file paths.

			USAGE:
			echo-file [...options] [--] ...<path>
			echo-lines ...<path> | echo-file [...options]

			OPTIONS:
			--[no-]bat
			    If affirmative, install and use [bat] if it doesn't exist.
				If missing, use [bat] iff it exists.
				If negative, don't use [bat].
				Bat will output syntax-highlighted file content wrapped in the filename.
			--plain
			    No line numbers, but file content is wrapped in the filename.
			--raw
			    No line numbers nor filename, only file contents.
			--trim
			    Trim the padding at the start and end of the file. Requires --raw.

			--quiet
			    If provided, do not output an error if the file is not readable.

			--elevated=<elevated>
			--elevate=<elevate>
			    Defaults to [13] and [93] which elevates privileges if necessary to read <path>.
			--user=<user>
			--group=<group>
			--reason=<reason>
			    Forwarded to [eval-helper].

			$(stdinargs_options_help --)
		EOF
		if [[ $# -ne 0 ]]; then
			__print_error "$@"
		fi
		return 22 # EINVAL 22 Invalid argument
	}

	# process our own arguments, delegate everything else to stdinargs
	local item option_quiet='no' option_bat='' option_install='' option_raw='no' option_plain='no' option_trim='' option_ignore_missing='no' option_args=() option_elevated='' option_elevate='' option_user='' option_group='' option_reason=''
	# don't move 13 and 93 into option_elevate here, as then that means they apply on bat and cat, which we don't want
	while [[ $# -ne 0 ]]; do
		item="$1"
		shift
		case "$item" in
		--help | -h) help ;;
		--no-verbose* | --verbose*) __flag --source={item} --target={option_quiet} --non-affirmative --coerce ;;
		--no-quiet* | --quiet*) __flag --source={item} --target={option_quiet} --affirmative --coerce ;;
		--no-bat* | --bat*) __flag --source={item} --target={option_bat} --affirmative --coerce ;;
		--no-raw* | --raw*) __flag --source={item} --target={option_raw} --affirmative --coerce ;;
		--no-plain* | --plain*) __flag --source={item} --target={option_plain} --affirmative --coerce ;;
		--no-trim* | --trim*) __flag --source={item} --target={option_trim} --affirmative --coerce ;;
		--no-ignore-missing* | --ignore-missing*) __flag --source={item} --target={option_ignore_missing} --affirmative --coerce ;;
		# <elevate>
		--elevated=*) option_elevated="${item#*=}" ;;
		--no-elevate* | --elevate*) __flag --source={item} --target={option_elevate} --affirmative ;;
		--user=*) option_user="${item#*=}" ;;
		--group=*) option_group="${item#*=}" ;;
		--reason=*) option_reason="${item#*=}" ;;
		# </elevate>
		# forward to stdinargs, however support mixing and matching of our options, with stdinargs options
		--)
			option_args+=("$item" "$@")
			shift $#
			break
			;;
		*) option_args+=("$item") ;;
		esac
	done

	# install bat if yes
	if [[ $option_bat == 'yes' ]]; then
		__command_required -- 'bat' || return
	elif [[ -z $option_bat ]]; then
		if [[ $option_raw == 'yes' ]]; then
			option_bat='no'
		elif __command_exists -- bat; then
			option_bat='yes'
		else
			option_bat='no'
		fi
	fi

	if [[ $option_trim == 'yes' && $option_raw != 'yes' ]]; then
		help 'The ' --code='--trim' ' option requires ' --code='--raw'
	fi

	if [[ $option_raw == 'yes' && $option_bat == 'yes' ]]; then
		help 'The ' --code='--raw' ' option cannot be used with ' --code='--bat'
	fi

	# =====================================
	# Action

	# preparation
	if [[ $option_bat == 'yes' ]]; then
		# bat with or without plain
		local terminal_theme='' bat_cmd=()
		bat_cmd+=(bat --paging=never)
		if [[ $option_plain == 'yes' ]]; then
			# what is this really?
			bat_cmd+=(--plain)
		else
			bat_cmd+=(--decorations=always --color=always)
		fi
		if [[ -z ${BAT_THEME-} ]]; then
			terminal_theme="$(get-terminal-theme || :)"
			if [[ $terminal_theme == 'light' ]]; then
				bat_cmd+=(--theme=ansi)
			elif [[ $terminal_theme == 'dark' ]]; then
				bat_cmd+=(--theme=1337)
			fi # else bat is installed, but without knowing the terminal theme, we cannot be sure that the bat theme is readable
		fi
	fi

	# receive then act on all files
	local FILE REASON ELEVATE
	function __wrap {
		eval-helper --elevated="$option_elevated" --elevate="$ELEVATE" --user="$option_user" --group="$option_group" --reason="$REASON" --inherit -- "$@" || return
	}
	if [[ $option_bat == 'yes' ]]; then
		function __echo_file_inner {
			__wrap "${bat_cmd[@]}" "$FILE" || return
		}
	elif [[ $option_trim == 'yes' ]]; then
		function __echo_file_inner {
			__wrap cat "$FILE" | echo-trim-padding --stdin || return
		}
	else
		function __echo_file_inner {
			__wrap cat "$FILE" || return
		}
	fi
	if [[ $option_plain == 'yes' ]]; then
		function __echo_file {
			local content
			content="$(__echo_file_inner)" || return
			__print_style --element="$FILE" --newline --="$content" --newline --/element="$FILE" || return
		}
	else
		function __echo_file {
			__echo_file_inner || return
		}
	fi
	# on_file
	function __on_piece {
		# share
		FILE="$1"
		REASON="${option_reason:-"Your password is required to momentarily grant privileges to read the file: $FILE"}"
		# auto-elevation
		ELEVATE="$option_elevate"
		local target_elevated
		target_elevated="$(mktemp)" || return

		# if we want to ignore missing, check if missing, to avoid outputting an error on missing
		if [[ $option_ignore_missing == 'yes' ]] && is-missing --elevated="$(__print_lines "$target_elevated" "$option_elevated")" --elevate="$ELEVATE" --user="$option_user" --group="$option_group" --reason="$REASON" -- "$FILE"; then
			return 0
		fi
		if [[ -s $target_elevated ]]; then
			ELEVATE='yes'
		fi

		# prep elevate
		is-readable --quiet="$option_quiet" --elevated="$(__print_lines "$target_elevated" "$option_elevated")" --elevate="93 $ELEVATE" --user="$option_user" --group="$option_group" --reason="$REASON" -- "$FILE" || return
		if [[ -s $target_elevated ]]; then
			ELEVATE='yes'
		fi

		# read the file
		__echo_file || return
	}

	stdinargs "${option_args[@]}"
)

# fire if invoked standalone
if [[ $0 == "${BASH_SOURCE[0]}" ]]; then
	echo_file "$@"
fi
