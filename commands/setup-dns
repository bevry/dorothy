#!/usr/bin/env bash

function setup_dns() (
	source "$DOROTHY/sources/bash.bash"
	__require_array 'mapfile' 'empty'

	# check for support
	if is-wsl; then
		echo-style --notice="[$0] is not applicable on WSL, skipping." >/dev/stderr
		return 0
	fi
	if ! (is-mac || is-ubuntu); then
		echo-style --warning="[$0] is implemented for macOS and Ubuntu systems..." >/dev/stderr
		if ! confirm --negative --ppid=$$ -- 'Proceed at your own risk?'; then
			return 0
		fi
	fi

	# ensure the paths are defined and exist
	if test -z "${BIN_DIR-}" -o -z "${CONF_DIR-}" -o -z "${DATA_DIR-}" -o -z "${LIB_DIR-}" -o -z "${SERVICE_DIR-}"-o -z "${LOGS_DIR-}"; then
		echo-error 'Missing a requried environment variable. Ensure these exist: BIN_DIR, CONF_DIR, DATA_DIR, LIB_DIR, SERVICE_DIR, LOGS_DIR'
		return 2 # ENOENT 2 No such file or directory
	fi
	echo-mkdir --sudo -- "$BIN_DIR" "$CONF_DIR" "$DATA_DIR" "$LIB_DIR" "$SERVICE_DIR" "$LOGS_DIR"

	# =====================================
	# Detection

	# helper
	function __die_unknown_os {
		echo-style --error='Unknown Operating System' >/dev/stderr || return
		return 19 # ENODEV 19 Operation not supported by device
	}

	# determine available services
	local arch services=('system')
	arch="$(get-arch)"
	if command-exists -- nordvpn; then
		echo-style --notice='NordVPN installation detected, only permitting system DNS service.'
	elif is-internet-working; then
		# load the services from dns.json
		if test -n "$aghome_installer"; then
			services+=(aghome)
		fi
		if test -n "$cloudflared_installer"; then
			services+=(cloudflared)
		fi
		if test -n "$dnscrypt_installer"; then
			services+=(dnscrypt)
		fi
	fi

	# helper
	function die_incompatible_service {
		local service_title
		service_title="$1"
		echo-style \
			--error="This platform [$arch] does not yet support: $service_title" $'\n' \
			--notice='Supported DNS services for this platform are:' $'\n' \
			"${services[*]}"
		return 19 # ENODEV 19 Operation not supported by device
	}

	# =====================================
	# Arguments

	# @todo move this later so that it also outputs providers
	function help {
		cat <<-EOF >/dev/stderr
			ABOUT:
			Setup the DNS service for your system.

			USAGE:
			setup-dns [...options] <service>

			SERVICES:
			$(__print_lines "${services[@]}")

			CONFIGURATION:
			dns.bash
		EOF
		if test "$#" -ne 0; then
			echo-error "$@"
		fi
		return 22 # EINVAL 22 Invalid argument
	}

	# process
	local item action='' option_service='' option_vpn_reconnect=''
	while test "$#" -ne 0; do
		item="$1"
		shift
		case "$item" in
		'--help' | '-h') help ;;
		'--no-vpn-reconnect'* | '--vpn-reconnect'*)
			option_vpn_reconnect="$(get-flag-value --affirmative --fallback="$option_vpn_reconnect" -- "$item")"
			;;
		'--no-quiet'* | '--quiet'* | '--no-verbose'* | '--verbose'*) ;; # handled by echo-quiet-enabled
		'--'*) help "An unrecognised flag was provided: $item" ;;
		*)
			if test -z "$option_service"; then
				option_service="$item"
			else
				help "An unrecognised argument was provided: $item"
			fi
			;;
		esac
	done

	# =====================================
	# Configuration

	source "$DOROTHY/sources/config.sh"

	# dns.bash provides:
	local DNS_SERVICE=''
	local DNS_PROVIDER=''
	local DNS_BACKUP_PROVIDER=''
	local DNS_IPV4_SERVERS=()
	local DNS_IPV6_SERVERS=()
	local DNS_DOH_SERVERS=()
	local DNS_DOT_SERVERS=()
	local DNS_QUIC_SERVERS=()
	local DNS_SDNS_SERVERS=()
	local DNS_DNSCRYPT_NAMES=()
	load_dorothy_config 'dns.bash'

	# =====================================
	# Helpers

	function verify_dns_generic {
		local attempt="${1:-1}" status=0
		nslookup cloudflare.com | echo-trim-padding --stdin || status=$?
		if test "$status" -ne 0; then
			echo-style --notice='DNS service failed to verify, trying again in 10 seconds.'
			sleep 10
			attempt="$((attempt + 1))"
			echo-style --notice="Attempt $attempt..."
			verify_dns_generic "$attempt"
			return
		fi
		return 0
		# `dig -x cloudflare.com` times out for some reason, nslookup works though
		# eval-helper -- what-is-listening dns
		# open 'https://www.cloudflare.com/en-au/ssl/encrypted-sni/'
		# open 'https://1.1.1.1/help'
	}

	function verify_dns_resolvectl {
		local attempt="${1:-1}" status=0
		resolvectl query cloudflare.com --no-pager || status=$?
		resolvectl status --no-pager || status=$?
		resolvectl statistics --no-pager || status=$?
		if test "$status" -ne 0; then
			echo-style --notice='DNS service failed to verify, trying again in 10 seconds.'
			sleep 10
			attempt="$((attempt + 1))"
			echo-style --notice="Attempt $attempt..."
			verify_dns_resolvectl "$attempt"
			return
		fi
		return 0
	}

	function check_installation {
		local id="$1" bin="$2" exists
		exists="$(type -P "$id" || :)"
		if test -n "$exists" -a "$exists" != "$bin"; then
			{
				echo-style --error='There is a non-standard installation at:'
				type -P "$id"
				echo-style --warning='Remove it and try again...'
			} >/dev/stderr
			return 75 # EPROGMISMATCH 75 Program version wrong
		fi
	}

	# https://support.apple.com/en-au/guide/terminal/apdc6c1077b-5d5d-4d35-9c19-60f2397b2369/mac
	# https://apple.stackexchange.com/a/366388/15131
	# stop the service (if it exists) temporarily
	function service_stop {
		local file="$1" id

		# check if the service file exists
		# which determines if it is even installed
		if test ! -f "$file"; then
			return 0
		fi

		# it does exist
		if is-mac; then
			# get its basename which is the service id
			id="$(fs-filename --basename -- "$file")"
			service-helper --stop -- "$id" || :
		else
			service-helper --stop -- "$id" || :
		fi
	}

	# stops, uninstalls, and deletes the service (if it exists)
	function service_disable {
		local file="$1" id

		# check if the service file exists
		# which determines if it is even installed
		if test ! -f "$file"; then
			return 0
		fi

		# it does exist
		# get its basename which is the service id
		id="$(fs-filename --basename -- "$file")"
		if is-mac; then
			# Usage: launchctl unload <service-path, service-path2, ...>
			# -w      Additionally disables the service such that future load
			#         operations will result in a service which launchd tracks but
			#         cannot be launched or discovered in any way.
			service-helper --disable -- "system/$id" || :
			service-helper --stop -- "$id" || :
			service-helper --unload -- "$file" || :
			do_remove -- "$LOGS_DIR/"*"$id"*.log
		else
			service-helper --disable --stop -- "$id" || :
			service-helper --status -- "$id" || :
		fi
		do_remove --reload -- "$file"
	}

	# loads/installs the service, then enables and starts it
	function service_enable {
		local file="$1" id
		id="$(fs-filename --basename -- "$file")"
		if is-mac; then
			# ensure correct permissions, not sure why
			# but [homebrew services] does this, so doing it here
			sudo-helper -- chown root:admin "$file"
			sudo-helper -- chmod +t "$file"
			service-helper --load -- "$file" || :
			# service-helper  --start -- "system/$id" || :
			service-helper --start -- "$id" || :
			sleep 3
			eval-helper --no-quiet -- cat "$LOGS_DIR/"*"$id"*.log || :
		else
			service-helper --enable --start -- "$id" || :
			service-helper --status -- "$id" || :
		fi
	}

	function service_reload {
		# after service additions/removals
		# systemctl needs to be reloaded apparently
		if command-exists -- systemctl; then
			sudo-helper -- systemctl daemon-reload
			sudo-helper -- systemctl reset-failed
			# ^ use sudo, otherwise prompted via ubuntu user password
		fi
	}

	function do_remove {
		# process
		local item service='' flags=() reload='no' remove_paths=()
		while test "$#" -ne 0; do
			item="$1"
			shift
			case "$item" in
			'--service='*) service="${item#*=}" ;;
			'--negative' | '--positive' | '--bool') flags+=("$item") ;;
			'--no-reload'* | '--reload'*)
				reload="$(get-flag-value --affirmative --fallback="$reload" -- "$item")"
				;;
			'--')
				remove_paths+=("$@")
				shift $#
				break
				;;
			'--'*) help "An unrecognised flag was provided: $item" ;;
			*) remove_paths+=("$item") ;;
			esac
		done

		# add default flag
		if test "${#flags[@]}" -eq 0; then
			flags+=('--positive')
		fi

		# service
		if test -n "$service"; then
			# remove common paths (files, and directories)
			remove_paths+=(
				# custom
				"$BIN_DIR/$service"
				"$CONF_DIR/$service"
				"$DATA_DIR/$service"
				"$LIB_DIR/$service"

				# xdg
				"$XDG_BIN_HOME/$service"
				"$XDG_CONFIG_HOME/$service"
				"$XDG_DATA_HOME/$service"
				"$XDG_STATE_HOME/$service"

				# standard
				"/usr/local/bin/$service"
				"/usr/local/etc/$service"
				"/usr/local/share/$service"
				"/usr/local/lib/$service"

				# services
				"$SERVICE_DIR/"*"$service"*
				/Library/LaunchAgents/*"$service"*   # user
				/Library/LaunchDaemons/*"$service"*  # everyone
				/etc/init.d/*"$service"*             # alt
				/usr/lib/systemd/system/*"$service"* # alt
				/etc/systemd/system/*"$service"*     # desired

				# logs
				"$LOGS_DIR/"*"$service"*.log
			)
		fi

		# remove files
		local remove_path question details removed='no'
		for remove_path in "${remove_paths[@]}"; do
			if is-present -- "$remove_path"; then
				question="Remove $(echo-style --bold="$remove_path")?"
				details="$(
					echo-style --dim="$(
						ls -la "$remove_path"
					)"
				)"
				if confirm "${flags[@]}" --ppid=$$ -- "$question" "$details"; then
					fs-rm --quiet --no-confirm --sudo -- "$remove_path"
					removed='yes'
				fi
			fi
		done

		# reload?
		if test "$reload" = 'yes' -a "$removed" = 'yes'; then
			service_reload
		fi
	}

	# =====================================
	# Select DNS Provider/Servers

	# providers that are user selectable
	# excludes local
	# excludes backup
	local providers=()
	# add env, if available
	if test \
		"${#DNS_IPV4_SERVERS[@]}" -ne 0 -o \
		"${#DNS_IPV6_SERVERS[@]}" -ne 0 -o \
		"${#DNS_DOH_SERVERS[@]}" -ne 0 -o \
		"${#DNS_DOT_SERVERS[@]}" -ne 0 -o \
		"${#DNS_QUIC_SERVERS[@]}" -ne 0 -o \
		"${#DNS_SDNS_SERVERS[@]}" -ne 0; then
		providers+=('env')
	fi
	# add standard options
	providers+=(
		# ... prefill from dns.json
	)

	# prepare selection vars
	# dot = dns over tls
	# doh = dns over https
	# sdns = dnscrypt
	# quic = preferred
	local provider_id provider_url provider_about ipv4_servers ipv6_servers dot_servers doh_servers sdns_servers quic_servers dnscrypt_names
	function fetch_provider {
		# reset shared vars
		ipv4_servers=()
		ipv6_servers=()
		dot_servers=()
		doh_servers=()
		sdns_servers=()
		quic_servers=()
		dnscrypt_names=()

		# load providers
		local providers=() providers_url=() providers_about=() provider_options=()
		mapfile -t providers < <(jq -r '.providers | keys[]' "$DOROTHY/config/dns.json")
		mapfile -t providers_url < <(jq -r '.providers[].url' "$DOROTHY/config/dns.json")
		mapfile -t providers_about < <(jq -r '.providers[].about' "$DOROTHY/config/dns.json")
		if test "${#providers[@]}" -ne "${#providers_about[@]}" -a "${#providers[@]}" -ne "${#provdiers_url[@]}"; then
			help 'A DNS provider is missing an about, or an about is multiline when it should be single line.'
		fi
		local provider index url about
		for index in "${!providers[@]}"; do
			provider="${providers[index]}"
			url="${providers_url[index]}"
			about="${providers_about[index]}"
			provider_options+=("$provider" "$(echo-style --bold="$provider" ': ' --code="$url" $'\n' "$about")")
		done
		index="$(
			choose --required --linger --index --confirm \
				--question='Which DNS provider to use?' \
				--skip-default --default="$provider" -- "${providers[@]}"
		)"
		provider="${providers[index]}"
		url="${providers_url[index]}"
		about="${providers_about[index]}"

		# extract their servers
		#	mapfile -t fodder < <(jq -r '.providers["]' "$DOROTHY/config/dns.json")

		# turn provider into servers
		case "$provider" in
		# 'local')
		# 	ipv4_servers=(
		# 		"${local_ipv4_servers[@]}"
		# 	)
		# 	ipv6_servers=(
		# 		"${local_ipv6_servers[@]}"
		# 	)
		# 	;;
		'env')
			ipv4_servers=(
				"${DNS_IPV4_SERVERS[@]}"
			)
			ipv6_servers=(
				"${DNS_IPV6_SERVERS[@]}"
			)
			doh_servers=(
				"${DNS_DOH_SERVERS[@]}"
			)
			dot_servers=(
				"${DNS_DOT_SERVERS[@]}"
			)
			quic_servers=(
				"${DNS_QUIC_SERVERS[@]}"
			)
			sdns_servers=(
				"${DNS_SDNS_SERVERS[@]}"
			)
			dnscrypt_names=(
				"${DNS_DNSCRYPT_NAMES[@]}"
			)
			;;
		*)
			# load values from the json file
			help "Invalid provider: $provider"
			;;
		esac
	}

	# =====================================
	# DNS Service: System

	function __is_vpn_interface {
		local interface="$1"
		if [[ $interface =~ (nordlynx|vpn|tun|tap) ]]; then # regex fuzzy match
			return 0
		fi
		return 1
	}
	function __system_exists {
		if is-mac; then
			command-exists -- networksetup || return
		elif is-linux; then
			command-exists -- systemctl resolvectl || return
		else
			__die_unknown_os || return
		fi
	}
	function system_install {
		if ! __system_exists; then
			# ignore exit status to keep customr return code
			__die_unknown_os || :
			return 29 # Illegal seek
		fi
	}
	function system_uninstall {
		# ignore exit status to keep customr return code
		__die_unknown_os || :
		return 29 # Illegal seek
	}
	function system_configure {
		# determine servers and action
		local servers action action_title
		action="$1"
		action_title="$(__uppercase_first_letter "$action")"
		if test "$action" = 'enable'; then
			servers=(
				"${ipv4_servers[@]}"
				"${ipv6_servers[@]}"
			)
		else
			servers=(
				"${local_ipv4_servers[@]}"
				"${local_ipv6_servers[@]}"
			)
		fi

		# handle the os changes
		if is-mac; then
			# -------------------------------------
			# DNS Service: macOS
			# https://support.apple.com/en-us/HT202516

			# log
			echo-style --h1="Configure and $action_title macOS"

			# apply
			local interface
			network-interface list | while read -r interface; do
				sudo-helper -- networksetup -setdnsservers "$interface" "${servers[@]}"
			done

			# log
			echo-style --g1="Configure and $action_title macOS"
		else
			# -------------------------------------
			# DNS Service: Systemd (aka systemd-resolved, systemd-resolve, resolvectl, resolv)
			# https://gist.github.com/balupton/f4aa448731d6b1bdf505c10078b9a8ad#file-resolv-bash

			# https://wiki.archlinux.org/title/Systemd-resolved
			# https://man.archlinux.org/man/systemd-resolved.8#/ETC/RESOLV.CONF

			# /run/systemd/resolve/stub-resolv.conf
			# ^ lists the 127.0.0.53 DNS stub as the only DNS server.
			# ^ It also contains a list of search domains that are in use by systemd-resolved.

			# /usr/lib/systemd/resolv.conf
			# ^ lists the 127.0.0.53 DNS stub as only DNS server.
			# ^ This file does not contain any search domains.

			# /run/systemd/resolve/resolv.conf
			# ^ containing information about all known DNS servers
			# ^ it does not know a concept of per-interface DNS servers and hence only contains system-wide DNS server definitions.

			# /etc/systemd/resolved.conf
			# ^ The DNS servers contacted are determined from the global settings in

			# /etc/systemd/network/*.network
			# ^ er-link static settings

			# /etc/resolv.conf
			# ^ used by everything

			#  To improve compatibility, /etc/resolv.conf is read in order to discover configured system DNS servers, but only if it is not a symlink to /run/systemd/resolve/stub-resolv.conf, /usr/lib/systemd/resolv.conf or /run/systemd/resolve/resolv.conf (see below).

			# log
			local systemd_title='Systemd-resolved'
			echo-style --h1="Configure and $action_title $systemd_title"

			# dump the data for where we are
			sudo-helper -- resolvectl status --no-pager || :

			# if there is nordvpn, we have to disconnect
			if command-exists -- nordvpn; then
				nordvpn set autoconnect off || :
				nordvpn set killswitch off || :
				nordvpn set firewall off || :
				nordvpn disconnect || :
				sleep 3
			fi

			# temporarily disable these services while we redo the configuration files
			# https://wiki.archlinux.org/title/systemd-networkd
			# resolved handles dns, networkd handles network interfaces
			service-helper --stop -- systemd-networkd systemd-resolved || :

			# allow modifications in case something has locked it
			# for some reason this can fail
			sudo-helper -- chattr -i /etc/resolv.conf || :

			# make life simple, using only /etc/resolv.conf
			# https://www.freedesktop.org/software/systemd/man/resolved.conf.html
			fs-rm --quiet --no-confirm --sudo -- \
				/run/systemd/resolve/stub-resolv.conf \
				/usr/lib/systemd/resolv.conf \
				/run/systemd/resolve/resolv.conf \
				/etc/systemd/resolved.conf \
				/etc/resolv.conf

			# prepare config for file, and for interfaces
			local Domains DNSOverTLS DNSSEC
			Domains='~.'
			if test "${#dot_servers[@]}" -ne 0; then
				DNSOverTLS='true'
				# DNSSEC='true' <= fails on cloudflare teams, perhaps more
				DNSSEC='allow-downgrade'
			else
				DNSOverTLS='opportunistic'
				DNSSEC='allow-downgrade'
			fi

			# apply specific config
			if test "$action" = 'enable'; then
				# using systemd, the initial lines are for ping/nslookup/etc, the [Resolve] lines are for systemd-resolve
				sudo-helper -- tee /etc/resolv.conf <<-EOF
					nameserver 127.0.0.53
					options edns0 trust-ad
					search .

					[Resolve]
					DNS=${servers[*]}
					Domains=$Domains
					DNSSEC=$DNSSEC
					DNSOverTLS=$DNSOverTLS
				EOF
			else
				# use custom service
				sudo-helper -- tee /etc/resolv.conf <<-EOF
					nameserver ${servers[0]}
					options edns0 trust-ad
				EOF
			fi

			# we have redone the configuration files so we must now restart the services
			# and ensure that are correctly enabled in case they weren't
			# which could happen via vpns or another dns service
			service-helper --enable --start -- systemd-resolved systemd-networkd || :

			# flush their caches
			sudo-helper -- resolvectl flush-caches --no-pager || :
			sudo-helper -- resolvectl reset-server-features --no-pager || :

			# apply the changes to their interfaces
			mapfile -t interfaces < <(network-interface list)
			if is-array-empty -- "${interfaces[@]}"; then
				echo-style --error='No interfaces were found.' >/dev/stderr
				return 1
			fi
			local default_route
			for interface in "${interfaces[@]}"; do
				# skip vpn interfaces
				if __is_vpn_interface "$interface"; then
					echo-style --dim="Skipping VPN interface: $interface"
					continue
				fi

				# save default route
				# as nordvpn needs its interface as the default route
				if resolvectl default-route "$interface" | grep --quiet --fixed-strings --regexp=yes; then
					default_route='yes'
				else
					default_route='no'
				fi

				# remove other changes
				sudo-helper -- resolvectl revert "$interface" || continue

				# apply intended changes
				sudo-helper -- resolvectl default-route "$interface" "$default_route"
				sudo-helper -- resolvectl domain "$interface" "$Domains"
				sudo-helper -- resolvectl dnssec "$interface" "$DNSSEC"
				sudo-helper -- resolvectl dnsovertls "$interface" "$DNSOverTLS"
				sudo-helper -- resolvectl dns "$interface" "${servers[@]}"

				# reboot the interface if it isn't a vpn
				sleep 3
				network-interface restart "$interface"
			done

			# dump the status now that we are done
			sudo-helper -- resolvectl status --no-pager || :

			# if there is nordvpn, we have to reconnect
			if command-exists -- nordvpn; then
				if test "$option_vpn_reconnect" = 'yes' || (test -z "$option_vpn_reconnect" && confirm --linger --positive --ppid="$$" -- 'Reconnect to NordVPN?'); then
					if nordvpn connect; then
						nordvpn set firewall on || :
						nordvpn set killswitch on || :
						nordvpn set autoconnect on || :
					fi
				fi
			fi

			# now that it is all done, enable or disable
			if test "$action" = 'enable'; then
				# verify
				verify_dns_resolvectl
			else
				service-helper --disable --stop -- systemd-resolved
			fi

			# after significant systemd changes, it may need to be reloaded
			# sudo-helper -- systemctl daemon-reload
			# sudo-helper -- systemctl reset-failed

			# log
			echo-style --g1="Configure and $action_title $systemd_title"
		fi
	}

	# =====================================
	# Action

	echo-style --h1='Setup DNS'

	# -------------------------------------
	# Prompts

	# Prompt the user which dns service they wish to use
	local service="${option_service:-"$DNS_SERVICE"}"
	service="$(
		choose --required --confirm \
			--question='Which DNS service do you wish to be your primary service?' \
			--skip-default --default="$DNS_SERVICE" -- "${services[@]}"
	)"

	# Prompt the user which dns provider they wish to use
	fetch_provider

	# -------------------------------------
	# Installations

	# Install the provider
	"setup-util-${service}" --install # eval

	# Detect installed custom services
	local installed_custom_services
	installed_custom_services=()
	if command-exists -- AdGuardHome; then
		installed_custom_services+=(adguard-home)
	fi
	if command-exists -- cloudflared; then
		installed_custom_services+=(cloudflared)
	fi
	if command-exists -- dnscrypt-proxy; then
		installed_custom_services+=(dnscrypt-proxy)
	fi

	# Disable all custom services, reconfigure the system (system on linux must be temporarily enabled to be configured), and then enable the chosen service
	local installed_custom_service
	for installed_custom_service in "${installed_custom_services[@]}"; do
		"setup-util-${installed_custom_service}" --disable # eval
	done
	if test "$service" = 'system'; then
		system_configure enable
	else
		system_configure disable
		"setup-util-${service}" --enable # eval
	fi

	# -------------------------------------
	# Verification

	# Verify DNS
	echo-style --h1='Verify DNS'
	verify_dns_generic
	echo-style --g1='Verify DNS'

	# Setup Hosts
	# do after DNS, as we need internet to work to download the hosts file
	setup-hosts

	# done
	echo-style --g1='Setup DNS'
)

# fire if invoked standalone
if test "$0" = "${BASH_SOURCE[0]}"; then
	setup_dns "$@"
fi
