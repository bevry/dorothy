#!/usr/bin/env bash
source "$DOROTHY/sources/strict.bash"
source "$DOROTHY/sources/nullglob.bash"
source "$DOROTHY/sources/arrays.bash"
requires_array_support 'mapfile' 'empty'

# dependencies
source "$DOROTHY/sources/ripgrep.bash"
env QUIET=yes setup-util-dig

# helpers
function die_unknown_os {
	echo-style --error='Unknown Operating System'
	return 29 # Illegal seek
}
function check_installation {
	local id bin exists
	id="$1"
	bin="$2"
	exists="$(which "$id" || :)"
	if test -n "$exists" -a "$exists" != "$bin"; then
		echo-style --error="There is a non-standard installation at:"
		which "$1"
		echo-style --notice="Remove it and try again..."
		return 75 # Program version wrong
	fi
}
function disable_service {
	if is-mac; then
		sudo launchctl stop "$1" || :
		sudo launchctl disable "$1" || :
		sudo launchctl status "$1" || :
	else
		sudo systemctl disable --now "$1" || :
		sudo systemctl status "$1" --no-pager || :
	fi
}
function enable_service {
	if is-mac; then
		sudo launchctl enable "$1" || :
		sudo launchctl start "$1" || :
		sudo launchctl status "$1" || :
	else
		sudo systemctl enable --now "$1" || :
		sudo systemctl status "$1" --no-pager || :
	fi
}

# =====================================
# Configuration

source "$DOROTHY/sources/config.bash"

# prepare the paths
BIN_DIR="$(echo-mkdir --sudo /usr/local/bin)"
CONF_DIR="$(echo-mkdir --sudo /usr/local/etc)"
DATA_DIR="$(echo-mkdir --sudo /usr/local/share)"
STATE_DIR="$(echo-mkdir --sudo /usr/local/lib)"
if is-mac; then
	SERVICE_DIR='/Library/LaunchDaemons/'
elif is-linux; then
	SERVICE_DIR='/etc/systemd/system/'
else
	die_unknown_os
fi

# dns.bash provides:
DNS_BACKUP_PROVIDER=''
DNS_PROVIDER=''
DNS_IPV4_SERVERS=()
DNS_IPV6_SERVERS=()
DNS_DOH_SERVERS=()
DNS_DOT_SERVERS=()
DNS_QUIC_SERVERS=()
DNS_SDNS_SERVERS=()
DNS_DNSCRYPT_NAMES=()
CLOUDFLARED_TUNNELS=()
NOFAP='maybe'
load_dorothy_config 'dns.bash'

# installers
# https://github.com/AdguardTeam/AdGuardHome/releases
# https://github.com/cloudflare/cloudflared/releases
# https://github.com/DNSCrypt/dnscrypt-proxy/releases
arch="$(get-arch)"
aghome_installer=''
cloudflared_installer=''
dnscrypt_installer=''
if is-mac; then
	if test "$arch" = 'a64'; then
		aghome_installer='AdGuardHome_darwin_arm64.zip'
		cloudflared_installer='cloudflared-darwin-amd64.tgz' # rosetta
		dnscrypt_installer='dnscrypt-proxy-macos_arm64'      # ...
	elif test "$arch" = 'x64'; then
		aghome_installer='AdGuardHome_darwin_amd64.zip'
		cloudflared_installer='cloudflared-darwin-amd64.tgz'
		dnscrypt_installer='dnscrypt-proxy-macos_x86_64' # ...
	fi
elif is-linux; then
	if test "$arch" = 'a64'; then
		aghome_installer='AdGuardHome_linux_arm64.tar.gz'
		cloudflared_installer='cloudflared-linux-arm64'
		dnscrypt_installer='dnscrypt-proxy-linux_arm64' # ...
	elif test "$arch" = 'x64'; then
		aghome_installer='AdGuardHome_linux_amd64.tar.gz'
		cloudflared_installer='cloudflared-linux-amd64'
		dnscrypt_installer='dnscrypt-proxy-linux_x86_64' # ...
	elif test "$arch" = 'x32'; then
		aghome_installer='AdGuardHome_linux_386.tar.gz'
		cloudflared_installer='cloudflared-linux-386'
		dnscrypt_installer='dnscrypt-proxy-linux_i386' # ...
	fi
fi

# available custom services
available_custom_services=()
if test -n "$aghome_installer"; then
	available_custom_services+=(aghome)
fi
if test -n "$cloudflared_installer"; then
	available_custom_services+=(cloudflared)
fi
if test -n "$dnscrypt_installer"; then
	available_custom_services+=(dnscrypt)
fi

# =====================================
# Helpers

function do_rm() {
	# remove all files associated with an id
	if test "$1" != '--'; then
		local id="$1"
		shift

		# remove common paths (files, and directories)
		local rm_paths=(
			# custom
			"$BIN_DIR/$id"
			"$CONF_DIR/$id"
			"$DATA_DIR/$id"
			"$STATE_DIR/$id"

			# xdg
			"$XDG_BIN_HOME/$id"
			"$XDG_CONFIG_HOME/$id"
			"$XDG_DATA_HOME/$id"
			"$XDG_STATE_HOME/$id"

			# standard
			"/usr/local/bin/$id"
			"/usr/local/etc/$id"
			"/usr/local/share/$id"
			"/usr/local/lib/$id"

			# services
			"/Library/LaunchAgents/"*"$id"*   # user
			"/Library/LaunchDaemons/"*"$id"*  # everyone
			"/etc/init.d/"*"$id"*             # alt
			"/usr/lib/systemd/system/"*"$id"* # alt
			"/etc/systemd/system/"*"$id"*     # desited
		)
	fi

	# add custom files
	if test "${1-}" = '--'; then
		shift
		rm_paths+=("$@")
	fi

	# remove them
	for rm_path in "${rm_paths[@]}"; do
		if test -e "$rm_path"; then
			if confirm-positive "Remove $rm_path?" "$(ls -la "$rm_path")"; then
				rm -rf "$rm_path"
			fi
		fi
	done

	# after service additions/removals
	# systemctl needs to be reloaded apparently
	systemctl daemon-reload
	systemctl reset-failed
}

function die_service_unsupported() {
	echo-style \
		--error="This platform [$arch] does not yet support: $1" $'\n' \
		--notice='Supported DNS services for this platform are:' $'\n' \
		"${services[*]}"
	return 19 # Operation not supported by device
}

function die_unknown() {
	echo-style \
		--error="Unknown DNS service: $1" $'\n' \
		--notice='Supported DNS services for this platform are:' $'\n' \
		"${services[*]}"
	return 22 # Invalid argument
}

# =====================================
# Select DNS Provider/Servers

# providers that are user selectable
# excludes local
# excludes backup
providers=()
# add env, if available
if test \
	"${#DNS_IPV4_SERVERS[@]}" -ne 0 -o \
	"${#DNS_IPV6_SERVERS[@]}" -ne 0 -o \
	"${#DNS_DOH_SERVERS[@]}" -ne 0 -o \
	"${#DNS_DOT_SERVERS[@]}" -ne 0 -o \
	"${#DNS_QUIC_SERVERS[@]}" -ne 0 -o \
	"${#DNS_SDNS_SERVERS[@]}" -ne 0; then
	providers+=('env')
fi
# add backup, if available
# if test -n "$DNS_BACKUP_PROVIDER"; then
# 	providers+=('backup')
# fi
# add standard options
providers+=(
	'adguard'
	'adguard-unfiltered'
	'adguard-family'
	'cloudflare'
	'cloudflare-malware'
	'cloudflare-family'
	'cloudflare-teams'
	'quad9'
	'google'
	'opendns'
)

# prepare local vars
local_ipv4_servers=(
	'127.0.0.1'
)
local_ipv6_servers=(
	'::1'
)

# prepare selection vars
provider=''
ipv4_servers=()
ipv6_servers=()
dot_servers=()  # dns over tls
doh_servers=()  # dns over https
sdns_servers=() # dnscrypt
quic_servers=() # preferred
dnscrypt_names=()
nofap='no'

# helper
function fetch_provider {
	# local vars
	local __provider="${1:-"$DNS_PROVIDER"}"

	# if backup was provided, use it
	if test "$__provider" = 'backup'; then
		if test -n "${DNS_BACKUP_PROVIDER}"; then
			fetch_provider "$DNS_BACKUP_PROVIDER"
			return "$?"
		else
			echo-style --notice="Backup DNS Provider Missing"
			echo "The backup DNS provider was requested, however it has not yet been configured. Set DNS_BACKUP_PROVIDER in your dns.bash configuration file to your desired backup provider of these: ${providers[*]}"
			return 1
		fi
	elif test "$__provider" != 'local'; then
		# if non-local provider was provided, confirm or ask for it
		provider="$(
			choose-option --required --confirm \
				--question='Which DNS provider to use?' \
				--filter="$__provider" -- "${providers[@]}"
		)"
	fi

	# reset global vars
	ipv4_servers=()
	ipv6_servers=()
	dot_servers=()  # dns over tls
	doh_servers=()  # dns over https
	sdns_servers=() # dnscrypt
	quic_servers=() # preferred
	dnscrypt_names=()
	nofap='no'

	# turn provider into servers
	case "$provider" in
	'local')
		nofap="$NOFAP"
		ipv4_servers=(
			"${local_ipv4_servers[@]}"
		)
		ipv6_servers=(
			"${local_ipv6_servers[@]}"
		)
		;;
	'env')
		nofap="$NOFAP"
		ipv4_servers=(
			"${DNS_IPV4_SERVERS[@]}"
		)
		ipv6_servers=(
			"${DNS_IPV6_SERVERS[@]}"
		)
		doh_servers=(
			"${DNS_DOH_SERVERS[@]}"
		)
		dot_servers=(
			"${DNS_DOT_SERVERS[@]}"
		)
		quic_servers=(
			"${DNS_QUIC_SERVERS[@]}"
		)
		sdns_servers=(
			"${DNS_SDNS_SERVERS[@]}"
		)
		dnscrypt_names=(
			"${DNS_DNSCRYPT_NAMES[@]}"
		)
		;;
	'adguard')
		# https://adguard-dns.com/en/public-dns.html
		# If you want to block ads and trackers.
		ipv4_servers=(
			'94.140.14.14'
			'94.140.15.15'
		)
		ipv6_servers=(
			'2a10:50c0::ad1:ff'
			'2a10:50c0::ad2:ff'
		)
		doh_servers=(
			'https://dns.adguard.com/dns-query'
		)
		dot_servers=(
			'tls://dns.adguard.com'
		)
		quic_servers=(
			'quic://dns.adguard.com'
		)
		sdns_servers=(
			'sdns://AQMAAAAAAAAAETk0LjE0MC4xNC4xNDo1NDQzINErR_JS3PLCu_iZEIbq95zkSV2LFsigxDIuUso_OQhzIjIuZG5zY3J5cHQuZGVmYXVsdC5uczEuYWRndWFyZC5jb20'
		)
		dnscrypt_names=(
			'adguard-dns'
			'adguard-dns-doh'
			'adguard-dns-ipv6'
		)
		;;
	'adguard-unfiltered')
		# https://adguard-dns.com/en/public-dns.html
		# If you don't want AdGuard DNS to block ads and trackers, or any other DNS requests.
		ipv4_servers=(
			'94.140.14.140'
			'94.140.14.141'
		)
		ipv6_servers=(
			'2a10:50c0::1:ff'
			'2a10:50c0::2:ff'
		)
		doh_servers=(
			'https://dns-unfiltered.adguard.com/dns-query'
		)
		dot_servers=(
			'tls://dns-unfiltered.adguard.com'
		)
		quic_servers=(
			'quic://dns-unfiltered.adguard.com'
		)
		sdns_servers=(
			'sdns://AQMAAAAAAAAAEjk0LjE0MC4xNC4xNDA6NTQ0MyC16ETWuDo-PhJo62gfvqcN48X6aNvWiBQdvy7AZrLa-iUyLmRuc2NyeXB0LnVuZmlsdGVyZWQubnMxLmFkZ3VhcmQuY29t'
		)
		dnscrypt_names=(
			'adguard-dns-unfiltered'
			'adguard-dns-unfiltered-ipv6'
		)
		;;
	'adguard-family')
		# If you want to block adult content, enable safe search and safe mode options wherever possible, and also block ads and trackers.
		nofap='yes'
		ipv4_servers=(
			'94.140.14.15'
			'94.140.15.16'
		)
		ipv6_servers=(
			'2a10:50c0::bad1:ff'
			'2a10:50c0::bad2:ff'
		)
		doh_servers=(
			'https://dns-family.adguard.com/dns-query'
		)
		dot_servers=(
			'tls://dns-family.adguard.com'
		)
		quic_servers=(
			'quic://dns-family.adguard.com'
		)
		sdns_servers=(
			'sdns://AQMAAAAAAAAAETk0LjE0MC4xNC4xNTo1NDQzILgxXdexS27jIKRw3C7Wsao5jMnlhvhdRUXWuMm1AFq6ITIuZG5zY3J5cHQuZmFtaWx5Lm5zMS5hZGd1YXJkLmNvbQ'
		)
		dnscrypt_names=(
			'adguard-dns-family'
			'adguard-dns-family-doh'
			'adguard-dns-family-ipv6'
		)
		;;
	'cloudflare')
		# https://developers.cloudflare.com/1.1.1.1/setting-up-1.1.1.1
		# https://developers.cloudflare.com/1.1.1.1/encrypted-dns/dns-over-https/make-api-requests
		# https://developers.cloudflare.com/1.1.1.1/encrypted-dns/dns-over-tls
		ipv4_servers=(
			'1.1.1.1'
			'1.0.0.1'
		)
		ipv6_servers=(
			'2606:4700:4700::1111'
			'2606:4700:4700::1001'
		)
		doh_servers=(
			'https://cloudflare-dns.com/dns-query'
		)
		dot_servers=(
			'tls://one.one.one.one'
		)
		dnscrypt_names=(
			'cloudflare'
			'cloudflare-ipv6'
		)
		;;
	'cloudflare-security')
		# https://developers.cloudflare.com/1.1.1.1/1.1.1.1-for-families/setup-instructions/router/
		ipv4_servers=(
			'1.1.1.2'
			'1.0.0.2'
		)
		ipv6_servers=(
			'2606:4700:4700::1112'
			'2606:4700:4700::1002'
		)
		doh_servers=(
			'https://security.cloudflare-dns.com/dns-query'
		)
		dot_servers=(
			'tls://security.cloudflare-dns.com'
		)
		dnscrypt_names=(
			'cloudflare-security'
			'cloudflare-security-ipv6'
		)
		;;
	'cloudflare-family')
		# https://developers.cloudflare.com/1.1.1.1/1.1.1.1-for-families/setup-instructions/router/
		# https://developers.cloudflare.com/1.1.1.1/1.1.1.1-for-families
		nofap='yes'
		ipv4_servers=(
			'1.1.1.3'
			'1.0.0.3'
		)
		ipv6_servers=(
			'2606:4700:4700::1113'
			'2606:4700:4700::1003'
		)
		doh_servers=(
			'https://family.cloudflare-dns.com/dns-query'
		)
		dot_servers=(
			'tls://family.cloudflare-dns.com'
		)
		dnscrypt_names=(
			'cloudflare-family'
			'cloudflare-family-ipv6'
		)
		;;
	'cloudflare-teams')
		# https://developers.cloudflare.com/1.1.1.1/1.1.1.1-for-families/setup-instructions/router/
		nofap='yes'
		ipv4_servers=(
			'172.64.36.1'
			'172.64.36.2'
		)
		ipv6_servers=()
		;;
	'google')
		ipv4_servers=(
			'8.8.8.8'
			'8.8.4.4'
		)
		ipv6_servers=(
			'2001:4860:4860::8888'
			'2001:4860:4860::8844'
		)
		dnscrypt_names=(
			'google'
			'google-ipv6'
		)
		;;
	'opendns')
		# https://support.opendns.com/hc/en-us/articles/227986667-Does-OpenDNS-support-IPv6-
		ipv4_servers=(
			'208.67.222.222'
			'208.67.220.220'
		)
		ipv6_servers=(
			'2620:0:ccc::2'
			'2620:0:ccd::2'
		)
		;;
	'quad9')
		ipv4_servers=(
			'9.9.9.9'
			'149.112.112.112'
		)
		ipv6_servers=(
			'2620:fe::fe'
			'2620:fe::9'
		)
		;;
	*)
		echo-style --error="Invalid state, invalid provider: $provider" >/dev/stderr
		exit 1
		;;
	esac
}

# =====================================
# DNS Service: System: macOS

function system_exists {
	if is-mac; then
		command-exists networksetup
	elif is-linux; then
		command-exists systemd-resolve && command-exists resolvectl
	else
		die_unknown_os
	fi
}
function system_install {
	if ! system_exists; then
		return 29 # Illegal seek
	fi
}
function system_uninstall {
	return 29 # Illegal seek
}
function system_configure {
	# determine servers and action
	local servers action="$1"
	if test "$action" = 'enable'; then
		servers=(
			"${ipv4_servers[@]}"
			"${ipv6_servers[@]}"
		)
	else
		servers=(
			"${local_ipv4_servers[@]}"
			"${local_ipv6_servers[@]}"
		)
	fi

	# handle the os changes
	if is-mac; then
		# -------------------------------------
		# DNS Service: macOS
		# https://support.apple.com/en-us/HT202516

		# log
		echo-style --h1="${action@u} macOS"

		# apply
		local interface
		networksetup -listallnetworkservices | grep -v '\*' | while read -r interface; do
			sudo networksetup -setdnsservers "$interface" "${servers[@]}"
		done

		# log
		echo-style --g1="${action@u} macOS"
	else
		# -------------------------------------
		# DNS Service: Systemd (aka systemd-resolved, systemd-resolve, resolvectl, resolv)
		# https://gist.github.com/balupton/f4aa448731d6b1bdf505c10078b9a8ad#file-resolv-bash

		# https://wiki.archlinux.org/title/Systemd-resolved
		# https://man.archlinux.org/man/systemd-resolved.8#/ETC/RESOLV.CONF

		# /run/systemd/resolve/stub-resolv.conf
		# ^ lists the 127.0.0.53 DNS stub as the only DNS server.
		# ^ It also contains a list of search domains that are in use by systemd-resolved.

		# /usr/lib/systemd/resolv.conf
		# ^ lists the 127.0.0.53 DNS stub as only DNS server.
		# ^ This file does not contain any search domains.

		# /run/systemd/resolve/resolv.conf
		# ^ containing information about all known DNS servers
		# ^ it does not know a concept of per-interface DNS servers and hence only contains system-wide DNS server definitions.

		# /etc/systemd/resolved.conf
		# ^ The DNS servers contacted are determined from the global settings in

		# /etc/systemd/network/*.network
		# ^ er-link static settings

		# /etc/resolv.conf
		# ^ used by everything

		#  To improve compatibility, /etc/resolv.conf is read in order to discover configured system DNS servers, but only if it is not a symlink to /run/systemd/resolve/stub-resolv.conf, /usr/lib/systemd/resolv.conf or /run/systemd/resolve/resolv.conf (see below).
		local systemd_title='Systemd-resolved'
		local servers Domains DNSOverTLS DNSSEC

		# log
		echo-style --g1="${action@u} ${systemd_title}"

		# apply changes to services
		sudo systemctl stop systemd-networkd || :
		sudo systemctl stop systemd-resolved || :

		# make life simple, using only /etc/resolv.conf
		# https://www.freedesktop.org/software/systemd/man/resolved.conf.html
		sudo rm -rf \
			/run/systemd/resolve/stub-resolv.conf \
			/usr/lib/systemd/resolv.conf \
			/run/systemd/resolve/resolv.conf \
			/etc/systemd/resolved.conf \
			/etc/resolv.conf

		# prepare config for file, and for interfaces
		Domains='~.'
		if test "${#dot_servers[@]}" -ne 0; then
			DNSOverTLS='true'
			DNSSEC='true'
		else
			DNSOverTLS='opportunistic'
			DNSSEC='allow-downgrade'
		fi

		# apply specific config
		if test "$action" = 'enable'; then
			# using systemd
			sudo tee /etc/resolv.conf <<-EOF
				[Resolve]
				DNS=${servers[*]}
				Domains=$Domains
				DNSSEC=$DNSSEC
				DNSOverTLS=$DNSOverTLS
			EOF
		else
			# use custom service
			sudo tee /etc/resolv.conf <<-EOF
				nameserver ${servers[0]}
				options edns0
			EOF
		fi

		# temporarily start system services, so that changes can be applied to them
		# sudo systemctl daemon-reload
		# sudo systemctl start systemd-networkd
		sudo systemctl start systemd-resolved

		# apply changes to interfaces
		sudo resolvectl flush-caches --no-pager
		sudo resolvectl reset-server-features --no-pager
		mapfile -t interfaces < <(
			resolvectl status --no-pager | rg 'Link \d \((.+?)\)' --replace '$1'
		)
		if is-array-empty "${interfaces[@]}"; then
			echo-style --error='No interfaces were found.' >/dev/stderr
			exit 1
		fi
		for interface in "${interfaces[@]}"; do
			# remove other changes
			sudo resolvectl revert "$interface" || continue

			# apply intended changes
			sudo resolvectl default-route "$interface" false
			sudo resolvectl domain "$interface" "$Domains"
			sudo resolvectl dnssec "$interface" "$DNSSEC"
			sudo resolvectl dnsovertls "$interface" "$DNSOverTLS"
			sudo resolvectl dns "$interface" "${servers[@]}"

			# reboot the interface
			sleep 1
			network-interface "$interface" restart
		done

		# now that it is all done, enable or disable
		if test "$action" = 'enable'; then
			# verify
			resolvectl status --no-pager
			resolvectl query cloudflare.com --no-pager
			resolvectl statistics --no-pager

			# enable
			sudo systemctl enable --now systemd-resolved
		else
			sudo systemctl disable --now systemd-resolved
		fi

		# after significant systemd changes, it may need to be reloaded
		# sudo systemctl daemon-reload
		# systemctl reset-failed

		# log
		echo-style --g1="${action@u} ${systemd_title}"
	fi
}

# =====================================
# DNS Service: Custom: AdGuard Home

# https://github.com/AdguardTeam/AdGuardHome/wiki/Configuration#command-line
aghome_title="AdGuard Home"
aghome_id='AdGuardHome'
aghome_bin_file="$BIN_DIR/$aghome_id"
aghome_conf_dir="$CONF_DIR/$aghome_id"
aghome_conf_file="$aghome_conf_dir/$aghome_id.yaml"
aghome_data_dir="$DATA_DIR/$aghome_id"
aghome_state_dir="$STATE_DIR/$aghome_id"
aghome_state_pid_file="$aghome_state_dir/$aghome_id.pid"
aghome_state_log_file="$aghome_state_dir/$aghome_id.log"
if is-mac; then
	aghome_service_file="$SERVICE_DIR/$aghome_id.plist" # @todo unknown
else
	aghome_service_file="$SERVICE_DIR/$aghome_id.service"
fi
aghome_bin_cmd=(
	"$aghome_bin_file"
	'--config' "$aghome_conf_file"
	'--work-dir' "$aghome_data_dir"
	'--pidfile' "$aghome_state_pid_file"
	'--logfile' "$aghome_state_log_file"
)
function aghome_exists {
	check_installation "$aghome_id" "$aghome_bin_file"
	text -x "$aghome_bin_file"
}
function aghome_install {
	# check
	if test -z "$aghome_installer"; then
		die_service_unsupported "$aghome_title"
	fi

	# log
	local action='install'
	if aghome_exists; then
		action='upgrade'
	fi
	echo-segment --h1="${action@u} ${aghome_title}"

	# make directories
	sudo mkdir -p "$aghome_conf_dir" "$aghome_data_dir" "$aghome_state_dir"

	# install/upgrade
	local temp_bin_file
	temp_bin_file="$(mktemp)"
	down-zip "https://static.adguard.com/adguardhome/release/${aghome_installer}" \
		--filter="AdGuardHome/AdGuardHome" \
		--destination="$temp_bin_file"
	sudo mv "$temp_bin_file" "$aghome_bin_file"
	sudo chmod +x "$aghome_bin_file"

	# log
	echo-segment --g1="${action@u} ${aghome_title}"
}
function aghome_uninstall {
	# check
	if ! aghome_exists; then
		return 0
	fi

	# log
	echo-segment --h1="Uninstall ${aghome_title}"

	# stop and uninstall the service
	sudo "${aghome_bin_cmd[@]}" --service stop || :
	sudo "${aghome_bin_cmd[@]}" --service uninstall || :

	# ensure adguard home has stopped
	killall "$aghome_id" || :

	# clean it all up
	do_rm "$aghome_id" -- "$aghome_bin_file" "$aghome_conf_dir" "$aghome_data_dir" "$aghome_state_dir" "$aghome_service_file"

	# log
	echo-segment --g1="Uninstall ${aghome_title}"
}
function aghome_configure {
	# check
	if ! aghome_exists; then
		return 0
	fi

	# log
	local action="$1"
	echo-segment --h1="${action@u} ${aghome_title}"

	# enable?
	if test "$action" = 'enable'; then
		sudo "${aghome_bin_cmd[@]}" --service install || :
		sudo "${aghome_bin_cmd[@]}" --service enable || :
		sudo "${aghome_bin_cmd[@]}" --service start || :
		confirm --ppid=$$ -- "Press any key once you have completed the initial $aghome_title setup..."
	else
		sudo "${aghome_bin_cmd[@]}" --service stop || :
		sudo "${aghome_bin_cmd[@]}" --service disable || :
	fi
	sudo "${aghome_bin_cmd[@]}" --service status || :

	# prepare desired providers
	local upstream_servers=(
		"${dot_servers[@]}"
		"${doh_servers[@]}"
		"${quic_servers[@]}"
		"${sdns_servers[@]}"
	)
	if test "${#upstream_servers[@]}" -eq 0; then
		upstream_servers=(
			"${ipv4_servers[@]}"
			"${ipv6_servers[@]}"
		)
	fi

	# use desired providers
	local pattern replace
	pattern='  upstream_dns:\n(  - .+\n)+'
	replace=$'  upstream_dns:\n'
	for server in "${upstream_servers[@]}"; do
		replace+="  - $server"$'\n'
	done
	sudo-inherit sd "$pattern" "$replace" "$aghome_conf_file"
	sudo "${aghome_bin_cmd[@]}" --check-config

	# reload if enable
	if test "$action" = 'enable'; then
		sudo "${aghome_bin_cmd[@]}" --service reload || :
		sudo "${aghome_bin_cmd[@]}" --service status || :
	fi

	# log
	echo-segment --g1="${action@u} ${aghome_title}"
}

# =====================================
# DNS Service: Custom: DNSCrypt Proxy
# https://github.com/DNSCrypt/dnscrypt-proxy/wiki/Installation-linux

dnscrypt_title='DNSCrypt Proxy'
dnscrypt_id='dnscrypt-proxy'
dnscrypt_brew_id="$dnscrypt_id"
dnscrypt_bin_file="${BIN_DIR}/$dnscrypt_id"
dnscrypt_conf_dir="${CONF_DIR}/$dnscrypt_id"
dnscrypt_conf_file="$dnscrypt_conf_dir/$dnscrypt_id.toml"
dnscrypt_bin_cmd=(
	"$dnscrypt_bin_file"
	'-config' "$dnscrypt_conf_file"
)
if is-mac; then
	# launchctl
	dnscrypt_service_id="$dnscrypt_id" # @todo assumed
	dnscrypt_service_file="$SERVICE_DIR/$dnscrypt_service_id.plist"
else
	# systemctl
	dnscrypt_service_id="$dnscrypt_id"
	dnscrypt_service_file="$SERVICE_DIR/$dnscrypt_service_id.service"
fi
function dnscrypt_exists {
	test -x "$dnscrypt_bin_file"
}
function dnscrypt_install {
	# check
	if test -z "$dnscrypt_installer"; then
		die_service_unsupported "$dnscrypt_title"
	fi

	# prepare
	local action='install'
	if dnscrypt_exists; then
		action='upgrade'
	fi

	# log
	echo-segment --h1="${action@u} ${dnscrypt_title}"

	# disable if it already exists
	dnscrypt_disable

	# don't use brew for this, as we want complete control
	brew uninstall "$dnscrypt_brew_id" || :
	check_installation "$dnscrypt_id" "$dnscrypt_bin_file"

	# install/upgrade
	local temp_bin_file
	temp_bin_file="$(mktemp)"
	github-release-file-download DNSCrypt/dnscrypt-proxy \
		--filter="$dnscrypt_installer" \
		--extract='*/dnscrypt-proxy' \
		--destination="$temp_bin_file"
	sudo mv "$temp_bin_file" "$dnscrypt_bin_file"
	sudo chmod +x "$dnscrypt_bin_file"

	# log
	echo-segment --g1="${action@u} ${dnscrypt_title}"
}
function dnscrypt_uninstall {
	dnscrypt_disable

	echo-style --h2="$dnscrypt_title is being uninstalled..."
	if is-brew; then
		brew uninstall "$dnscrypt_brew_id" || :
	fi
	do_rm "$dnscrypt_id" -- "$dnscrypt_service_file"
	echo-style --g2="$dnscrypt_title is now uninstalled."
}
function dnscrypt_disable {
	echo-style --h2="$dnscrypt_title service is being disabled..."
	if is-brew; then
		sudo brew services stop "$dnscrypt_brew_id" || :
	else
		sudo "${dnscrypt_bin_cmd[@]}" -service stop || :
		sudo "${dnscrypt_bin_cmd[@]}" -service uninstall || :
	fi
	echo-style --g2="$dnscrypt_title service is now disabled."
}
function dnscrypt_enable {
	# service
	echo "$dnscrypt_title service is being installed..."
	if is-brew; then
		sudo brew services start "$dnscrypt_brew_id"
	else
		sudo "${dnscrypt_bin_cmd[@]}" -check
		sudo "${dnscrypt_bin_cmd[@]}" -service install
		sudo "${dnscrypt_bin_cmd[@]}" -service start
		sleep 5 # needed otherwise sometimes resolve fails
		sudo systemctl status "$dnscrypt_service_id" --no-pager
		sudo "${dnscrypt_bin_cmd[@]}" -resolve cloudflare.com
	fi
	echo "$dnscrypt_title service is now installed"
}
function dnscrypt_configure {
	echo-style --h2="$dnscrypt_title is being configured..."

	# prep the config replacement
	if test ! -f "$dnscrypt_conf_file"; then
		local temp_conf_file
		temp_conf_file="$(mktemp)"
		github-file-download \
			'dnscrypt-proxy/master/dnscrypt-proxy/example-dnscrypt-proxy.toml' \
			--destination="$temp_conf_file"
		sudo mv "$temp_conf_file" "$dnscrypt_conf_file"
	fi

	# if the server names were missing, get the user to decide on an alternative
	if test "${#dnscrypt_names[@]}" -eq 0; then
		mapfile -t dnscrypt_options < <(
			fetch 'https://download.dnscrypt.info/resolvers-list/v2/public-resolvers.md' | rg '^## (.+)$' --replace '$1'
		)
		mapfile -t dnscrypt_names < <(
			choose-option --required --multi --question="Which DNSCrypt Server names do you wish to use?" --
			"${dnscrypt_options[@]}"
		)
	fi

	# apply the server names
	sudo-inherit config-helper --file="$dnscrypt_conf_file" -- \
		--field='ipv6_servers' --value='true' \
		--field='dnscrypt_names' --value='true' \
		--field='doh_servers' --value='true' \
		--field='server_names' --value="[$(echo-join ', ' -- "${dnscrypt_names[@]}")]"

	# move the changes over
	sudo mv "$f" "$dnscrypt_conf"
	echo-style --g2="$dnscrypt_title is now configured"
}

# =====================================
# DNS Service: Custom: Cloudflare Warp

# doesn't yet support any of the platforms I use, so no support in here yet

# =====================================
# DNS Service: Custom: Cloudflared Proxy

cloudflared_title='Cloudflared'
cloudflared_id='cloudflared'
cloudflared_brew_id='cloudflare/cloudflare/cloudflared'
cloudflared_bin_file="$BIN_DIR/$cloudflared_id"
if is-mac; then
	# launchctl
	cloudflared_proxy_service_id='com.cloudflare.cloudflared-proxy'
	cloudflared_proxy_service_file="$SERVICE_DIR/$cloudflared_proxy_service_id.plist"
else
	# systemctl
	cloudflared_proxy_service_id='cloudflared-proxy'
	cloudflared_proxy_service_file="$SERVICE_DIR/$cloudflared_proxy_service_id.service"
fi

function cloudflared_exists {
	text -x "$cloudflared_bin_file"
}
function cloudflared_install {
	# check
	if test -z "$cloudflared_installer"; then
		die_service_unsupported "$cloudflared_title"
	fi

	# prepare
	local action='install'
	if cloudflared_exists; then
		action='upgrade'
	fi

	# log
	echo-segment --h1="${action@u} ${cloudflared_title}"

	# disable if it already exists
	cloudflared_disable

	# don't use brew for this, as we want complete control
	brew uninstall "$cloudflared_brew_id" || :
	check_installation "$cloudflared_id" "$cloudflared_bin_file"

	# install/upgrade
	local temp_bin_file
	temp_bin_file="$(mktemp)"
	github-release-file-download cloudflare/cloudflared \
		--filter="$cloudflared_installer" \
		--destination="$temp_bin_file"
	sudo mv "$temp_bin_file" "$cloudflared_bin_file"
	sudo chmod +x "$cloudflared_bin_file"

	# log
	echo-segment --g1="${action@u} ${cloudflared_title}"
}
function cloudflared_uninstall {
	# check
	if ! cloudflared_exists; then
		return 0
	fi

	# log
	echo-segment --h1="Uninstall ${cloudflared_title}"

	# disable
	cloudflared_disable

	# don't use brew for this, as we want complete control
	brew uninstall "$cloudflared_brew_id" || :
	check_installation "$cloudflared_id" "$cloudflared_bin_file"

	# after systemctl additions and removals, one has to do this
	if test "${#CLOUDFLARED_TUNNELS[@]}" -eq 0; then
		do_rm "$cloudflared_id" -- "$cloudflared_proxy_service_file" || :
	else
		do_rm -- "$cloudflared_proxy_service_file" || :
	fi

	# log
	echo-segment --g1="Uninstall ${cloudflared_title}"
}
function cloudflared_disable {
	# check
	if ! cloudflared_exists; then
		return 0
	fi

	# log
	echo-segment --h2="Disable ${cloudflared_title}"

	# disable
	if is-mac; then
		sudo launchctl stop "$cloudflared_proxy_service_id"
		sudo launchctl disable "$cloudflared_proxy_service_id"
		sudo launchctl status "$cloudflared_proxy_service_id"
	else
		sudo systemctl disable --now "$cloudflared_proxy_service_id"
		sudo systemctl status "$cloudflared_proxy_service_id" --no-pager
	fi

	# log
	echo-segment --g2="Disable ${cloudflared_title}"
}
function cloudflared_enable {
	# check
	if ! cloudflared_exists; then
		return 0
	fi

	# log
	echo-segment --h2="Enable ${cloudflared_title}"

	# enable
	if is-mac; then
		sudo launchctl enable "$cloudflared_proxy_service_id" # aka load
		sudo launchctl start "$cloudflared_proxy_service_id"
		sudo launchctl status "$cloudflared_proxy_service_id"
	else
		sudo systemctl enable --now "$cloudflared_proxy_service_id"
		sudo systemctl status "$cloudflared_proxy_service_id" --no-pager
	fi

	# log
	echo-segment --g2="Enable ${cloudflared_title}"
}
function cloudflared_configure {
	# check
	if ! cloudflared_exists; then
		return 0
	fi

	# log
	local action="$1"
	echo-segment --h1="${action@u} ${cloudflared_title}"

	# check
	check_installation "$cloudflared_id" "$cloudflared_bin_file"

	# disable for now
	cloudflared_disable

	# prepare
	local upstream_servers=(
		"${dot_servers[@]}"
		"${doh_servers[@]}"
		"${quic_servers[@]}"
	)
	if test "${#upstream_servers[@]}" -eq 0; then
		upstream_servers=(
			"${ipv4_servers[@]}"
			"${ipv6_servers[@]}"
		)
	fi

	# configure service
	if is-mac; then
		# generate upstreams
		local upstream_section=''
		for server in "${upstream_servers[@]}"; do
			upstream_section+=$'\n'"			<string>--upstream</string>"
			upstream_section+=$'\n'"			<string>$server</string>"
		done

		# create service with custom upstreams
		sudo tee "$cloudflared_proxy_service_file" >/dev/null <<EOF
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
	<dict>
		<key>Label</key>
		<string>Cloudflared Proxy: ${cloudflared_proxy_service_id}</string>
		<key>ProgramArguments</key>
		<array>
			<string>${cloudflared_bin_file}</string>
			<string>--proxy-dns</string>$upstream_section
		</array>
		<key>RunAtLoad</key>
		<true/>
		<key>StandardOutPath</key>
		<string>/Library/Logs/${cloudflared_proxy_service_id}.out.log</string>
		<key>StandardErrorPath</key>
		<string>/Library/Logs/${cloudflared_proxy_service_id}.err.log</string>
		<key>KeepAlive</key>
		<dict>
			<key>SuccessfulExit</key>
			<false/>
		</dict>
		<key>ThrottleInterval</key>
		<integer>5</integer>
	</dict>
</plist>
EOF
	else
		# generate upstreams
		local upstream_args=''
		for server in "${upstream_servers[@]}"; do
			upstream_args+=" --upstream ${server@Q}"
		done

		# create service with custom upstreams
		sudo tee "$cloudflared_proxy_service_file" >/dev/null <<-EOF
			[Unit]
			Description=Cloudflared Proxy: ${cloudflared_proxy_service_id}
			Wants=network-online.target nss-lookup.target
			Before=nss-lookup.target

			[Service]
			AmbientCapabilities=CAP_NET_BIND_SERVICE
			CapabilityBoundingSet=CAP_NET_BIND_SERVICE
			DynamicUser=yes
			ExecStart=${cloudflared_bin_file} proxy-dns ${upstream_args}

			[Install]
			WantedBy=multi-user.target
		EOF
	fi

	# reload if enable
	if test "$action" = 'enable'; then
		cloudflared_enable
	fi
}

# =====================================
# DNS Service: Special: Cloudflared Tunnels

tunnel_service_id='cloudflared-tunnel'
tunnel_user_dir="$HOME/.cloudflared"
tunnel_user_pem="$tunnel_user_dir/cert.pem"
tunnel_conf_dir="$CONF_DIR/$cloudflared_id"
# ^ cloudflared always places login cert here

function tunnel_install() {
	# ensure cloudflared is installed
	cloudflared_install

	# make tunnel directories
	mkdir -p "$tunnel_user_dir"
}
function tunnel_uninstall() {
	# disable tunnel
	tunnel_disable

	# remove files for all tunnels
	do_rm "$tunnel_service_id" -- "$tunnel_user_dir" "$tunnel_conf_dir"
}
function tunnel_disable {
	# check
	if ! tunnel_exists; then
		return 0
	fi

	# disable all the tunnels
	local tunnel_service_id
	for file in "$SERVICE_DIR/"*"$tunnel_service_id"*; do
		tunnel_service_id="$(fs-filename "$file")"
		disable_service "$tunnel_service_id"
	done
}
function tunnel_enable {
	# check
	if test ! -f "$tunnel_service_file"; then
		return 0
	fi

	# enable all the tunnels
	local tunnel_service_id
	for file in "$SERVICE_DIR/"*"$tunnel_service_id"*; do
		tunnel_service_id="$(basename "$file")"
		enable_service "$tunnel_service_id"
	done
}
function tunnel_configure_single {
	# check
	if ! cloudflared_exists; then
		return 0
	fi

	# process args
	local tunnel='' hostnames=() url='' ingress=''
	while test "$#" -ne 0; do
		item="$1"
		shift
		case "$item" in
		'--tunnel='*) tunnel="${item:9}" ;;
		'--hostname='*) hostname+=("${item:11}") ;;
		'--url='*) url="${item:6}" ;;
		'--ingress='*) ingress="${item:10}" ;;
		--) break ;;
		*)
			echo-style --error="Unknown tunnel argument: $item"
			exit 1
			;;
		esac
	done

	# ask if required args missing
	if test -z "$tunnel"; then
		tunnel="$(
			ask --required --confirm \
				--question="What will be name identifier of the tunnel?"
		)"
	fi
	if test "${#hostname[@]}" -eq 0; then
		hostnames+=(
			"$(
				ask --required --confirm \
					--question="What will be the hostname to access the tunnel? E.g. ${name}.domain.com"
			)"
		)
	fi
	if test -z "$ingress"; then
		if test -z "$url"; then
			url="$(
				ask --required --confirm \
					--question="What will be local URL the tunnel will expose?"
			)"
		fi
		ingress="url: $url"
	fi

	# prepare specific files
	local tunnel_conf_file tunnel_cred_file tunnel_service_id tunnel_service_file
	tunnel_conf_file="$tunnel_conf_dir/$tunnel_service_id-$tunnel.yml"
	tunnel_cred_file="$tunnel_conf_dir/$tunnel_service_id-$tunnel.json"
	if is-mac; then
		# launchctl
		tunnel_service_id="com.cloudflare.cloudflared-tunnel-$tunnel"
		tunnel_service_file="$SERVICE_DIR/$tunnel_service_id.plist"
	else
		# systemctl
		tunnel_service_id="cloudflared-tunnel-$tunnel"
		tunnel_service_file="$SERVICE_DIR/$tunnel_service_id.service"
	fi

	# cleanup
	do_rm "cloudflared-tunnel-$tunnel" -- "$tunnel_user_pem" "$tunnel_conf_file" "$tunnel_cred_file" || :

	# login
	"$cloudflared_bin_file" tunnel login
	chmod 600 "$tunnel_user_pem"
	# creates $tunnel_user_pem no need to move it though

	# tunnel prepare
	"$cloudflared_bin_file" tunnel cleanup "$tunnel" || :
	"$cloudflared_bin_file" tunnel delete "$tunnel" || :

	# tunnel create
	local temp_cred_file
	temp_cred_file="$(mktemp)"
	"$cloudflared_bin_file" tunnel create \
		--credentials-file "$temp_cred_file" \
		"$tunnel"
	chmod 660 "$temp_cred_file"
	sudo mv "$temp_cred_file" "$tunnel_cred_file"

	# route create
	sudo tee "$tunnel_conf_file" >/dev/null <<-EOF
		tunnel: ${tunnel}
		credentials-file: ${tunnel_cred_file}
		${ingress}
	EOF

	# tunnel route
	local hostname
	for hostname in "${hostnames[@]}"; do
		"$cloudflared_bin_file" tunnel route dns \
			--overwrite-dns "$name" \
			"$hostname"
	done

	# service create
	if is-mac; then
		sudo tee "$tunnel_service_file" >/dev/null <<EOF
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
	<dict>
		<key>Label</key>
		<string>Cloudflared Tunnel: ${tunnel_service_id}</string>
		<key>ProgramArguments</key>
		<array>
			<string>${cloudflared_bin_file}</string>
			<string>tunnel</string>
			<string>run</string>
			<string>--config</string>
			<string>${tunnel_conf_file}</string>
		</array>
		<key>RunAtLoad</key>
		<true/>
		<key>StandardOutPath</key>
		<string>/Library/Logs/${tunnel_service_id}.out.log</string>
		<key>StandardErrorPath</key>
		<string>/Library/Logs/${tunnel_service_id}.err.log</string>
		<key>KeepAlive</key>
		<dict>
			<key>SuccessfulExit</key>
			<false/>
		</dict>
		<key>ThrottleInterval</key>
		<integer>5</integer>
	</dict>
</plist>
EOF
	else
		sudo tee "$tunnel_service_file" >/dev/null <<-EOF
			[Unit]
			Description=Cloudflared Tunnel: ${tunnel_service_id}
			After=network.target

			[Service]
			TimeoutStartSec=0
			Type=notify
			ExecStart=${cloudflared_bin_file} tunnel run --config $tunnel_conf_file
			Restart=on-failure
			RestartSec=5s

			[Install]
			WantedBy=multi-user.target
		EOF
	fi
}
function tunnel_configure {
	# check
	if ! cloudflared_exists; then
		return 0
	fi

	# if no args
	if test "$#" -eq 0; then
		# check env
		if test "${#CLOUDFLARED_TUNNELS[@]}" -eq 0; then
			return 0 # @todo not currently implemented
			# if no env, call single without args so it pompts
			tunnel_configure_single
			# and ask again until the user is done adding tunnels
			while confirm-negative "Do you wish to add another tunnel?"; do
				tunnel_configure_single
			done
		else
			# use env
			tunnel_configure "${CLOUDFLARED_TUNNELS[@]}"
			return "$?"
		fi
	fi

	# cycle through the tunnels
	local args=() arg
	while true; do
		arg="$1"
		args+=("$arg")
		shift
		if test "$arg" = '--' -o "$#" -eq 0; then
			# run the configure
			tunnel_configure_single "${args[@]}"
			# reset for next
			args=()
		fi
	done
}

# =====================================
# Action

# -------------------------------------
# Prompts

# 1. Prompt the user which hosts they want to use
select-hosts

# 2. Prompt the user which dns service they wish to use
services=(
	"${available_custom_services[@]}"
	"${services_available[@]}"
)
if test -n "$DNS_SERVICE" && is-needle "$DNS_SERVICE" "${services[@]}"; then
	service="$DNS_SERVICE"
else
	service="$(
		choose-option \
			--question="Which DNS service do you wish to be your primary service?" \
			-- "${services[@]}"
	)"
fi

# 3. Prompt the user if they intend to use cloudflared tunnels
if test "${#CLOUDFLARED_TUNNELS[@]}" -ne 0; then
	cloudflared_tunnels='yes'
else
	cloudflared_tunnels="$(
		confirm-negative \
			--question="Do you wish to create a Cloudflare tunnel?" | echo-affirmative
	)"
fi

# 4. Prompt the user which dns provider they wish to use
fetch_provider

# -------------------------------------
# Actions

# 5. Install the provider
("$service"_install)

# 5. Install the tunnel provider
if test "$cloudflared_tunnels" = 'yes'; then
	tunnel_install
else
	tunnel_uninstall
fi

# 6. Detect installed custom services
installed_custom_services=()
if aghome_exists; then
	installed_custom_services+=(aghome)
fi
if cloudflared_exists; then
	installed_custom_services+=(cloudflared)
fi
if dnscrypt_exists; then
	installed_custom_services+=(dnscrypt)
fi

# 7. Disable all custom services, reconfigure the system (system on linux must be temporarily enabled to be configured), and then enable the chosen service
for __service in "${installed_custom_services[@]}"; do
	("$__service"_configure disable)
done
if test "$service" = 'system'; then
	system_configure enable
else
	system_configure disable
	("$service"_configure enable)
fi

# -------------------------------------
# Verification

# 7. Verify DNS
echo-segment --h1='Verify DNS'
echo-eval -- dig -x cloudflare.com
echo-eval -- what-is-listening dns
echo-segment --g1='Verify DNS'

# echo
# echo 'Testing that the system is now using the custom DNS service...'
# if ! (dig -x cloudflare.com | rg -q ';; SERVER: 127.0.0.1'); then
# 	cat <<-EOF >/dev/stderr
# 		FAILURE
# 		Custom DNS configuration has failed.
# 		The domain failed to resolve or did not resolve with the local DNS service.
# 		You can debug further by running [debug-network].
# 	EOF
# 	exit 1
# fi
# echo "DNS service setup succesfully âœ…"

# 7. Configure the tunnel
if test "$cloudflared_tunnels" = 'yes'; then
	tunnel_configure
	# verify tunnels works
fi

# letsencrypt cert
# https://certbot.eff.org/instructions?ws=other&os=ubuntufocal
# https://eff-certbot.readthedocs.io/en/stable/using.html
# https://certbot-dns-cloudflare.readthedocs.io/en/stable/
# function letsencrypt() {
# 	sudo snap install core
# 	sudo snap refresh core
# 	sudo apt-get remove certbot

# 	sudo snap install --classic certbot
# 	sudo snap set certbot trust-plugin-with-root=ok
# 	sudo snap install certbot-dns-cloudflare

# 	mkdir -p .secrets/certbot
# 	vim ~/.secrets/certbot/cloudflare.ini

# 	chmod -R 700 ~/.secrets
# 	chmod 600 ~/.secrets/certbot/cloudflare.ini

# 	sudo certbot certonly --dns-cloudflare --dns-cloudflare-credentials ~/.secrets/certbot/cloudflare.ini -d dns.lupton.cc

# 	sudo certbot renew --dry-run
# }

# nofap
source "$DOROTHY/sources/nofap.bash"
nofap "$nofap" 'DNS selection' "$provider"

# update configuration
# update_dorothy_user_config --prefer=local 'dns.bash' -- \
# 	--field='NOFAP' --value="$NOFAP" \
# 	--field='DNS_SERVICE' --value="$DNS_SERVICE" \
# 	--field='DNS_PROVIDER' --value="$DNS_PROVIDER"
