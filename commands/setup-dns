#!/usr/bin/env bash

# Since 2020 iOS 14 and macOS Big Sur v11 have encryption but requires manual .mobileconfig profile installation which expire; as such it is not worth implementing compared to recommending alternative encrypted DNS services on macOS
# https://developer.apple.com/videos/play/wwdc2020/10047/
# https://docs.quad9.net/Setup_Guides/MacOS/Big_Sur_and_later_%28Encrypted%29/
# https://github.com/paulmillr/encrypted-dns

# dot = dns over tls
# doh = dns over https
# sdns = dnscrypt
# quic = preferred

# Cloudflare Warp doesn't yet support any of the platforms I use, so no support in here yet

function setup_dns() (
	source "$DOROTHY/sources/bash.bash"
	__require_array 'mapfile' 'empty'

	# =====================================
	# Compatibility

	# check for support
	if is-wsl; then
		echo-style --code-error1="$0" --error1=' is not applicable on WSL.' >/dev/stderr
		return 19 # ENODEV 19 Operation not supported by device
	elif is-mac; then
		if command-missing -- networksetup; then
			echo-style --code-error1="$0" --error1=' is not applicable on this macOS environment, as ' --code-error1='networksetup' --error1=' was not available.' >/dev/stderr
			return 19 # ENODEV 19 Operation not supported by device
		fi
	elif is-ubuntu; then
		if command-missing -- systemctl resolvectl; then
			echo-style --code-error1="$0" --error1=' is not applicable on this Linux environment, as ' --code-error1='systemctl' ' and/or ' --code-error1='resolvectl' --error1=' were not available.' >/dev/stderr
			return 19 # ENODEV 19 Operation not supported by device
		fi
	else
		echo-style --code-error1="$0" --error1=' is not applicable on this unknown system.' >/dev/stderr
		return 19 # ENODEV 19 Operation not supported by device
	fi

	# ensure the paths are defined, they will be created later
	local path_vars=('BIN_DIR' 'CONF_DIR' 'DATA_DIR' 'LIB_DIR' 'STATE_DIR' 'SERVICE_DIR' 'LOGS_DIR')
	function make_system_paths {
		local values=()
		for path_var in "${path_vars[@]}"; do
			values+=("${!path_var}")
		done
		echo-mkdir --sudo --quiet -- "${values[@]}"
	}
	function __check_env_vars {
		local env_var missing_env_vars=()
		for env_var in "$@"; do
			if test -z "${!env_var-}"; then
				missing_env_vars+=("$env_var")
			fi
		done
		if test "${#missing_env_vars[@]}" -ne 0; then
			echo-style --error1='Missing these requried environment variables: ' --code-error1="${missing_env_vars[*]}" >/dev/stderr
			return 2 # ENOENT 2 No such file or directory
		fi
	}
	__check_env_vars "${path_vars[@]}"

	# =====================================
	# Configuration

	# -------------------------------------
	# Locals

	local \
		service provider \
		ipv4_servers ipv6_servers dot_servers doh_servers sdns_servers quic_servers dnscrypt_names \
		local_ipv4_servers=('127.0.0.1') local_ipv6_servers=('::1') \
		properties=('ipv4_servers' 'ipv6_servers' 'doh_servers' 'dot_servers' 'quic_servers' 'sdns_servers' 'dnscrypt_names')

	# -------------------------------------
	# Fetch Configuration

	source "$DOROTHY/sources/config.sh"

	# dns.bash provides:
	local DNS_SERVICE=''
	local DNS_PROVIDER=''
	local DNS_IPV4_SERVERS=()
	local DNS_IPV6_SERVERS=()
	local DNS_DOH_SERVERS=()
	local DNS_DOT_SERVERS=()
	local DNS_QUIC_SERVERS=()
	local DNS_SDNS_SERVERS=()
	local DNS_DNSCRYPT_NAMES=()
	load_dorothy_config 'dns.bash'

	# -------------------------------------
	# Fetch Services

	local services_id=() services_about=() services_url=()

	# load id
	mapfile -t services_id < <(jq -r '.services | keys[]' "$DOROTHY/config/dns.json")

	# load about
	mapfile -t services_about < <(jq -r '.services[].about' "$DOROTHY/config/dns.json")
	if test "${#services_id[@]}" -ne "${#services_about[@]}"; then
		help 'A DNS service is missing an about, or an about is multiline when it should be single line.'
	fi

	# load url
	mapfile -t services_url < <(jq -r '.services[].url' "$DOROTHY/config/dns.json")
	if test "${#services_id[@]}" -ne "${#services_url[@]}"; then
		help 'A DNS service is missing a URL.'
	fi

	# -------------------------------------
	# Fetch Providers

	local providers_id=() providers_url=() providers_about=()

	# load id
	mapfile -t providers_id < <(jq -r '.providers | keys[]' "$DOROTHY/config/dns.json")

	# load about
	mapfile -t providers_about < <(jq -r '.providers[].about' "$DOROTHY/config/dns.json")
	if test "${#providers_id[@]}" -ne "${#providers_about[@]}"; then
		help 'A DNS provider is missing an about, or an about is multiline when it should be single line.'
	fi

	# load url
	mapfile -t providers_url < <(jq -r '.providers[].url' "$DOROTHY/config/dns.json")
	if test "${#providers_id[@]}" -ne "${#providers_url[@]}"; then
		help 'A DNS provider is missing a URL.'
	fi

	# =====================================
	# Helpers

	function __is_vpn_interface {
		local interface="$1"
		if [[ $interface =~ (nordlynx|vpn|tun|tap) ]]; then # regex fuzzy match
			return 0
		fi
		return 1
	}

	function check_dns_service_installation {
		local id="$1" bin="$2" exists
		exists="$(type -P "$id" || :)"
		if test -n "$exists" -a "$exists" != "$bin"; then
			echo-style --error1='There is a non-standard installation at: ' --code-error1="$exists" $'\n' --error1='Remove it and try again...' >/dev/stderr
			return 75 # EPROGMISMATCH 75 Program version wrong
		fi
	}

	function verify_dns_generic {
		local attempt="${1:-1}" status=0
		nslookup cloudflare.com | echo-trim-padding --stdin || status=$?
		if test "$status" -ne 0; then
			echo-style --notice='DNS service failed to verify, trying again in 10 seconds.'
			sleep 10
			attempt="$((attempt + 1))"
			echo-style --notice="Attempt $attempt..."
			verify_dns_generic "$attempt"
			return
		fi
		return 0
		# `dig -x cloudflare.com` times out for some reason, nslookup works though
		# eval-helper -- what-is-listening dns
		# open 'https://www.cloudflare.com/en-au/ssl/encrypted-sni/'
		# open 'https://1.1.1.1/help'
	}

	function verify_dns_resolvectl {
		local attempt="${1:-1}" status=0
		resolvectl query cloudflare.com --no-pager || status=$?
		resolvectl status --no-pager || status=$?
		resolvectl statistics --no-pager || status=$?
		if test "$status" -ne 0; then
			echo-style --notice='DNS service failed to verify, trying again in 10 seconds.'
			sleep 10
			attempt="$((attempt + 1))"
			echo-style --notice="Attempt $attempt..."
			verify_dns_resolvectl "$attempt"
			return
		fi
		return 0
	}

	# https://support.apple.com/en-au/guide/terminal/apdc6c1077b-5d5d-4d35-9c19-60f2397b2369/mac
	# https://apple.stackexchange.com/a/366388/15131
	# stop the service (if it exists) temporarily
	function dns_service_stop {
		local file="$1" id

		# check if the service file exists
		# which determines if it is even installed
		if test ! -f "$file"; then
			return 0
		fi

		# it does exist
		if is-mac; then
			# get its basename which is the service id
			id="$(fs-filename --basename -- "$file")"
			service-helper --stop -- "$id" || :
		else
			service-helper --stop -- "$id" || :
		fi
	}

	# stops, uninstalls, and deletes the service (if it exists)
	function dns_service_disable {
		local file="$1" id

		# check if the service file exists
		# which determines if it is even installed
		if test ! -f "$file"; then
			return 0
		fi

		# it does exist
		# get its basename which is the service id
		id="$(fs-filename --basename -- "$file")"
		if is-mac; then
			# Usage: launchctl unload <service-path, service-path2, ...>
			# -w      Additionally disables the service such that future load
			#         operations will result in a service which launchd tracks but
			#         cannot be launched or discovered in any way.
			service-helper --disable -- "system/$id" || :
			service-helper --stop -- "$id" || :
			service-helper --unload -- "$file" || :
			dns_service_remove -- "$LOGS_DIR/"*"$id"*.log
		else
			service-helper --disable --stop -- "$id" || :
			service-helper --status -- "$id" || :
		fi
		dns_service_remove --reload -- "$file"
	}

	# loads/installs the service, then enables and starts it
	function dns_service_enable {
		local file="$1" id
		id="$(fs-filename --basename -- "$file")"
		if is-mac; then
			# ensure correct permissions, not sure why
			# but [homebrew services] does this, so doing it here
			sudo-helper -- chown root:admin "$file"
			sudo-helper -- chmod +t "$file"
			service-helper --load -- "$file" || :
			# service-helper  --start -- "system/$id" || :
			service-helper --start -- "$id" || :
			sleep 3
			eval-helper --no-quiet -- cat "$LOGS_DIR/"*"$id"*.log || :
		else
			service-helper --enable --start -- "$id" || :
			service-helper --status -- "$id" || :
		fi
	}

	function dns_service_reload {
		# after service additions/removals
		# systemctl needs to be reloaded apparently
		if command-exists -- systemctl; then
			sudo-helper -- systemctl daemon-reload
			sudo-helper -- systemctl reset-failed
			# ^ use sudo, otherwise prompted via ubuntu user password
		fi
	}

	function dns_service_remove {
		# process
		local item service='' flags=() reload='no' remove_paths=()
		while test "$#" -ne 0; do
			item="$1"
			shift
			case "$item" in
			'--service='*) service="${item#*=}" ;;
			'--negative' | '--positive' | '--bool') flags+=("$item") ;;
			'--no-reload'* | '--reload'*)
				reload="$(get-flag-value --affirmative --fallback="$reload" -- "$item")"
				;;
			'--')
				remove_paths+=("$@")
				shift $#
				break
				;;
			'--'*) help "An unrecognised flag was provided: $item" ;;
			*) remove_paths+=("$item") ;;
			esac
		done

		# add default flag
		if test "${#flags[@]}" -eq 0; then
			flags+=('--positive')
		fi

		# service
		if test -n "$service"; then
			# remove common paths (files, and directories)
			remove_paths+=(
				# custom
				"$BIN_DIR/$service"
				"$CONF_DIR/$service"
				"$DATA_DIR/$service"
				"$LIB_DIR/$service"

				# xdg
				"$XDG_BIN_HOME/$service"
				"$XDG_CONFIG_HOME/$service"
				"$XDG_DATA_HOME/$service"
				"$XDG_STATE_HOME/$service"

				# standard
				"/usr/local/bin/$service"
				"/usr/local/etc/$service"
				"/usr/local/share/$service"
				"/usr/local/lib/$service"

				# services
				"$SERVICE_DIR/"*"$service"*
				/Library/LaunchAgents/*"$service"*   # user
				/Library/LaunchDaemons/*"$service"*  # everyone
				/etc/init.d/*"$service"*             # alt
				/usr/lib/systemd/system/*"$service"* # alt
				/etc/systemd/system/*"$service"*     # desired

				# logs
				"$LOGS_DIR/"*"$service"*.log
			)
		fi

		# remove files
		local remove_path question details removed='no'
		for remove_path in "${remove_paths[@]}"; do
			if is-present -- "$remove_path"; then
				question="Remove $(echo-style --bold="$remove_path")?"
				details="$(
					echo-style --dim="$(
						ls -la "$remove_path"
					)"
				)"
				if confirm "${flags[@]}" --ppid=$$ -- "$question" "$details"; then
					fs-rm --quiet --no-confirm --sudo -- "$remove_path"
					removed='yes'
				fi
			fi
		done

		# reload?
		if test "$reload" = 'yes' -a "$removed" = 'yes'; then
			dns_service_reload
		fi
	}

	# =====================================
	# DNS Service: System DNS

	function system_dns__configure {
		# determine servers and action
		local servers action action_title
		action="$1"
		action_title="$(__uppercase_first_letter "$action")"
		if test "$action" = 'enable'; then
			servers=(
				"${ipv4_servers[@]}"
				"${ipv6_servers[@]}"
			)
		else
			servers=(
				"${local_ipv4_servers[@]}"
				"${local_ipv6_servers[@]}"
			)
		fi

		# handle the os changes
		if is-mac; then
			# -------------------------------------
			# DNS Service: macOS
			# https://support.apple.com/en-us/HT202516

			# log
			echo-style --h1="Configure and $action_title $system_dns__title"

			# apply
			local interface
			network-interface list | while read -r interface; do
				sudo-helper -- networksetup -setdnsservers "$interface" "${servers[@]}"
			done

			# log
			echo-style --g1="Configure and $action_title $system_dns__title"
		else
			# -------------------------------------
			# DNS Service: Systemd (aka systemd-resolved, systemd-resolve, resolvectl, resolv)
			# https://gist.github.com/balupton/f4aa448731d6b1bdf505c10078b9a8ad#file-resolv-bash

			# https://wiki.archlinux.org/title/Systemd-resolved
			# https://man.archlinux.org/man/systemd-resolved.8#/ETC/RESOLV.CONF

			# /run/systemd/resolve/stub-resolv.conf
			# ^ lists the 127.0.0.53 DNS stub as the only DNS server.
			# ^ It also contains a list of search domains that are in use by systemd-resolved.

			# /usr/lib/systemd/resolv.conf
			# ^ lists the 127.0.0.53 DNS stub as only DNS server.
			# ^ This file does not contain any search domains.

			# /run/systemd/resolve/resolv.conf
			# ^ containing information about all known DNS servers
			# ^ it does not know a concept of per-interface DNS servers and hence only contains system-wide DNS server definitions.

			# /etc/systemd/resolved.conf
			# ^ The DNS servers contacted are determined from the global settings in

			# /etc/systemd/network/*.network
			# ^ er-link static settings

			# /etc/resolv.conf
			# ^ used by everything

			#  To improve compatibility, /etc/resolv.conf is read in order to discover configured system DNS servers, but only if it is not a symlink to /run/systemd/resolve/stub-resolv.conf, /usr/lib/systemd/resolv.conf or /run/systemd/resolve/resolv.conf (see below).

			# log
			echo-style --h1="Configure and $action_title $system_dns__title"

			# dump the data for where we are
			sudo-helper -- resolvectl status --no-pager || :

			# if there is nordvpn, we have to disconnect
			if command-exists -- nordvpn; then
				nordvpn set autoconnect off || :
				nordvpn set killswitch off || :
				nordvpn set firewall off || :
				nordvpn disconnect || :
				sleep 3
			fi

			# temporarily disable these services while we redo the configuration files
			# https://wiki.archlinux.org/title/systemd-networkd
			# resolved handles dns, networkd handles network interfaces
			service-helper --stop -- systemd-networkd systemd-resolved || :

			# allow modifications in case something has locked it
			# for some reason this can fail
			sudo-helper -- chattr -i /etc/resolv.conf || :

			# make life simple, using only /etc/resolv.conf
			# https://www.freedesktop.org/software/systemd/man/resolved.conf.html
			fs-rm --quiet --no-confirm --sudo -- \
				/run/systemd/resolve/stub-resolv.conf \
				/usr/lib/systemd/resolv.conf \
				/run/systemd/resolve/resolv.conf \
				/etc/systemd/resolved.conf \
				/etc/resolv.conf

			# prepare config for file, and for interfaces
			local Domains DNSOverTLS DNSSEC
			Domains='~.'
			if test "${#dot_servers[@]}" -ne 0; then
				DNSOverTLS='true'
				# DNSSEC='true' <= fails on cloudflare teams, perhaps more
				DNSSEC='allow-downgrade'
			else
				DNSOverTLS='opportunistic'
				DNSSEC='allow-downgrade'
			fi

			# apply specific config
			if test "$action" = 'enable'; then
				# using systemd, the initial lines are for ping/nslookup/etc, the [Resolve] lines are for systemd-resolve
				sudo-helper -- tee /etc/resolv.conf <<-EOF
					nameserver 127.0.0.53
					options edns0 trust-ad
					search .

					[Resolve]
					DNS=${servers[*]}
					Domains=$Domains
					DNSSEC=$DNSSEC
					DNSOverTLS=$DNSOverTLS
				EOF
			else
				# use custom service
				sudo-helper -- tee /etc/resolv.conf <<-EOF
					nameserver ${servers[0]}
					options edns0 trust-ad
				EOF
			fi

			# we have redone the configuration files so we must now restart the services
			# and ensure that are correctly enabled in case they weren't
			# which could happen via vpns or another dns service
			service-helper --enable --start -- systemd-resolved systemd-networkd || :

			# flush their caches
			sudo-helper -- resolvectl flush-caches --no-pager || :
			sudo-helper -- resolvectl reset-server-features --no-pager || :

			# apply the changes to their interfaces
			mapfile -t interfaces < <(network-interface list)
			if is-array-empty -- "${interfaces[@]}"; then
				echo-style --error='No interfaces were found.' >/dev/stderr
				return 1
			fi
			local default_route
			for interface in "${interfaces[@]}"; do
				# skip vpn interfaces
				if __is_vpn_interface "$interface"; then
					echo-style --dim="Skipping VPN interface: $interface"
					continue
				fi

				# save default route
				# as nordvpn needs its interface as the default route
				if resolvectl default-route "$interface" | grep --quiet --fixed-strings --regexp=yes; then
					default_route='yes'
				else
					default_route='no'
				fi

				# remove other changes
				sudo-helper -- resolvectl revert "$interface" || continue

				# apply intended changes
				sudo-helper -- resolvectl default-route "$interface" "$default_route"
				sudo-helper -- resolvectl domain "$interface" "$Domains"
				sudo-helper -- resolvectl dnssec "$interface" "$DNSSEC"
				sudo-helper -- resolvectl dnsovertls "$interface" "$DNSOverTLS"
				sudo-helper -- resolvectl dns "$interface" "${servers[@]}"

				# reboot the interface if it isn't a vpn
				sleep 3
				network-interface restart "$interface"
			done

			# dump the status now that we are done
			sudo-helper -- resolvectl status --no-pager || :

			# if there is nordvpn, we have to reconnect
			if command-exists -- nordvpn; then
				if test "$option_vpn_reconnect" = 'yes' || (test -z "$option_vpn_reconnect" && confirm --linger --positive --ppid="$$" -- 'Reconnect to NordVPN?'); then
					if nordvpn connect; then
						nordvpn set firewall on || :
						nordvpn set killswitch on || :
						nordvpn set autoconnect on || :
					fi
				fi
			fi

			# now that it is all done, enable or disable
			if test "$action" = 'enable'; then
				# verify
				verify_dns_resolvectl
			else
				service-helper --disable --stop -- systemd-resolved
			fi

			# after significant systemd changes, it may need to be reloaded
			# sudo-helper -- systemctl daemon-reload
			# sudo-helper -- systemctl reset-failed

			# log
			echo-style --g1="Configure and $action_title $system_dns__title"
		fi
	}

	# =====================================
	# DNS Services

	local arch
	arch="$(get-arch)"

	local system_dns__title

	local adguard_home__asset_url adguard_home__asset_filter adguard_home__archive_filter='AdGuardHome/AdGuardHome'
	local adguard_home__title="AdGuard Home" adguard_home__bin_id='AdGuardHome'
	local adguard_home__bin_file="$BIN_DIR/$adguard_home__bin_id"
	local adguard_home__conf_dir="$CONF_DIR/$adguard_home__bin_id"
	local adguard_home__conf_file="$adguard_home__conf_dir/$adguard_home__bin_id.yaml"
	local adguard_home__data_dir="$DATA_DIR/$adguard_home__bin_id"
	local adguard_home__state_dir="$STATE_DIR/$adguard_home__bin_id"
	local adguard_home__state_pid_file="$adguard_home__state_dir/$adguard_home__bin_id.pid"
	local adguard_home__state_log_file="$adguard_home__state_dir/$adguard_home__bin_id.log"
	local adguard_home__bin_cmd=(
		# https://github.com/AdguardTeam/AdGuardHome/wiki/Configuration#command-line
		"$adguard_home__bin_file"
		'--config' "$adguard_home__conf_file"
		'--work-dir' "$adguard_home__data_dir"
		'--pidfile' "$adguard_home__state_pid_file"
		'--logfile' "$adguard_home__state_log_file"
	)
	local adguard_home__service_file

	local cloudflared__slug='cloudflare/cloudflared' cloudflared__asset_filter cloudflared__archive_filter=''
	local cloudflared__title='Cloudflared' cloudflared__bin_id='cloudflared' cloudflared__brew_id='cloudflared'
	local cloudflared__bin_file="$BIN_DIR/$cloudflared__bin_id"
	local cloudflared__proxy_service_id cloudflared__proxy_service_file

	local dnscrypt_proxy__slug='DNSCrypt/dnscrypt-proxy' dnscrypt_proxy__asset_filter dnscrypt_proxy__archive_filter='**/dnscrypt-proxy'
	local dnscrypt_proxy__title='DNSCrypt Proxy' dnscrypt_proxy__bin_id='dnscrypt-proxy' dnscrypt_proxy__brew_id='dnscrypt-proxy'
	local dnscrypt_proxy__bin_file="${BIN_DIR}/$dnscrypt_proxy__bin_id"
	local dnscrypt_proxy__conf_dir="${CONF_DIR}/$dnscrypt_proxy__bin_id"
	local dnscrypt_proxy__conf_file="$dnscrypt_proxy__conf_dir/$dnscrypt_proxy__bin_id.toml"
	local dnscrypt_proxy__bin_cmd=(
		"$dnscrypt_proxy__bin_file"
		'-config' "$dnscrypt_proxy__conf_file"
	)
	local dnscrypt_proxy__service_file

	if is-mac; then
		# launchctl
		system_dns__title='System DNS on macOS'
		adguard_home__service_file="$SERVICE_DIR/$adguard_home__bin_id.plist"
		cloudflared__archive_filter='cloudflared'
		cloudflared__proxy_service_id='com.cloudflare.cloudflared-proxy'
		cloudflared__proxy_service_file="$SERVICE_DIR/$cloudflared__proxy_service_id.plist"
		dnscrypt_proxy__service_file="$SERVICE_DIR/$dnscrypt_proxy__bin_id.plist"
		if test "$arch" = 'a64'; then
			adguard_home__asset_filter='AdGuardHome_darwin_arm64.zip'
			cloudflared__asset_filter='cloudflared-darwin-arm64.tgz'
			dnscrypt_proxy__asset_filter='dnscrypt-proxy-macos_arm64' # ... .zip
		elif test "$arch" = 'x64'; then
			adguard_home__asset_filter='AdGuardHome_darwin_amd64.zip'
			cloudflared__asset_filter='cloudflared-darwin-amd64.tgz'
			dnscrypt_proxy__asset_filter='dnscrypt-proxy-macos_x86_64' # ... .zip
		fi
	elif is-linux; then
		# systemctl / resolvectl / systemd-resolved
		system_dns__title='System DNS on Linux'
		adguard_home__service_file="$SERVICE_DIR/$adguard_home__bin_id.service"
		cloudflared__proxy_service_id='cloudflared-proxy'
		cloudflared__proxy_service_file="$SERVICE_DIR/$cloudflared__proxy_service_id.service"
		dnscrypt_proxy__service_file="$SERVICE_DIR/$dnscrypt_proxy__bin_id.service"
		if test "$arch" = 'a64'; then
			adguard_home__asset_filter='AdGuardHome_linux_arm64.tar.gz'
			cloudflared__asset_filter='cloudflared-linux-arm64'
			dnscrypt_proxy__asset_filter='dnscrypt-proxy-linux_arm64' # ... .tar.gz
		elif test "$arch" = 'x64'; then
			adguard_home__asset_filter='AdGuardHome_linux_amd64.tar.gz'
			cloudflared__asset_filter='cloudflared-linux-amd64'
			dnscrypt_proxy__asset_filter='dnscrypt-proxy-linux_x86_64' # ... .tar.gz
		elif test "$arch" = 'x32'; then
			adguard_home__asset_filter='AdGuardHome_linux_386.tar.gz'
			cloudflared__asset_filter='cloudflared-linux-386'
			dnscrypt_proxy__asset_filter='dnscrypt-proxy-linux_i386' # ... .tar.gz
		fi
	else
		echo-error 'Unknown Operating System'
		return 19 # ENODEV 19 Operation not supported by device
	fi
	adguard_home__asset_url="https://static.adguard.com/adguardhome/release/${adguard_home__asset_filter-}"

	function die_incompatible_dns_service {
		local service_title="${item#*=}"
		echo-style --error1='This platform architecture ' --code-error1="$arch" --error1=' does not yet support: ' --code-error1="$service_title" >/dev/stderr
		return 19 # ENODEV 19 Operation not supported by device
	}

	# =====================================
	# DNS Service: AdGuard Home

	function __adguard_home__available {
		test -n "${adguard_home__asset_filter-}"
	}
	function __adguard_home__installed {
		test -x "$adguard_home__bin_file"
	}
	function adguard_home__install {
		local action action_title temp__bin_file
		action='install'
		if __adguard_home__installed; then
			action='upgrade'
		fi
		action_title="$(__uppercase_first_letter "$action")"

		# check
		if ! __adguard_home__available; then
			die_incompatible_dns_service "$adguard_home__title"
			return $?
		fi

		# log
		echo-style --h1="$action_title $adguard_home__title"

		# check we are the right one
		check_dns_service_installation "$adguard_home__bin_id" "$adguard_home__bin_file"

		# ensure directories
		sudo-helper -- mkdir -p "$adguard_home__conf_dir" "$adguard_home__data_dir" "$adguard_home__state_dir"

		# download the installer, prior to disabling
		temp__bin_file="$(
			fs-temp \
				--directory='setup-dns' \
				--file='AdGuardHome'
		)"
		down "$adguard_home__asset_url" \
			--archive-glob="$adguard_home__archive_filter" \
			--filepath="$temp__bin_file" || :
		# ^ allow failures, in case dns is botched

		# if downloaded, stop and install
		if test -f "$temp__bin_file"; then
			if test -x "$adguard_home__bin_file"; then
				# only tell prior cmd to stop if the prior cmd exists
				sudo-helper -- "${adguard_home__bin_cmd[@]}" --service stop || :
			fi
			sudo-helper -- mv "$temp__bin_file" "$adguard_home__bin_file" || :
			sudo-helper -- chmod +x "$adguard_home__bin_file" || :
			# ^ allow failure,s as we will check this later
		fi

		# confirm success
		if test -x "$adguard_home__bin_file"; then
			echo-style --g1="$action_title $adguard_home__title"
		else
			echo-style --error="Unable to make executable: $adguard_home__bin_file" >/dev/stderr
			echo-style --e1="$action_title $adguard_home__title"
			return 1
		fi
	}
	function adguard_home__uninstall {
		# check
		if ! __adguard_home__installed; then
			return 0
		fi

		# log
		echo-style --h1="Uninstall $adguard_home__title"

		# stop and uninstall the service
		sudo-helper -- "${adguard_home__bin_cmd[@]}" --service stop || :
		sudo-helper -- "${adguard_home__bin_cmd[@]}" --service uninstall || :

		# ensure adguard home has stopped
		killall "$adguard_home__bin_id" || :

		# clean it all up
		dns_service_remove --reload --service="$adguard_home__bin_id" -- "$adguard_home__bin_file" "$adguard_home__conf_dir" "$adguard_home__data_dir" "$adguard_home__state_dir" "$adguard_home__service_file"

		# log
		echo-style --g1="Uninstall $adguard_home__title"
	}
	function adguard_home__configure {
		local action action_title upstream_servers server pattern replace
		action="$1" # enable/disable
		action_title="$(__uppercase_first_letter "$action")"

		# check
		if ! __adguard_home__installed; then
			return 0
		fi

		# log
		echo-style --h1="Configure and $action_title $adguard_home__title"

		# this is here, because we need to seed the configuration file before we can do changes to it
		if test ! -f "$adguard_home__conf_file" -a "$action" = 'enable'; then
			sudo-helper -- "${adguard_home__bin_cmd[@]}" --service install || :
			sudo-helper -- "${adguard_home__bin_cmd[@]}" --service start || :
			confirm --ppid=$$ -- "Press <enter> once you have completed the initial $adguard_home__title setup..."
		fi

		# stop before config update
		sudo-helper -- "${adguard_home__bin_cmd[@]}" --service stop || :

		# prepare desired providers
		upstream_servers=(
			"${dot_servers[@]}"
			"${doh_servers[@]}"
			"${quic_servers[@]}"
			"${sdns_servers[@]}"
		)
		if test "${#upstream_servers[@]}" -eq 0; then
			upstream_servers=(
				"${ipv4_servers[@]}"
				"${ipv6_servers[@]}"
			)
		fi

		# update the configuration with the new upstreams
		pattern='  upstream_dns:\n(  - .+\n)+'
		replace=$'  upstream_dns:\n'
		for server in "${upstream_servers[@]}"; do
			replace+="  - $server"$'\n'
		done
		sudo-helper --inherit \
			-- sd "$pattern" "$replace" "$adguard_home__conf_file"
		sudo-helper -- \
			"${adguard_home__bin_cmd[@]}" --check-config

		# enable or disable
		# Service control action: status, install, uninstall, start, stop, restart, reload (configuration).
		if test "$action" = 'enable'; then
			sudo-helper -- "${adguard_home__bin_cmd[@]}" --service install || :
			sudo-helper -- "${adguard_home__bin_cmd[@]}" --service reload || sudo-helper -- "${adguard_home__bin_cmd[@]}" --service start || :
			sudo-helper -- "${adguard_home__bin_cmd[@]}" --service status || :
		else
			sudo-helper -- "${adguard_home__bin_cmd[@]}" --service uninstall || :
		fi

		# log
		echo-style --g1="Configure and $action_title $adguard_home__title"
	}

	# =====================================
	# DNS Service: Cloudflared Proxy

	function __cloudflared__available {
		test -n "${cloudflared__asset_filter-}"
	}
	function __cloudflared__installed {
		test -x "$cloudflared__bin_file"
	}
	function cloudflared__install {
		local action action_title temp__bin_file
		action='install' # install/upgrade
		if __cloudflared__installed; then
			action='upgrade'
		fi
		action_title="$(__uppercase_first_letter "$action")"

		# check
		if ! __cloudflared__available; then
			die_incompatible_dns_service "$cloudflared__title"
			return $?
		fi

		# log
		echo-style --h1="$action_title $cloudflared__title"

		# download the upgrade, prior to disabling
		# setup-util --cli=cloudflared APT_KEY='https://pkg.cloudflare.com/cloudflare-main.gpg' APT_REPO='deb [arch={ARCH} signed-by={KEY}] https://pkg.cloudflare.com/cloudflared jammy main' APT='cloudflared'
		# setup-util --cli=cloudflared APT_KEY='https://pkg.cloudflare.com/cloudflare-main.gpg' APT_REPO='deb [arch={ARCH} signed-by={KEY}] https://pkg.cloudflare.com/cloudflared {RELEASE} main' APT='cloudflared'
		temp__bin_file="$(
			fs-temp \
				--directory='setup-dns' \
				--file="$cloudflared__bin_id"
		)"
		github-download \
			--slug="$cloudflared__slug" \
			--latest \
			--asset-regexp="$cloudflared__asset_filter" \
			--archive-glob="$cloudflared__archive_filter" \
			--filepath="$temp__bin_file"

		# disable/uninstall the service if it exists
		dns_service_disable "$cloudflared__proxy_service_file"

		# don't use brew for this, as we want complete control
		if is-brew; then
			brew uninstall "$cloudflared__brew_id" &>/dev/null || :
		fi
		check_dns_service_installation "$cloudflared__bin_id" "$cloudflared__bin_file"

		# if downloaded, stop and install
		if test -f "$temp__bin_file"; then
			dns_service_stop "$cloudflared__proxy_service_file"
			sudo-helper -- mv "$temp__bin_file" "$cloudflared__bin_file"
			sudo-helper -- chmod +x "$cloudflared__bin_file"
		fi

		# confirm success
		if test -x "$cloudflared__bin_file"; then
			echo-style --g1="$action_title $cloudflared__title"
		else
			echo-style --error="Unable to make executable: $cloudflared__bin_file" >/dev/stderr
			echo-style --e1="$action_title $cloudflared__title"
			return 1
		fi
	}
	function cloudflared__uninstall {
		# check
		if ! __cloudflared__installed; then
			return 0
		fi

		# log
		echo-style --h1="Uninstall $cloudflared__title"

		# stop, disable, uninstall the service if it exists
		dns_service_disable "$cloudflared__proxy_service_file"

		# if we are using tunnels
		if test "${#CLOUDFLARED__TUNNELS[@]}" -ne 0; then
			# only remove the service file
			# as tunnels uses the same binary
			dns_service_remove --reload -- "$cloudflared__proxy_service_file"
		else
			# ensure everything related to the proxy is removed
			dns_service_remove --reload --service="$cloudflared__bin_id" -- "$cloudflared__proxy_service_file"
		fi

		# log
		echo-style --g1="Uninstall $cloudflared__title"
	}
	function cloudflared__configure {
		local action action_title upstream_servers upstream_section upstream_args server
		action="$1" # enable/disable
		action_title="$(__uppercase_first_letter "$action")"
		upstream_section=''
		upstream_args=''

		# check
		if ! __cloudflared__installed; then
			return 0
		fi

		# log
		echo-style --h1="Configure and $action_title $cloudflared__title"

		# check
		check_dns_service_installation "$cloudflared__bin_id" "$cloudflared__bin_file"

		# stop, disable, uninstall the old service if it exists
		dns_service_disable "$cloudflared__proxy_service_file"

		# only update the configuration, if we are [enable] action
		# as the SERVICE IS THE CONFIGURATION for [cloudflared proxy-dns]
		# as it doesn't support a configuration file
		# so we have to configure it via CLI args in the service definition
		if test "$action" = 'enable'; then
			# prepare upstreams (despite docs, cloudflared doesn't support tls)
			upstream_servers=(
				"${doh_servers[@]}"
				"${quic_servers[@]}"
			)
			if test "${#upstream_servers[@]}" -eq 0; then
				upstream_servers=(
					"${ipv4_servers[@]}"
					"${ipv6_servers[@]}"
				)
			fi

			# configure service with the upstreams
			if is-mac; then
				# generate upstreams
				for server in "${upstream_servers[@]}"; do
					upstream_section+=$'\n'"			<string>--upstream</string>"
					upstream_section+=$'\n'"			<string>$server</string>"
				done

				# create service with custom upstreams
				# <string>--address</string>
				# <string>0.0.0.0</string>
				sudo-helper -- tee "$cloudflared__proxy_service_file" >/dev/null <<EOF
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
	<dict>
		<key>Label</key>
		<string>${cloudflared__proxy_service_id}</string>
		<key>ProgramArguments</key>
		<array>
			<string>${cloudflared__bin_file}</string>
			<string>proxy-dns</string>${upstream_section}
		</array>
		<key>RunAtLoad</key>
		<true/>
		<key>StandardOutPath</key>
		<string>${LOGS_DIR}/${cloudflared__proxy_service_id}.out.log</string>
		<key>StandardErrorPath</key>
		<string>${LOGS_DIR}/${cloudflared__proxy_service_id}.err.log</string>
		<key>KeepAlive</key>
		<dict>
			<key>SuccessfulExit</key>
			<false/>
		</dict>
		<key>ThrottleInterval</key>
		<integer>5</integer>
	</dict>
</plist>
EOF

			else
				# generate upstreams
				for server in "${upstream_servers[@]}"; do
					upstream_args+=" --upstream $(echo-quote -- "$server")"
				done

				# create service with custom upstreams
				sudo-helper -- tee "$cloudflared__proxy_service_file" >/dev/null <<-EOF
					[Unit]
					Description=${cloudflared__proxy_service_id}
					Wants=network-online.target nss-lookup.target
					Before=nss-lookup.target

					[Service]
					AmbientCapabilities=CAP_NET_BIND_SERVICE
					CapabilityBoundingSet=CAP_NET_BIND_SERVICE
					DynamicUser=yes
					ExecStart=${cloudflared__bin_file} proxy-dns --address 0.0.0.0 ${upstream_args}

					[Install]
					WantedBy=multi-user.target
				EOF
			fi

			# enable the service
			dns_service_enable "$cloudflared__proxy_service_file"
		fi

		# log
		echo-style --g1="Configure and $action_title $cloudflared__title"
	}

	# =====================================
	# DNS Service: DNSCrypt Proxy
	# https://github.com/DNSCrypt/dnscrypt-proxy/wiki/Installation-linux

	function __dnscrypt_proxy__available {
		test -n "${dnscrypt_proxy__asset_filter-}"
	}
	function __dnscrypt_proxy__installed {
		test -x "$dnscrypt_proxy__bin_file"
	}
	function dnscrypt_proxy__install {
		local action action_title temp__bin_file
		action='install'
		if __dnscrypt_proxy__installed; then
			action='upgrade'
		fi
		action_title="$(__uppercase_first_letter "$action")"

		# check
		if ! __dnscrypt_proxy__available; then
			die_incompatible_dns_service "$dnscrypt_proxy__title"
			return $?
		fi

		# prepare and log
		echo-style --h1="$action_title $dnscrypt_proxy__title"

		# download the upgrade, prior to disabling
		temp__bin_file="$(
			fs-temp \
				--directory='setup-dns' \
				--file="$dnscrypt_proxy__bin_id"
		)"
		github-download \
			--slug="$dnscrypt_proxy__slug" \
			--latest \
			--asset-regexp="$dnscrypt_proxy__asset_filter" \
			--archive-glob="$dnscrypt_proxy__archive_filter" \
			--filepath="$temp__bin_file"

		# don't use brew for this, as we want complete control
		if is-brew; then
			brew uninstall "$dnscrypt_proxy__brew_id" &>/dev/null || :
		fi
		check_dns_service_installation "$dnscrypt_proxy__bin_id" "$dnscrypt_proxy__bin_file"

		# ensure directories
		sudo-helper -- mkdir -p "$dnscrypt_proxy__conf_dir"

		# if downloaded, stop and install
		if test -f "$temp__bin_file"; then
			if test -x "$dnscrypt_proxy__bin_file"; then
				# only tell prior cmd to stop if the prior cmd exists
				sudo-helper -- "${dnscrypt_proxy__bin_cmd[@]}" --service stop || :
			fi
			sudo-helper -- mv "$temp__bin_file" "$dnscrypt_proxy__bin_file" || :
			sudo-helper -- chmod +x "$dnscrypt_proxy__bin_file" || :
			# ^ allow failure,s as we will check this later
		fi

		# download the configuration if it doesn't exist
		# https://github.com/DNSCrypt/dnscrypt-proxy/blob/master/dnscrypt-proxy/example-dnscrypt-proxy.toml
		if test ! -f "$dnscrypt_proxy__conf_file"; then
			temp_conf_file="$(
				fs-temp \
					--directory='setup-dns' \
					--file='dnscrypt-proxy.toml'
			)"
			github-download \
				--slug='DNSCrypt/dnscrypt-proxy' \
				--head \
				--pathname='dnscrypt-proxy/example-dnscrypt-proxy.toml' \
				--filepath="$temp_conf_file"
			sudo-helper -- mv "$temp_conf_file" "$dnscrypt_proxy__conf_file"
		fi

		# confirm success
		if test -x "$dnscrypt_proxy__bin_file"; then
			echo-style --g1="$action_title $dnscrypt_proxy__title"
		else
			echo-style --error="Unable to make executable: $dnscrypt_proxy__bin_file" >/dev/stderr
			echo-style --e1="$action_title $dnscrypt_proxy__title"
			return 1
		fi
	}
	function dnscrypt_proxy__uninstall {
		# check
		if ! __dnscrypt_proxy__installed; then
			return 0
		fi

		# log
		echo-style --h1="Uninstall $dnscrypt_proxy__title"

		# stop and uninstall the service
		sudo-helper -- "${dnscrypt_proxy__bin_cmd[@]}" --service stop || :
		sudo-helper -- "${dnscrypt_proxy__bin_cmd[@]}" --service uninstall || :

		# ensure adguard home has stopped
		killall "$dnscrypt_proxy__bin_id" || :

		# clean it all up
		dns_service_remove --reload --service="$dnscrypt_proxy__bin_id" -- "$dnscrypt_proxy__bin_file" "$dnscrypt_proxy__conf_dir" "$dnscrypt_proxy__service_file"

		# log
		echo-style --g1="Uninstall $dnscrypt_proxy__title"
	}
	function dnscrypt_proxy__configure {
		local action action_title temp_conf_file dnscrypt_proxy__options
		action="$1" # enable/disable
		action_title="$(__uppercase_first_letter "$action")"

		# check
		if ! __dnscrypt_proxy__installed; then
			return 0
		fi

		# log
		echo-style --h1="Configure and $action_title $dnscrypt_proxy__title"

		# if the configuration doesn't exist
		if test ! -f "$dnscrypt_proxy__conf_file"; then
			# then give up, as the internet is disabled in this mode
			# as we deactivated the prior service
			echo-style --error="Missing configuration file: $dnscrypt_proxy__conf_file" >/dev/stderr
			echo-style --warning='You should attempt reinstallation then try again.' >/dev/stderr
			echo-style --e1="Configure and $action_title $dnscrypt_proxy__title"
		fi

		# if [dnscrypt_names] is empty, get the user to decide
		# but only go through the trouble if we are actually intending
		# to use dns-crypt
		if test "${#dnscrypt_names[@]}" -eq 0 -a "$action" = 'enable'; then
			mapfile -t dnscrypt_proxy__options < <(
				# trunk-ignore(shellcheck/SC2016)
				fetch 'https://download.dnscrypt.info/resolvers-list/v2/public-resolvers.md' | echo-regexp -ongm --regexp='^## (.+)$' --replace='$1'
			)
			mapfile -t dnscrypt_names < <(
				choose --required --multi --question="Which DNSCrypt Server names do you wish to use?" --
				"${dnscrypt_proxy__options[@]}"
			)
		fi

		# stop the service if it is installed, before config update
		if test -f "$dnscrypt_proxy__service_file"; then
			sudo-helper -- "${dnscrypt_proxy__bin_cmd[@]}" --service stop || :
			sudo-helper -- "${dnscrypt_proxy__bin_cmd[@]}" --service disable || :
		fi

		# update the configuration with the new [dnscrypt_names], if any
		if test "${#dnscrypt_names[@]}" -ne 0; then
			sudo-helper --inherit \
				-- config-helper --file="$dnscrypt_proxy__conf_file" -- \
				--field='ipv4_servers' --no-quote --value='true' \
				--field='ipv6_servers' --no-quote --value='true' \
				--field='dnscrypt_servers' --no-quote --value='true' \
				--field='doh_servers' --no-quote --value='true' \
				--field='server_names' --no-quote --value="[$(
					echo-join ', ' -- "${dnscrypt_names[@]@Q}"
				)]"
			sudo-helper -- "${dnscrypt_proxy__bin_cmd[@]}" --check -config "$dnscrypt_proxy__conf_file"
		fi

		# enable or disable
		if test "$action" = 'enable'; then
			sudo-helper -- "${dnscrypt_proxy__bin_cmd[@]}" --service install || :
			sudo-helper -- "${dnscrypt_proxy__bin_cmd[@]}" --service enable || :
			sudo-helper -- "${dnscrypt_proxy__bin_cmd[@]}" --service start || :
		elif test -f "$dnscrypt_proxy__service_file"; then
			sudo-helper -- "${dnscrypt_proxy__bin_cmd[@]}" --service stop || :
			sudo-helper -- "${dnscrypt_proxy__bin_cmd[@]}" --service disable || :
			sudo-helper -- "${dnscrypt_proxy__bin_cmd[@]}" --service uninstall || :
		fi

		# log
		echo-style --g1="Configure and $action_title $dnscrypt_proxy__title"
	}

	# ---------------------------------
	# Availability and Installation Detection

	local available_services_id=() installed_services_id=()

	function __check_dns_service_helpers {
		local id="$1" fn_id
		fn_id="${id//-/_}" # replace dashes with underscores
		local fn fns=(
			"__${fn_id}__available"
			"__${fn_id}__installed"
			"${fn_id}__install"
			"${fn_id}__uninstall"
			"${fn_id}__configure"
		)
		for fn in "${fns[@]}"; do
			command -v "$fn" >/dev/null || {
				echo-style --error1='The DNS service ' --code-error1="$fn_id" --error1=' is missing its helper: ' --code-error1="$fn" >/dev/stderr
				return 1
			}
		done
		return 0
	}

	function fetch_available_and_installed_services {
		local id fn_id
		for id in "${services_id[@]}"; do
			__check_dns_service_helpers "$id"
			fn_id="${id//-/_}"               # replace dashes with underscores
			if "__${fn_id}__available"; then # eval
				available_services_id+=("$id")
				if "__${fn_id}__installed"; then # eval
					installed_services_id+=("$id")
				fi
			fi
		done
	}

	fetch_available_and_installed_services

	# =====================================
	# Arguments

	# @todo move this later so that it also outputs providers
	function help {
		cat <<-EOF >/dev/stderr
			ABOUT:
			Setup the DNS service for your system.

			USAGE:
			setup-dns [...options] <service>

			OPTIONS:
			--install | --uninstall
			    Install or uninstall the service, defaults to --install.

			--enable | --disable
			    Enable or disable the service, defaults to --enable.

			--installed | --uninstalled
			    Check if the service is installed or uninstalled.

			SERVICES:
			system
			$(__print_lines "${services_id[@]}")

			AVAILABLE SERVICES:
			system
			$(__print_lines "${available_services_id[@]}")

			INSTALLED SERVICES:
			system
			$(__print_lines "${installed_services_id[@]}")

			PROVIDERS:
			$(__print_lines "${providers_id[@]}")

			CONFIGURATION:
			DNS_SERVICE=$(echo-quote -- "$DNS_SERVICE")
			DNS_PROVIDER=$(echo-quote -- "$DNS_PROVIDER")
			DNS_IPV4_SERVERS=($(echo-quote -- "${DNS_IPV4_SERVERS[@]}" | echo-join --stdin))
			DNS_IPV6_SERVERS=($(echo-quote -- "${DNS_IPV6_SERVERS[@]}" | echo-join --stdin))
			DNS_DOH_SERVERS=($(echo-quote -- "${DNS_DOH_SERVERS[@]}" | echo-join --stdin))
			DNS_DOT_SERVERS=($(echo-quote -- "${DNS_DOT_SERVERS[@]}" | echo-join --stdin))
			DNS_QUIC_SERVERS=($(echo-quote -- "${DNS_QUIC_SERVERS[@]}" | echo-join --stdin))
			DNS_SDNS_SERVERS=($(echo-quote -- "${DNS_SDNS_SERVERS[@]}" | echo-join --stdin))
			DNS_DNSCRYPT_NAMES=($(echo-quote -- "${DNS_DNSCRYPT_NAMES[@]}" | echo-join --stdin))

			CONFIGURATION FILES:
			dns.bash
			dns.json
		EOF
		if test "$#" -ne 0; then
			echo-error "$@"
		fi
		return 22 # EINVAL 22 Invalid argument
	}

	# process
	local item option_vpn_reconnect='' option_service='' option_provider='' option_ipv4_servers=() option_ipv6_servers=() option_doh_servers=() option_dot_servers=() option_quic_servers=() option_sdns_servers=() option_dnscrypt_names=()
	while test "$#" -ne 0; do
		item="$1"
		shift
		case "$item" in
		'--help' | '-h') help ;;
		'--no-vpn-reconnect'* | '--vpn-reconnect'*)
			option_vpn_reconnect="$(get-flag-value --affirmative --fallback="$option_vpn_reconnect" -- "$item")"
			;;
		'--service='*) option_service="${item#*=}" ;;
		'--provider='*) option_provider="${item#*=}" ;;
		'--ipv4='*) option_ipv4_servers+=("${item#*=}") ;;
		'--ipv6='*) option_ipv6_servers+=("${item#*=}") ;;
		'--doh='*) option_doh_servers+=("${item#*=}") ;;
		'--dot='*) option_dot_servers+=("${item#*=}") ;;
		'--quic='*) option_quic_servers+=("${item#*=}") ;;
		'--sdns='*) option_sdns_servers+=("${item#*=}") ;;
		'--dnscrypt='*) option_dnscrypt_names+=("${item#*=}") ;;
		'--'*) help "An unrecognised flag was provided: $item" ;;
		*) help "An unrecognised argument was provided: $item" ;;
		esac
	done

	# ---------------------------------
	# Select DNS Provider/Servers

	function render_service_or_provider {
		local id="$1" about="$2" url="$3" style_options
		style_options=("--bold+underline=$id:")
		if is-value -- "$about"; then
			style_options+=($'\n' "$about")
		fi
		if is-value -- "$url"; then
			style_options+=($'\n' "--code=$url")
		fi
		echo-style "${style_options[@]}"
	}

	function select_service {
		local id index about url options=()
		if command-exists -- nordvpn; then
			service='system'
			echo-style --notice='NordVPN installation detected, only permitting system DNS service.'
		else
			# add system
			id='system'
			about="Use the system's default DNS service. Since 2018, Linux's systemd-resolved v239 includes encryption — https://github.com/systemd/systemd/blob/04c00944d8494b88b29fd432189cf575dd0de0db/NEWS#L9866-L9870 — macOS to this day still requires an alternative service/profile for encryption."
			url=''
			options+=(
				"$id"
				"$(render_service_or_provider "$id" "$about" "$url")"
			)

			# render service options
			for id in "${available_services_id[@]}"; do
				for index in "${!services_id[@]}"; do
					if test "${services_id[index]}" = "$id"; then
						about="${services_about[index]}"
						url="${services_url[index]}"
						break
					fi
				done
				options+=(
					"$id"
					"$(render_service_or_provider "$id" "$about" "$url")"
				)
			done

			# prompt the user which dns service they wish to use
			service="$(
				choose --required --confirm --label \
					--question='Which DNS service do you wish to be your primary service?' \
					--default="${option_service:-"$DNS_SERVICE"}" -- "${options[@]}"
			)"
		fi
	}

	function __has_arg_provider {
		test \
			"${#option_ipv4_servers[@]}" -ne 0 -o \
			"${#option_ipv6_servers[@]}" -ne 0 -o \
			"${#option_doh_servers[@]}" -ne 0 -o \
			"${#option_dot_servers[@]}" -ne 0 -o \
			"${#option_quic_servers[@]}" -ne 0 -o \
			"${#option_sdns_servers[@]}" -ne 0 -o \
			"${#option_dnscrypt_names[@]}" -ne 0
	}

	function __has_env_provider {
		test \
			"${#DNS_IPV4_SERVERS[@]}" -ne 0 -o \
			"${#DNS_IPV6_SERVERS[@]}" -ne 0 -o \
			"${#DNS_DOH_SERVERS[@]}" -ne 0 -o \
			"${#DNS_DOT_SERVERS[@]}" -ne 0 -o \
			"${#DNS_QUIC_SERVERS[@]}" -ne 0 -o \
			"${#DNS_SDNS_SERVERS[@]}" -ne 0 -o \
			"${#DNS_DNSCRYPT_NAMES[@]}" -ne 0
	}

	function select_provider {
		local index id url about options=() property

		# reset shared vars
		for property in "${properties[@]}"; do
			eval "$property=()"
		done

		# render arg provider if applicable
		if __has_arg_provider; then
			id='arg'
			about='Use the provided DNS servers specified in the CLI arguments'
			url=''
			options+=(
				"$id"
				"$(render_service_or_provider "$id" "$about" "$url")"
			)
		fi

		# render env provider if applicable
		if __has_env_provider; then
			id='env'
			about='Use the provided DNS servers specified in your dns.bash user configuration'
			url=''
			options+=(
				"$id"
				"$(render_service_or_provider "$id" "$about" "$url")"
			)
		fi

		# render provider options
		for index in "${!providers_id[@]}"; do
			id="${providers_id[index]}"
			about="${providers_about[index]}"
			url="${providers_url[index]}"
			options+=(
				"$id"
				"$(render_service_or_provider "$id" "$about" "$url")"
			)
		done

		# select provider
		provider="$(
			choose --required --linger --label --confirm \
				--question='Which DNS provider to use?' \
				--default="${option_provider:-"$DNS_PROVIDER"}" -- "${options[@]}"
		)"

		# apply
		if test "$provider" = 'arg'; then
			ipv4_servers=("${option_ipv4_servers[@]}")
			ipv6_servers=("${option_ipv6_servers[@]}")
			doh_servers=("${option_doh_servers[@]}")
			dot_servers=("${option_dot_servers[@]}")
			quic_servers=("${option_quic_servers[@]}")
			sdns_servers=("${option_sdns_servers[@]}")
			dnscrypt_names=("${option_dnscrypt_names[@]}")
		elif test "$provider" = 'env'; then
			ipv4_servers=("${DNS_IPV4_SERVERS[@]}")
			ipv6_servers=("${DNS_IPV6_SERVERS[@]}")
			doh_servers=("${DNS_DOH_SERVERS[@]}")
			dot_servers=("${DNS_DOT_SERVERS[@]}")
			quic_servers=("${DNS_QUIC_SERVERS[@]}")
			sdns_servers=("${DNS_SDNS_SERVERS[@]}")
			dnscrypt_names=("${DNS_DNSCRYPT_NAMES[@]}")
		else
			for property in "${properties[@]}"; do
				mapfile -t "$property" < <(
					jq -r \
						--arg provider "$provider" \
						--arg property "$property" \
						'.providers[$provider][$property][]' \
						"$DOROTHY/config/dns.json" 2>/dev/null || :
				)
			done
		fi
	}

	# ---------------------------------
	# Configure DNS Service with Provider

	function configure_service_with_provider {
		local id fn_id service_fn_id="${service//-/_}" # replace dashes with underscores

		# Install then configure the service if not system
		if test "$service" = 'system'; then
			# Disable other services and enable system
			for id in "${installed_services_id[@]}"; do
				fn_id="${id//-/_}"            # replace dashes with underscores
				"${fn_id}__configure" disable # eval
			done
			system_dns__configure enable
		elif ! is-internet-working; then
			# If the internet is not working, disable other services and enable system, then install and enable our desired service
			for id in "${installed_services_id[@]}"; do
				fn_id="${id//-/_}"            # replace dashes with underscores
				"${fn_id}__configure" disable # eval
			done
			system_dns__configure enable

			# Install and enable our desired service
			"${service_fn_id}__install" # eval
			system_dns__configure disable
			"${service_fn_id}__configure" enable # eval
		else
			# If the internet is working, install the desired service, disable alternative services, then enable the desired service
			"${service_fn_id}__install" # eval
			for id in "${installed_services_id[@]}"; do
				fn_id="${id//-/_}" # replace dashes with underscores
				if test "$fn_id" != "$service_fn_id"; then
					"${fn_id}__configure" disable # eval
				fi
			done
			system_dns__configure disable
			"${service_fn_id}__configure" enable # eval
		fi
	}

	function verify_dns {
		echo-style --h1='Verify DNS'
		verify_dns_generic
		echo-style --g1='Verify DNS'
		is-internet-working
	}

	# ---------------------------------
	# Action

	echo-style --h1='Setup DNS'
	make_system_paths
	select_service
	select_provider
	configure_service_with_provider
	verify_dns
	echo-style --g1='Setup DNS'
)

# fire if invoked standalone
if test "$0" = "${BASH_SOURCE[0]}"; then
	setup_dns "$@"
fi
