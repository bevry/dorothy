#!/usr/bin/env bash

function echo_lines_test() (
	source "$DOROTHY/sources/bash.bash"
	eval-tester --ignore-stderr --status=22 -- echo-lines --help

	eval-tester --name='args' --stdout=$'a\nb' -- \
		echo-lines -- a b

	{
		__print_lines a
		__print_lines b
	} | eval-tester --name='stdin' --stdout=$'a\nb' -- \
		echo-lines --stdin

	{
		__print_lines e1
		__print_lines f1
	} | eval-tester --name='args, ignoring stdin' --stdout=$'a\nb\nc\nd' -- \
		echo-lines -- a b c d

	{
		__print_lines e2
		__print_lines f2
	} | eval-tester --name='args, with stdin' --stdout=$'a\nb\nc\nd\ne2\nf2' -- \
		echo-lines --stdin -- a b c d

	{
		__print_lines e3
		__print_lines f3
	} | eval-tester --name='args quoted, ignoring stdin' --stdout=$'\'a\'\n\'b\'\n\'c\'\n\'d\'' -- \
		echo-lines --quote -- a b c d

	{
		__print_lines e4
		__print_lines f4
	} | eval-tester --name='args quoted, with stdin' --stdout=$'\'a\'\n\'b\'\n\'c\'\n\'d\'\n\'e4\'\n\'f4\'' -- \
		echo-lines --stdin --quote -- a b c d

	{
		__print_lines e5
		__print_lines f5
	} | eval-tester --name='args indent, ignoring stdin' --stdout=$'xa\nxb\nxc\nxd' -- \
		echo-lines --indent=x -- a b c d

	{
		__print_lines e6
		__print_lines f6
	} | eval-tester --name='args indent, with stdin' --stdout=$'xa\nxb\nxc\nxd\nxe6\nxf6' -- \
		echo-lines --stdin --indent=x -- a b c d

	{
		__print_lines e7
		__print_lines f7
	} | eval-tester --name='args prefix, ignoring stdin' --stdout=$'--flag=a\n--flag=b\n--flag=c\n--flag=d' -- \
		echo-lines --prefix='--flag=' -- a b c d

	{
		__print_lines e8
		__print_lines f8
	} | eval-tester --name='args prefix, with stdin' --stdout=$'--flag=a\n--flag=b\n--flag=c\n--flag=d\n--flag=e8\n--flag=f8' -- \
		echo-lines --stdin --prefix='--flag=' -- a b c d

	{
		__print_lines e9
		__print_lines f9
	} | eval-tester --name='args columns, ignoring stdin' --stdout=$'a\tb\nc\td' -- \
		echo-lines --columns=2 --filler=tab --width=inputs -- a b c d

	{
		__print_lines e10
		__print_lines f10
	} | eval-tester --name='args columns, with stdin' --stdout=$'a\tb\nc\td\ne10\tf10' -- \
		echo-lines --stdin --columns=2 --filler=tab --width=inputs -- a b c d

	{
		__print_lines e11
		__print_lines f11
	} | eval-tester --name='args columns, indent, prefix, suffix, ignoring stdin' --stdout=$'x[a]\t[b]\nx[c]\t[d]' -- \
		echo-lines --columns=2 --filler=tab --width=inputs --indent='x' --prefix='[' --suffix=']' -- a b c d

	{
		__print_lines e12
		__print_lines f12
	} | eval-tester --name='args columns, indent, prefix, suffix, with stdin' --stdout=$'x[a]\t[b]\nx[c]\t[d]\nx[e12]\t[f12]' -- \
		echo-lines --stdin --columns=2 --filler=tab --width=inputs --indent='x' --prefix='[' --suffix=']' -- a b c d

	{
		__print_lines e12
		__print_lines f12
	} | eval-tester --name='args columns, indent, prefix, suffix, with stdin, with predefined width' --stdout=$'x[a]\t[b]\nx[c]\t[d]\nx[e12]\t[f12]' -- \
		echo-lines --stdin --columns=2 --filler=tab --width=20 --indent='x' --prefix='[' --suffix=']' -- a b c d

	{
		__print_lines e13
		__print_lines f13
	} | eval-tester --name='args columns, indent, prefix, suffix, with stdin, with width=inputs' --stdout=$'x[aaa]\t[b]\nx[c]\t[d]\nx[e13]\t[f13]' -- \
		echo-lines --stdin --columns=2 --filler=tab --width=inputs --indent='x' --prefix='[' --suffix=']' -- aaa b c d

	{
		__print_lines e14
		__print_lines f14
	} | eval-tester --name='args columns, indent, prefix, suffix, with stdin, with width=inputs' --stdout=$'x[aaaa]\t\t[b]\nx[ccc]\t\t[d]\nx[e14]\t\t[f14]' -- \
		echo-lines --stdin --columns=2 --filler=tab --width=inputs --indent='x' --prefix='[' --suffix=']' -- aaaa b ccc d

	eval-tester --name='double tab indent' --stdout=$'\t\t\'double "quote" inside\'\t\t"single \'quote\' inside"\t\t\'3\'\n\t\t\'4\'\t\t\t\t\'5\'\t\t\t\t\'6\'' -- \
		echo-lines --columns=3 --filler=tab --width=inputs --quote --indent=$'\t\t' -- 'double "quote" inside' "single 'quote' inside" 3 4 5 6

	{
		__print_lines e15
		__print_lines f15
	} | eval-tester --name='args columns, ignoring stdin' --stdout=$'a  b\nc  d' -- \
		echo-lines --columns=2 --filler=space --width=inputs -- a b c d

	{
		__print_lines e16
		__print_lines f16
	} | eval-tester --name='args columns, with stdin' --stdout=$'a    b\nc    d\ne16  f16' -- \
		echo-lines --stdin --columns=2 --filler=space --width=inputs -- a b c d

	{
		__print_lines e17
		__print_lines f17
	} | eval-tester --name='args columns, indent, prefix, suffix, ignoring stdin' --stdout=$'x[a]  [b]\nx[c]  [d]' -- \
		echo-lines --columns=2 --filler=space --width=inputs --indent='x' --prefix='[' --suffix=']' -- a b c d

	{
		__print_lines e18
		__print_lines f18
	} | eval-tester --name='args columns, indent, prefix, suffix, with stdin' --stdout=$'x[a]    [b]\nx[c]    [d]\nx[e18]  [f18]' -- \
		echo-lines --stdin --columns=2 --filler=space --width=inputs --indent='x' --prefix='[' --suffix=']' -- a b c d

	# predefined width of 20, expands each column to 10, hence the extra spacing between first column to make it size 10
	{
		__print_lines e19
		__print_lines f19
	} | eval-tester --name='args columns, indent, prefix, suffix, with stdin, with predefined width' --stdout=$'x[a]      [b]\nx[c]      [d]\nx[e19]    [f19]' -- \
		echo-lines --stdin --columns=2 --filler=space --width=20 --indent='x' --prefix='[' --suffix=']' -- a b c d

	{
		__print_lines e20
		__print_lines f20
	} | eval-tester --name='args columns, indent, prefix, suffix, with stdin, with width=inputs' --stdout=$'x[aaa]  [b]\nx[c]    [d]\nx[e20]  [f20]' -- \
		echo-lines --stdin --columns=2 --filler=space --width=inputs --indent='x' --prefix='[' --suffix=']' -- aaa b c d

	{
		__print_lines e21
		__print_lines f21
	} | eval-tester --name='args columns, indent, prefix, suffix, with stdin, with width=inputs' --stdout=$'x[aaaa]  [b]\nx[ccc]   [d]\nx[e21]   [f21]' -- \
		echo-lines --stdin --columns=2 --filler=space --width=inputs --indent='x' --prefix='[' --suffix=']' -- aaaa b ccc d

	eval-tester --name='double tab indent' --stdout=$'\t\t\'double "quote" inside\'  "single \'quote\' inside"  \'3\'\n\t\t\'4\'                      \'5\'                      \'6\'' -- \
		echo-lines --columns=3 --filler=space --width=inputs --quote --indent=$'\t\t' -- 'double "quote" inside' "single 'quote' inside" 3 4 5 6

	return 0
)
function echo_lines() (
	source "$DOROTHY/sources/stdinargs.bash"

	# =====================================
	# Arguments

	function __help {
		__print_help "$@" <<-EOF || return $?
			ABOUT:
			Outputs each input on a separate line.

			USAGE:
			\`echo-lines [...options] [--] ...<input>\`

			OPTIONS:
			--columns | --columns=<columns>
			    If \`0\`: output as many columns that will fit within <width>.
			    If not provided or \`1\`: output no columns.
			    If greater than \`1\`: output as many columns that will fit within <width> limited to <columns> (e.g. if 5 columns is specified, but 4 will fit, then 4 will be used; if 3 columns is specified, but 4 will fit, then 3 will be used).
			--width=inputs | --width=terminal | --width=<width>
			    If not provided, \`0\`, or \`terminal\`: the terminal width will be used to determine the spacing between columns, if this detection fails, columns will be disabled.
			    If \`inputs\`: the columns will adapt to the inputs provided.
			    If an integer: the columns will adapt to this <width>.
			--filler=<filler>
			    The character to use to fill the space between columns; sensible values are a single space character (which has a filler spacing size of 1), or a single tab character (which has a filler spacing size of 8).
			    The default is a space character as it doesn't risk issues with variance.
			--distance=<distance>
			    The minimum amount of filler spacing to provide between columns.
			--trail=<YES/no>
			    If \`yes\`: output will contain a trailing newline.
			    If \`no\`: output will contain a trailing newline.
			--spread=<YES/no>
			    If \`yes\`: unused space will be spread evenly between columns.
			    If \`no\`: unused space will be right-aligned.
			--shrink=<YES/no>
			    If \`yes\`: columns will be shrunk to an appropriate size to ensure there isn't huge amount of empty space.
			    If \`no\`: columns will always make use of the entire canvas.

			--indent=<indent>
			    Prefix each line with this, useful for indentation.
			--prefix=<prefix>
			    Prefix each input with this.
			--suffix=<suffix>
			    Suffix each input with this.

			--quote=<yes/NO> | --quoted=<yes/NO>
			    If yes, the arguments will be quoted if necessary.

			$(__stdinargs__help_options --)
		EOF
		return 22 # EINVAL 22 Invalid argument
	}

	# process our own arguments, delegate everything else to stdinargs
	local item option_columns=1 option_width='terminal' option_filler=' ' option_distance=2 option_trail='yes' option_spread='yes' option_shrink='yes' option_indent='' option_prefix='' option_suffix='' option_quote='no' option_args=()
	while [[ $# -ne 0 ]]; do
		item="$1"
		shift
		case "$item" in
		'--help' | '-h') __help || return $? ;;
		'--columns='*) option_columns="${item#*=}" ;;
		'--columns') option_columns=0 ;;
		'--filler=tab') option_filler=$'\t' ;;
		'--filler=space') option_filler=' ' ;;
		'--filler='*) option_filler="${item#*=}" ;;
		'--distance='*) option_distance="${item#*=}" ;;
		'--width='*) option_width="${item#*=}" ;;
		'--prefix='*) option_prefix="${item#*=}" ;;
		'--indent='*) option_indent="${item#*=}" ;;
		'--suffix='*) option_suffix="${item#*=}" ;;
		'--no-trail'* | '--trail'*) __flag --source={item} --target={option_trail} --affirmative ;;
		'--no-spread'* | '--spread'*) __flag --source={item} --target={option_spread} --affirmative ;;
		'--no-shrink'* | '--shrink'*) __flag --source={item} --target={option_shrink} --affirmative ;;
		'--quote=bash') option_quote='bash' ;;
		'--quote=command') option_quote='command' ;;
		'--quote=generic') option_quote='generic' ;;
		'--no-quote'* | '--quote'*)
			# will also support quoted
			__flag --source={item} --target={option_quote} --affirmative
			;;
		# forward to stdinargs, however support mixing and matching of our options, with stdinargs options
		'--')
			option_args+=("$item" "$@")
			shift $#
			break
			;;
		*) option_args+=("$item") ;;
		esac
	done

	# =====================================
	# Action

	# quote the arguments if desired
	local items=()
	if [[ $option_quote == 'bash' ]]; then
		function __on_piece {
			local item="$1" escaped
			escaped="$(echo-escape-bash -- "$item")" || return $?
			items+=("$option_prefix$escaped$option_suffix")
		}
	elif [[ $option_quote == 'command' ]]; then
		function __on_piece {
			local item="$1" escaped
			escaped="$(echo-escape-command -- "$item")" || return $?
			items+=("$option_prefix$escaped$option_suffix")
		}
	elif [[ $option_quote =~ ^(generic|yes)$ ]]; then
		function __on_piece {
			local item="$1" escaped
			escaped="$(echo-quote -- "$item")" || return $?
			items+=("$option_prefix$escaped$option_suffix")
		}
	else
		function __on_piece {
			local item="$1"
			items+=("$option_prefix$item$option_suffix")
		}
	fi
	function __floor {
		local n="$1" d="$2"
		if [[ $d -eq 1 ]]; then
			__print_lines "$n" || return $?
			return 0
		fi
		__print_lines "$((n / d * d))" || return $?
	}
	function __ceil {
		local n="$1" d="$2"
		if [[ $d -eq 1 ]]; then
			__print_lines "$n" || return $?
			return 0
		fi
		__print_lines "$((n / d * d + (n % d != 0) * d))" || return $?
	}
	function __get_size {
		# ' ' = 1
		# '  ' = 2
		# '\t' = 8
		# '\t\t' = 16
		# '\t\t'[0] = 16, '\t\t':0:1 = 8
		local input="$1" size=0
		for ((i = 0; i < ${#input}; i++)); do
			if [[ ${input:i:1} == $'\t' ]]; then
				size="$((size + 8))"
			else
				size="$((size + 1))"
			fi
		done
		__print_lines "$size" || return $?
	}
	function __get_inverse_proportion {
		# bash does not support decimals (floating point arithmetic)
		# 1 = 0
		# 2 = 50
		# 3 = 66
		# 4 = 75
		# 5 = 80
		# and so on, always approaching 1
		local share="$1" divisor="$2"
		echo-math --integer -- "$share * (1 - (1 / $divisor))" || return $?
	}
	function __output_single_column {
		# prepare the format
		local last=''
		if [[ $option_trail == 'yes' ]]; then
			last=$'\n'
		fi

		# output lines to the format
		if [[ ${#items[@]} -ne 0 ]]; then
			__join --source={items} --left="$option_indent" --last="$last" --between=$'\n' || return $?
		fi
	}
	function on_finish {
		# verify
		local -i columns
		if [[ -z $option_columns || $option_columns == '0' ]]; then
			columns=0
		elif __is_integer "$option_columns"; then
			columns="$option_columns"
		else
			__help --help='<columns> must be a positive integer: ' --variable-value={option_columns} || return $?
		fi
		if [[ $columns -eq 1 ]]; then
			# simple mode, as single column
			__output_single_column || return $?
			return 0
		fi
		if [[ $columns -le 1 && $option_width == 'inputs' ]]; then
			# simple mode, inputs requires at least 2 columns
			__output_single_column || return $?
			return 0
		fi

		# if unable to autodetect, be simple
		if [[ -z $option_width ]]; then
			option_width='terminal'
		fi
		local -i terminal_columns=0
		if [[ $option_width == 'terminal' ]]; then
			local terminal_size=()
			__split --target={terminal_size} --no-zero-length --invoke=try -- \
				get-terminal-lines-and-columns
			if [[ ${#terminal_size[@]} -eq 2 ]]; then
				terminal_columns="${terminal_size[1]}"
			else
				# simple mode, as cannot determine terminal size
				__output_single_column || return $?
				return 0
			fi
		fi

		# verify
		if [[ -z $option_filler ]]; then
			__help --help='<filler> cannot be empty: ' --variable-value={option_filler} || return $?
		fi
		if [[ $option_distance -le 0 ]] || ! __is_integer "$option_distance"; then
			__help --help='<distance> must be a positive integer: ' --variable-value={option_distance} || return $?
		fi

		# ensure filler and indent padding is respectful of tabs
		local -i filler_size indent_size
		filler_size="$(__get_size "$option_filler")" || return $?
		indent_size="$(__get_size "$option_indent")" || return $?

		# calculate size of largest line/item
		local item
		local -i item_size largest_item_size=0
		for item in "${items[@]}"; do
			item_size="${#item}"
			if [[ $item_size -gt $largest_item_size ]]; then
				largest_item_size="$item_size"
			fi
		done
		if [[ $largest_item_size -eq 0 ]]; then
			# nothing to output
			return 0
		fi

		# calculate column size
		local -i generic_column_size indent_column_size content_size
		generic_column_size="$((largest_item_size + option_distance))"
		generic_column_size="$(__ceil "$generic_column_size" "$filler_size")" || return $?
		indent_column_size="$((indent_size + largest_item_size + option_distance))"
		indent_column_size="$(__ceil "$indent_column_size" "$filler_size")" || return $?
		if [[ $columns -eq 0 ]]; then
			if [[ $terminal_columns -le 0 ]]; then
				# simple mode, as cannot determine terminal size
				__output_single_column || return $?
				return 0
			fi
			columns="$((1 + (terminal_columns - indent_column_size) / generic_column_size))"
		fi
		content_size="$((indent_column_size + generic_column_size * (columns - 1)))"
		content_size="$(__ceil "$content_size" "$filler_size")" || return $?

		# calculate canvas size
		local -i canvas_size
		if [[ $option_width == 'inputs' ]]; then
			canvas_size="$content_size"
		elif [[ $option_width == 'terminal' ]]; then
			canvas_size="$terminal_columns"
		elif __is_integer "$option_width"; then
			canvas_size="$option_width"
		else
			__help --help='<width> must be one of: `inputs`, `terminal`, or an integer: ' --variable-value={option_width} || return $?
		fi
		if [[ $canvas_size -le 0 ]]; then
			# simple mode, as could not determine canvas_size
			__output_single_column || return $?
			return 0
		fi
		if [[ $canvas_size -le $indent_column_size ]]; then
			# simple mode, as columns are too large
			__output_single_column || return $?
			return 0
		fi
		if [[ $canvas_size -le $content_size ]]; then
			# shrink the amount of columns, as there are too many
			columns="$((1 + (canvas_size - indent_column_size) / generic_column_size))"
			if [[ $columns -le 1 ]]; then
				# simple mode, as single column
				__output_single_column || return $?
				return 0
			fi
			content_size="$((indent_column_size + generic_column_size * (columns - 1)))"
			content_size="$(__ceil "$content_size" "$filler_size")" || return $?
		fi

		# shrink or expand if we care for that
		local -i unused_size=0 margin_size=0
		if [[ $option_width != 'inputs' ]]; then
			# if the canvas will be mostly empty, shrink it
			local temp_size
			if [[ $option_shrink == 'yes' ]]; then
				temp_size="$(__get_inverse_proportion "$canvas_size" "$columns")" || return $?
				if [[ $temp_size -gt $content_size ]]; then
					canvas_size="$temp_size"
				fi
			fi

			# expand the column size to fill the canvas
			if [[ $option_spread == 'yes' ]]; then
				unused_size="$((canvas_size - content_size))"
				unused_size="$(__floor "$unused_size" "$filler_size")" || return $?
				margin_size="$((unused_size / columns))"
				margin_size="$(__floor "$margin_size" "$filler_size")" || return $?
			fi
		fi

		# render the columns
		local -i item_column_size padding_size column=0
		local had_trailing_newline='no'
		for item in "${items[@]}"; do
			item_size="${#item}"
			if [[ $column -eq 0 ]]; then
				# first column
				item_column_size="$indent_column_size"
				item_size="$((item_size + indent_size))"
				printf '%s' "$option_indent$item"
			else
				# inside column
				item_column_size="$generic_column_size"
				printf '%s' "$item"
			fi
			column="$((column + 1))"
			if [[ $column -eq $columns ]]; then
				# last column
				had_trailing_newline='yes'
				printf '\n'
				column=0
			else
				# first or inside column
				had_trailing_newline='no'
				padding_size="$((item_column_size - item_size + margin_size))"
				for ((i = 0; i < padding_size; i += filler_size)); do
					printf '%s' "$option_filler"
				done
			fi
		done
		if [[ $had_trailing_newline == 'no' && $option_trail == 'yes' ]]; then
			printf '\n'
		fi
		return 0
	}

	stdinargs "${option_args[@]}"
)

# fire if invoked standalone
if [[ $0 == "${BASH_SOURCE[0]}" ]]; then
	if [[ $* == '--test' ]]; then
		echo_lines_test
	else
		echo_lines "$@"
	fi
fi
