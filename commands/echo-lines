#!/usr/bin/env bash

function echo_lines_test() (
	source "$DOROTHY/sources/bash.bash"
	echo-segment --h1="TEST: $0"

	eval-tester --name='args' --stdout=$'a\nb' \
		-- echo-lines -- a b

	{
		print_line a
		print_line b
	} | eval-tester --name='stdin' --stdout=$'a\nb' \
		-- echo-lines --stdin

	{
		print_line e1
		print_line f1
	} | eval-tester --name='args, ignoring stdin' --stdout=$'a\nb\nc\nd' \
		-- echo-lines -- a b c d

	{
		print_line e2
		print_line f2
	} | eval-tester --name='args, with stdin' --stdout=$'a\nb\nc\nd\ne2\nf2' \
		-- echo-lines --stdin -- a b c d

	{
		print_line e3
		print_line f3
	} | eval-tester --name='args quoted, ignoring stdin' --stdout=$'\'a\'\n\'b\'\n\'c\'\n\'d\'' \
		-- echo-lines --quoted -- a b c d

	{
		print_line e4
		print_line f4
	} | eval-tester --name='args quoted, with stdin' --stdout=$'\'a\'\n\'b\'\n\'c\'\n\'d\'\n\'e4\'\n\'f4\'' \
		-- echo-lines --stdin --quoted -- a b c d

	{
		print_line e5
		print_line f5
	} | eval-tester --name='args indent, ignoring stdin' --stdout=$'xa\nxb\nxc\nxd' \
		-- echo-lines --indent=x -- a b c d

	{
		print_line e6
		print_line f6
	} | eval-tester --name='args indent, with stdin' --stdout=$'xa\nxb\nxc\nxd\nxe6\nxf6' \
		-- echo-lines --stdin --indent=x -- a b c d

	{
		print_line e7
		print_line f7
	} | eval-tester --name='args prefix, ignoring stdin' --stdout=$'--flag=a\n--flag=b\n--flag=c\n--flag=d' \
		-- echo-lines --prefix='--flag=' -- a b c d

	{
		print_line e8
		print_line f8
	} | eval-tester --name='args prefix, with stdin' --stdout=$'--flag=a\n--flag=b\n--flag=c\n--flag=d\n--flag=e8\n--flag=f8' \
		-- echo-lines --stdin --prefix='--flag=' -- a b c d

	{
		print_line e9
		print_line f9
	} | eval-tester --name='args columns, ignoring stdin' --stdout=$'a\tb\nc\td' \
		-- echo-lines --columns=2 --filler=tab --width=inputs -- a b c d

	{
		print_line e10
		print_line f10
	} | eval-tester --name='args columns, with stdin' --stdout=$'a\tb\nc\td\ne10\tf10' \
		-- echo-lines --stdin --columns=2 --filler=tab --width=inputs -- a b c d

	{
		print_line e11
		print_line f11
	} | eval-tester --name='args columns, indent, prefix, suffix, ignoring stdin' --stdout=$'x[a]\t[b]\nx[c]\t[d]' \
		-- echo-lines --columns=2 --filler=tab --width=inputs --indent='x' --prefix='[' --suffix=']' -- a b c d

	{
		print_line e12
		print_line f12
	} | eval-tester --name='args columns, indent, prefix, suffix, with stdin' --stdout=$'x[a]\t[b]\nx[c]\t[d]\nx[e12]\t[f12]' \
		-- echo-lines --stdin --columns=2 --filler=tab --width=inputs --indent='x' --prefix='[' --suffix=']' -- a b c d

	{
		print_line e12
		print_line f12
	} | eval-tester --name='args columns, indent, prefix, suffix, with stdin, with predefined width' --stdout=$'x[a]\t[b]\nx[c]\t[d]\nx[e12]\t[f12]' \
		-- echo-lines --stdin --columns=2 --filler=tab --width=20 --indent='x' --prefix='[' --suffix=']' -- a b c d

	{
		print_line e13
		print_line f13
	} | eval-tester --name='args columns, indent, prefix, suffix, with stdin, with width=inputs' --stdout=$'x[aaa]\t[b]\nx[c]\t[d]\nx[e13]\t[f13]' \
		-- echo-lines --stdin --columns=2 --filler=tab --width=inputs --indent='x' --prefix='[' --suffix=']' -- aaa b c d

	{
		print_line e14
		print_line f14
	} | eval-tester --name='args columns, indent, prefix, suffix, with stdin, with width=inputs' --stdout=$'x[aaaa]\t\t[b]\nx[ccc]\t\t[d]\nx[e14]\t\t[f14]' \
		-- echo-lines --stdin --columns=2 --filler=tab --width=inputs --indent='x' --prefix='[' --suffix=']' -- aaaa b ccc d

	eval-tester --name='double tab indent' --stdout=$'\t\t\'double "quote" inside\'\t\t"single \'quote\' inside"\t\t\'3\'\n\t\t\'4\'\t\t\t\t\'5\'\t\t\t\t\'6\'' \
		-- echo-lines --columns=3 --filler=tab --width=inputs --quoted --indent=$'\t\t' -- 'double "quote" inside' "single 'quote' inside" 3 4 5 6

	{
		print_line e15
		print_line f15
	} | eval-tester --name='args columns, ignoring stdin' --stdout=$'a  b\nc  d' \
		-- echo-lines --columns=2 --filler=space --width=inputs -- a b c d

	{
		print_line e16
		print_line f16
	} | eval-tester --name='args columns, with stdin' --stdout=$'a    b\nc    d\ne16  f16' \
		-- echo-lines --stdin --columns=2 --filler=space --width=inputs -- a b c d

	{
		print_line e17
		print_line f17
	} | eval-tester --name='args columns, indent, prefix, suffix, ignoring stdin' --stdout=$'x[a]  [b]\nx[c]  [d]' \
		-- echo-lines --columns=2 --filler=space --width=inputs --indent='x' --prefix='[' --suffix=']' -- a b c d

	{
		print_line e18
		print_line f18
	} | eval-tester --name='args columns, indent, prefix, suffix, with stdin' --stdout=$'x[a]    [b]\nx[c]    [d]\nx[e18]  [f18]' \
		-- echo-lines --stdin --columns=2 --filler=space --width=inputs --indent='x' --prefix='[' --suffix=']' -- a b c d

	# predefined width of 20, expands each column to 10, hence the extra spacing between first column to make it size 10
	{
		print_line e19
		print_line f19
	} | eval-tester --name='args columns, indent, prefix, suffix, with stdin, with predefined width' --stdout=$'x[a]      [b]\nx[c]      [d]\nx[e19]    [f19]' \
		-- echo-lines --stdin --columns=2 --filler=space --width=20 --indent='x' --prefix='[' --suffix=']' -- a b c d

	{
		print_line e20
		print_line f20
	} | eval-tester --name='args columns, indent, prefix, suffix, with stdin, with width=inputs' --stdout=$'x[aaa]  [b]\nx[c]    [d]\nx[e20]  [f20]' \
		-- echo-lines --stdin --columns=2 --filler=space --width=inputs --indent='x' --prefix='[' --suffix=']' -- aaa b c d

	{
		print_line e21
		print_line f21
	} | eval-tester --name='args columns, indent, prefix, suffix, with stdin, with width=inputs' --stdout=$'x[aaaa]  [b]\nx[ccc]   [d]\nx[e21]   [f21]' \
		-- echo-lines --stdin --columns=2 --filler=space --width=inputs --indent='x' --prefix='[' --suffix=']' -- aaaa b ccc d

	eval-tester --name='double tab indent' --stdout=$'\t\t\'double "quote" inside\'  "single \'quote\' inside"  \'3\'\n\t\t\'4\'                      \'5\'                      \'6\'' \
		-- echo-lines --columns=3 --filler=space --width=inputs --quoted --indent=$'\t\t' -- 'double "quote" inside' "single 'quote' inside" 3 4 5 6

	echo-segment --g1="TEST: $0"
	return 0
)
function echo_lines() (
	source "$DOROTHY/sources/stdinargs.bash"

	# =====================================
	# Arguments

	function help {
		cat <<-EOF >/dev/stderr
			ABOUT:
			Outputs each input on a separate line.

			USAGE:
			echo-lines [...options] [--] ...<input>

			OPTIONS:
			--columns | --columns=<columns>
			    if 0: output as many columns that will fit within <width>
			    if not provided or 1: output no columns
			    if >1: output as  many columns that will fit within <width> limited to <columns> (e.g. if 5 columns is specified, but 4 will fit, 4 will be used; if 3 columns is specified, but 4 will fit, 3 will be used)
			--width=inputs | --width=terminal | --width=<width>
			    if not provided, 0, or terminal: the terminal width will be used to determine the spacing between columns, if this detection fails, columns will be disabled
			    if inputs: the columns will adapt to the inputs provided
			    if an integer: the columns will adapt to this <width>
			--filler=<filler>
			    the character to use to fill the space between columns
			    sensible values are a single space character (which has a filler spacing size of 1), or a single tab character (which has a filler spacing size of 8)
			    the default is a space character as it doesn't risk issues with variance
			--distance=<distance>
			    the minimum amount of filler spacing to provide between columns
			--spread=<YES/no>
			    if ye: unused space will be spread evenly between columns
			    if no: unused space will be right-aligned
			--shrink=<YES/no>
			    if yes: columns will be shrunk to an appropriate size to ensure there isn't huge amount of empty space
			    if no: columns will always make use of the entire canvas

			--indent=<indent>
			    prefix each line with this, useful for indentation
			--prefix=<prefix>
			    prefix each input with this d
			--suffix=<suffix>
			    suffix each input with this

			--quoted=<yes/no>
			    if yes, the arguments will be quoted if necessary

			$(stdinargs_options_help --)
		EOF
		if test "$#" -ne 0; then
			echo-error "$@"
		fi
		return 22 # EINVAL 22 Invalid argument
	}

	# process our own arguments, delegate everything else to stdinargs
	local item option_columns=1 option_width='terminal' option_filler=' ' option_distance=2 option_spread='yes' option_shrink='yes' option_indent='' option_prefix='' option_suffix='' option_quoted='no' option_args=()
	while test "$#" -ne 0; do
		item="$1"
		shift
		case "$item" in
		'--help' | '-h') help ;;
		'--columns='*) option_columns="${item#*=}" ;;
		'--columns') option_columns=0 ;;
		'--filler=tab') option_filler=$'\t' ;;
		'--filler=space') option_filler=' ' ;;
		'--filler='*) option_filler="${item#*=}" ;;
		'--distance='*) option_distance="${item#*=}" ;;
		'--width='*) option_width="${item#*=}" ;;
		'--prefix='*) option_prefix="${item#*=}" ;;
		'--indent='*) option_indent="${item#*=}" ;;
		'--suffix='*) option_suffix="${item#*=}" ;;
		'--no-spread'* | '--spread'*)
			option_spread="$(get-flag-value --affirmative --fallback="$option_spread" -- "$item")"
			;;
		'--no-shrink'* | '--shrink'*)
			option_shrink="$(get-flag-value --affirmative --fallback="$option_shrink" -- "$item")"
			;;
		'--no-quoted'* | '--quoted'*)
			option_quoted="$(get-flag-value --affirmative --fallback="$option_quoted" -- "$item")"
			;;
		# forward to stdinargs, however support mixing and matching of our options, with stdinarg options
		'--')
			option_args+=("$item" "$@")
			shift $#
			break
			;;
		*) option_args+=("$item") ;;
		esac
	done

	# =====================================
	# Action

	# quote the arguments if desired
	local items=()
	if test "$option_quoted" = 'yes'; then
		function on_input {
			items+=("$option_prefix$(echo-quote -- "$1")$option_suffix")
		}
	else
		function on_input {
			items+=("$option_prefix$1$option_suffix")
		}
	fi
	function floor {
		local n="$1" d="$2"
		if test "$d" -eq 1; then
			print_line "$n"
			return 0
		fi
		print_line "$((n / d * d))"
	}
	function ceil {
		local n="$1" d="$2"
		if test "$d" -eq 1; then
			print_line "$n"
			return 0
		fi
		print_line "$((n / d * d + (n % d != 0) * d))"
	}
	function get_size {
		# ' ' = 1
		# '  ' = 2
		# '\t' = 8
		# '\t\t' = 16
		# '\t\t'[0] = 16, '\t\t':0:1 = 8
		local input="$1" size=0
		for ((i = 0; i < ${#input}; i++)); do
			if test "${input:i:1}" = $'\t'; then
				size="$((size + 8))"
			else
				size="$((size + 1))"
			fi
		done
		print_line "$size"
	}
	function get_inverse_proportion {
		# bash does not support decimals (floating point arithmetic)
		# 1 = 0
		# 2 = 50
		# 3 = 66
		# 4 = 75
		# 5 = 80
		# and so on, always approaching 1
		local share="$1" divisor="$2"
		echo-math --precision=0 -- "$share * (1 - (1 / $divisor))"
	}
	function output_single_column {
		# prepare the format
		local format='%s\n'
		if test -n "$option_indent"; then
			format="$option_indent$format"
		fi

		# output lines to the format
		if test "${#items[@]}" -ne 0; then
			# trunk-ignore(shellcheck/SC2059)
			printf "$format" "${items[@]}"
		fi
	}
	function on_finish {
		# verify
		local -i columns terminal_size=0
		if test -z "$option_columns" -o "$option_columns" = '0'; then
			columns=0
		elif is-integer -- "$option_columns"; then
			columns="$option_columns"
		else
			help "<columns> must be a positive integer: $option_columns"
		fi
		if test "$columns" -eq 1; then
			# simple mode, as single column
			output_single_column
			return
		fi
		if test "$columns" -le 1 -a "$option_width" = 'inputs'; then
			# simple mode, inputs requires at least 2 columns
			output_single_column
			return
		fi

		# if unable to autodetect, be simple
		if test -z "$option_width"; then
			option_width='terminal'
		fi
		if test "$option_width" = 'terminal'; then
			# trunk-ignore(shellcheck/SC2015)
			terminal_size="$(is-tty && tput cols || :)"
			if test -z "$terminal_size" || test "$terminal_size" -eq 0; then
				# simple mode, as cannot determine terminal size
				output_single_column
				return
			fi
		fi

		# verify
		if test -z "$option_filler"; then
			help "<filler> cannot be empty: $option_filler"
		fi
		if ! is-integer -- "$option_distance" || test "$option_distance" -le 0; then
			help "<distance> must be a positive integer: $option_distance"
		fi

		# ensure filler and indent padding is respectful of tabs
		local filler_size indent_size
		filler_size="$(get_size "$option_filler")"
		indent_size="$(get_size "$option_indent")"

		# calculate size of largest line/item
		local item item_size largest_item_size=0
		for item in "${items[@]}"; do
			item_size="${#item}"
			if test "$item_size" -gt "$largest_item_size"; then
				largest_item_size="$item_size"
			fi
		done
		if test "$largest_item_size" -eq 0; then
			# nothing to output
			return 0
		fi

		# calculate column size
		local generic_column_size indent_column_size content_size
		generic_column_size="$((largest_item_size + option_distance))"
		generic_column_size="$(ceil "$generic_column_size" "$filler_size")"
		indent_column_size="$((indent_size + largest_item_size + option_distance))"
		indent_column_size="$(ceil "$indent_column_size" "$filler_size")"
		if test "$columns" -eq 0; then
			if test "$terminal_size" -eq 0; then
				# simple mode, as cannot determine terminal size
				output_single_column
				return
			fi
			columns="$((1 + (terminal_size - indent_column_size) / generic_column_size))"
		fi
		content_size="$((indent_column_size + generic_column_size * (columns - 1)))"
		content_size="$(ceil "$content_size" "$filler_size")"

		# calculate canvas size
		local canvas_size
		if test "$option_width" = 'inputs'; then
			canvas_size="$content_size"
		elif test "$option_width" = 'terminal'; then
			canvas_size="$terminal_size"
		elif is-integer -- "$option_width"; then
			canvas_size="$option_width"
		else
			help "<width> must be one of: inputs, terminal, or an integer: $option_width"
		fi
		if test "$canvas_size" -le 0; then
			# simple mode, as could not determine canvas_size
			output_single_column
			return
		fi
		if test "$canvas_size" -le "$indent_column_size"; then
			# simple mode, as columns are too large
			output_single_column
			return
		fi
		if test "$canvas_size" -le "$content_size"; then
			# shrink the amount of columns, as there are too many
			columns="$((1 + (canvas_size - indent_column_size) / generic_column_size))"
			if test "$columns" -le 1; then
				# simple mode, as single column
				output_single_column
				return
			fi
			content_size="$((indent_column_size + generic_column_size * (columns - 1)))"
			content_size="$(ceil "$content_size" "$filler_size")"
		fi

		# shrink or expand if we care for that
		local unused_size=0 margin_size=0
		if test "$option_width" != 'inputs'; then
			# if the canvas will be mostly empty, shrink it
			local temp_size
			if test "$option_shrink" = 'yes'; then
				temp_size="$(get_inverse_proportion "$canvas_size" "$columns")"
				if test "$temp_size" -gt "$content_size"; then
					canvas_size="$temp_size"
				fi
			fi

			# expand the column size to fill the canvas
			if test "$option_spread" = 'yes'; then
				unused_size="$((canvas_size - content_size))"
				unused_size="$(floor "$unused_size" "$filler_size")"
				margin_size="$((unused_size / columns))"
				margin_size="$(floor "$margin_size" "$filler_size")"
			fi
		fi

		# render the columns
		local item_column_size padding_size column=0 trailing_newline='no'
		for item in "${items[@]}"; do
			item_size="${#item}"
			if test "$column" -eq 0; then
				# first column
				item_column_size="$indent_column_size"
				item_size="$((item_size + indent_size))"
				printf '%s' "$option_indent$item"
			else
				# inside column
				item_column_size="$generic_column_size"
				printf '%s' "$item"
			fi
			column="$((column + 1))"
			if test "$column" -eq "$columns"; then
				# last column
				trailing_newline='yes'
				printf '\n'
				column=0
			else
				# first or inside column
				trailing_newline='no'
				padding_size="$((item_column_size - item_size + margin_size))"
				for ((i = 0; i < padding_size; i += filler_size)); do
					printf '%s' "$option_filler"
				done
			fi
		done
		if test "$trailing_newline" = 'no'; then
			printf '\n'
		fi
		return 0
	}

	stdinargs "${option_args[@]}"
)

# fire if invoked standalone
if test "$0" = "${BASH_SOURCE[0]}"; then
	if test "$*" = '--test'; then
		echo_lines_test
	else
		echo_lines "$@"
	fi
fi
