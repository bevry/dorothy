#!/usr/bin/env bash

function echo_math_test() (
	source "$DOROTHY/sources/bash.bash"

	# the 1 -1 test is necessary because of a fltexpr edge case, documented later
	# @todo add tests for ceil and floor
	# @todo add handling for these commented out rounding tests
	# @todo handle rounding with negative numbers correctly
	local inputs=('1 - 1' '1 - 1/2' '1 - 1/3' '1 - 1/4' '123456789 / 0.0987654321') # '0.005' '0.015' '0.025' '0.035' '0.045' '0.055')
	local expected_six=$'0.000000\n0.500000\n0.666667\n0.750000\n1249999988.609375' # \n0.005000\n0.015000\n0.025000\n0.035000\n0.045000\n0.055000'
	local expected_six_trim=$'0\n0.5\n0.666667\n0.75\n1249999988.609375'            # \n0.005\n0.015\n0.025\n0.035\n0.045\n0.055'
	local expected_two=$'0.00\n0.50\n0.67\n0.75\n1249999988.61'                     # \n0.01\n0.02\n0.03\n0.04\n0.05\n0.06'
	local expected_two_trim=$'0\n0.5\n0.67\n0.75\n1249999988.61'                    # \n0.01\n0.02\n0.03\n0.04\n0.05\n0.06'
	local expected_zero=$'0\n1\n1\n1\n1249999989'                                   # \n0\n0\n0\n0\n0\n0'
	function __test {
		local expected

		# this first one may install the tool, use --discard-tty to avoid dumping thousands of lines to the CI terminal, and --ignore-tty to avoid comparisons of the captured TTY data

		# --decimals=6
		# arguments
		eval-tester --discard-tty --ignore-tty --stdout="$expected_six_trim" -- \
			echo-math "$@" -- "${inputs[@]}"
		# stdin
		__print_lines "${inputs[@]}" |
			eval-tester --stdout="$expected_six_trim" -- \
				echo-math "$@" --stdin

		# --decimals=6
		# arguments
		eval-tester --discard-tty --ignore-tty --stdout="$expected_six" -- \
			echo-math --no-trim "$@" -- "${inputs[@]}"
		# stdin
		__print_lines "${inputs[@]}" |
			eval-tester --stdout="$expected_six" -- \
				echo-math --no-trim "$@" --stdin

		# --decimals=6
		# arguments
		eval-tester --discard-tty --ignore-tty --stdout="$expected_six" -- \
			echo-math --decimals=6 "$@" -- "${inputs[@]}"
		# stdin
		__print_lines "${inputs[@]}" |
			eval-tester --stdout="$expected_six" -- \
				echo-math --decimals=6 "$@" --stdin

		# --decimals=6 --trim
		# arguments
		eval-tester --discard-tty --ignore-tty --stdout="$expected_six_trim" -- \
			echo-math --trim "$@" -- "${inputs[@]}"
		# stdin
		__print_lines "${inputs[@]}" |
			eval-tester --stdout="$expected_six_trim" -- \
				echo-math --trim "$@" --stdin

		# --decimals=2
		# arguments
		eval-tester --stdout="$expected_two" -- \
			echo-math --decimals=2 "$@" -- "${inputs[@]}"
		# stdin
		__print_lines "${inputs[@]}" |
			eval-tester --stdout="$expected_two" -- \
				echo-math --decimals=2 "$@" --stdin

		# --decimals=2 --trim
		# arguments
		eval-tester --stdout="$expected_two_trim" -- \
			echo-math --decimals=2 --trim "$@" -- "${inputs[@]}"
		# stdin
		__print_lines "${inputs[@]}" |
			eval-tester --stdout="$expected_two_trim" -- \
				echo-math --decimals=2 --trim "$@" --stdin

		# --decimals=0
		# arguments
		eval-tester --stdout="$expected_zero" -- \
			echo-math --decimals=0 "$@" -- "${inputs[@]}"
		# stdin
		__print_lines "${inputs[@]}" |
			eval-tester --stdout="$expected_zero" -- \
				echo-math --decimals=0 "$@" --stdin
	}

	# run test with defaults
	__test

	# now run tests for each tool
	local tools=() tool benchmarks=()
	__split --target={tools} --no-zero-length --invoke=try -- \
		echo-math --only-print-tools
	if [[ ${#tools[@]} -eq 0 ]]; then
		__print_error "Failed to fetch available tools for [echo-math]."
		return 1
	fi
	for tool in "${tools[@]}"; do
		__test --tool="$tool"
		benchmarks+=("echo-math --tool=$tool -- '123456789 / 0.0987654321'")
	done

	# now run benchmarks
	# if __command_exists -- hyperfine; then
	# 	hyperfine --warmup 10 --runs 25 -- "${benchmarks[@]}"
	# fi

	return 0
)
function echo_math() (
	source "$DOROTHY/sources/stdinargs.bash"
	local all_tools=()
	if [[ $BASH_NATIVE_FLOATING_POINT == 'yes' ]]; then
		all_tools+=(bash)
	fi
	all_tools+=(awk gawk deno)
	# [bc] is removed, as it fails silently on debian systems

	# =====================================
	# Arguments

	function help {
		__print_help "$@" <<-EOF || return
			ABOUT:
			Compute a mathematical expression.

			USAGE:
			\`echo-math [...options] [--] ...<input>\`
			\`echo-lines ...<input> | echo-math [...options]\`

			OPTIONS:
			--rounding=<floor|ceil|nearest> | --floor | --ceil | --nearest
			    The rounding method to use. Defaults to <nearest>, which unfortunately is a bit ambiguous.
			    If specified, defaults <decimals> to \`0\`.
			--decimals=<decimals:integer>
			    The number of decimals for the result.
			    If <rounding> is not specified, defaults to \`6\`.
			--[no-]trim
			    If enabled, trims unnecessary trailing zeroes from the result.
			    If <decimals> is not specified, defaults to enabled.
			--integer
			    Alias for <decimals:0>.

			--tool=<tool:$(__join --source={all_tools} --delimiter='|')|?>
			    The tool to use. Use [?] to prompt. Default is the first available tool.

			$(__stdinargs__help_options --)
		EOF
		return 22 # EINVAL 22 Invalid argument
	}

	# process our own arguments, delegate everything else to stdinargs
	local item option_precision='' option_trim='' option_rounding='' option_tool='' only_print_tools=''
	while [[ $# -ne 0 ]]; do
		item="$1"
		shift
		case "$item" in
		'--help' | '-h') help ;;
		'--only-print-tools') only_print_tools='yes' ;;
		'--no-trim'* | '--trim'*) __flag --source={item} --target={option_trim} --affirmative --coerce ;;
		'--decimals='* | '--precision='*) option_precision="${item#*=}" ;;
		'--rounding='*) option_rounding="${item#*=}" ;;
		'--floor' | '--ceil' | '--nearest' | '--round') option_rounding="${item#--}" ;;
		'--integer') option_precision=0 ;;
		'--tool='*) option_tool="${item#*=}" ;;
		# forward to stdinargs, however support mixing and matching of our options, with stdinargs options
		'--')
			option_args+=("$item" "$@")
			shift $#
			break
			;;
		*) option_args+=("$item") ;;
		esac
	done

	# tool
	if [[ $only_print_tools == 'yes' ]]; then
		__print_lines "${all_tools[@]}"
		return 0
	fi
	__tool --tool={option_tool} --tools={all_tools} --help={help} || return

	# adjustments
	if [[ -n $option_rounding && -z $option_precision ]]; then
		option_precision=0
	fi
	if [[ -z $option_trim ]]; then
		if [[ -z $option_precision ]]; then
			option_trim='yes'
		else
			option_trim='no'
		fi
	fi
	if [[ -z $option_precision ]]; then
		option_precision=6
	fi
	if [[ $option_precision -lt 0 ]]; then
		help '<precision> must be a non-negative integer, it was: ' --variable-value={option_precision}
	fi
	if [[ -z $option_trim ]]; then
		option_trim='yes'
	fi
	if [[ -z $option_rounding || $option_rounding == 'round' ]]; then
		option_rounding='nearest'
	fi

	# =====================================
	# Action

	# bash: dynamic decimals by default
	# bc: 0 decimals by default
	# bc -l: 20 decimals by default
	# 0. becomes ., hence need for printf
	# awk: 6 decimals by default

	local precision_inner="$option_precision" precision_outer="$((option_precision + 1))"
	function __bash_failure {
		__print_error 'Failed to compute: ' --code="$(echo-quote --always=no -- "$@" | echo-join --stdin || :)" --newline \
			"With bash binary: " --code="$0" --newline \
			"With bash version: " --code="$BASH_VERSION" || :
		return 1
	}
	function __command_failure {
		# use echo-quote over echo-escape-command as echo-escape-command uses too many slashes
		# echo-quote: Failed to compute: awk -v precision=6 'BEGIN { printf "%." precision "f\n", / }'
		# echo-escape-command: Failed to compute: awk -v precision=6 BEGIN\ \{\ printf\ \"%.\"\ precision\ \"f\\n\"\,\ /\ \}
		__print_error 'Failed to compute: ' --code="$(echo-quote --always=no -- "$@" | echo-join --stdin || :)" --newline \
			"With $1 binary: " --code="$(type -P "$1" || :)" --newline \
			"With $1 version: " --code="$($1 --version 2>/dev/null || :)" || :
		return 1
	}
	function __command_wrap {
		REPLY="$("$@")" || __command_failure "$@" || return
	}
	function __round {
		local value="$REPLY" inner outer inner_size inner_last_index inner_last_char outer_size outer_last_index outer_last_char
		printf -v inner "%.${precision_inner}f" "$value" # 0.7 => 1
		printf -v outer "%.${precision_outer}f" "$value"
		inner_size="${#inner}"
		inner_last_index="$((inner_size - 1))"
		outer_size="${#outer}"
		outer_last_index="$((outer_size - 1))"
		# printf already rounds, so we have to undo rounding
		inner_last_char="${inner:inner_last_index:1}"
		outer_last_char="${outer:outer_last_index:1}"
		if [[ $option_rounding == 'nearest' ]]; then
			# fix this weird behaviour
			# `printf %.1f 0.55` => `0.6` (rounds up)
			# `printf %.0f 0.5` => `0` (rounds down)
			# however, it gets weirder, and we haven't solved this yet
			# `printf %.0f 0.005` => `0.01`
			# `printf %.0f 0.015` => `0.01`
			# `printf %.0f 0.025` => `0.03`
			# `printf %.0f 0.035` => `0.04`
			# `printf %.0f 0.045` => `0.04`
			# `printf %.0f 0.055` => `0.06`
			# __dump value inner outer inner_last_char outer_last_char >&2
			if [[ $outer_last_char -eq 5 ]]; then
				inner_last_char="$((inner_last_char + 1))"
				REPLY="${inner:0:inner_last_index}${inner_last_char}"
			else
				REPLY="$inner"
			fi
		elif [[ $option_rounding == 'floor' ]]; then
			if [[ $outer_last_char -ge 5 ]]; then
				inner_last_char="$((inner_last_char - 1))"
				REPLY="${inner:0:inner_last_index}${inner_last_char}"
			else
				REPLY="$inner"
			fi
		elif [[ $option_rounding == 'ceil' ]]; then
			if [[ $outer_last_char -ne 0 && $outer_last_char -le 5 ]]; then
				inner_last_char="$((inner_last_char + 1))"
				REPLY="${inner:0:inner_last_index}${inner_last_char}"
			else
				REPLY="$inner"
			fi
		else
			REPLY="$inner"
		fi
		# remove unnecessary trailing zeroes from inner
		if [[ $option_trim == 'yes' && $REPLY == *.* ]]; then
			while [[ $REPLY == *0 ]]; do
				REPLY="${REPLY%0}"
			done
			while [[ $REPLY == *. ]]; do
				REPLY="${REPLY%.}"
			done
		fi
		# trim
		printf '%s\n' "$REPLY"
	}

	# perl implementation (doesn't work on opensuse): https://gist.github.com/balupton/2a8ec0c004cb382895807ae71c6cef83
	if [[ $option_tool == 'bash' ]]; then
		function __on_piece {
			local formula="$1" REPLY=''
			# `fltexpr --help`:
			# Exit Status:
			# If the EXPRESSION evaluates to 0, the return status is 1; 0 otherwise.
			fltexpr "REPLY=$formula" || : # 5.3.3(1)-release has the unintuitive behaviour of if the result is zero, it will be assigned, however it will fail with exit status of 1:
			[[ -n $REPLY ]] || __bash_failure "$formula" || return
			__round || __bash_failure "$formula" || return
		}
	elif [[ $option_tool == 'bc' ]]; then
		function __on_piece {
			local formula="$1" REPLY=''
			__command_wrap bc --mathlib --no-prompt --no-read-prompt --standard --warn --expression="$formula" || return
			__round || return
		}
	elif [[ $option_tool == 'deno' ]]; then
		local deno_script
		deno_script="$(type -P echo-math.ts)"
		function __on_piece {
			local formula="$1" REPLY=''
			__command_wrap "$deno_script" "$precision_outer" "$formula" || return
			__round || return
		}
	elif [[ $option_tool == 'awk' || $option_tool == 'gawk' ]]; then
		function __on_piece {
			local formula="$1" REPLY=''
			__command_wrap "$option_tool" -v precision="$precision_outer" 'BEGIN { printf "%." precision "f\n", '"$formula"' }' || return
			__round || return
		}
	else
		return 19 # ENODEV 19 Operation not supported by device
	fi

	stdinargs "${option_args[@]}"
)

# fire if invoked standalone
if [[ $0 == "${BASH_SOURCE[0]}" ]]; then
	if [[ $* == '--test' ]]; then
		echo_math_test
	else
		echo_math "$@"
	fi
fi
