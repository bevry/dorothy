#!/usr/bin/env bash

# QUIRKS:
# - if there are more options than [$LINES - header], then this will fall apart

# TODOS:
# - [ ] limit the options output to [$LINES - header]
# - [ ] if one gets to $LINES, and there are truncated values, then scroll downwards
# - [ ] support $COLUMNS - if a menu item is larger than the column, then it will show all of it when active
# - [ ] ctrl n/p for navigating up/down.
# - [ ] `hjkl` vim arrow keys.

function choose_test() (
	source "$DOROTHY/sources/bash.bash"
	echo-segment --h1="TEST: $0"

	## choose-menu ##

	# timeout response not required
	eval-tester --name='timeout response not required' --status='60' --stderr='Read timed out [60], without selection.' \
		-- env NO_COLOR=yes choose --index --question='timeout response not required' --timeout=5 -- a b c

	# timeout response is required
	eval-tester --name='timeout response is required' --status='60' --stderr='Read timed out [60], without selection.' \
		-- env NO_COLOR=yes choose --index --question='timeout response is required' --timeout=5 --required -- a b c

	# default response
	{
		sleep 3
	} | eval-tester --name='default response' --stdout='1' --ignore-stderr \
		-- choose --index --question='default response' --timeout=2 --default=b -- a b c

	# default response should clear on movement
	{
		# move down and select second response
		sleep 3
		printf $'\eOB'
		sleep 3
	} | eval-tester --name='default response should clear on movement' --status='60' --stdout='' --ignore-stderr \
		-- choose --index --question='default response should clear on movement' --timeout=10 --default=b -- a b c

	# default multi response
	{
		sleep 3
	} | eval-tester --name='default multi response' --stdout=$'1\n2' --ignore-stderr \
		-- choose --index --question='default multi response' --timeout=2 --multi --default=b --default=c -- a b c

	# default multi response should not clear on movement
	{
		sleep 3
		printf $'\eOB'
		sleep 3
	} | eval-tester --name='default multi response should not clear on movement' --stdout=$'1\n2' --ignore-stderr \
		-- choose --index --question='default multi response should not clear on movement' --timeout=10 --multi --default=b --default=c -- a b c

	# multiline defaults
	{
		sleep 3
	} | eval-tester --name='default multiline response' --stdout=$'1\n2\n3' --ignore-stderr \
		-- choose --index --question='default multiline response' --timeout=2 --multi --default=$'b\nB' --defaults=$'c\nd' -- a $'b\nB' c d

	# first selection
	{
		sleep 3
		echo
	} | eval-tester --name='first response' --stdout='0' \
		-- choose --index --question='first selection' -- a b c

	# second selection
	{
		# move down and select second response
		sleep 3
		printf $'\eOB'
		sleep 3
		echo
	} | eval-tester --name='second response' --stdout='1' \
		-- choose --index --question='second selection' -- a b c

	# abort response via escape
	{
		# press escape key
		sleep 3
		printf $'\x1b'
	} | eval-tester --name='abort response via escape' \
		-- choose --index --question='abort response via escape' -- a b c

	## choose ##

	# timeout response not required
	eval-tester --name='timeout response not required' --status='0' --stderr=$'Read timed out [60], without selection.\nMenu timed out [60], no result, not required.' \
		-- env NO_COLOR=yes choose --question='timeout response not required' --timeout=5 -- a b c

	# timeout response is required
	eval-tester --name='timeout response is required' --status='60' --stderr=$'Read timed out [60], without selection.\nMenu timed out [60], no result, is required.' \
		-- env NO_COLOR=yes choose --question='timeout response is required' --timeout=5 --required -- a b c

	# default response
	{
		sleep 3
	} | eval-tester --name='default response' --stdout='b' --ignore-stderr \
		-- choose --question='default response' --timeout=2 --default=b -- a b c

	# default multi response
	{
		sleep 3
	} | eval-tester --name='default multi response' --stdout=$'b\nc' --ignore-stderr \
		-- choose --question='default multi response' --timeout=2 --multi --default=b --default=c -- a b c

	# first selection
	{
		sleep 3
		echo
	} | eval-tester --name='first selection' --stdout='a' \
		-- choose --question='first selection' -- a b c

	# second selection
	{
		# move down and select second response
		sleep 3
		printf $'\eOB'
		sleep 3
		echo
	} | eval-tester --name='second selection' --stdout='b' \
		-- choose --question='second selection' -- a b c

	# abort response via escape
	{
		# press escape key
		sleep 3
		printf $'\x1b'
	} | eval-tester --name='abort response via escape' \
		-- choose --question='abort response via escape' -- a b c

	echo-segment --g1="TEST: $0"
	return 0
)
function choose_() (
	source "$DOROTHY/sources/bash.bash"
	source "$DOROTHY/sources/tty.bash"
	__require_array 'mapfile'

	# =====================================
	# Arguments

	function help {
		cat <<-EOF >/dev/stderr
			ABOUT:
			Prompt the user to select an item from the menu, in a clean and robust way.

			USAGE:
			choose [...options] -- ...<item>

			OPTIONS:
			<question> | --question=<question>
			    Display this question in the prompt. If specified multiple times, they will be joined by newline, and only the first will be lingered.

			--label -- ...[<value> <label>]
			    Pass values and labels.

			--label=first -- ...[<label> <value>]
			    Pass values and labels, with the label first.

			--visual='\$LABEL' -- ...[<value> <label>]
			    Customise what is displayed to the user. It is eval'd. E.g.
			    To show label and value, use: --visual='\$LABEL [\$VALUE]'
			    If empty LABEL, then will equal VALUE.

			--return='\$VALUE' -- ...[<value> <label>]
			    Customise how the value is returned to the program. It is eval'd. E.g.
			    To return the visual, use: --return='\$VISUAL'
			    Tto return the index, use: --return='\$INDEX' or --index

			--default-exact=<value>
			--defaults-exact=<newline separated values>
			    Pre-select <value>s by exact matching.

			--default-fuzzy=<value>
			--defaults-fuzzy=<newline separated values>
			    Pre-select <value>s by fuzzy matching.

			--[no-]confirm=[yes|no]
			    Confirm the (default/entered) value(s) before continuing.

			--[no-]confirm-default=[YES|no] | --[no-]skip-default=[yes|NO]
			    Confirm the default value(s) (if provided) before continuing. Defaults to enabled.

			--[no-]confirm-input=[yes|NO]
			    Confirm the entered value(s) before continuing. Defaults to disabled.

			--[no-]required=[yes|NO]
			    Do not continue until a selection is made. Disable aborting the prompt.

			--[no-]multi=[yes|NO]
			    Multiple items can be selected.

			--[no-]hints=[YES|no]
			    Display interaction hint line.

			--[no-]linger=[yes|NO]
			    Whether the prompt should persist afterwards.

			--timeout=<timeout>
			    Custom timeout value in seconds.

			QUIRKS:
			If you wish to return the index, which is desirable in the case of when multiple values can be identical, use --index or --return='\$INDEX'.
		EOF
		if test "$#" -ne 0; then
			echo-error "$@"
		fi
		return 22 # EINVAL 22 Invalid argument
	}

	# process
	local item='' inputs=() tmp=()
	local option_question=()
	# trunk-ignore(shellcheck/SC2016)
	local option_label='no' option_visual='' option_return='$VALUE'
	local defaults_exact=() defaults_fuzzy=() option_confirm_default='yes' option_confirm_input='no'
	local option_required='no' option_multi='no'
	local option_linger='no' option_timeout=''
	local use_colors
	use_colors="$(echo-color-enabled --fallback=yes -- "$@")"
	while test "$#" -ne 0; do
		item="$1"
		shift
		case "$item" in
		'--help' | '-h') help ;;
		'--no-color'* | '--color'*) ;; # handled by echo-color-enabled
		'--question='*) option_question+=("${item#*=}") ;;
		'--no-label'* | '--label'*)
			# label can be 'yes', 'no', and 'first'
			option_label="$(get-flag-value --fallback="$option_label" -- "$item")"
			;;
		'--visual='*) option_visual="${item#*=}" ;;
		'--return='*) option_return="${item#*=}" ;;
		# trunk-ignore(shellcheck/SC2016)
		'--index') option_return='$INDEX' ;;
		'--default-exact='* | '--default='*) defaults_exact+=("${item#*=}") ;;
		'--defaults-exact='* | '--defaults='*)
			mapfile -t tmp <<<"${item#*=}"
			defaults_exact+=("${tmp[@]}")
			;;
		'--default-fuzzy='*) defaults_fuzzy+=("${item#*=}") ;;
		'--defaults-fuzzy='*)
			mapfile -t tmp <<<"${item#*=}"
			defaults_fuzzy+=("${tmp[@]}")
			;;
		'--no-skip-default'* | '--skip-default'*)
			option_confirm_default="$(get-flag-value --non-affirmative --fallback="$option_confirm_default" -- "$item")"
			;;
		'--no-confirm-default'* | '--confirm-default'*)
			option_confirm_default="$(get-flag-value --affirmative --fallback="$option_confirm_default" -- "$item")"
			;;
		'--no-confirm-input'* | '--confirm-input'*)
			option_confirm_input="$(get-flag-value --affirmative --fallback="$option_confirm_input" -- "$item")"
			;;
		'--no-confirm'* | '--confirm'*)
			option_confirm_default="$(get-flag-value --affirmative --fallback="$option_confirm_default" -- "$item")"
			option_confirm_input="$(get-flag-value --affirmative --fallback="$option_confirm_input" -- "$item")"
			;;
		'--no-required'* | '--required'*)
			option_required="$(get-flag-value --affirmative --fallback="$option_required" -- "$item")"
			;;
		'--no-multi'* | '--multi'*)
			option_multi="$(get-flag-value --affirmative --fallback="$option_multi" -- "$item")"
			;;
		'--no-linger'* | '--linger'*)
			option_linger="$(get-flag-value --affirmative --fallback="$option_linger" -- "$item")"
			;;
		'--timeout='*) option_timeout="${item#*=}" ;;
		'--')
			inputs+=("$@")
			shift $#
			break
			;;
		'--'*) help "An unrecognised flag was provided: $item" ;;
		*) option_question+=("$item") ;;
		esac
	done

	# ensure items were provided
	if test "${#inputs[@]}" -eq 0; then
		help 'No <item>s provided.'
	fi

	# styles for items:
	# one hollow circle: ‚ö¨ ‚óã ‚óØ ‚ùç
	# two hollow circles: ‚óé ‚¶æ ‚äö
	# one hollow, one full: ‚òâ ‚¶ø ‚óâ
	# one full: ‚óè
	# ‚ñ£ ‚ñ¢ ‚ñ° ‚ä°
	# ‚òë ‚òí ‚åß
	# ‚úì ‚úî ‚úñ  ‚úó  ‚úò
	#
	# conclusions for cursor:
	# doesn't space correctly in Terminal: ‚∏ª
	# too small: ‚Üí ‚òû ‚û°
	# too unclear: ‚ñ∫
	# gets turned into an emoji: ‚û°Ô∏è
	# other options: ‚ñ∂‚ñ∑‚ñ∏‚ñπ‚èµ‚Øà
	local \
		_temp \
		color_reset \
		color_bold \
		color_dim \
		color_underline \
		color_invert \
		color_framed \
		color_background_intense_white \
		color_background_white \
		color_disable_background \
		color_disable_foreground \
		color_disable_framed \
		color_disable_intensity \
		color_disable_invert \
		color_foreground_black \
		color_foreground_green \
		color_foreground_intense_green \
		color_foreground_intense_magenta \
		color_foreground_intense_yellow \
		color_foreground_white \
		color_foreground_yellow \
		icon_active \
		icon_default \
		icon_standard \
		style_help_begin \
		style_help_end \
		style_key_begin \
		style_key_begin \
		style_key_end \
		style_key_end \
		style_key_indent='  '
	if test "$use_colors" = 'no'; then
		color_reset=''
		color_bold=''
		color_dim=''
		color_underline=''
		color_disable_intensity=''
		color_invert=''
		color_framed=''
		color_disable_background=''
		color_disable_foreground=''
		color_disable_framed=''
		color_disable_invert=''
		color_foreground_black=''
		color_foreground_green=''
		color_foreground_intense_black=''
		color_foreground_intense_green=''
		color_foreground_intense_magenta=''
		color_foreground_intense_yellow=''
		color_foreground_white=''
		color_foreground_yellow=''
		style_help_begin=''
		style_help_end=''
		style_key_begin='['
		style_key_end=']'
	else
		color_reset=$'\e[0m'
		color_bold=$'\e[1m'
		color_dim=$'\e[2m'
		color_underline=$'\e[4m'
		color_disable_intensity=$'\e[22m'
		color_invert=$'\e[7m'
		color_framed=$'\e[51m'
		color_disable_background=$'\e[49m'
		color_disable_foreground=$'\e[39m'
		color_disable_framed=$'\e[54m'
		color_disable_invert=$'\e[27m'
		color_foreground_black=$'\e[30m'
		color_foreground_green=$'\e[32m'
		color_foreground_intense_black=$'\e[90m'
		color_foreground_intense_green=$'\e[92m'
		color_foreground_intense_magenta=$'\e[95m'
		color_foreground_intense_yellow=$'\e[93m'
		color_foreground_white=$'\e[37m'
		color_foreground_yellow=$'\e[33m'
		color_background_white=$'\e[47m'
		color_background_intense_white=$'\e[107m'
		style_help_begin="$color_dim"
		style_help_end="$color_reset"
		if test "$(get-terminal-theme || :)" = 'dark'; then
			style_key_begin="${color_foreground_black}${color_background_white} "
		else
			style_key_begin="${color_background_intense_white} " # foreground default black, background intense white
		fi
		style_key_end=" $color_reset"
	fi
	if test "$option_multi" = 'yes'; then
		icon_selected='‚ñ£'
		icon_default='‚ä°'
		icon_active='‚ä°'
		icon_standard='‚ñ°'
	else
		icon_selected='‚¶ø' # only used in confirmation and linger
		icon_default='‚¶æ'
		if test "$option_required" = 'yes'; then
			icon_active='‚óâ'
		else
			icon_active='‚¶ø'
		fi
		icon_standard='‚óã'
	fi
	function render_key {
		local result
		result="${style_help_begin}$1${style_help_end}  "
		shift
		while test "$#" -ne 0; do
			result+="${style_key_begin}$1${style_key_end}"
			shift
			if test "$#" -ne 0; then
				result+=' '
			fi
		done
		__print_line "$result"
	}
	function indent_key {
		__print_line "${style_key_indent}$(render_key "$@")"
	}

	# adjust question
	local question_title question_with_body
	if test "${#option_question[@]}" -ne 0; then # bash v3 compat
		if test -n "${option_question[0]}"; then
			question_title="$color_underline$color_bold${option_question[0]}$color_reset"
			question_with_body="$(__print_lines "$question_title" "${option_question[@]:1}")"
		else
			question_title="$(__print_lines "${option_question[@]:1}")"
			question_with_body="$question_title"
		fi
	else
		question_title=''
		question_with_body=''
	fi

	# enforce question if lingering
	if test "$option_linger" = 'yes' -a -z "$question_title"; then
		help 'A <question >is required when using --linger'
	fi

	# generic helpers
	function __fuzzy_haystack_needle {
		local haystack="$1" needle="$2"
		[[ "$(__lowercase_string "$haystack")" == *"$(__lowercase_string "$needle")"* ]]
	}

	# prepare label handling
	local inputs_step=1
	if test "$option_label" != 'no'; then
		# because of labels, we will iterate items two at a time
		inputs_step=2

		# verify we have a label for each value
		if is-odd -- "${#inputs[@]}"; then
			{
				echo-style --colors="$use_colors" --error="The amount of <label>s must match the amount of <value>s. See [$0 --help] for usage." $'\n' --bold='Make the below provide an even amount of items, to ensure there is a each \
			\
			be style_key_indented properly, use fmt if it exists in this mode for item <label >for <value >.'
				echo-verbose -- "${inputs[@]}"
			} >/dev/stderr
			return 22 # EINVAL 22 Invalid argument
		fi
	fi

	# generate the items
	# @todo add support for option_default_indexes if a user requests it
	local index item INDEX=-1 VALUE LABEL VISUAL RETURN items=() returns=() defaults=() default_indexes=() defaults_count=0 defaults_last_index=-1
	for ((index = 0; index < ${#inputs[@]}; index = index + inputs_step)); do
		# index considers inputs_step, INDEX is only each item (label/value combo)
		INDEX=$((INDEX + 1))

		# order of
		if test "$option_label" = 'no'; then
			VALUE="${inputs[index]}"
			LABEL="$VALUE"
			if test -z "$VALUE"; then
				echo-style --colors="$use_colors" --error="The $INDEX item at index $index was empty, all items must be non-empty." >/dev/stderr
				return 22 # EINVAL 22 Invalid argument
			fi
		else
			if test "$option_label" = 'yes'; then
				VALUE="${inputs[index]}"
				LABEL="${inputs[index + 1]}"
			elif test "$option_label" = 'first'; then
				VALUE="${inputs[index + 1]}"
				LABEL="${inputs[index]}"
			else
				echo-style --colors="$use_colors" --error="Invalid label option [$option_label], it must be no, yes, or first" >/dev/stderr
				return 22 # EINVAL 22 Invalid argument
			fi
			if test -z "$LABEL" -o -z "$VALUE"; then
				echo-style --colors="$use_colors" --error="Invalid label=[$LABEL] value=[$VALUE] combination, both must be non-empty" >/dev/stderr
				return 22 # EINVAL 22 Invalid argument
			fi
		fi

		# enable if default
		if test "${#defaults_exact[@]}" -ne 0; then # bash v3 compat
			for item in "${defaults_exact[@]}"; do
				if test "$VALUE" = "$item"; then
					defaults[INDEX]='yes'
				fi
			done
		elif test "${#defaults_fuzzy[@]}" -ne 0; then # bash v3 compat
			for item in "${defaults_fuzzy[@]}"; do
				if __fuzzy_haystack_needle "$VALUE" "$item"; then
					defaults[INDEX]='yes'
				fi
			done
		fi

		# generate what is used
		if test -n "$option_visual"; then
			eval "VISUAL=\"$option_visual\""
		else
			VISUAL="$LABEL"
		fi
		if test -z "$VISUAL"; then
			echo-style --colors="$use_colors" --error="Invalid visual=[$VISUAL] for label=[$LABEL] value=[$VALUE], all must be non-empty" >/dev/stderr
			return 22 # EINVAL 22 Invalid argument
		fi
		if test -n "$option_return"; then
			eval "RETURN=\"$option_return\""
		else
			RETURN="$VALUE"
		fi
		if test -z "$RETURN"; then
			echo-style --colors="$use_colors" --error="Invalid return=[$RETURN] for label=[$LABEL] value=[$VALUE], all must be non-empty" >/dev/stderr
			return 22 # EINVAL 22 Invalid argument
		fi
		items+=("$VISUAL")
		returns+=("$RETURN")
	done
	defaults_count="${#defaults[@]}"
	default_indexes=("${!defaults[@]}")

	# handle default options
	local can_revert_to_defaults can_cancel
	if test "$defaults_count" -ne 0; then
		defaults_last_index="$((defaults_count - 1))"
		can_revert_to_defaults='yes'
		can_cancel='yes'
	else
		can_revert_to_defaults='no'
		if test "$option_required" = 'no'; then
			can_cancel='yes'
		else
			can_cancel='no'
		fi
	fi

	# prepare menu vars
	local \
		bin_gfmt='' \
		bin_gfold='' \
		bin_gwc='' \
		commentary='' \
		items_last_index \
		items_count="${#items[@]}" \
		menu_bottom_index_choose=0 \
		menu_bottom_index_confirm=0 \
		menu_cursor_choose=0 \
		menu_cursor_confirm=0 \
		menu_direction=1 \
		menu_header_shrunk='' \
		menu_header_size \
		menu_header='' \
		menu_skip_render='no' \
		menu_hint_extras_cancel='' \
		menu_hint_extras_choose='' \
		menu_hint_extras_confirm='' \
		menu_hint_main_choose='' \
		menu_hint_main_confirm='' \
		menu_hint_render_cancel='' \
		menu_hint_render_choose='' \
		menu_hint_render_confirm='' \
		menu_hint_size_cancel \
		menu_hint_size_choose \
		menu_hint_size_confirm \
		menu_mode='choose' \
		menu_status=0 \
		menu_top_index_choose=0 \
		menu_top_index_confirm=0 \
		paging_supported='yes' \
		paging_used \
		renders=() \
		size_columns_prior=0 \
		size_columns=80 \
		size_content=75 \
		size_rows_prior=0 \
		size_rows=10 \
		sizes=() \
		tty_target
	items_last_index="$((items_count - 1))"
	mapfile -t renders < <(get-array "$items_count")
	mapfile -t sizes < <(get-array "$items_count")

	# prepare paging
	tty_target="$(is-tty --fallback)"
	if test "$tty_target" = '/dev/stderr' || command-missing tput; then
		# fix [tput: No value for $TERM and no -T specified] errors when fetching columns and rows on CI
		paging_supported='no'
	# @todo multi-line items won't
	else
		if is-mac; then
			bin_gfold="$(type -P 'gfold' 2>/dev/null || :)"
			bin_gfmt="$(type -P 'gfmt' 2>/dev/null || :)"
			bin_gwc="$(type -P 'gwc' 2>/dev/null || :)"
		else
			# we could support these on macos, however fmt does not support -t on macos (it is something different, so we'd have to manually do that)
			bin_gfold="$(type -P 'fold' 2>/dev/null || :)"
			bin_gfmt="$(type -P 'fmt' 2>/dev/null || :)"
			bin_gwc="$(type -P 'wc' 2>/dev/null || :)"
		fi
		if test -z "$bin_gfold" -o -z "$bin_gfmt" -o -z "$bin_gwc"; then
			paging_supported='no'
			# don't bother installing, as that will require brew, and we might now yet have brew installed
		fi
	fi

	# prepare hints
	# prefer key names if possible, as people don't know the symbols
	if test "$option_multi" = 'yes'; then
		menu_hint_main_cancel+="$(render_key 'CONFIRM CANCELATION' 'ENTER' 'E')"
		menu_hint_main_choose+="$(render_key 'SELECT' 'SPACE')"
		menu_hint_main_choose+="$(indent_key 'CONFIRM' 'ENTER' 'E')"
		menu_hint_main_confirm+="$(render_key 'CONFIRM SELECTION' 'ENTER' 'E')"
	else
		menu_hint_main_cancel+="$(render_key 'CONFIRM CANCELATION' 'SPACE' 'ENTER' 'E')"
		menu_hint_main_choose+="$(render_key 'SELECT' 'SPACE' 'ENTER' 'E')"
		menu_hint_main_confirm+="$(render_key 'CONFIRM SELECTION' 'SPACE' 'ENTER' 'E')"
	fi
	menu_hint_main_cancel+="$(indent_key 'ABORT CANCELATION' 'ESC' 'Q')"
	menu_hint_main_confirm+="$(indent_key 'CHANGE SELECTION' 'ESC' 'Q')"
	_temp="$(indent_key 'ABORT' 'CTRL C')"
	menu_hint_extras_cancel+="$_temp"
	menu_hint_extras_confirm+="$_temp"
	if test "$can_cancel" = 'yes'; then
		# cancel restores defaults (if multi) or selects none (if non-multi) and leaves
		menu_hint_main_choose+="$(indent_key 'CANCEL' 'ESC' 'Q')"
	fi
	if test "$items_count" -ne 1; then
		# [‚¨Ü‚¨á‚áß] have alignment issues, use [‚Üë‚Üì]
		_temp="$(indent_key 'UP' '‚Üë' 'W' 'K')"
		_temp+="$(indent_key 'DOWN' '‚Üì' 'S' 'J')"
		menu_hint_main_choose+="$_temp"
		menu_hint_extras_cancel+="$_temp"
		menu_hint_extras_confirm+="$_temp"
		# comment out self-explanatory keys
		# menu_hint_extras_choose+="$(indent_key 'FIRST' 'HOME', 'fn ‚áß ‚Üë')"
		# menu_hint_extras_choose+="$(indent_key 'LAST' 'END', 'fn ‚áß ‚Üì')"
		# menu_hint_extras_choose+="$(indent_key 'PAGE UP' '‚Üê' 'A' 'H')"
		# menu_hint_extras_choose+="$(indent_key 'PAGE DOWN' '‚Üí' 'D' 'L')"
		if test "$option_multi" = 'yes'; then
			# comment out self-explanatory keys
			# menu_hint_extras_choose+="$(indent_key 'SELECT & NEXT' '+' 'INSERT')"
			# menu_hint_extras_choose+="$(indent_key 'SELECT & PREV' '-')"
			# menu_hint_extras_choose+="$(indent_key 'UNSELECT & NEXT' 'DELETE')"
			# menu_hint_extras_choose+="$(indent_key 'UNSELECT & PREV' 'BACKSPACE')"
			menu_hint_extras_choose+="$(indent_key 'ALL/NONE' 'T')"
		fi
	fi
	if test "$can_revert_to_defaults" = 'yes'; then
		menu_hint_extras_choose+="$(indent_key 'NEXT PREF' 'TAB')"   # next preference
		menu_hint_extras_choose+="$(indent_key 'PREV PREF' '‚áß TAB')" # prior preference
		menu_hint_extras_choose+="$(indent_key 'RESET' 'Z')"         # reset preferences
	fi
	if test -n "$question_with_body"; then
		# @todo only bold the first question line
		menu_header="$question_with_body"$'\n'
	fi
	# @todo: FILTER [asd] SHOWING [2] HIDING [19] TOTAL [21] TOGGLE [F]

	# this is too slow to recalculate on each interaction
	# @todo why isn't this called?
	function refresh_menu_hint {
		local which="$1" main extras render cleaned size
		if test "$which" = 'choose'; then
			main="$menu_hint_main_choose"
			extras="$menu_hint_extras_choose"
		elif test "$which" = 'cancel'; then
			main="$menu_hint_main_cancel"
			extras="$menu_hint_extras_cancel"
		else
			main="$menu_hint_main_confirm"
			extras="$menu_hint_extras_confirm"
		fi
		# see if the hint supports exctras
		render="$main$extras"
		cleaned="$(echo-trim-colors -- "$render" | "$bin_gfold" -w "$size_columns")"
		size="$("$bin_gwc" -l <<<"${cleaned}")"
		if test "$size" -gt 1; then
			# the menu hint does not have enough room for extras
			render="$main"
			cleaned="$(echo-trim-colors -- "$render" | "$bin_gfold" -w "$size_columns")"
			size="$("$bin_gwc" -l <<<"${cleaned}")"
		fi
		# apply
		if test "$which" = 'choose'; then
			menu_hint_render_choose="$render"
			menu_hint_size_choose="$size"
		elif test "$which" = 'cancel'; then
			menu_hint_render_cancel="$render"
			menu_hint_size_cancel="$size"
		else
			menu_hint_render_confirm="$render"
			menu_hint_size_confirm="$size"
		fi
	}
	function refresh_terminal_size {
		if test "$paging_supported" = 'no'; then
			paging_used='no'
			menu_hint_render_cancel="$menu_hint_main_cancel"
			menu_hint_render_choose="$menu_hint_main_confirm"
			menu_hint_render_confirm="$menu_hint_main_confirm"
			menu_hint_size_cancel=0
			menu_hint_size_choose=0
			menu_hint_size_confirm=0
		else
			size_rows="$(tput lines)"
			size_columns="$(tput cols)"
			# only recalculate everything if the size actually changed from last time
			if test "$size_rows" -ne "$size_rows_prior" -o "$size_columns" -ne "$size_columns_prior"; then
				size_content="$((size_columns - 5))"
				# calculate menu header size
				menu_header_shrunk="$(echo-trim-colors -- "$menu_header" | "$bin_gfold" -w "$size_columns")"
				menu_header_size="$("$bin_gwc" -l <<<"${menu_header_shrunk}")"
				# see if the hint supports exctras
				refresh_menu_hint 'cancel'
				refresh_menu_hint 'choose'
				refresh_menu_hint 'confirm'
				# move start index to current item, as otherwise it could be out of range
				if test "$size_rows" -lt "$size_rows_prior" -o "$size_columns" -lt "$size_columns_prior"; then
					# @todo we should detect if showing everything is possible before resorting to this
					menu_top_index_choose="$menu_cursor_choose"
					menu_bottom_index_choose="$menu_cursor_choose"
					menu_top_index_confirm="$menu_cursor_confirm"
					menu_bottom_index_confirm="$menu_cursor_confirm"
				fi
				# reset paging for new size
				paging_used='maybe'
				mapfile -t renders < <(get-array "$items_count")
				mapfile -t sizes < <(get-array "$items_count")
				# update priors
				size_rows_prior="$size_rows"
				size_columns_prior="$size_columns"
			fi
		fi
	}

	# actions and selection modifications
	local selected=() selected_indexes=() selected_count=0 selected_last_index=-1
	function select_none {
		selected=()
		selected_indexes=()
		selected_count=0
		selected_last_index=-1
	}
	if test "$option_multi" = 'yes'; then
		function unselect_index {
			local index
			for index in "$@"; do
				if test "${selected[index]-}" = 'yes'; then
					unset 'selected[index]'
				fi
			done
			selected_indexes=("${!selected[@]}")
			selected_count="${#selected[@]}"
			selected_last_index="$((selected_count - 1))"
		}
		function select_index {
			local index
			for index in "$@"; do
				if test "${selected[index]-}" != 'yes'; then
					selected[index]='yes'
				fi
			done
			selected_indexes=("${!selected[@]}")
			selected_count="${#selected[@]}"
			selected_last_index="$((selected_count - 1))"
		}
		function toggle_index {
			local index
			for index in "$@"; do
				if test "${selected[index]-}" = 'yes'; then
					unset 'selected[index]'
				else
					selected[index]='yes'
				fi
			done
			selected_indexes=("${!selected[@]}")
			selected_count="${#selected[@]}"
			selected_last_index="$((selected_count - 1))"
		}
		function select_all {
			select_index "${!items[@]}"
		}
		function select_defaults {
			if test "$defaults_count" -ne 0; then # bash v3 compat
				select_index "${default_indexes[@]}"
			fi
		}
		function action_toggle_cursor {
			if test "$menu_mode" = 'choose'; then
				toggle_index "$menu_cursor_choose"
				if test "$menu_cursor_choose" -eq "$menu_bottom_index_choose"; then
					# don't cause a new page, instead keep rendering it as the bottom item
					menu_direction=-1
				fi
			else
				toggle_index "$menu_cursor_confirm"
				if test "$menu_cursor_confirm" -eq "$menu_bottom_index_confirm"; then
					# don't cause a new page, instead keep rendering it as the bottom item
					menu_direction=-1
				fi
			fi
		}
		function action_select_and_next {
			if test "$menu_mode" = 'choose'; then
				select_index "$menu_cursor_choose"
			else
				select_index "$menu_cursor_confirm"
			fi
			action_down
		}
		function action_unselect_and_next {
			if test "$menu_mode" = 'choose'; then
				unselect_index "$menu_cursor_choose"
			else
				unselect_index "$menu_cursor_confirm"
			fi
			action_down
		}
		function action_select_and_prior {
			if test "$menu_mode" = 'choose'; then
				select_index "$menu_cursor_choose"
			else
				select_index "$menu_cursor_confirm"
			fi
			action_up
		}
		function action_unselect_and_prior {
			if test "$menu_mode" = 'choose'; then
				unselect_index "$menu_cursor_choose"
			else
				unselect_index "$menu_cursor_confirm"
			fi
			action_up
		}
		function action_all {
			select_all
		}
	else
		function select_only_index {
			if test "$#" -ne 0; then
				selected=()
				selected["$1"]='yes'
				selected_indexes=("${selected_indexes[@]}")
				selected_count=1
				selected_last_index=0
				menu_cursor_choose="$1"
				menu_cursor_confirm=0
			fi
		}
		function select_defaults {
			# select only first preference
			if test "$defaults_count" -ne 0; then
				select_only_index "${default_indexes[0]}"
			fi
		}
		function action_select_cursor {
			if test "$menu_mode" = 'choose'; then
				select_only_index "$menu_cursor_choose"
			else
				select_only_index "$menu_cursor_confirm"
			fi
		}
	fi
	function select_only_defaults {
		select_none # needed in case there are no defaults, we still want to erase selection
		select_defaults
	}
	function action_none {
		select_none
	}
	# function action_enable_defaults { # this isn't actually an action....
	# 	select_defaults
	# }
	function action_revert {
		# if no defaults, removes selection
		select_none
		select_defaults
	}
	function action_jump {
		local index="$1"
		# jump to number
		if test "$menu_mode" = 'choose'; then
			if test "$index" -le 1; then
				menu_cursor_choose=0
			elif test "$index" -ge "$items_count"; then
				menu_cursor_choose="$items_last_index"
			else
				menu_cursor_choose="$((index - 1))"
			fi
		else
			if test "$index" -le 1; then
				menu_cursor_confirm=0
			elif test "$index" -ge "$selected_count"; then
				menu_cursor_confirm="$selected_last_index"
			else
				menu_cursor_confirm="$((index - 1))"
			fi
		fi

	}
	function action_up {
		if test "$menu_mode" = 'choose'; then
			if test "$menu_cursor_choose" -le 0; then
				menu_cursor_choose="$items_last_index"
			else
				menu_cursor_choose="$((menu_cursor_choose - 1))"
			fi
		else
			if test "$menu_cursor_confirm" -le 0; then
				menu_cursor_confirm="$selected_last_index"
			else
				menu_cursor_confirm="$((menu_cursor_confirm - 1))"
			fi
		fi
	}
	function action_down {
		if test "$menu_mode" = 'choose'; then
			if test "$menu_cursor_choose" -ge "$items_last_index"; then
				menu_cursor_choose=0
			else
				menu_cursor_choose="$((menu_cursor_choose + 1))"
				if test "$menu_cursor_choose" -ge "$menu_bottom_index_choose"; then
					# scroll down by one, rather than render whole new page
					menu_direction=-1
				fi
			fi
		else
			if test "$menu_cursor_confirm" -ge "$selected_last_index"; then
				menu_cursor_confirm=0
			else
				menu_cursor_confirm="$((menu_cursor_confirm + 1))"
				if test "$menu_cursor_confirm" -ge "$menu_bottom_index_confirm"; then
					# scroll down by one, rather than render whole new page
					menu_direction=-1
				fi
			fi
		fi
	}
	function action_page_up {
		if test "$menu_mode" = 'choose'; then
			if test "$menu_cursor_choose" -le "$menu_top_index_choose"; then
				menu_direction=-1
			else
				menu_cursor_choose="$menu_top_index_choose"
			fi
		else
			if test "$menu_cursor_confirm" -le "$menu_top_index_confirm"; then
				menu_direction=-1
			else
				menu_cursor_confirm="$menu_top_index_confirm"
			fi
		fi
	}
	function action_page_down {
		if test "$menu_mode" = 'choose'; then
			if test "$menu_cursor_choose" -ge "$menu_bottom_index_choose"; then
				menu_direction=1
			else
				menu_cursor_choose="$menu_bottom_index_choose"
				menu_direction=-1
			fi
		else
			if test "$menu_cursor_confirm" -ge "$menu_bottom_index_confirm"; then
				menu_direction=1
			else
				menu_cursor_confirm="$menu_bottom_index_confirm"
				menu_direction=-1
			fi
		fi
	}
	function action_first {
		if test "$menu_mode" = 'choose'; then
			menu_cursor_choose=0
		else
			menu_cursor_confirm=0
		fi
	}
	function action_last {
		if test "$menu_mode" = 'choose'; then
			menu_cursor_choose="$items_last_index"
		else
			menu_cursor_confirm="$selected_last_index"
		fi
	}
	function is_preference {
		local index="$1"
		test "${selected[index]-}" = 'yes' -o "${defaults[index]-}" = 'yes'
	}
	function action_next_preference {
		if test "$menu_mode" != 'choose'; then
			action_down
			return
		fi
		local index
		# next selection
		for ((index = menu_cursor_choose + 1; index <= items_last_index; index++)); do
			if is_preference "$index"; then
				menu_cursor_choose="$index"
				return 0
			fi
		done
		# earlier selection
		for ((index = 0; index < menu_cursor_choose; index++)); do
			if is_preference "$index"; then
				menu_cursor_choose="$index"
				return 0
			fi
		done
		# no selection
		return 0
	}
	function action_prior_preference {
		if test "$menu_mode" != 'choose'; then
			action_up
			return
		fi
		local index
		# go backwards to the start
		for ((index = menu_cursor_choose - 1; index >= 0; index--)); do
			if is_preference "$index"; then
				menu_cursor_choose="$index"
				return 0
			fi
		done
		# go backwards from the end
		for ((index = items_last_index; index > menu_cursor_choose; index--)); do
			if is_preference "$index"; then
				menu_cursor_choose="$index"
				return 0
			fi
		done
		# no selection
		return 0
	}
	function set_menu_mode {
		local new="$1"
		# sanity check if confirm is appropriate
		if test "$new" = 'confirm' -a "$option_required" = 'yes' -a "$selected_count" -eq 0; then
			menu_skip_render='yes'
			menu_mode='choose'
			return 0
		fi
		# check if we need to recalculate paging and update the mode
		if test "$new" != "$menu_mode"; then
			paging_used='maybe'
			menu_mode="$new"
			if test "$new" != 'choose'; then
				# reset cursor
				menu_cursor_confirm=0
			fi
		fi
		# all done
		return 0
	}
	local debug_counter=0
	function render_menu {
		local \
			item_index=0 \
			item_line \
			item_original \
			item_rendered \
			item_size \
			items_bundled_size=0 \
			items_bundled='' \
			line_prefix \
			line_style \
			menu_bottom_index \
			menu_cursor \
			menu_hint_render \
			menu_hint_size \
			menu_index=0 \
			menu_total \
			menu_last_index \
			menu_size=0 \
			menu_title='' \
			menu_top_index \
			verb
		# refresh the terminal size
		refresh_terminal_size
		# fetch the appropriate size, must be done after refresh_terminal_size
		if test "$menu_mode" = 'choose'; then
			verb='Selected'
			menu_bottom_index="$menu_bottom_index_choose"
			menu_cursor="$menu_cursor_choose"
			menu_hint_render="$menu_hint_render_choose"
			menu_hint_size="$menu_hint_size_choose"
			menu_total="$items_count"
			menu_last_index="$items_last_index"
			menu_top_index="$menu_top_index_choose"
		else
			if test "$menu_mode" = 'cancel'; then
				verb='Cancel to'
				menu_total="$defaults_count"
				menu_last_index="$defaults_last_index"
				menu_hint_render="$menu_hint_render_cancel"
				menu_hint_size="$menu_hint_size_cancel"
			else
				verb='Confirm'
				menu_total="$selected_count"
				menu_last_index="$selected_last_index"
				menu_hint_render="$menu_hint_render_confirm"
				menu_hint_size="$menu_hint_size_confirm"
			fi
			# @todo, consider having these and cursors for cancel as well, instead of sharing with confirm
			menu_bottom_index="$menu_bottom_index_confirm"
			menu_cursor="$menu_cursor_confirm"
			menu_top_index="$menu_top_index_confirm"
		fi
		# adjust page direction
		if test "$menu_cursor" -le 0; then
			menu_cursor=0
			menu_index="$menu_cursor"
			menu_direction=1
		elif test "$menu_cursor" -ge "$menu_last_index"; then
			menu_cursor="$menu_last_index"
			menu_index="$menu_cursor"
			menu_direction=-1
		elif test "$menu_cursor" -le "$menu_top_index"; then
			menu_index="$menu_cursor"
		elif test "$menu_cursor" -ge "$menu_bottom_index"; then
			menu_index="$menu_cursor"
		elif test "$menu_direction" -eq 1; then
			# maintain the same page, as the cursor is within it
			menu_index="$menu_top_index"
		else
			# maintain the same page, as the cursor is within it
			menu_index="$menu_bottom_index"
		fi
		# @TODO HANDLE NO SELECTED OPTIONS BETTER, PERHAPS AN IF HERE
		menu_top_index="$menu_index"
		menu_bottom_index="$menu_index"
		# debug
		function debug {
			printf '%s' $'\e]0;'"c=$menu_cursor,mi=$menu_index,ii=$item_index,d=$menu_direction,t=$menu_top_index,b=$menu_bottom_index,l=$menu_last_index,u=$paging_used,s=$menu_size,r=$size_rows,c=$debug_counter"$'\a' >"$tty_target"
			debug_counter="$((debug_counter + 1))"
		}
		# e.g. go to second page, navigate half way, go page up
		local page_visible_selected_count=0 page_visible_unselected_defaults_count=0
		for (( ; menu_index >= 0 && menu_index <= menu_last_index; menu_index += menu_direction)); do
			if test "$menu_mode" = 'choose'; then
				item_index="$menu_index"
			elif test "$menu_mode" = 'cancel'; then
				item_index="${default_indexes[menu_index]}"
			else
				item_index="${selected_indexes[menu_index]}"
			fi
			# determine prefix
			line_prefix=''
			line_style=''
			if test "$menu_index" -eq "$menu_cursor"; then
				line_style+="$color_invert"
				line_prefix+='‚èµ  '
			else
				line_prefix+='   '
			fi
			if test "${selected[item_index]-}" = 'yes' -a "$menu_mode" != 'cancel'; then
				line_style+="$color_foreground_intense_green"
				line_prefix+="$icon_selected "
				page_visible_selected_count="$((page_visible_selected_count + 1))"
			elif test "${defaults[item_index]-}" = 'yes'; then
				line_style+="$color_foreground_intense_yellow"
				line_prefix+="$icon_default "
				page_visible_unselected_defaults_count="$((page_visible_unselected_defaults_count + 1))"
			elif test "$menu_index" -eq "$menu_cursor"; then
				line_prefix+="$icon_active "
			else
				line_prefix+="$icon_standard "
			fi
			line_prefix="${line_style}${line_prefix}"

			# determine paging
			if test "$paging_used" = 'no'; then
				# paging is no longer needed, no recalculations needed
				if test -n "${renders[item_index]}"; then
					# use rendered item (in case it needed to be formatted if it exists)
					item_line="${line_prefix}${renders[item_index]}${color_reset}"$'\n'
				else
					# otherwise use original item
					item_line="${line_prefix}${items[item_index]}${color_reset}"$'\n'
				fi
			else
				# paging is needed, so we must recalculate bundled size
				if test -n "${renders[item_index]}"; then
					item_rendered="${renders[item_index]}"
					item_size="${sizes[item_index]}"
				else
					item_original="${items[item_index]}"
					if test "${#item_original}" -lt "$size_content" && [[ $item_original != *$'\n'* && $item_original != *$'\t'* ]]; then
						# no need to format item, as it is small enough
						item_rendered="$item_original"
						item_size=1
						renders[item_index]="$item_rendered"
						sizes[item_index]="$item_size"
					else
						# need to format item, as it is too big
						item_rendered="$("$bin_gfmt" -t -w "$size_content" <<<"$item_original")"
						item_rendered="${item_rendered//$'\n'/$'\n     '}"
						item_size="$("$bin_gwc" -l <<<"${item_rendered}")"
						renders[item_index]="$item_rendered"
						sizes[item_index]="$item_size"
					fi
				fi
				# calculate total menu size
				menu_size="$((menu_header_size + items_bundled_size + item_size + menu_hint_size + 2))"
				if test "$menu_size" -gt "$size_rows"; then
					# the menu would now be too large, so skip the rest
					item_line=''
					break
				else
					item_line="${line_prefix}${item_rendered}${color_reset}"$'\n'
					items_bundled_size="$((items_bundled_size + item_size))"
				fi
			fi
			# append or prepend the line to the bundle
			if test -n "$item_line"; then
				if test "$menu_direction" -eq 1; then
					items_bundled+="$item_line"
					menu_bottom_index="$menu_index"
				else
					items_bundled="$item_line$items_bundled"
					menu_top_index="$menu_index"
				fi
			fi
		done

		# save paging changes
		if test "$menu_mode" = 'choose'; then
			menu_top_index_choose="$menu_top_index"
			menu_bottom_index_choose="$menu_bottom_index"
		else
			menu_top_index_confirm="$menu_top_index"
			menu_bottom_index_confirm="$menu_bottom_index"
		fi

		# calculate paging needed
		if test "$paging_used" = 'maybe' -a "$paging_supported" = 'yes'; then
			if test "$menu_top_index" -eq 0 -a "$menu_bottom_index" -eq "$menu_last_index"; then
				paging_used='no'
			else
				paging_used='yes'
			fi
		fi

		# if paging was used, and we could support more rows, then re-render in the other direction
		# @todo update menu_index instead of cursor, so that cursor remains sensible (optional, may not be a good idea)
		if test "$paging_used" = 'yes' -a "$menu_size" -lt "$size_rows"; then
			if test "$menu_direction" -eq -1 -a "$menu_top_index" -eq 0; then
				# we can show more items, so re-render in the other direction
				if test "$menu_mode" = 'choose'; then
					menu_cursor_choose=0
				else
					menu_cursor_confirm=0
				fi
				menu_direction=1
				render_menu
				return
			elif test "$menu_direction" -eq 1 -a "$menu_bottom_index" -eq "$menu_last_index"; then
				if test "$menu_mode" = 'choose'; then
					menu_cursor_choose="$menu_last_index"
				else
					menu_cursor_confirm="$menu_last_index"
				fi
				menu_direction=-1
				render_menu
				return
			fi
		fi

		# calculate headers and footers
		local page_header='' page_visible='' page_footer='' page_count
		if test "$paging_supported" = 'yes'; then
			page_count="$((menu_bottom_index - menu_top_index + 1))"
			# [ 5 above: 1 selected, 3 preferences]
			# ...  5 above: 1 selected, 3 preferences ...
			# ‚îî‚îò‚îå‚îê  5 above: 1 selected, 3 preferences ...
			# ‚îî  5 above, 1 selected, 3 preferences ‚îò
			# ‚îå  5 above | 1 selected | 3 preferences ‚îê
			# ‚Ä¶
			# [ no above ]
			###
			# ‚îå BELOW: 376 below ‚àô 45 selected ‚àô 8 unselected defaults ‚îê
			# ..
			# ‚îú ABOVE: 5 items ‚àô 22 selected ‚î§
			# ‚îú SHOWN: 30 items ‚àô 24 selected ‚àô 8 unselected defaults ‚î§
			# ...
			# ‚îú BELOW: 283 items ‚î§
			# ...
			# ‚îî ABOVE: 376 below ‚àô 45 selected ‚àô 8 unselected defaults ‚îò
			local index \
				page_header_selected_count=0 \
				page_header_unselected_defaults_count=0 \
				page_footer_selected_count=0 \
				page_footer_unselected_defaults_count=0 \
				page_hint_indent='   ' \
				color_symbol_start="$color_foreground_intense_black" color_symbol_end="$color_disable_foreground"
			local below_open_symbol="${color_symbol_start}‚îå${color_symbol_end}" below_close_symbol="${color_symbol_start}‚îê${color_symbol_end}" \
				continue_open_symbol="${color_symbol_start}‚îú${color_symbol_end}" continue_close_symbol="${color_symbol_start}‚î§${color_symbol_end}" \
				above_open_symbol="${color_symbol_start}‚îî${color_symbol_end}" above_close_symbol="${color_symbol_start}‚îò${color_symbol_end}" \
				sep_symbol="${color_symbol_start}‚àô${color_symbol_end}"
			local header_close_symbol='' visibile_close_symbol="$continue_close_symbol" footer_close_symbol=''
			# ‚è∫ = too big
			# ‚à∂
			# ‚åú	‚åù	‚åû	‚åü
			# ‚åå	‚åç	‚åé	‚åè
			# ‚ï≠	‚ïÆ	‚ïØ ‚ï∞

			# calculate header counts
			if test "$menu_top_index" -eq 0; then
				if test "$menu_mode" = 'choose'; then
					# choose: fetch all below
					page_header+="${page_hint_indent}${below_open_symbol} ${color_foreground_white}choose any $menu_total below${color_disable_foreground}"
					page_header_selected_count="$selected_count"
					for index in "${default_indexes[@]}"; do
						if test "${selected[index]-}" = 'yes'; then
							continue
						fi
						page_header_unselected_defaults_count="$((page_header_unselected_defaults_count + 1))"
					done
				elif test "$menu_mode" = 'cancel'; then
					page_header+="${page_hint_indent}${below_open_symbol} ${color_foreground_yellow}cancel to all $menu_total defaults below${color_disable_foreground}"
				else
					page_header+="${page_hint_indent}${below_open_symbol} ${color_foreground_green}confirm all $menu_total selected below${color_disable_foreground}"
				fi
				header_close_symbol="$below_close_symbol"
			else
				if test "$menu_mode" = 'choose'; then
					# choose: fetch more above
					page_header+="${page_hint_indent}${continue_open_symbol} ${color_foreground_white}$menu_top_index more above${color_disable_foreground}"
					for index in "${selected_indexes[@]}"; do
						if test "$index" -ge "$menu_top_index"; then
							break
						fi
						page_header_selected_count="$((page_header_selected_count + 1))"
					done
					for index in "${default_indexes[@]}"; do
						if test "$index" -ge "$menu_top_index"; then
							break
						fi
						if test "${selected[index]-}" = 'yes'; then
							continue
						fi
						page_header_unselected_defaults_count="$((page_header_unselected_defaults_count + 1))"
					done
				elif test "$menu_mode" = 'cancel'; then
					page_header+="${page_hint_indent}${continue_open_symbol} ${color_foreground_yellow}$menu_top_index more defaults above${color_disable_foreground}"
				else
					page_header+="${page_hint_indent}${continue_open_symbol} ${color_foreground_green}$menu_top_index more selected above${color_disable_foreground}"
				fi
				header_close_symbol="$continue_close_symbol"
			fi

			# calculate bottom counts
			if test "$menu_bottom_index" -eq "$menu_last_index"; then
				if test "$menu_mode" = 'choose'; then
					# choose: fetch all above
					page_footer+="${page_hint_indent}${above_open_symbol} ${color_foreground_white}choose any $menu_total above${color_disable_foreground}"
					page_footer_selected_count="$selected_count"
					for index in "${default_indexes[@]}"; do
						if test "${selected[index]-}" = 'yes'; then
							continue
						fi
						page_footer_unselected_defaults_count="$((page_footer_unselected_defaults_count + 1))"
					done
				elif test "$menu_mode" = 'cancel'; then
					page_footer+="${page_hint_indent}${above_open_symbol} ${color_foreground_yellow}cancel to all $menu_total defaults above${color_disable_foreground}"
				else
					page_footer+="${page_hint_indent}${above_open_symbol} ${color_foreground_green}confirm all $menu_total selected above${color_disable_foreground}"
				fi
				footer_close_symbol="$above_close_symbol"
			else
				index="$((menu_last_index - menu_bottom_index))"
				if test "$menu_mode" = 'choose'; then
					# choose: fetch more below
					page_footer+="${page_hint_indent}${continue_open_symbol} ${color_foreground_white}$index more below${color_disable_foreground}"
					for index in "${selected_indexes[@]}"; do
						if test "$index" -le "$menu_bottom_index"; then
							continue
						fi
						page_footer_selected_count="$((page_footer_selected_count + 1))"
					done
					for index in "${default_indexes[@]}"; do
						if test "$index" -le "$menu_bottom_index" -o "${selected[index]-}" = 'yes'; then
							continue
						fi
						page_footer_unselected_defaults_count="$((page_footer_unselected_defaults_count + 1))"
					done
				elif test "$menu_mode" = 'cancel'; then
					page_footer+="${page_hint_indent}${continue_open_symbol} ${color_foreground_yellow}cancel to $index more defaults below${color_disable_foreground}"
				else
					page_footer+="${page_hint_indent}${continue_open_symbol} ${color_foreground_green}confirm $index more selected below${color_disable_foreground}"
				fi
				footer_close_symbol="$continue_close_symbol"
			fi

			# add selected and unslected defaults counts
			if test "$menu_mode" = 'choose'; then
				if test "$page_header_selected_count" -ne 0; then
					page_header+=" ${sep_symbol} ${color_foreground_green}${page_header_selected_count} selected${color_disable_foreground}"
				fi
				if test "$page_header_unselected_defaults_count" -ne 0; then
					page_header+=" ${sep_symbol} ${color_foreground_yellow}${page_header_unselected_defaults_count} unselected defaults${color_disable_foreground}"
				fi
				page_visible+="${page_hint_indent}${continue_open_symbol} ${color_foreground_white}$page_count visible${color_disable_foreground}"
				if test -n "$page_visible"; then
					if test "$page_visible_selected_count" -ne 0; then
						page_visible+=" ${sep_symbol} ${color_foreground_green}${page_visible_selected_count} selected${color_disable_foreground}"
					fi
					if test "$page_visible_unselected_defaults_count" -ne 0; then
						page_visible+=" ${sep_symbol} ${color_foreground_yellow}${page_visible_unselected_defaults_count} unselected defaults${color_disable_foreground}"
					fi
				fi
				if test "$page_footer_selected_count" -ne 0; then
					page_footer+=" ${sep_symbol} ${color_foreground_green}${page_footer_selected_count} selected${color_disable_foreground}"
				fi
				if test "$page_footer_unselected_defaults_count" -ne 0; then
					page_footer+=" ${sep_symbol} ${color_foreground_yellow}${page_footer_unselected_defaults_count} unselected defaults${color_disable_foreground}"
				fi
			elif test "$menu_mode" = 'cancel'; then
				page_visible+="${page_hint_indent}${continue_open_symbol} ${color_foreground_yellow}$page_count visible${color_disable_foreground}"
			else
				page_visible+="${page_hint_indent}${continue_open_symbol} ${color_foreground_green}$page_count visible${color_disable_foreground}"
			fi

			page_header+=" ${header_close_symbol}"$'\n'
			if test -n "$page_visible"; then
				page_visible+=" ${visibile_close_symbol}"$'\n'
			fi
			page_footer+=" ${footer_close_symbol}"$'\n'
		fi

		# reset direction
		if test "$menu_direction" -eq -1; then
			menu_direction=1
		fi

		# output menu
		if test -z "$items_bundled"; then
			items_bundled="${color_dim}[ nothing provided ]"$'\n'
		fi
		if test "$paging_used" = 'yes'; then
			menu_title=$'\e]0;'"üëâ $verb $menu_total of $items_count items üíÅ‚Äç‚ôÄÔ∏è Viewing $page_count of $items_count items [$((menu_top_index + 1))‚Ä¶$((menu_cursor + 1))‚Ä¶$((menu_bottom_index + 1))] üëà"$'\a'
		else
			menu_title=$'\e]0;'"üëâ $verb $menu_total of $items_count items üëà"$'\a'
		fi
		printf '\e[H\e[2J%s' "${menu_title}${menu_header}${page_header}${page_visible}${items_bundled}${page_footer}${menu_hint_render}" >"$tty_target"
	}
	function render_result {
		local render="$question_title" index
		if test -n "$commentary"; then
			if test -n "$render"; then
				render+=" $commentary"
			else
				render="$commentary"
			fi
		fi
		if test -n "$render"; then
			render+=$'\n'
		fi
		if test "$menu_status" -eq 0; then
			# render linger or temp
			if test "$option_linger" = 'yes'; then
				# add results only if lingering, as there may be more than terminal height, so clearing wouldn't support such
				for index in "${selected_indexes[@]}"; do
					if test "${selected[index]}" = 'yes'; then
						render+="$color_dim$icon_selected ${items[index]}${color_reset}"$'\n'
					fi
				done
				if test "$selected_count" -eq 0; then
					render+="${color_dim}[ nothing provided ]"$'\n'
				fi
				# inform
				__print_string "$render" >"$tty_target"
			elif test -n "$commentary"; then
				# inform to stderr, consistent with ask, choose, confirm
				__print_string "$render" >/dev/stderr
				# sleep 3
				# echo-clear-lines --stdin < <(__print_string "$render") >/dev/stderr
			fi
			# stdout
			for index in "${selected_indexes[@]}"; do
				if test "${selected[index]}" = 'yes'; then
					__print_line "${returns[index]}"
				fi
			done
		else
			# inform
			if test -n "$commentary"; then
				if test "$option_linger" = 'yes'; then
					__print_line "$render" >"$tty_target"
				else
					__print_line "$render" >/dev/stderr
				fi
			fi
			return "$menu_status"
		fi
	}
	function handle_menu {
		local input read_status
		# action
		tty_start
		while true; do
			# (re-)render the menu?
			if test "$menu_skip_render" = 'no'; then
				render_menu
			fi
			menu_skip_render='no'

			# handle the response
			eval_capture --statusvar=read_status --stdoutvar=input -- read-key --timeout="$option_timeout"
			if test "$read_status" -eq 60; then
				if test "$selected_count" -ne 0; then
					commentary="$(echo-style --yellow='[timed out: using defaults]')"
					action_revert
					set_menu_mode 'finished'
				elif test "$option_required" = 'no'; then
					commentary="$(echo-style --yellow='[timed out: not required]')"
					action_none
					set_menu_mode 'finished'
				else
					commentary="$(echo-style --red='[input failure: timed out: required]')"
					menu_status="$read_status" # error cases no seleciotn
					set_menu_mode 'finished'
				fi
			elif test "$read_status" -ne 0; then
				# some other failure
				commentary="$(echo-style --red="[input failure: $read_status]")"
				menu_status="$read_status" # error causes no selection
				set_menu_mode 'finished'
			elif is-digit -- "$input"; then
				action_jump "$input"
				# it may be tempting to make these (this action and below) non-multi selections, however that is not desired for timeouts, as timeouts should be empty if non-required, or the default if required, rather than whatever the user had their menu on, as timeout = escape/cancel
			elif test "$input" = 'up' -o "$input" = 'w' -o "$input" = 'k'; then
				action_up
			elif test "$input" = 'down' -o "$input" = 's' -o "$input" = 'j'; then
				action_down
			elif test "$input" = 'left' -o "$input" = 'a' -o "$input" = 'h' -o "$input" = 'page-up'; then
				action_page_up
			elif test "$input" = 'right' -o "$input" = 'd' -o "$input" = 'l' -o "$input" = 'page-down'; then
				action_page_down
			elif test "$input" = 'home'; then
				action_first
			elif test "$input" = 'end'; then
				action_last
			elif test "$input" = 'tab'; then
				action_next_preference
			elif test "$input" = 'backtab'; then
				action_prior_preference
			elif test "$menu_mode" = 'cancel'; then
				# CANCEL MENU
				if test "$input" = 'enter' -o "$input" = 'e' || test "$input" = 'space' -a "$option_multi" = 'no'; then
					set_menu_mode 'finished'
				elif test "$input" = 'escape' -o "$input" = 'q'; then
					set_menu_mode 'choose'
				fi
			elif test "$menu_mode" = 'confirm'; then
				# CONFIRM MENU
				if test "$input" = 'enter' -o "$input" = 'e' || test "$input" = 'space' -a "$option_multi" = 'no'; then
					set_menu_mode 'finished'
				elif test "$input" = 'escape' -o "$input" = 'q'; then
					set_menu_mode 'choose'
				fi
			elif test "$input" = 'space'; then
				if test "$option_multi" = 'yes'; then
					action_toggle_cursor
				else
					action_select_cursor
					if test "$option_confirm_input" = 'yes'; then
						set_menu_mode 'confirm'
					else
						set_menu_mode 'finished'
					fi
				fi
			elif test "$input" = 'escape' -o "$input" = 'q' -a "$can_cancel" = 'yes'; then
				if test "$option_confirm_input" = 'yes'; then
					set_menu_mode 'cancel'
				else
					action_revert
					set_menu_mode 'finished'
				fi
			elif test "$input" = 'enter' -o "$input" = 'e'; then
				if test "$option_multi" = 'no'; then
					action_select_cursor
				fi
				if test "$option_confirm_input" = 'yes'; then
					set_menu_mode 'confirm'
				else
					set_menu_mode 'finished'
				fi
			elif test "$input" = 'z'; then
				action_revert
			elif test "$input" = 't'; then
				if test "$selected_count" -eq "$items_count"; then
					action_none
				else
					action_all
				fi
			elif test "$input" = 'insert' -o "$input" = '+'; then
				action_select_and_next
			elif test "$input" = '-'; then
				action_select_and_prior
			elif test "$input" = 'backspace'; then
				action_unselect_and_prior
			elif test "$input" = 'delete'; then
				action_unselect_and_next
			else
				# nothing done, no need to repeat, just need to read again
				menu_skip_render='yes'
				continue
			fi

			# do a re-render
			if test "$menu_mode" = 'finished'; then
				break
			else
				menu_skip_render='no'
			fi
		done
		tty_finish
	}

	# select the defaults
	select_defaults

	# render if not skipping
	if test "$option_confirm_default" = 'no' -a "$can_revert_to_defaults" = 'yes'; then
		: # we have defaults, and want to skip defaults
	else
		handle_menu
	fi

	# render result
	render_result
	return
)

# fire if invoked standalone
if test "$0" = "${BASH_SOURCE[0]}"; then
	if test "$*" = '--test'; then
		choose_test
	else
		choose_ "$@"
	fi
fi
