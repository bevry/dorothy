#!/usr/bin/env bash

# @todo tests for solo item, tests for fuzzy and exact defaults

function choose_test() (
	source "$DOROTHY/sources/bash.bash"

	local -i delay=1
	if [[ -n $CI ]]; then
		# https://github.com/bevry/dorothy/actions/runs/16092593894/job/45411265124#step:2:704
		delay=2
	fi

	local up=$'\e[A' down=$'\e[B' right=$'\e[C' left=$'\e[D' home=$'\e[H' end=$'\e[F' insert=$'\e[2~' delete=$'\e[3~' page_up=$'\e[5~' page_down=$'\e[6~' backspace=$'\177' escape=$'\e' tab=$'\t' backtab=$'\e[Z' all=$'\x01' enter=$'\n' space=' '

	local \
		timeout_optional='[ timed out: not required ]' \
		timeout_required='[ input failure: timed out: required ]' \
		timeout_defaults='[ timed out: used default ]'

	# TESTS WITHOUT INTERACTION
	# as we are checking stderr, do not use color for these tests, as gets too complicated

	# skip default tests
	eval-tester --ignore-tty --name='receive default first response with --skip-default' --stdout=b -- \
		choose --no-color 'q' 'd' --skip-default --default=b --default=c -- a b c

	eval-tester --ignore-tty --name='receive default first --index response with --skip-default' --stdout=1 -- \
		choose --no-color 'q' 'd' --index --skip-default --default=b --default=c -- a b c

	eval-tester --ignore-tty --name='receive default responses with --skip-default' --stdout=$'b\nc' -- \
		choose --no-color 'q' 'd' --multi --skip-default --default=b --default=c -- a b c

	eval-tester --ignore-tty --name='receive default --index responses with --skip-default' --stdout=$'1\n2' -- \
		choose --no-color 'q' 'd' --multi --index --skip-default --default=b --default=c -- a b c

	# custom match tests
	eval-tester --ignore-tty --name='receive default first response with --skip-default and custom --match prep' --stdout=b-value -- \
		choose --no-color 'q' 'd' --skip-default --default=b-value --label -- a-value a-label b-value b-label

	eval-tester --ignore-tty --name='receive default first response with --skip-default and custom --match label' --stdout=b-value -- \
		choose --no-color 'q' 'd' --skip-default --default=b-label --match="\$LABEL" --label -- a-value a-label b-value b-label

	eval-tester --ignore-tty --name='receive default first response with --skip-default and custom --match index' --stdout=b-value -- \
		choose --no-color 'q' 'd' --skip-default --default=1 --match="\$INDEX" --label -- a-value a-label b-value b-label

	eval-tester --ignore-tty --name='receive default first response with --skip-default and custom --match visual' --stdout=b-value -- \
		choose --no-color 'q' 'd' --skip-default --default='1 b-value b-label' --visual="\$INDEX \$VALUE \$LABEL" --match="\$VISUAL" --label -- a-value a-label b-value b-label

	eval-tester --ignore-tty --name='receive default first response with --skip-default and custom --match return' --stdout='1 b-value b-label' -- \
		choose --no-color 'q' 'd' --skip-default --default='1 b-value b-label' --return="\$INDEX \$VALUE \$LABEL" --match="\$RETURN" --label -- a-value a-label b-value b-label

	eval-tester --ignore-tty --name='receive default first response with --skip-default and custom --match index and label (part 1)' --stdout='b-value' -- \
		choose --no-color 'q' 'd' --skip-default --default=1 --match="\$INDEX" --match="\$LABEL" --label -- a-value a-label b-value b-label

	eval-tester --ignore-tty --name='receive default first response with --skip-default and custom --match index and label (part 2)' --stdout='b-value' -- \
		choose --no-color 'q' 'd' --skip-default --default='b-label' --match="\$INDEX" --match="\$LABEL" --label -- a-value a-label b-value b-label

	# timeout optional
	eval-tester --ignore-tty --name='receive no response by timeout with no input and optional' --stderr="q $timeout_optional" -- \
		choose --no-color 'q' 'd' --timeout="$delay" -- a b c

	eval-tester --ignore-tty --name='receive no --index response by timeout with no input and optional' --stderr="q $timeout_optional" -- \
		choose --no-color 'q' 'd' --index --timeout="$delay" -- a b c

	# timeout required
	eval-tester --ignore-tty --name='receive timeout response by timeout with no input and required' --status='60' --stderr="q $timeout_required" -- \
		choose --no-color 'q' 'd' --required --timeout="$delay" -- a b c

	eval-tester --ignore-tty --name='receive timeout --index response by timeout with no input and required' --status='60' --stderr="q $timeout_required" -- \
		choose --no-color 'q' 'd' --index --required --timeout="$delay" -- a b c

	# single mode, single default
	eval-tester --ignore-tty --name='receive default response by timeout with no input and optional' --stdout=b --stderr="q $timeout_defaults" -- \
		choose --no-color 'q' 'd' --timeout="$delay" --default=b -- a b c

	eval-tester --ignore-tty --name='receive default --index response by timeout with no input and optional' --stdout=1 --stderr="q $timeout_defaults" -- \
		choose --no-color 'q' 'd' --index --timeout="$delay" --default=b -- a b c

	eval-tester --ignore-tty --name='receive default response by timeout with no input and required' --stdout=b --stderr="q $timeout_defaults" -- \
		choose --no-color 'q' 'd' --timeout="$delay" --default=b --required -- a b c

	eval-tester --ignore-tty --name='receive default --index response by timeout with no input and required' --stdout=1 --stderr="q $timeout_defaults" -- \
		choose --no-color 'q' 'd' --index --timeout="$delay" --default=b --required -- a b c

	# single mode, so only the first match is selected
	eval-tester --ignore-tty --name='receive default first response by timeout with no input and optional' --stdout=b --stderr="q $timeout_defaults" -- \
		choose --no-color 'q' 'd' --timeout="$delay" --default-fuzzy=b -- a b bb c

	eval-tester --ignore-tty --name='receive default first --index response by timeout with no input and optional' --stdout=1 --stderr="q $timeout_defaults" -- \
		choose --no-color 'q' 'd' --index --timeout="$delay" --default-fuzzy=b -- a b bb c

	eval-tester --ignore-tty --name='receive default first response by timeout with no input and required' --stdout=b --stderr="q $timeout_defaults" -- \
		choose --no-color 'q' 'd' --timeout="$delay" --default-fuzzy=b --required -- a b bb c

	eval-tester --ignore-tty --name='receive default first --index response by timeout with no input and required' --stdout=1 --stderr="q $timeout_defaults" -- \
		choose --no-color 'q' 'd' --index --timeout="$delay" --default-fuzzy=b --required -- a b bb c

	# multi mode
	eval-tester --ignore-tty --name='receive default responses by timeout with no input and multi and optional' --stdout=$'b\nbb' --stderr="q $timeout_defaults" -- \
		choose --no-color --multi 'q' 'd' --timeout="$delay" --default-fuzzy=b -- a b bb c

	eval-tester --ignore-tty --name='receive default --index responses by timeout with no input and multi and optional' --stdout=$'1\n2' --stderr="q $timeout_defaults" -- \
		choose --no-color --multi 'q' 'd' --index --timeout="$delay" --default-fuzzy=b -- a b bb c

	eval-tester --ignore-tty --name='receive default responses by timeout with no input and multi and required' --stdout=$'b\nbb' --stderr="q $timeout_defaults" -- \
		choose --no-color --multi 'q' 'd' --timeout="$delay" --default-fuzzy=b --required -- a b bb c

	eval-tester --ignore-tty --name='receive default --index responses by timeout with no input and multi and required' --stdout=$'1\n2' --stderr="q $timeout_defaults" -- \
		choose --no-color --multi 'q' 'd' --index --timeout="$delay" --default-fuzzy=b --required -- a b bb c

	# multiline defaults
	eval-tester --ignore-tty --name='receive multi-line default first response by timeout with no input' --stdout=$'b\nB' --stderr="q $timeout_defaults" -- \
		choose --no-color 'q' 'd' --timeout="$delay" --default=$'b\nB' --defaults=$'c\nd' -- a $'b\nB' c d
	eval-tester --ignore-tty --name='receive multi-line default first --index response by timeout with no input' --stdout=1 --stderr="q $timeout_defaults" -- \
		choose --no-color 'q' 'd' --index --timeout="$delay" --default=$'b\nB' --defaults=$'c\nd' -- a $'b\nB' c d
	eval-tester --ignore-tty --name='receive multi-line default responses by timeout with no input' --stdout=$'b\nB\nc\nd' --stderr="q $timeout_defaults" -- \
		choose --no-color 'q' 'd' --multi --timeout="$delay" --default=$'b\nB' --defaults=$'c\nd' -- a $'b\nB' c d
	eval-tester --ignore-tty --name='receive multi-line default responses by timeout with no input' --stdout=$'1\n2\n3' --stderr="q $timeout_defaults" -- \
		choose --no-color 'q' 'd' --multi --index --timeout="$delay" --default=$'b\nB' --defaults=$'c\nd' -- a $'b\nB' c d

	# TESTS WITH INTERACTION

	# enter key with no defaults causes first selection in single mode
	{
		sleep "$delay"
		__print_string "$enter"
	} | eval-tester --ignore-tty --name='receive first item by enter key' --stdout='a' -- \
		choose 'q' 'd' --timeout=$((delay * 2)) -- a b c

	{
		sleep "$delay"
		__print_string "$enter"
	} | eval-tester --ignore-tty --name='receive first --index item by enter key' --stdout='0' -- \
		choose 'q' 'd' --index --timeout=$((delay * 2)) -- a b c

	# enter key with no defaults causes no selection in multi mode
	{
		sleep "$delay"
		__print_string "$enter"
	} | eval-tester --ignore-tty --name='receive no response by enter key with --multi' -- \
		choose 'q' 'd' --multi --timeout=$((delay * 2)) -- a b c

	{
		sleep "$delay"
		__print_string "$enter"
	} | eval-tester --ignore-tty --name='receive no --index response by enter key with --multi' -- \
		choose 'q' 'd' --multi --index --timeout=$((delay * 2)) -- a b c

	# --confirm: enter key with no defaults causes first selection in single mode
	{
		sleep "$delay"
		__print_string "$enter"
		sleep "$delay"
		__print_string "$enter"
	} | eval-tester --ignore-tty --name='receive first item by enter key after confirm' --stdout='a' -- \
		choose 'q' 'd' --confirm --timeout=$((delay * 3)) -- a b c

	{
		sleep "$delay"
		__print_string "$enter"
		sleep "$delay"
		__print_string "$enter"
	} | eval-tester --ignore-tty --name='receive first --index item by enter key after confirm' --stdout='0' -- \
		choose 'q' 'd' --confirm --index --timeout=$((delay * 3)) -- a b c

	# --confirm: enter key after confirm with no defaults causes no selection in multi mode
	{
		sleep "$delay"
		__print_string "$enter"
		sleep "$delay"
		__print_string "$enter"
	} | eval-tester --ignore-tty --name='receive no response by enter key after confirm with --multi' -- \
		choose 'q' 'd' --confirm --multi --timeout=$((delay * 3)) -- a b c

	{
		sleep "$delay"
		__print_string "$enter"
		sleep "$delay"
		__print_string "$enter"
	} | eval-tester --ignore-tty --name='receive no --index response by enter key after confirm with --multi' -- \
		choose 'q' 'd' --confirm --multi --index --timeout=$((delay * 3)) -- a b c

	# enter key to select the defaults
	{
		sleep "$delay"
		__print_string "$enter"
	} | eval-tester --ignore-tty --name='receive default first response by enter key' --stdout='b' -- \
		choose 'q' 'd' --timeout=$((delay * 2)) --default=b --default=c -- a b c

	{
		sleep "$delay"
		__print_string "$enter"
	} | eval-tester --ignore-tty --name='receive default first --index response by enter key' --stdout='1' -- \
		choose 'q' 'd' --index --timeout=$((delay * 2)) --default=b --default=c -- a b c

	{
		sleep "$delay"
		__print_string "$enter"
	} | eval-tester --ignore-tty --name='receive default responses by enter key' --stdout=$'b\nc' -- \
		choose 'q' 'd' --multi --timeout=$((delay * 2)) --default=b --default=c -- a b c

	{
		sleep "$delay"
		__print_string "$enter"
	} | eval-tester --ignore-tty --name='receive default --index responses by enter key' --stdout=$'1\n2' -- \
		choose 'q' 'd' --multi --index --timeout=$((delay * 2)) --default=b --default=c -- a b c

	# at this point, we know --index works as expected, so no need to test it further

	# test navigation keys
	{
		sleep "$delay"
		__print_string "$down"
		sleep "$delay"
		__print_string "$enter"
	} | eval-tester --ignore-tty --name='down key' --stdout='b' -- \
		choose 'q' 'd' -- a b c

	{
		sleep "$delay"
		__print_string "$up"
		sleep "$delay"
		__print_string "$enter"
	} | eval-tester --ignore-tty --name='up key' --stdout='c' -- \
		choose 'q' 'd' -- a b c

	{
		sleep "$delay"
		__print_string "$right"
		sleep "$delay"
		__print_string "$enter"
	} | eval-tester --ignore-tty --name='right key' --stdout='c' -- \
		choose 'q' 'd' -- a b c

	{
		sleep "$delay"
		__print_string "$right"
		sleep "$delay"
		__print_string "$left"
		sleep "$delay"
		__print_string "$enter"
	} | eval-tester --ignore-tty --name='right, left key' --stdout='a' -- \
		choose 'q' 'd' -- a b c

	{
		sleep "$delay"
		__print_string "$end"
		sleep "$delay"
		__print_string "$enter"
	} | eval-tester --ignore-tty --name='end key' --stdout='c' -- \
		choose 'q' 'd' -- a b c

	{
		sleep "$delay"
		__print_string "$end"
		sleep "$delay"
		__print_string "$home"
		sleep "$delay"
		__print_string "$enter"
	} | eval-tester --ignore-tty --name='end, home key' --stdout='a' -- \
		choose 'q' 'd' -- a b c

	{
		sleep "$delay"
		__print_string "$page_down"
		sleep "$delay"
		__print_string "$enter"
	} | eval-tester --ignore-tty --name='page down key' --stdout='c' -- \
		choose 'q' 'd' -- a b c

	{
		sleep "$delay"
		__print_string "$page_down"
		sleep "$delay"
		__print_string "$page_up"
		sleep "$delay"
		__print_string "$enter"
	} | eval-tester --ignore-tty --name='page down, page up key' --stdout='a' -- \
		choose 'q' 'd' -- a b c

	{
		sleep "$delay"
		__print_string "$insert"
		sleep "$delay"
		__print_string '+'
		sleep "$delay"
		__print_string '-'
		sleep "$delay"
		__print_string "$delete"
		sleep "$delay"
		__print_string "$backspace"
		sleep "$delay"
		__print_string "$all"
		sleep "$delay"
		__print_string '2' # move to second index
		sleep "$delay"
		__print_string 't'
		sleep "$delay"
		__print_string "$space"
		sleep "$delay"
	} | eval-tester --ignore-tty --name='test multi modifiers are no-ops in single mode' --stdout='b' -- \
		choose --no-color 'q' 'd' -- a b c

	{
		sleep "$delay"
		__print_string "$insert" # select and next
		sleep "$delay"
		__print_string '+' # select and next
		sleep "$delay"
		__print_string "$enter"
	} | eval-tester --ignore-tty --name='insert key --multi' --stdout=$'a\nb' -- \
		choose 'q' 'd' --multi -- a b c

	{
		sleep "$delay"
		__print_string "$space" # select
		sleep "$delay"
		__print_string "$delete" # unselect and next
		sleep "$delay"
		__print_string "$space" # select
		sleep "$delay"
		__print_string "$enter"
	} | eval-tester --ignore-tty --name='select, delete, select --multi' --stdout='b' -- \
		choose 'q' 'd' --multi -- a b c

	{
		sleep "$delay"
		__print_string "$all"
		sleep "$delay"
		__print_string "$enter"
	} | eval-tester --ignore-tty --name='all key --multi' --stdout=$'a\nb\nc' -- \
		choose 'q' 'd' --multi -- a b c

	{
		sleep "$delay"
		__print_string 't'
		sleep "$delay"
		__print_string "$enter"
	} | eval-tester --ignore-tty --name='toggle key --multi' --stdout=$'a\nb\nc' -- \
		choose 'q' 'd' --multi -- a b c

	{
		sleep "$delay"
		__print_string 't'
		sleep "$delay"
		__print_string 't'
		sleep "$delay"
		__print_string "$enter"
	} | eval-tester --ignore-tty --name='toggle key x2 --multi' -- \
		choose 'q' 'd' --multi -- a b c

	# escape key on optional send empty response
	{
		sleep "$delay"
		__print_string "$escape"
		sleep "$delay"
		__print_string "$enter"
	} | eval-tester --ignore-tty --name='escape key on optional send empty response: confirmed' -- \
		choose 'q' 'd' -- a b c

	# escape key on optional send empty response
	{
		sleep "$delay"
		__print_string "$escape"
	} | eval-tester --ignore-tty --name='escape key on optional send empty response: no-confirm-cancel' -- \
		choose --no-confirm-cancel 'q' 'd' -- a b c

	# escape key on optional send empty response
	{
		sleep "$delay"
		__print_string "$escape"
	} | eval-tester --ignore-tty --name='escape key on optional send empty response: timeout' --stderr="q $timeout_optional" -- \
		choose --no-color --timeout=$((delay * 2)) 'q' 'd' -- a b c

	# test escape key disabled conditions
	{
		sleep "$delay"
		__print_string "$escape"
		sleep "$delay"
		__print_string "$down"
		sleep "$delay"
		__print_string "$enter"
	} | eval-tester --ignore-tty --name='escape key is disabled in single required mode with no default' --stdout='b' -- \
		choose 'q' 'd' --required -- a b c

	{
		sleep "$delay"
		__print_string "$escape"
		sleep "$delay"
		__print_string "$down"
		sleep "$delay"
		__print_string "$space"
		sleep "$delay"
		__print_string "$enter"
	} | eval-tester --ignore-tty --name='escape key is disabled in multi required mode with no defaults' --stdout='b' -- \
		choose 'q' 'd' --required --multi -- a b c

	# test escape key is enabled on required conditions: single
	{
		sleep "$delay"
		__print_string "$escape"
	} | eval-tester --ignore-tty --name='escape key is enabled in single required mode with default: timeout' --stdout='b' --stderr="q $timeout_defaults" -- \
		choose --no-color --timeout=$((delay * 2)) 'q' 'd' --required --default=b -- a b c

	{
		sleep "$delay"
		__print_string "$escape"
		sleep "$delay"
		__print_string "$enter"
	} | eval-tester --ignore-tty --name='escape key is enabled in single required mode with default: confirmed' --stdout='b' -- \
		choose 'q' 'd' --required --default=b -- a b c

	{
		sleep "$delay"
		__print_string "$escape"
	} | eval-tester --ignore-tty --name='escape key is enabled in single required mode with default: no-confirm-cancel' --stdout='b' -- \
		choose 'q' 'd' --no-confirm-cancel --required --default=b -- a b c

	# test escape key is enabled on required conditions: multi
	{
		sleep "$delay"
		__print_string "$escape"
	} | eval-tester --ignore-tty --name='escape key is enabled in multi required mode with defaults: timeout' --stdout='b' --stderr="q $timeout_defaults" -- \
		choose --no-color --timeout=$((delay * 2)) 'q' 'd' --required --multi --default=b -- a b c

	{
		sleep "$delay"
		__print_string "$escape"
		sleep "$delay"
		__print_string "$enter"
	} | eval-tester --ignore-tty --name='escape key is enabled in multi required mode with defaults: confirmed' --stdout='b' -- \
		choose 'q' 'd' --required --multi --default=b -- a b c

	{
		sleep "$delay"
		__print_string "$escape"
	} | eval-tester --ignore-tty --name='escape key is enabled in multi required mode with defaults: no-confirm-cancel' --stdout='b' -- \
		choose 'q' 'd' --no-confirm-cancel --required --multi --default=b -- a b c

	# test tab keys
	{
		# single starts on first preference, in this case b (index 1)
		sleep "$delay"
		__print_string "$tab"
		sleep "$delay"
		__print_string "$enter"
	} | eval-tester --ignore-tty --name='tab works in single mode' --stdout='c' -- \
		choose 'q' 'd' --default=b --default=c --default=d -- a b c d

	{
		# single starts on first preference, in this case b (index 1)
		sleep "$delay"
		__print_string "$backtab"
		sleep "$delay"
		__print_string "$enter"
	} | eval-tester --ignore-tty --name='backtab works in single mode' --stdout='d' -- \
		choose 'q' 'd' --default=b --default=c --default=d -- a b c d

	{
		# single starts on first preference, in this case b (index 1)
		sleep "$delay"
		__print_string "$backtab"
		sleep "$delay"
		__print_string "$tab"
		sleep "$delay"
		__print_string "$enter"
	} | eval-tester --ignore-tty --name='tabs works in single mode' --stdout='b' -- \
		choose 'q' 'd' --default=b --default=c --default=d -- a b c d

	{
		# multi starts on a (index 0), ignoring preference (even if it is on another page)
		sleep "$delay"
		__print_string "$tab"
		sleep "$delay"
		__print_string "$space"
		sleep "$delay"
		__print_string "$enter"
	} | eval-tester --ignore-tty --name='tab works in multi mode' --stdout=$'c\nd' -- \
		choose 'q' 'd' --multi --default=b --default=c --default=d -- a b c d

	{
		# multi starts on a (index 0), ignoring preference (even if it is on another page)
		sleep "$delay"
		__print_string "$backtab"
		sleep "$delay"
		__print_string "$space"
		sleep "$delay"
		__print_string "$enter"
	} | eval-tester --ignore-tty --name='backtab works in multi mode' --stdout=$'b\nc' -- \
		choose 'q' 'd' --multi --default=b --default=c --default=d -- a b c d

	{
		# multi starts on a (index 0), ignoring preference (even if it is on another page)
		sleep "$delay"
		__print_string "$backtab"
		sleep "$delay"
		__print_string "$tab"
		sleep "$delay"
		__print_string "$space"
		sleep "$delay"
		__print_string "$enter"
	} | eval-tester --ignore-tty --name='tabs works in multi mode' --stdout=$'c\nd' -- \
		choose 'q' 'd' --multi --default=b --default=c --default=d -- a b c d

	# confirm and cancel screens in optional mode
	{
		sleep "$delay"
		__print_string "$down"
		sleep "$delay"
		__print_string "$enter"
		sleep "$delay"
		__print_string "$enter"
		sleep "$delay"
	} | eval-tester --ignore-tty --name='select second preference then confirm that' --stdout='c' -- \
		choose 'q' 'd' --confirm --default=b --default=c --default=d -- a b c d

	{
		sleep "$delay"
		__print_string "$down" # down to second preference
		sleep "$delay"
		__print_string "$enter" # select second preference
		sleep "$delay"
		__print_string "$escape" # cancel the confirmation of second preference
		sleep "$delay"
		__print_string "$enter" # change mind, do select second preference
		sleep "$delay"
		__print_string "$enter" # confirm second preference
	} | eval-tester --ignore-tty --name='select second preference then cancel that, select second preference then confirm that' --stdout='c' -- \
		choose 'q' 'd' --confirm --default=b --default=c --default=d -- a b c d

	{
		sleep "$delay"
		__print_string "$down" # down to second preference
		sleep "$delay"
		__print_string "$enter" # select second preference
		sleep "$delay"
		__print_string "$escape" # cancel the confirmation of second preference
		sleep "$delay"
		__print_string "$escape" # cancel to no selection, as no selection is required
		sleep "$delay"
		__print_string "$escape" # cancel the cancellation of no selection, which applies defaults
		sleep "$delay"
		__print_string "$enter" # select the first preference
		sleep "$delay"
		__print_string "$enter" # confirm the first preference
	} | eval-tester --ignore-tty --name='select second preference then cancel that, cancel to no selection then cancel that, select the reset first preference then confirm that' --stdout='b' -- \
		choose 'q' 'd' --confirm --default=b --default=c --default=d -- a b c d

	{
		sleep "$delay"
		__print_string "$down" # down to second preference
		sleep "$delay"
		__print_string "$enter" # select second preference
		sleep "$delay"
		__print_string "$escape" # cancel the confirmation of second preference
		sleep "$delay"
		__print_string "$escape" # cancel to no selection, as no selection is required
		sleep "$delay"
		__print_string "$enter" # confirm the cancellation to no preference
	} | eval-tester --ignore-tty --name='select second preference then cancel that, cancel to no selection then confirm that' -- \
		choose 'q' 'd' --confirm --default=b --default=c --default=d -- a b c d

	# confirm and cancel screens in required mode
	{
		sleep "$delay"
		__print_string "$down"
		sleep "$delay"
		__print_string "$enter"
		sleep "$delay"
		__print_string "$enter"
		sleep "$delay"
	} | eval-tester --ignore-tty --name='select second preference then confirm that' --stdout='c' -- \
		choose 'q' 'd' --confirm --required --default=b --default=c --default=d -- a b c d

	{
		sleep "$delay"
		__print_string "$down" # down to second preference
		sleep "$delay"
		__print_string "$enter" # select second preference
		sleep "$delay"
		__print_string "$escape" # cancel the confirmation of second preference
		sleep "$delay"
		__print_string "$enter" # change mind, do select second preference
		sleep "$delay"
		__print_string "$enter" # confirm second preference
	} | eval-tester --ignore-tty --name='select second preference then cancel that, select second preference then confirm that' --stdout='c' -- \
		choose 'q' 'd' --confirm --required --default=b --default=c --default=d -- a b c d

	{
		sleep "$delay"
		__print_string "$down" # down to second preference
		sleep "$delay"
		__print_string "$enter" # select second preference
		sleep "$delay"
		__print_string "$escape" # cancel the confirmation of second preference
		sleep "$delay"
		__print_string "$escape" # cancel to first preference, as no selection is required
		sleep "$delay"
		__print_string "$escape" # cancel the cancellation to first preference, which applies defaults
		sleep "$delay"
		__print_string "$enter" # select the first preference
		sleep "$delay"
		__print_string "$enter" # confirm the first preference
	} | eval-tester --ignore-tty --name='select second preference then cancel that, cancel to first preference then cancel that, select the reset first preference then confirm that' --stdout='b' -- \
		choose 'q' 'd' --confirm --required --default=b --default=c --default=d -- a b c d

	{
		sleep "$delay"
		__print_string "$down" # down to second preference
		sleep "$delay"
		__print_string "$enter" # select second preference
		sleep "$delay"
		__print_string "$escape" # cancel the confirmation of second preference
		sleep "$delay"
		__print_string "$escape" # cancel to first preference, as selection is required
		sleep "$delay"
		__print_string "$enter" # confirm the cancellation to first preference
	} | eval-tester --ignore-tty --name='select second preference then cancel that, cancel to first preference then confirm that' --stdout='b' -- \
		choose 'q' 'd' --confirm --required --default=b --default=c --default=d -- a b c d

	return 0
)
function choose_() (
	source "$DOROTHY/sources/bash.bash"
	source "$DOROTHY/sources/styles.bash" # __refresh_style_cache
	source "$(type -P read-key)"

	# =====================================
	# Arguments

	function help {
		cat <<-EOF >&2
			ABOUT:
			Prompt the user to select an item from the menu, in a clean and robust way.

			USAGE:
			choose [...options] -- ...<item>

			OPTIONS:
			<question> | --question=<question>
			    Display this question in the prompt. If specified multiple times, they will be joined by newline, and only the first will be lingered.

			--label -- ...[<value> <label>]
			    Pass values and labels.

			--label=first -- ...[<label> <value>]
			    Pass values and labels, with the label first.

			--visual='\$LABEL' -- ...[<value> <label>]
			    Customise what is displayed to the user. It is eval'd. E.g.
			    To show label and value, use: --visual='\$LABEL [\$VALUE]'
			    If empty LABEL, then will equal VALUE.

			--return='\$VALUE' -- ...[<value> <label>]
			    Customise what is returned to the caller. It is eval'd. E.g.
			    To return the visual, use: --return='\$VISUAL'
			    To return the index, use: --return='\$INDEX' or --index

			--match='\$VALUE' -- ...[<value> <label>]
			    Customise what is matched to a default, can be specified multiple times. It is eval'd. E.g.
			    To match the label, use: --match='\$LABEL'
			    To match the index, use: --match='\$INDEX'
			    To match either the value or the label, use: --match='\$VALUE' --match='\$LABEL'

			--default-exact=<value>
			--defaults-exact=<newline separated values>
			    Pre-select <value>s by exact matching.

			--default-fuzzy=<value>
			--defaults-fuzzy=<newline separated values>
			    Pre-select <value>s by fuzzy matching.

			--[no-]default-all=[yes|NO]
			    If provided, select everything as a default.

			--[no-]skip-solo=[YES|no] | --[no-]confirm-solo=[NO|yes]
			    If a selection is required, and there is only a single item, the solo item will be selected. This option skips the prompt for the required solo item, sending it without doing the prompt. Defaults to disabled.

			--[no-]skip-default=[yes|NO] | --[no-]confirm-default=[YES|no]
			    If there are defaults, skip the prompt and send the defaults. Defaults to disabled.

			--[no-]confirm-input=[yes|NO]
			    Have the choose menu confirm the user's input (their selection or lack of selection). Defaults to disabled.

			--[no-]confirm-cancel=[YES|no]
			    Have the cancel menu confirm the user's cancellation (whether it will revert to nothing when not required, or to the default if provided and required). Defaults to enabled.

			--[no-]confirm=[yes|no]
			    Have the prompt not skip any step, requiring solo values to be prompted, default values to be prompted, cancellations to be prompted, and selections or their lack of to be confirmed.

			--[no-]required=[yes|NO]
			    Do not continue until a selection is made. Disable aborting the prompt.

			--[no-]multi=[yes|NO]
			    Multiple items can be selected.

			--[no-]hints=[YES|no]
			    Display interaction hint line.

			--[no-]linger=[yes|NO]
			    Whether the prompt should persist afterwards.

			--[no-]truncate-body=[yes|NO]
			    Truncate the body if it would prevent the menu items from being visible.

			--timeout=<timeout>
			    Custom timeout value in seconds.

			QUIRKS:
			If you wish to return the index, which is desirable in the case of when multiple values can be identical, use [--index].
		EOF
		if [[ $# -ne 0 ]]; then
			__print_error "$@"
		fi
		return 22 # EINVAL 22 Invalid argument
	}

	# process
	local args_string="$*"
	local item='' inputs=()
	local option_question=()
	local option_label='no' option_visual='' option_return='$VALUE' option_matches=()
	local defaults_exact=() defaults_fuzzy=() option_default_all='' option_confirm_solo='yes' option_confirm_default='yes' option_confirm_input='no' option_confirm_cancel='yes'
	local option_required='no' option_multi='no'
	local option_linger='no' option_timeout='' option_truncate_body='no'
	while [[ $# -ne 0 ]]; do
		item="$1"
		shift
		case "$item" in
		'--help' | '-h') help ;;
		'--no-color'* | '--color'*) __flag --source={item} --target={COLOR} --affirmative --export ;;
		'--question='*) option_question+=("${item#*=}") ;;
		'--no-label'* | '--label'*) __flag --source={item} --target={option_label} ;; # label can be 'yes', 'no', or 'first'
		'--visual='*) option_visual="${item#*=}" ;;
		'--return='*) option_return="${item#*=}" ;;
		'--index') option_return='$INDEX' ;;
		'--match='*) option_matches+=("${item#*=}") ;;
		'--default-exact='* | '--default='*) defaults_exact+=("${item#*=}") ;;
		'--defaults-exact='* | '--defaults='*)
			# splits the flag value by newlines and places them into defaults_exact
			__split --target={defaults_exact} --append -- "${item#*=}"
			;;
		'--default-fuzzy='*) defaults_fuzzy+=("${item#*=}") ;;
		'--defaults-fuzzy='*)
			# splits the flag value by newlines and places them into defaults_fuzzy
			__split --target={defaults_fuzzy} --append -- "${item#*=}"
			;;
		'--no-default-all'* | '--default-all'*) __flag --source={item} --target={option_default_all} --affirmative ;;
		'--no-skip-solo'* | '--skip-solo'*) __flag --source={item} --target={option_confirm_solo} --non-affirmative ;;
		'--no-confirm-solo'* | '--confirm-solo'*) __flag --source={item} --target={option_confirm_solo} --affirmative ;;
		'--no-skip-default'* | '--skip-default'*) __flag --source={item} --target={option_confirm_default} --non-affirmative ;;
		'--no-confirm-default'* | '--confirm-default'*) __flag --source={item} --target={option_confirm_default} --affirmative ;;
		'--no-confirm-input'* | '--confirm-input'*) __flag --source={item} --target={option_confirm_input} --affirmative ;;
		'--no-confirm-cancel'* | '--confirm-cancel'*) __flag --source={item} --target={option_confirm_cancel} --affirmative ;;
		'--no-confirm'* | '--confirm'*)
			__flag --source={item} --target={option_confirm_solo} --affirmative
			__flag --source={item} --target={option_confirm_default} --affirmative
			__flag --source={item} --target={option_confirm_input} --affirmative
			__flag --source={item} --target={option_confirm_cancel} --affirmative
			;;
		'--no-required'* | '--required'*) __flag --source={item} --target={option_required} --affirmative ;;
		'--no-multi'* | '--multi'*) __flag --source={item} --target={option_multi} --affirmative ;;
		'--no-linger'* | '--linger'*) __flag --source={item} --target={option_linger} --affirmative ;;
		'--no-truncate-body'* | '--truncate-body'*) __flag --source={item} --target={option_truncate_body} --affirmative ;;
		'--timeout='*) option_timeout="${item#*=}" ;;
		'--')
			inputs+=("$@")
			shift $#
			break
			;;
		'--'*) help 'An unrecognised flag was provided: ' --variable-value={item} ;;
		*) option_question+=("$item") ;;
		esac
	done

	# ensure items were provided
	if [[ ${#inputs[@]} -eq 0 ]]; then
		help 'No ' --code='<item>' 's were provided in the invocation of: ' --code="choose $args_string"
	fi
	if [[ ${#option_matches[@]} -eq 0 ]]; then
		option_matches=('$VALUE')
	fi

	# question
	local question_title question_body
	if [[ ${#option_question[@]} -ne 0 ]]; then
		if [[ -n ${option_question[0]} ]]; then
			question_title="${option_question[0]}"
			question_body="$(__print_lines "${option_question[@]:1}")"
		else
			question_title="$(__print_lines "${option_question[@]:1}")"
			question_body=''
		fi
	else
		question_title=''
		question_body=''
	fi

	# =====================================
	# Styles

	__refresh_style_cache -- question_title_prompt question_title_result question_body input_warning input_error icon_prompt error notice count_spacer result_line active_line selected_line default_line empty_line inactive_line legend key count_more count_selected count_defaults count_empty bar_top bar_middle bar_bottom icon_multi_selected icon_multi_default icon_multi_active icon_multi_standard icon_single_selected icon_single_default icon_single_active_required icon_single_active_optional icon_single_standard icon_nothing_provided icon_no_selection commentary_nothing_selected legend_legend_spacer legend_key_spacer key_key_spacer indent_bar indent_active indent_inactive indent_blockquote bar_line alternative_screen_buffer default_screen_buffer commentary_timeout_default commentary_timeout_optional commentary_timeout_required commentary_input_failure result_commentary_spacer terminal_resize terminal_title || return

	# select icons
	if [[ $option_multi == 'yes' ]]; then
		style__icon_selected="$style__icon_multi_selected"
		style__icon_default="$style__icon_multi_default"
		style__icon_active="$style__icon_multi_active"
		style__icon_standard="$style__icon_multi_standard"
	else
		style__icon_selected="$style__icon_single_selected"
		style__icon_default="$style__icon_single_default"
		if [[ $option_required == 'yes' ]]; then
			style__icon_active="$style__icon_single_active_required"
		else
			style__icon_active="$style__icon_single_active_optional"
		fi
		style__icon_standard="$style__icon_single_standard"
	fi

	# =====================================
	# Menu

	# enforce question if lingering
	if [[ $option_linger == 'yes' && -z $question_title ]]; then
		help 'A <question> is required when using --linger'
	fi

	# prepare label handling
	local inputs_step=1
	if [[ $option_label != 'no' ]]; then
		# because of labels, we will iterate items two at a time
		inputs_step=2

		# verify we have a label for each value
		if is-odd -- "${#inputs[@]}"; then
			help \
				'When using ' --code='--label=' --variable-value={option_label} ' the amount of ' --code='<label>' 's must match the amount of ' --code='<value>' 's.' --newline \
				'Provide an even amount of ' --code='<item>' 's to ensure there is a ' --code='<label>' ' for each ' --code='<value>' '.' --newline \
				'As you can see, the provided ' --code='<item>' 's are uneven:' --newline \
				--variable-value={inputs}
		fi
	fi

	# generate the items
	# @todo add support for option_defaults_indexes if a user requests it
	local index item INDEX=-1 VALUE LABEL VISUAL RETURN MATCH items=() returns=() defaults=() items_count can_skip_prompt='no' defaults_indexes=() defaults_count=0 defaults_last=-1 fallbacks_indexes=() fallbacks_count=0 fallbacks_last=-1 match_lower item_lower
	for ((index = 0; index < ${#inputs[@]}; index = index + inputs_step)); do
		# index considers inputs_step, INDEX is only each item (label/value combo)
		INDEX=$((INDEX + 1))

		# order of
		if [[ $option_label == 'no' ]]; then
			VALUE="${inputs[index]}"
			LABEL="$VALUE"
			if [[ -z $VALUE ]]; then
				help \
					'The ' --code='<item>' ' at index ' --variable-value={index} ' is empty, all ' --code='<item>' 's must be non-empty.' --newline \
					'The provided ' --code='<item>' 's were:' --newline \
					--variable-value={inputs}
			fi
		else
			if [[ $option_label == 'yes' ]]; then
				VALUE="${inputs[index]}"
				LABEL="${inputs[index + 1]}"
			elif [[ $option_label == 'first' ]]; then
				VALUE="${inputs[index + 1]}"
				LABEL="${inputs[index]}"
			else
				help 'The provided ' --code='--label=' --variable-value={option_label} ' is invalid, its value must be either ' --value=no ', ' --value=yes ', or ' --value=first '.'
			fi
			if [[ -z $LABEL || -z $VALUE ]]; then
				help 'The ' --code='<label=' --variable-value={LABEL} --code='> <value=' --variable-value={VALUE} --code='>' ' combination is invalid, all ' --code='<item>' 's must be non-empty.' --newline \
					'The provided ' --code='<item>' 's were:' --newline \
					--variable-value={inputs}
			fi
		fi

		# generate what is used
		if [[ -n $option_visual ]]; then
			eval "VISUAL=\"$option_visual\""
		else
			VISUAL="$LABEL"
		fi
		if [[ -z $VISUAL ]]; then
			__print_error 'The provided ' --code='--visual=' --variable-value={option_visual} ' resulted in an invalid empty result of ' --variable-value={VISUAL} ' for the ' --code='<item>' ' at index ' --variable-value={index} ' that evaluated to a ' --code='<label=' --variable-value={LABEL} --code='> <value=' --variable-value={VALUE} --code='>' ' combination.' --newline \
				'The provided ' --code='<item>' 's were:' --newline \
				--variable-value={inputs}
			return 22 # EINVAL 22 Invalid argument
		fi
		items+=("$VISUAL")
		if [[ -n $option_return ]]; then
			eval "RETURN=\"$option_return\""
		else
			RETURN="$VALUE"
		fi
		if [[ -z $RETURN ]]; then
			__print_error 'The provided ' --code='--return=' --variable-value={option_return} ' resulted in an invalid empty result of ' --variable-value={RETURN} ' for the ' --code='<item>' ' at index ' --variable-value={index} ' that evaluated to a ' --code='<label=' --variable-value={LABEL} --code='> <value=' --variable-value={VALUE} --code='>' ' combination.' --newline \
				'The provided ' --code='<item>' 's were:' --newline \
				--variable-value={inputs}
			return 22 # EINVAL 22 Invalid argument
		fi
		returns+=("$RETURN")

		# enable if default
		if [[ $option_default_all == 'yes' ]]; then
			defaults[INDEX]='yes'
		else
			for MATCH in "${option_matches[@]}"; do
				eval "MATCH=\"$MATCH\""
				if [[ -z $MATCH ]]; then
					__print_error 'The provided ' --code='--match=' --variable-value={option_match} ' resulted in an invalid empty result of ' --variable-value={MATCH} ' for the ' --code='<item>' ' at index ' --variable-value={index} ' that evaluated to a ' --code='<label=' --variable-value={LABEL} --code='> <value=' --variable-value={VALUE} --code='>' ' combination.' --newline \
						'The provided ' --code='<item>' 's were:' --newline \
						--variable-value={inputs}
					return 22 # EINVAL 22 Invalid argument
				fi
				for item in "${defaults_exact[@]}"; do
					if [[ $MATCH == "$item" ]]; then
						defaults[INDEX]='yes'
					fi
				done
				match_lower="$(__get_lowercase_string "$MATCH")" || return
				for item in "${defaults_fuzzy[@]}"; do
					item_lower="$(__get_lowercase_string "$item")" || return
					if [[ $match_lower == *"$item_lower"* ]]; then
						defaults[INDEX]='yes'
					fi
				done
			done
		fi
	done
	items_count="${#items[@]}"
	if [[ $items_count -eq 1 && $option_required == 'yes' ]]; then
		defaults[0]='yes'
		if [[ $option_confirm_solo == 'no' ]]; then
			can_skip_prompt='yes'
		fi
	fi
	defaults_count="${#defaults[@]}"
	defaults_indexes=("${!defaults[@]}")

	# handle default options
	local can_revert_to_defaults can_cancel
	if [[ $defaults_count -ne 0 ]]; then
		defaults_last="$((defaults_count - 1))"
		can_revert_to_defaults='yes'
		can_cancel='yes'
		if [[ $option_confirm_default == 'no' ]]; then
			can_skip_prompt='yes'
		fi
		# adjust fallbacks for single vs multi mode
		# fallbacks=(...) not actually needed, as never used
		if [[ $option_required == 'yes' ]]; then
			if [[ $option_multi == 'no' ]]; then
				fallbacks_count=1
				fallbacks_indexes=("${defaults_indexes[0]}")
				fallbacks_last=0
			else
				fallbacks_count="$defaults_count"
				fallbacks_indexes=("${defaults_indexes[@]}")
				fallbacks_last="$defaults_last"
			fi
		fi
	else
		can_revert_to_defaults='no'
		if [[ $option_required == 'no' ]]; then
			can_cancel='yes'
		else
			can_cancel='no'
		fi
	fi

	# prepare menu vars
	local \
		commentary='' \
		content_columns \
		items_last \
		items_renders=() \
		items_rows=() \
		legend_cancel_content legend_cancel_rows \
		legend_cancel_rows \
		legend_choose_content legend_choose_rows \
		legend_confirm_content legend_confirm_rows \
		legend_confirm_rows \
		menu_bottom_index_choose=0 \
		menu_bottom_index_confirm=0 \
		menu_cursor_choose=0 \
		menu_cursor_confirm_and_cancel=0 \
		menu_direction=1 \
		menu_title_rows=0 \
		menu_title='' \
		menu_body_rows_whole=0 \
		menu_body_rows=0 \
		menu_body='' \
		menu_mode='choose' \
		menu_resized_lines='' \
		menu_skip_render='no' \
		menu_status=0 \
		menu_top_index_choose=0 \
		menu_top_index_confirm=0 \
		paging_supported='yes' \
		paging_used \
		text__pick_nothing_cancel \
		text__pick_nothing_choose \
		text__pick_nothing_confirm \
		text__pick_cancel \
		text__pick_choose \
		text__pick_confirm \
		terminal_columns_prior=-1 \
		terminal_columns \
		terminal_margin=5 \
		terminal_lines_prior=-1 \
		terminal_lines \
		terminal_too_short='no' \
		title_supported='yes'
	items_last="$((items_count - 1))"

	# pick language
	text__pick_nothing_cancel='cancel with nothing'
	text__pick_nothing_choose='choose from nothing'
	text__pick_nothing_confirm='confirm with nothing'
	if [[ $items_count -eq 1 && $option_required == 'yes' ]]; then
		text__pick_cancel='cancel to the'
		text__pick_choose='choose the'
		text__pick_confirm='confirm the'
	elif [[ $option_multi == 'yes' ]]; then
		text__pick_cancel='cancel to the'
		text__pick_choose='choose any of'
		text__pick_confirm='confirm the'
	else
		text__pick_cancel='cancel to the'
		text__pick_choose='choose one of the'
		text__pick_confirm='confirm the'
	fi

	# prepare paging
	if ! get-terminal-size-support --quiet; then
		# fix [tput: No value for $TERM and no -T specified] errors when fetching columns and rows on CI
		paging_supported='no'
	fi
	if ! get-terminal-title-support --quiet; then
		title_supported='no'
	fi

	# prepare hints
	function add_legend_keys {
		# extract the current state
		local name="$1" legend="$2" keys=("${@:3}") var content rows inject='' total last index key # shrunk lines
		var="${name}_content"
		content="${!var}"
		var="${name}_rows"
		rows="${!var}"
		total="${#keys[@]}"
		last="$((total - 1))"

		# render the legend keys
		# this could be cached, but no need, this operation is rare enough it doesn't matter
		inject+="${style__legend}${legend}${style__end__legend}${style__legend_key_spacer}"
		for ((index = 0; index < total; index++)); do
			key="${keys[index]}"
			inject+="${style__key}${key}${style__end__key}"
			if [[ $index -ne $last ]]; then
				inject+="${style__key_key_spacer}"
			fi
		done

		# apply the change performant
		if [[ -n $content && $content != *$'\n' ]]; then # the trailing newline check is for [SEND LINE BUFFER] edge case
			content+="${style__legend_legend_spacer}${inject}"
		else
			content+="$inject"
		fi
		eval "${name}_content=\"\$content\""

		# append the content, not splitting legend keys across lines - this is disabled because it is not performant and in practice is not ideal
		# if [[ "$rows" -eq 0 ]]; then
		# 	content+="$inject"
		# 	eval "${name}_content=\"\$content\""
		# 	lines="$(echo-count-lines -- "$content")"
		# 	eval "${name}_rows=\"\$lines\""
		# elif [[ "$paging_supported" = 'yes' ]]; then
		# 	shrunk="$(echo-wrap --width="$content_columns" -- "${content}${style__legend_legend_spacer}${inject}")"
		# 	lines="$(echo-count-lines -- "$shrunk")"
		# 	# if same rows as before, then append on same line, otherwise, append on new line
		# 	if [[ "$rows" -eq "$lines" ]]; then
		# 		content+="${style__legend_legend_spacer}${inject}"
		# 	else
		# 		content+=$'\n'"$inject"
		# 	fi
		# 	eval "${name}_content=\"\$content\""
		# 	eval "${name}_rows=\"\$lines\""
		# else
		# 	content+="${style__legend_legend_spacer}${inject}"
		# 	eval "${name}_content=\"\$content\""
		# fi
	}
	function legends_rows {
		local name="$1" var content rows
		var="${name}_content"
		content="${!var}"
		rows="$(echo-wrap --width="$content_columns" -- "$content" | echo-count-lines --stdin)"
		eval "${name}_rows=\"$rows\""
	}
	function render_legends {
		# reset legends
		legend_cancel_content=''
		legend_cancel_rows=0
		legend_choose_content=''
		legend_choose_rows=0
		legend_confirm_content=''
		legend_confirm_rows=0

		# prefer key names if possible, as people don't know the symbols
		if [[ $option_multi == 'yes' ]]; then
			add_legend_keys 'legend_cancel' 'CONFIRM CANCELLATION' 'ENTER' 'E'
			add_legend_keys 'legend_choose' 'SELECT' 'SPACE'
			add_legend_keys 'legend_choose' 'CONFIRM' 'ENTER' 'E'
			add_legend_keys 'legend_confirm' 'CONFIRM SELECTION' 'ENTER' 'E'
		else
			add_legend_keys 'legend_cancel' 'CONFIRM CANCELLATION' 'SPACE' 'ENTER' 'E'
			add_legend_keys 'legend_choose' 'SELECT' 'SPACE' 'ENTER' 'E'
			add_legend_keys 'legend_confirm' 'CONFIRM SELECTION' 'SPACE' 'ENTER' 'E'
		fi
		add_legend_keys 'legend_cancel' 'ABORT CANCELLATION' 'ESC' 'Q'
		add_legend_keys 'legend_confirm' 'CHANGE SELECTION' 'ESC' 'Q'
		add_legend_keys 'legend_cancel' 'ABORT' 'CTRL C'
		add_legend_keys 'legend_confirm' 'ABORT' 'CTRL C'
		if [[ $can_cancel == 'yes' ]]; then
			# cancel restores defaults (if multi) or selects none (if non-multi) and leaves
			add_legend_keys 'legend_choose' 'CANCEL' 'ESC' 'Q'
		fi
		if [[ $items_count -ne 1 ]]; then
			# [⬆⬇⇧] have alignment issues, use [↑↓]
			add_legend_keys 'legend_choose' 'UP' '↑' 'W' 'K'
			add_legend_keys 'legend_choose' 'DOWN' '↓' 'S' 'J'
			if [[ $can_revert_to_defaults == 'yes' ]]; then
				add_legend_keys 'legend_choose' 'NEXT PREF' 'TAB'   # next preference
				add_legend_keys 'legend_choose' 'PREV PREF' '⇧ TAB' # prior preference
				add_legend_keys 'legend_choose' 'RESET' 'Z' 'R'     # reset preferences
				if [[ $option_multi == 'yes' ]]; then
					add_legend_keys 'legend_choose' 'ALL/NONE' 'T'
				fi
			fi
			if [[ $paging_supported == 'no' ]]; then
				add_legend_keys 'legend_choose' 'FIRST' '←' 'A' 'H' 'HOME' 'fn ⇧ ←'
				add_legend_keys 'legend_choose' 'LAST' '→' 'D' 'L' 'END' 'fn ⇧ →'
			else
				add_legend_keys 'legend_choose' 'PAGE UP' '←' 'A' 'H'   # 'fn ⇧ ↑'
				add_legend_keys 'legend_choose' 'PAGE DOWN' '→' 'D' 'L' # 'fn ⇧ ↓'
				add_legend_keys 'legend_choose' 'FIRST' 'HOME' 'fn ⇧ ←'
				add_legend_keys 'legend_choose' 'LAST' 'END' 'fn ⇧ →'
			fi
			if [[ $option_multi == 'yes' ]]; then
				add_legend_keys 'legend_choose' 'SELECT & NEXT' '+' 'INSERT'
				add_legend_keys 'legend_choose' 'SELECT & PREV' '-'
				add_legend_keys 'legend_choose' 'UNSELECT & NEXT' 'DELETE'
				add_legend_keys 'legend_choose' 'UNSELECT & PREV' 'BACKSPACE'
			fi
		fi
		if [[ $paging_supported == 'yes' ]]; then
			legends_rows 'legend_cancel'
			legends_rows 'legend_choose'
			legends_rows 'legend_confirm'
		else
			legend_cancel_content+=$'\n'
			legend_choose_content+=$'\n'
			legend_confirm_content+=$'\n'
			add_legend_keys 'legend_cancel' 'SEND LINE BUFFER OF KEYPRESSES' 'ENTER'
			add_legend_keys 'legend_choose' 'SEND LINE BUFFER OF KEYPRESSES' 'ENTER'
			add_legend_keys 'legend_confirm' 'SEND LINE BUFFER OF KEYPRESSES' 'ENTER'
			legend_cancel_content+=': '
			legend_choose_content+=': '
			legend_confirm_content+=': '
		fi
	}
	if [[ -n $question_title ]]; then
		menu_title="${style__question_title_prompt}${question_title}${style__end__question_title_prompt}"$'\n'
	fi
	function render_body {
		local limit="${1-}" trimmed_lines=0
		if [[ -n $question_body ]]; then
			if [[ -z $menu_body ]]; then
				menu_body="${style__question_body}${question_body}${style__end__question_body}"$'\n'
				menu_body_rows_whole="$(echo-wrap --width="$content_columns" -- "$menu_body" | echo-count-lines --stdin)"
			fi
			menu_body_rows="$menu_body_rows_whole"
			if [[ $option_truncate_body != 'yes' || -z $limit || $menu_body_rows -le $limit ]]; then
				return
			fi
			while :; do
				limit="$((limit - 1))" # trim one line from the current limit for our "lines were trimmed" line
				if [[ $limit -le 1 ]]; then
					menu_body="${style__input_warning}...${style__end__input_warning} $menu_body_rows_whole hidden description lines"$'\n'
					menu_body_rows="$(echo-wrap --width="$content_columns" -- "$menu_body" | echo-count-lines --stdin)"
					return
				fi
				# only trim whole lines, rather than wrapped lines, as it is more sensible and far simpler for code and reasoning
				menu_body="${style__question_body}$(head -n "$limit" <<<"$question_body")${style__end__question_body}"$'\n'
				menu_body_rows="$(echo-wrap --width="$content_columns" -- "$menu_body" | echo-count-lines --stdin)"
				trimmed_lines="$((menu_body_rows_whole - menu_body_rows))"
				menu_body+="${style__input_warning}...${style__end__input_warning} $trimmed_lines more description lines"$'\n'
				if [[ $menu_body_rows -le $limit ]]; then
					break
				fi
			done
			menu_body_rows="$((menu_body_rows + 1))"
		fi
	}
	if [[ $paging_supported == 'no' ]]; then
		# no need for paging
		paging_used='no'
		# no need for row and column sizes
		terminal_lines=0
		terminal_columns=0
		content_columns=0
		render_body
		terminal_too_short='no'
		# menu header adjustments
		# set the legends. and disable cursors on line-buffering no-TTY mode as it is useful to see where the keys are being buffered
		render_legends
		style__hide_cursor=''
		style__show_cursor=''
		# set rendering
		__array --target={items_renders} --target={items_rows} --size="$items_count"
		# paging support is eternal, so no need for future updates if disabled
		function reset_terminal_modifications_now {
			:
		}
		function reset_terminal_modifications_on_exit {
			:
		}
		function refresh_terminal_size {
			:
		}
	else
		# @todo: without the below capability implemented, then any custom styling for item indentation characters will not be wrapped correctly, which currently is hardcoded to 5 which is the current indentation character length; the difficulty here is having echo-wrap strip colour information (which it does) but without actually performing the wrap, or it does perform the wrap and we just error if it did wrap on the indentation
		# terminal_margin="$(echo-wrap --count-only --terminal-lines=0 --terminal-columns=0 -- "${style__inactive_line}${style__indent_inactive}${style__end__inactive_line}")"
		function reset_terminal_modifications_now {
			__do --redirect-stdout=TTY -- __print_string "$style__show_cursor$style__default_screen_buffer"
			trap - EXIT
		}
		function reset_terminal_modifications_on_exit {
			trap reset_terminal_modifications_now EXIT
		}
		# paging support is eternal, so we need to refresh if enabled
		function refresh_terminal_size {
			# refresh
			local terminal_size=()
			__split --target={terminal_size} --no-zero-length --invoke -- \
				get-terminal-lines-and-columns
			terminal_lines="${terminal_size[0]}"
			terminal_columns="${terminal_size[1]}"

			# only recalculate everything if the size actually changed from last time
			if [[ $terminal_lines -ne $terminal_lines_prior || $terminal_columns -ne $terminal_columns_prior ]]; then
				content_columns="$((terminal_columns - terminal_margin))"

				# menu title rows
				if [[ -n $menu_title ]]; then
					menu_title_rows="$(echo-wrap --width="$content_columns" -- "$menu_title" | echo-count-lines --stdin)"
				else
					menu_title_rows=0
				fi

				# menu body rows
				menu_body=''
				render_body

				# refresh the legends
				render_legends

				# move start index to current item, as otherwise it could be out of range
				if [[ $terminal_lines -lt $terminal_lines_prior || $terminal_columns -lt $terminal_columns_prior ]]; then
					# @todo we should detect if showing everything is possible before resorting to this
					menu_top_index_choose="$menu_cursor_choose"
					menu_bottom_index_choose="$menu_cursor_choose"
					menu_top_index_confirm="$menu_cursor_confirm_and_cancel"
					menu_bottom_index_confirm="$menu_cursor_confirm_and_cancel"
				fi

				# reset paging for new size
				paging_used='maybe'
				__array --target={items_renders} --target={items_rows} --size="$items_count"

				# update priors
				terminal_lines_prior="$terminal_lines"
				terminal_columns_prior="$terminal_columns"
			fi
			if [[ -n $menu_resized_lines && $menu_resized_lines -gt $terminal_lines ]]; then
				terminal_too_short='yes'
			else
				terminal_too_short='no'
			fi
		}
	fi

	# actions and selection modifications
	local selected=() selected_indexes=() selected_count=0 selected_last=-1
	function select_none {
		selected=()
		selected_indexes=()
		selected_count=0
		selected_last=-1
	}
	if [[ $option_multi == 'yes' ]]; then
		function unselect_index {
			local index
			for index in "$@"; do
				if [[ ${selected[index]-} == 'yes' ]]; then
					unset 'selected[index]'
				fi
			done
			selected_indexes=("${!selected[@]}")
			selected_count="${#selected[@]}"
			selected_last="$((selected_count - 1))"
		}
		function select_index {
			local index
			for index in "$@"; do
				if [[ ${selected[index]-} != 'yes' ]]; then
					selected[index]='yes'
				fi
			done
			selected_indexes=("${!selected[@]}")
			selected_count="${#selected[@]}"
			selected_last="$((selected_count - 1))"
		}
		function toggle_index {
			local index
			for index in "$@"; do
				if [[ ${selected[index]-} == 'yes' ]]; then
					unset 'selected[index]'
				else
					selected[index]='yes'
				fi
			done
			selected_indexes=("${!selected[@]}")
			selected_count="${#selected[@]}"
			selected_last="$((selected_count - 1))"
		}
		function select_all {
			select_index "${!items[@]}"
		}
		function select_defaults {
			if [[ $defaults_count -ne 0 ]]; then
				select_index "${defaults_indexes[@]}"
			fi
		}
		function action_toggle_cursor {
			if [[ $menu_mode == 'choose' ]]; then
				toggle_index "$menu_cursor_choose"
				if [[ $menu_cursor_choose -eq $menu_bottom_index_choose ]]; then
					# don't cause a new page, instead keep rendering it as the bottom item
					menu_direction=-1
				fi
			else
				toggle_index "$menu_cursor_confirm_and_cancel"
				if [[ $menu_cursor_confirm_and_cancel -eq $menu_bottom_index_confirm ]]; then
					# don't cause a new page, instead keep rendering it as the bottom item
					menu_direction=-1
				fi
			fi
		}
		function action_select_and_next {
			if [[ $menu_mode == 'choose' ]]; then
				select_index "$menu_cursor_choose"
			else
				select_index "$menu_cursor_confirm_and_cancel"
			fi
			action_down
		}
		function action_unselect_and_next {
			if [[ $menu_mode == 'choose' ]]; then
				unselect_index "$menu_cursor_choose"
			else
				unselect_index "$menu_cursor_confirm_and_cancel"
			fi
			action_down
		}
		function action_select_and_prior {
			if [[ $menu_mode == 'choose' ]]; then
				select_index "$menu_cursor_choose"
			else
				select_index "$menu_cursor_confirm_and_cancel"
			fi
			action_up
		}
		function action_unselect_and_prior {
			if [[ $menu_mode == 'choose' ]]; then
				unselect_index "$menu_cursor_choose"
			else
				unselect_index "$menu_cursor_confirm_and_cancel"
			fi
			action_up
		}
		function action_all {
			select_all
		}
	else
		function select_only_index {
			if [[ $# -ne 0 ]]; then
				selected=()
				selected["$1"]='yes'
				selected_indexes=("${!selected[@]}")
				selected_count=1
				selected_last=0
				menu_cursor_choose="$1"
				menu_cursor_confirm_and_cancel=0
			fi
		}
		function select_index {
			select_only_index "$1"
		}
		function select_defaults {
			# select only first preference
			if [[ $defaults_count -ne 0 ]]; then
				select_only_index "${defaults_indexes[0]}"
			fi
		}
		function action_select_cursor {
			if [[ $menu_mode == 'choose' ]]; then
				select_only_index "$menu_cursor_choose"
			else
				select_only_index "$menu_cursor_confirm_and_cancel"
			fi
		}
	fi
	function select_only_defaults {
		select_none # needed in case there are no defaults, we still want to erase selection
		select_defaults
	}
	function action_none {
		select_none
	}
	function action_revert {
		# if no defaults, removes selection
		select_none
		select_defaults
	}
	function action_fallbacks {
		if [[ $fallbacks_count -eq 0 ]]; then
			select_none
		else
			select_none
			select_index "${fallbacks_indexes[@]}"
		fi
	}
	function action_jump {
		local index="$1"
		# jump to number
		if [[ $menu_mode == 'choose' ]]; then
			if [[ $index -le 1 ]]; then
				menu_cursor_choose=0
			elif [[ $index -ge $items_count ]]; then
				menu_cursor_choose="$items_last"
			else
				menu_cursor_choose="$((index - 1))"
			fi
		else
			if [[ $index -le 1 ]]; then
				menu_cursor_confirm_and_cancel=0
			elif [[ $index -ge $selected_count ]]; then
				menu_cursor_confirm_and_cancel="$selected_last"
			else
				menu_cursor_confirm_and_cancel="$((index - 1))"
			fi
		fi

	}
	function action_up {
		if [[ $menu_mode == 'choose' ]]; then
			if [[ $menu_cursor_choose -le 0 ]]; then
				menu_cursor_choose="$items_last"
			else
				menu_cursor_choose="$((menu_cursor_choose - 1))"
			fi
		else
			if [[ $menu_cursor_confirm_and_cancel -le 0 ]]; then
				menu_cursor_confirm_and_cancel="$selected_last"
			else
				menu_cursor_confirm_and_cancel="$((menu_cursor_confirm_and_cancel - 1))"
			fi
		fi
	}
	function action_down {
		if [[ $menu_mode == 'choose' ]]; then
			if [[ $menu_cursor_choose -ge $items_last ]]; then
				menu_cursor_choose=0
			else
				menu_cursor_choose="$((menu_cursor_choose + 1))"
				if [[ $menu_cursor_choose -ge $menu_bottom_index_choose ]]; then
					# scroll down by one, rather than render whole new page
					menu_direction=-1
				fi
			fi
		else
			if [[ $menu_cursor_confirm_and_cancel -ge $selected_last ]]; then
				menu_cursor_confirm_and_cancel=0
			else
				menu_cursor_confirm_and_cancel="$((menu_cursor_confirm_and_cancel + 1))"
				if [[ $menu_cursor_confirm_and_cancel -ge $menu_bottom_index_confirm ]]; then
					# scroll down by one, rather than render whole new page
					menu_direction=-1
				fi
			fi
		fi
	}
	if [[ $paging_supported == 'yes' ]]; then
		function action_page_up {
			if [[ $menu_mode == 'choose' ]]; then
				if [[ $menu_cursor_choose -le $menu_top_index_choose ]]; then
					menu_direction=-1
				else
					menu_cursor_choose="$menu_top_index_choose"
				fi
			else
				if [[ $menu_cursor_confirm_and_cancel -le $menu_top_index_confirm ]]; then
					menu_direction=-1
				else
					menu_cursor_confirm_and_cancel="$menu_top_index_confirm"
				fi
			fi
		}
		function action_page_down {
			if [[ $menu_mode == 'choose' ]]; then
				if [[ $menu_cursor_choose -ge $menu_bottom_index_choose ]]; then
					menu_direction=1
				else
					menu_cursor_choose="$menu_bottom_index_choose"
					menu_direction=-1
				fi
			else
				if [[ $menu_cursor_confirm_and_cancel -ge $menu_bottom_index_confirm ]]; then
					menu_direction=1
				else
					menu_cursor_confirm_and_cancel="$menu_bottom_index_confirm"
					menu_direction=-1
				fi
			fi
		}
	fi
	function action_first {
		if [[ $menu_mode == 'choose' ]]; then
			menu_cursor_choose=0
		else
			menu_cursor_confirm_and_cancel=0
		fi
	}
	function action_last {
		if [[ $menu_mode == 'choose' ]]; then
			menu_cursor_choose="$items_last"
		else
			menu_cursor_confirm_and_cancel="$selected_last"
		fi
	}
	function __is_preference {
		local index="$1"
		[[ ${selected[index]-} == 'yes' || ${defaults[index]-} == 'yes' ]] || return
	}
	function action_next_preference {
		if [[ $menu_mode != 'choose' ]]; then
			action_down
			return
		fi
		local index
		# next selection
		for ((index = menu_cursor_choose + 1; index <= items_last; index++)); do
			if __is_preference "$index"; then
				menu_cursor_choose="$index"
				return 0
			fi
		done
		# earlier selection
		for ((index = 0; index < menu_cursor_choose; index++)); do
			if __is_preference "$index"; then
				menu_cursor_choose="$index"
				return 0
			fi
		done
		# no selection
		return 0
	}
	function action_prior_preference {
		if [[ $menu_mode != 'choose' ]]; then
			action_up
			return
		fi
		local index
		# go backwards to the start
		for ((index = menu_cursor_choose - 1; index >= 0; index--)); do
			if __is_preference "$index"; then
				menu_cursor_choose="$index"
				return 0
			fi
		done
		# go backwards from the end
		for ((index = items_last; index > menu_cursor_choose; index--)); do
			if __is_preference "$index"; then
				menu_cursor_choose="$index"
				return 0
			fi
		done
		# no selection
		return 0
	}
	function set_menu_mode {
		local new="$1"
		# sanity check if new menu is appropriate
		if [[ $option_required == 'yes' ]]; then
			# if required, and trying to do proceed without items, then go back to choose and send a bell
			if [[ ($selected_count -eq 0 && $new =~ ^(confirm|confirmed)$) || ($fallbacks_count -eq 0 && $new == 'cancel') ]]; then
				menu_skip_render='yes'
				menu_mode='choose'
				__do --redirect-stdout=TTY -- __print_string "$style__bell"
				return 0
			fi
		fi
		# check if we need to recalculate paging and update the mode
		if [[ $new != "$menu_mode" ]]; then
			if [[ $paging_supported == 'yes' ]]; then
				paging_used='maybe'
			fi
			menu_mode="$new"
			if [[ $new != 'choose' ]]; then
				# reset cursor
				menu_cursor_confirm_and_cancel=0
			fi
		fi
		# all done
		return 0
	}
	local debug_counter=0
	function render_menu {
		local \
			bar_bottom_content='' \
			bar_bottom_selected_count=0 \
			bar_bottom_unselected_defaults_count=0 \
			bar_middle_content='' \
			bar_middle_selected_count=0 \
			bar_middle_unselected_defaults_count=0 \
			bar_top_content='' \
			bar_top_selected_count=0 \
			bar_top_unselected_defaults_count=0 \
			index \
			item_index=0 \
			item_line \
			item_original \
			item_rendered \
			item_rows \
			items_bundled_rows=0 \
			items_bundled='' \
			line_prefix \
			line_begin \
			line_end \
			menu_bottom_index \
			menu_cursor \
			menu_index="${1-}" \
			menu_last \
			menu_legend_content \
			menu_legend_rows \
			menu_rows=0 \
			menu_top_index \
			menu_total \
			page_items_count \
			terminal_title='' \
			verb \
			verb_total
		# refresh the terminal size
		refresh_terminal_size
		# fetch the appropriate size, must be done after refresh_terminal_size
		if [[ $menu_mode == 'choose' ]]; then
			verb='Selected'
			menu_bottom_index="$menu_bottom_index_choose"
			menu_cursor="$menu_cursor_choose"
			menu_legend_content="$legend_choose_content"
			menu_legend_rows="$legend_choose_rows"
			menu_total="$items_count"
			menu_last="$items_last"
			menu_top_index="$menu_top_index_choose"
		else
			if [[ $menu_mode == 'cancel' ]]; then
				verb='Cancel to'
				menu_total="$fallbacks_count"
				menu_last="$fallbacks_last"
				menu_legend_content="$legend_cancel_content"
				menu_legend_rows="$legend_cancel_rows"
			else
				verb='Confirm'
				menu_total="$selected_count"
				menu_last="$selected_last"
				menu_legend_content="$legend_confirm_content"
				menu_legend_rows="$legend_confirm_rows"
			fi
			# @todo, consider having these and cursors for cancel as well, instead of sharing with confirm
			menu_bottom_index="$menu_bottom_index_confirm"
			menu_cursor="$menu_cursor_confirm_and_cancel"
			menu_top_index="$menu_top_index_confirm"
		fi
		# adjust page direction
		if [[ -z $menu_index ]]; then
			if [[ $menu_cursor -le 0 ]]; then
				menu_cursor=0
				menu_index="$menu_cursor"
				menu_direction=1
			elif [[ $menu_cursor -ge $menu_last ]]; then
				menu_cursor="$menu_last"
				menu_index="$menu_cursor"
				menu_direction=-1
			elif [[ $menu_cursor -le $menu_top_index ]]; then
				menu_index="$menu_cursor"
			elif [[ $menu_cursor -ge $menu_bottom_index ]]; then
				menu_index="$menu_cursor"
			elif [[ $menu_direction -eq 1 ]]; then
				# maintain the same page, as the cursor is within it
				menu_index="$menu_top_index"
			else
				# maintain the same page, as the cursor is within it
				menu_index="$menu_bottom_index"
			fi
		fi
		# @TODO HANDLE NO SELECTED OPTIONS BETTER, PERHAPS AN IF HERE
		if [[ $paging_supported == 'no' ]]; then
			menu_index=0
			menu_direction=1
		fi
		menu_top_index="$menu_index"
		menu_bottom_index="$menu_index"
		menu_resized_lines=''
		# debug
		function debug_menu {
			debug "c=$menu_cursor" "mi=$menu_index" "ii=$item_index" "d=$menu_direction" "t=$menu_top_index" "b=$menu_bottom_index" "l=$menu_last" "u=$paging_used" "r=$menu_rows" "mr=$menu_resized_lines" "tr=$terminal_lines" "tts=$terminal_too_short"
		}
		# e.g. go to second page, navigate half way, go page up
		for (( ; menu_index >= 0 && menu_index <= menu_last; menu_index += menu_direction)); do
			if [[ $menu_mode == 'choose' ]]; then
				item_index="$menu_index"
			elif [[ $menu_mode == 'cancel' ]]; then
				item_index="${fallbacks_indexes[menu_index]}"
			else
				item_index="${selected_indexes[menu_index]}"
			fi
			# determine prefix
			if [[ $menu_index -eq $menu_cursor ]]; then
				line_begin="$style__active_line"
				line_prefix="$style__indent_active"
				line_end="$style__end__active_line"
			else
				line_begin="$style__inactive_line"
				line_prefix="$style__indent_inactive"
				line_end="$style__end__inactive_line"
			fi
			if [[ ${selected[item_index]-} == 'yes' && $menu_mode != 'cancel' ]]; then
				line_begin+="$style__selected_line"
				line_prefix+="${style__icon_selected}"
				line_end+="$style__end__selected_line"
				bar_middle_selected_count="$((bar_middle_selected_count + 1))"
			elif [[ ${defaults[item_index]-} == 'yes' ]]; then
				line_begin+="$style__default_line"
				line_prefix+="${style__icon_default}"
				line_end+="$style__end__default_line"
				bar_middle_unselected_defaults_count="$((bar_middle_unselected_defaults_count + 1))"
			elif [[ $menu_index -eq $menu_cursor ]]; then
				line_prefix+="${style__icon_active}"
			else
				line_prefix+="${style__icon_standard}"
			fi
			line_prefix="${line_begin}${line_prefix}"

			# determine paging
			if [[ $paging_used == 'no' ]]; then
				# paging is no longer needed, now row calculations needed, only need to blockquote the multiline item
				if [[ -n ${items_renders[item_index]} ]]; then
					item_rendered="${items_renders[item_index]}"
				else
					item_original="${items[item_index]}"
					item_rendered="$item_original"
					item_rendered="${item_rendered//$'\n'/$'\n'"${style__indent_bar}${style__bar_line}"}" # re-add the necessary indentation
					items_renders[item_index]="$item_rendered"
				fi
				# use rendered item
				item_line="${line_prefix}${item_rendered}${line_end}"$'\n'
			else
				# paging is needed, so we must recalculate bundled size
				if [[ -n ${items_rows[item_index]} ]]; then
					item_rendered="${items_renders[item_index]}"
					item_rows="${items_rows[item_index]}"
				else
					item_original="${items[item_index]}"
					if [[ ${#item_original} -lt $content_columns && $item_original != *$'\n'* && $item_original != *$'\t'* ]]; then
						# no need to format item, as it is small enough
						item_rendered="$item_original"
						item_rows=1
						items_renders[item_index]="$item_rendered"
						items_rows[item_index]="$item_rows"
					else
						# need to format item, as it is too big
						item_rendered="$item_original"
						item_rendered="${item_rendered//$'\n'/$'\n'"${style__indent_bar}${style__bar_line}"}" # re-add the necessary indentation
						item_rendered="$(echo-wrap --width="$content_columns" -- "$item_rendered")"
						item_rows="$(echo-count-lines -- "$item_rendered")"
						items_renders[item_index]="$item_rendered"
						items_rows[item_index]="$item_rows"
					fi
				fi
				# calculate total menu size
				menu_rows="$((menu_title_rows + menu_body_rows + items_bundled_rows + item_rows + menu_legend_rows + 3))"
				item_line="${line_prefix}${item_rendered}${line_end}"$'\n'
				items_bundled_rows="$((items_bundled_rows + item_rows))"
				if [[ $menu_rows -gt $terminal_lines ]]; then
					if [[ -z $items_bundled ]]; then
						# we need to resize the terminal
						menu_resized_lines="$menu_rows"
					else
						# we already have content rendered, so exit with what we have
						break
					fi
				fi
			fi
			# append or prepend the line to the bundle
			# item line will always be defined, no need for [[ -n ... ]]
			if [[ $menu_direction -eq 1 ]]; then
				items_bundled+="$item_line"
				menu_bottom_index="$menu_index"
			else
				items_bundled="$item_line$items_bundled"
				menu_top_index="$menu_index"
			fi
			if [[ -n $menu_resized_lines ]]; then
				break
			fi
		done

		# save paging changes
		if [[ $menu_mode == 'choose' ]]; then
			menu_top_index_choose="$menu_top_index"
			menu_bottom_index_choose="$menu_bottom_index"
		else
			menu_top_index_confirm="$menu_top_index"
			menu_bottom_index_confirm="$menu_bottom_index"
		fi

		# calculate paging needed
		if [[ $paging_supported == 'yes' ]]; then
			if [[ $menu_top_index -eq 0 && $menu_bottom_index -eq $menu_last ]]; then
				paging_used='no'
			else
				paging_used='yes'
			fi
		fi

		# if paging was used, and we could support more rows, then re-render in the other direction
		if [[ $paging_used == 'yes' ]]; then
			if [[ $menu_rows -lt $terminal_lines ]]; then
				# we have paging, and less menu rows than terminal lines
				# if we rendered the first item, then re-render from the first item, expanding downwards
				# if we rendered the last item, then re-render from the last item, expanding upwards
				# this will guarantee the max amount of items were rendered
				# which will either result in the last rendered index not being the start or end (resulting in paging), or resulting in hte last rendered index being a start or end (paging not needed)
				if [[ $menu_direction -eq -1 && $menu_top_index -eq 0 ]]; then
					menu_direction=1
					render_menu 0
					return
				elif [[ $menu_direction -eq 1 && $menu_bottom_index -eq $menu_last ]]; then
					menu_direction=-1
					render_menu "$menu_last"
					return
				fi
			fi
		fi

		# adjust the menu body
		if [[ $option_truncate_body == 'yes' && $paging_supported == 'yes' && -n $question_body ]]; then
			if [[ $menu_rows -lt $terminal_lines ]]; then
				# there were less menu rows than terminal lines, so lets see if we can expand the body
				if [[ $menu_body_rows_whole -gt $menu_body_rows ]]; then
					# paging was used, and we are in-between content, which means the paging is correct and we don't have enough content to fill the terminal
					# can we expand the body in this case?
					render_body "$((menu_body_rows + terminal_lines - menu_rows))"
					render_menu
					return
				fi
			else
				# there were more menu rows than terminal lines, so see if we can shrink the body
				local shrink_body_rows
				shrink_body_rows="$(echo-math --integer -- "$terminal_lines / 4")"
				# if [[ $shrink_body_rows -le 2 ]]; then
				# 	# just make it zero
				# 	shrink_body_rows=0
				# fi
				if [[ $menu_body_rows -gt $shrink_body_rows && $menu_body_rows -gt 1 ]]; then
					render_body "$shrink_body_rows"
					render_menu
					return
				fi
			fi
		fi
		# else paging was not used, or we have maxed out content rendering

		# reset direction
		if [[ $menu_direction -eq -1 ]]; then
			menu_direction=1
		fi

		# resize the terminal if it is too short?
		if [[ -n $menu_resized_lines ]]; then
			terminal_title+="${style__terminal_resize}${menu_resized_lines};${style__end__terminal_resize}"
		fi

		# calculate page top, middle, bottom
		if [[ -z $items_bundled ]]; then
			# no items, no need to count
			page_items_count=0
			if [[ $menu_mode == 'choose' ]]; then
				bar_top_content+="${style__indent_bar}${style__bar_top}${style__count_empty}${text__pick_nothing_choose} below${style__end__count_empty}"
				items_bundled="${style__active_line}${style__empty_line}${style__indent_active}${style__icon_nothing_provided}${style__end__empty_line}${style__end__active_line}"$'\n'
				bar_bottom_content+="${style__indent_bar}${style__bar_bottom}${style__count_empty}${text__pick_nothing_choose} above${style__end__count_empty}"
			elif [[ $menu_mode == 'cancel' ]]; then
				bar_top_content+="${style__indent_bar}${style__bar_top}${style__count_defaults}${text__pick_nothing_cancel} selected${style__end__count_empty}"
				items_bundled="${style__active_line}${style__empty_line}${style__indent_active}${style__icon_no_selection}${style__end__empty_line}${style__end__active_line}"$'\n'
				bar_bottom_content+="${style__indent_bar}${style__bar_bottom}${style__count_defaults}${text__pick_nothing_cancel} selected${style__end__count_empty}"
			else
				bar_top_content+="${style__indent_bar}${style__bar_top}${style__count_selected}${text__pick_nothing_confirm} selected${style__end__count_empty}"
				items_bundled="${style__active_line}${style__empty_line}${style__indent_active}${style__icon_no_selection}${style__end__empty_line}${style__end__active_line}"$'\n'
				bar_bottom_content+="${style__indent_bar}${style__bar_bottom}${style__count_selected}${text__pick_nothing_confirm} selected${style__end__count_empty}"
			fi
		else
			# has items, do counts
			page_items_count="$((menu_bottom_index - menu_top_index + 1))"

			# calculate header counts
			if [[ $menu_top_index -eq 0 ]]; then
				if [[ $menu_mode == 'choose' ]]; then
					# choose
					bar_top_content+="${style__indent_bar}${style__bar_top}${style__count_more}${text__pick_choose} ${menu_total} below${style__end__count_more}"
					bar_top_selected_count="$selected_count"
					for index in "${defaults_indexes[@]}"; do
						if [[ ${selected[index]-} == 'yes' ]]; then
							continue
						fi
						bar_top_unselected_defaults_count="$((bar_top_unselected_defaults_count + 1))"
					done
				elif [[ $menu_mode == 'cancel' ]]; then
					# cancel
					if [[ $defaults_count -ne $fallbacks_count && $fallbacks_count -eq 1 ]]; then
						bar_top_content+="${style__indent_bar}${style__bar_top}${style__count_defaults}${text__pick_cancel} first default below${style__end__count_defaults}"
					else
						bar_top_content+="${style__indent_bar}${style__bar_top}${style__count_defaults}${text__pick_cancel} ${menu_total} defaults below${style__end__count_defaults}"
					fi
				else
					# confirm
					bar_top_content+="${style__indent_bar}${style__bar_top}${style__count_selected}${text__pick_confirm} ${menu_total} selected below${style__end__count_selected}"
				fi
			else
				if [[ $menu_mode == 'choose' ]]; then
					# choose
					bar_top_content+="${style__indent_bar}${style__bar_middle}${style__count_more}${menu_top_index} more above${style__end__count_more}"
					for index in "${selected_indexes[@]}"; do
						if [[ $index -ge $menu_top_index ]]; then
							break
						fi
						bar_top_selected_count="$((bar_top_selected_count + 1))"
					done
					for index in "${defaults_indexes[@]}"; do
						if [[ $index -ge $menu_top_index ]]; then
							break
						fi
						if [[ ${selected[index]-} == 'yes' ]]; then
							continue
						fi
						bar_top_unselected_defaults_count="$((bar_top_unselected_defaults_count + 1))"
					done
				elif [[ $menu_mode == 'cancel' ]]; then
					# cancel
					bar_top_content+="${style__indent_bar}${style__bar_middle}${style__count_defaults}${menu_top_index} more defaults above${style__end__count_defaults}"
				else
					# confirm
					bar_top_content+="${style__indent_bar}${style__bar_middle}${style__count_selected}${menu_top_index} more selected above${style__end__count_selected}"
				fi
			fi

			# calculate bottom counts
			if [[ $menu_bottom_index -eq $menu_last ]]; then
				if [[ $menu_mode == 'choose' ]]; then
					# choose
					bar_bottom_content+="${style__indent_bar}${style__bar_bottom}${style__count_more}${text__pick_choose} ${menu_total} above${style__end__count_more}"
					bar_bottom_selected_count="$selected_count"
					for index in "${defaults_indexes[@]}"; do
						if [[ ${selected[index]-} == 'yes' ]]; then
							continue
						fi
						bar_bottom_unselected_defaults_count="$((bar_bottom_unselected_defaults_count + 1))"
					done
				elif [[ $menu_mode == 'cancel' ]]; then
					# cancel
					if [[ $defaults_count -ne $fallbacks_count && $fallbacks_count -eq 1 ]]; then
						bar_bottom_content+="${style__indent_bar}${style__bar_bottom}${style__count_defaults}${text__pick_cancel} first default above${style__end__count_defaults}"
					else
						bar_bottom_content+="${style__indent_bar}${style__bar_bottom}${style__count_defaults}${text__pick_cancel} ${menu_total} defaults above${style__end__count_defaults}"
					fi
				else
					# confirm
					bar_bottom_content+="${style__indent_bar}${style__bar_bottom}${style__count_selected}${text__pick_confirm} ${menu_total} selected above${style__end__count_selected}"
				fi
			else
				index="$((menu_last - menu_bottom_index))"
				if [[ $menu_mode == 'choose' ]]; then
					# choose
					bar_bottom_content+="${style__indent_bar}${style__bar_middle}${style__count_more}${index} more below"
					for index in "${selected_indexes[@]}"; do
						if [[ $index -le $menu_bottom_index ]]; then
							continue
						fi
						bar_bottom_selected_count="$((bar_bottom_selected_count + 1))"
					done
					for index in "${defaults_indexes[@]}"; do
						if [[ $index -le $menu_bottom_index || ${selected[index]-} == 'yes' ]]; then
							continue
						fi
						bar_bottom_unselected_defaults_count="$((bar_bottom_unselected_defaults_count + 1))"
					done
				elif [[ $menu_mode == 'cancel' ]]; then
					# cancel
					bar_bottom_content+="${style__indent_bar}${style__bar_middle}${style__count_defaults}cancel to ${index} more defaults below${style__end__count_defaults}"
				else
					# confirm
					bar_bottom_content+="${style__indent_bar}${style__bar_middle}${style__count_selected}confirm ${index} more selected below${style__end__count_selected}"
				fi
			fi

			# add selected and unselected defaults counts
			if [[ $menu_mode == 'choose' ]]; then
				# choose: top bar
				if [[ $bar_top_selected_count -ne 0 ]]; then
					bar_top_content+="${style__count_spacer}${style__count_selected}${bar_top_selected_count} selected${style__end__count_selected}"
				fi
				if [[ $bar_top_unselected_defaults_count -ne 0 ]]; then
					bar_top_content+="${style__count_spacer}${style__count_defaults}${bar_top_unselected_defaults_count} unselected defaults${style__end__count_defaults}"
				fi
				# choose: middle bar
				if [[ $paging_used == 'yes' ]]; then
					bar_middle_content+="${style__indent_bar}${style__bar_middle}${style__count_more}${page_items_count} visible${style__end__count_more}"
					if [[ $bar_middle_selected_count -ne 0 ]]; then
						bar_middle_content+="${style__count_spacer}${style__count_selected}${bar_middle_selected_count} selected${style__end__count_selected}"
					fi
					if [[ $bar_middle_unselected_defaults_count -ne 0 ]]; then
						bar_middle_content+="${style__count_spacer}${style__count_defaults}${bar_middle_unselected_defaults_count} unselected defaults${style__end__count_defaults}"
					fi
				fi
				# choose: bottom bar
				if [[ $bar_bottom_selected_count -ne 0 ]]; then
					bar_bottom_content+="${style__count_spacer}${style__count_selected}${bar_bottom_selected_count} selected${style__end__count_selected}"
				fi
				if [[ $bar_bottom_unselected_defaults_count -ne 0 ]]; then
					bar_bottom_content+="${style__count_spacer}${style__count_defaults}${bar_bottom_unselected_defaults_count} unselected defaults${style__end__count_defaults}"
				fi
			elif [[ $menu_mode == 'cancel' ]]; then
				# cancel
				bar_middle_content+="${style__indent_bar}${style__bar_middle}${style__count_defaults}${page_items_count} visible${style__end__count_defaults}"
			else
				# confirm
				bar_middle_content+="${style__indent_bar}${style__bar_middle}${style__count_selected}${page_items_count} visible${style__end__count_selected}"
			fi
		fi
		bar_top_content+="${style__end__bar_top}"$'\n'
		if [[ -n $bar_middle_content ]]; then
			bar_middle_content+="${style__end__bar_middle}"$'\n'
		fi
		bar_bottom_content+="${style__end__bar_bottom}"$'\n'

		# output menu
		if [[ $menu_mode == 'choose' ]]; then
			verb_total="$selected_count"
		else
			verb_total="$menu_total"
		fi
		if [[ $title_supported == 'no' ]]; then
			terminal_title=''
		elif [[ $paging_used == 'yes' ]]; then
			terminal_title+="${style__terminal_title}👉 ${verb} ${verb_total} of ${items_count} items 💁‍♀️ Viewing ${page_items_count} of ${items_count} items [$((menu_top_index + 1))…$((menu_cursor + 1))…$((menu_bottom_index + 1))] 👈${style__end__terminal_title}"
		else
			terminal_title+="${style__terminal_title}👉 ${verb} ${verb_total} of ${items_count} items 👈${style__end__terminal_title}"
		fi
		__do --redirect-stdout=TTY -- printf '%s' "${style__clear_screen}${style__hide_cursor}${terminal_title}${menu_title}${menu_body}${bar_top_content}${bar_middle_content}${items_bundled}${bar_bottom_content}${menu_legend_content}"
		if [[ -n $menu_resized_lines ]]; then
			refresh_terminal_size
			if [[ $terminal_too_short == 'yes' ]]; then
				terminal_title="${style__terminal_title}‼️ TERMINAL TOO SHORT ‼️${style__end__terminal_title}"
				local additional_rows="$((menu_resized_lines - terminal_lines))"
				__do --redirect-stdout=TTY -- printf '%s' "${style__clear_screen}${style__hide_cursor}${terminal_title}${style__error}You have been prompted to make a menu selection, however the terminal does not have enough vertical height to make that selection.${style__end__error}"$'\n'"${style__notice}Increase the terminal height or reduce font size to proceed, then press any key.${style__end__notice}"$'\n'"Terminal rows = ${terminal_lines}, Needed rows = ${menu_resized_lines}, Additional rows = ${additional_rows}"$'\n'
			fi
		fi
	}
	function render_result {
		local render='' index item item_rendered
		if [[ -n $question_title ]]; then
			render+="${style__question_title_result}${question_title}${style__end__question_title_result}"
		fi
		render+="${commentary}"
		if [[ -n $render ]]; then
			render+=$'\n'
		fi
		if [[ $menu_status -eq 0 ]]; then
			# render linger or temp
			if [[ $option_linger == 'yes' ]]; then
				# add results only if lingering, as there may be more than terminal height, so clearing wouldn't support such
				if [[ $selected_count -eq 0 ]]; then
					render+="${style__commentary_nothing_selected}"$'\n'
				else
					for index in "${selected_indexes[@]}"; do
						if [[ ${selected[index]} == 'yes' ]]; then
							item="${items[index]}"
							item_rendered="${item//$'\n'/$'\n'"$style__indent_blockquote"}" # re-add the necessary indentation
							render+="${style__result_line}${style__icon_selected}${item_rendered}${style__end__result_line}"$'\n'
						fi
					done
				fi
				# inform
				__do --redirect-stdout=TTY -- __print_string "$render"
			elif [[ -n $commentary ]]; then
				# inform to stderr, consistent with ask, choose, confirm
				__print_string "$render" >&2
			fi
			# stdout
			for index in "${selected_indexes[@]}"; do
				if [[ ${selected[index]} == 'yes' ]]; then
					__print_lines "${returns[index]}"
				fi
			done
		else
			# inform
			if [[ -n $commentary ]]; then
				if [[ $option_linger == 'yes' ]]; then
					__do --redirect-stdout=TTY -- __print_string "$render"
				else
					__print_string "$render" >&2
				fi
			fi
			return "$menu_status"
		fi
	}
	local debug_counter=0
	function debug {
		local message
		if [[ $debug_counter -eq 0 ]]; then
			printf '' >debug.txt
		fi
		message="$(printf '%q ' "$@" "c=${debug_counter}")"
		__do --redirect-stdout=TTY -- printf '%s' "${style__terminal_title}${message}${style__end__terminal_title}"
		printf '%s\n' "$message" >>debug.txt
		debug_counter="$((debug_counter + 1))"
	}
	function handle_menu {
		local read_status input keys skips
		# action
		reset_terminal_modifications_on_exit
		__do --redirect-stdout=TTY -- __print_string "$style__alternative_screen_buffer"
		while :; do
			# (re-)render the menu?
			if [[ $menu_skip_render == 'no' ]]; then
				render_menu
			fi
			menu_skip_render='no'

			# handle the response
			__do --redirect-status={read_status} --redirect-stdout={input} -- \
				read_key --timeout="$option_timeout"
			if [[ $read_status -eq 60 ]]; then
				if [[ $selected_count -ne 0 ]]; then
					# default
					commentary="${style__result_commentary_spacer}${style__commentary_timeout_default}"
					action_revert
					set_menu_mode 'exit'
					break
				elif [[ $option_required == 'no' ]]; then
					# optional
					commentary="${style__result_commentary_spacer}${style__commentary_timeout_optional}"
					action_none
					set_menu_mode 'exit'
					break
				else
					# required
					commentary="${style__result_commentary_spacer}${style__commentary_timeout_required}"
					menu_status="$read_status"
					set_menu_mode 'exit'
					break
				fi
			elif [[ $read_status -eq 94 ]]; then
				# unknown character, send bell and continue
				menu_skip_render='yes'
				__do --redirect-stdout=TTY -- __print_string "$style__bell"
				continue
			elif [[ $read_status -ne 0 ]]; then
				# failure
				commentary="${style__result_commentary_spacer}$(printf "$style__commentary_input_failure" "read status: $read_status")"
				menu_status="$read_status" # error causes no selection
				set_menu_mode 'exit'
				break
			elif [[ $terminal_too_short != 'no' ]]; then
				continue
			elif [[ -z $input ]]; then
				menu_skip_render='yes'
				continue
			fi

			# input => keys => key
			keys=()
			skips=()
			__split --source={input} --target={keys}
			for key in "${keys[@]}"; do
				if is-digit -- "$key"; then
					action_jump "$key"
					# it may be tempting to make these (this action and below) non-multi selections, however that is not desired for timeouts, as timeouts should be empty if non-required, or the default if required, rather than whatever the user had their menu on, as timeout = escape/cancel
				elif [[ $key =~ ^(up|w|k)$ ]]; then
					action_up
				elif [[ $key =~ ^(down|s|j)$ ]]; then
					action_down
				elif [[ $key =~ ^(left|a|h|page-up)$ ]]; then
					if [[ $paging_supported == 'yes' ]]; then
						action_page_up
					else
						action_first
					fi
				elif [[ $key =~ ^(right|d|l|page-down)$ ]]; then
					if [[ $paging_supported == 'yes' ]]; then
						action_page_down
					else
						action_last
					fi
				elif [[ $key == 'home' ]]; then
					action_first
				elif [[ $key == 'end' ]]; then
					action_last
				elif [[ $key == 'tab' ]]; then
					action_next_preference
				elif [[ $key == 'backtab' ]]; then
					action_prior_preference
				elif [[ $menu_mode == 'cancel' ]]; then
					# CANCEL MENU
					if [[ $key =~ ^(enter|e)$ || ($key == 'space' && $option_multi == 'no') ]]; then
						action_fallbacks
						set_menu_mode 'confirmed'
						break
					elif [[ $key =~ ^(escape|q)$ ]]; then
						if [[ $option_multi == 'no' ]]; then
							action_revert
						fi
						set_menu_mode 'choose'
					fi
				elif [[ $menu_mode == 'confirm' ]]; then
					# CONFIRM MENU
					if [[ $key =~ ^(enter|e)$ || ($key == 'space' && $option_multi == 'no') ]]; then
						set_menu_mode 'confirmed'
						break
					elif [[ $key =~ ^(escape|q)$ ]]; then
						set_menu_mode 'choose'
					fi
				elif [[ $key == 'space' ]]; then
					if [[ $option_multi == 'yes' ]]; then
						action_toggle_cursor
					else
						action_select_cursor
						if [[ $option_confirm_input == 'yes' ]]; then
							set_menu_mode 'confirm'
						else
							set_menu_mode 'confirmed'
							break
						fi
					fi
				elif [[ $can_cancel == 'yes' && $key =~ ^(escape|q)$ ]]; then
					if [[ $option_confirm_cancel == 'yes' ]]; then
						# note that selection has no impact on cancel, as cancel's behaviour for rendering is hard coded
						set_menu_mode 'cancel'
					else
						action_fallbacks
						set_menu_mode 'confirmed'
						break
					fi
				elif [[ $key =~ ^(enter|e)$ ]]; then
					if [[ $option_multi == 'no' ]]; then
						action_select_cursor
					fi
					if [[ $option_confirm_input == 'yes' ]]; then
						set_menu_mode 'confirm'
					else
						set_menu_mode 'confirmed'
						break
					fi
				elif [[ $key =~ ^(z|r)$ ]]; then
					action_revert
				elif [[ $option_multi == 'yes' ]]; then
					if [[ $key == 't' ]]; then
						if [[ $selected_count -eq $items_count ]]; then
							action_none
						else
							action_all
						fi
					elif [[ $key =~ ^(insert|\+)$ ]]; then
						action_select_and_next
					elif [[ $key == '-' ]]; then
						action_select_and_prior
					elif [[ $key == 'backspace' ]]; then
						action_unselect_and_prior
					elif [[ $key == 'delete' ]]; then
						action_unselect_and_next
					elif [[ $key == 'all' ]]; then
						action_all
					else
						# nothing done, no need to repeat, just need to read again
						skips+=("$key")
						continue
					fi
				else
					# nothing done, no need to repeat, just need to read again
					skips+=("$key")
					continue
				fi
			done
			if [[ ${#skips[@]} -eq ${#keys[@]} ]]; then
				# all were unknown characters, send bell and continue
				menu_skip_render='yes'
				__do --redirect-stdout=TTY -- __print_string "$style__bell"
				continue
			fi

			# finish if finished
			if [[ $menu_mode =~ ^(confirmed|exit)$ ]]; then
				break
			fi
		done
		reset_terminal_modifications_now
	}

	# select the defaults
	select_defaults

	# render if not skipping
	if [[ $can_skip_prompt == 'yes' ]]; then
		: # we have defaults, and want to skip defaults
	else
		handle_menu
	fi

	# render result
	render_result
)

# fire if invoked standalone
if [[ $0 == "${BASH_SOURCE[0]}" ]]; then
	if [[ $* == '--test' ]]; then
		choose_test
	else
		choose_ "$@"
	fi
fi
