#!/usr/bin/env bash

# @todo tests for solo item, tests for fuzzy and exact defaults

function choose_test() (
	source "$DOROTHY/sources/bash.bash"
	echo-style --h1="TEST: $0"
	local delay=2
	if is-ci; then
		delay=3
	fi

	local up=$'\e[A' down=$'\e[B' right=$'\e[C' left=$'\e[D' home=$'\e[H' end=$'\e[F' insert=$'\e[2~' delete=$'\e[3~' page_up=$'\e[5~' page_down=$'\e[6~' backspace=$'\177' escape=$'\e' tab=$'\t' backtab=$'\e[Z' all=$'\x01' # enter=$'\x0a' space=' '

	local \
		timeout_optional='[ timed out: not required ]' \
		timeout_required='[ input failure: timed out: required ]' \
		timeout_defaults='[ timed out: used default ]'

	# TESTS WITHOUT INTERACTION
	# as we are checking stderr, do not use color for these tests, as gets too complicated

	# skip default tests
	eval-tester --name='receive default first response with --skip-default' --stdout=b \
		-- env COLOR=no choose 'q' 'd' --skip-default --default=b --default=c -- a b c

	eval-tester --name='receive default first --index response with --skip-default' --stdout=1 \
		-- env COLOR=no choose 'q' 'd' --index --skip-default --default=b --default=c -- a b c

	eval-tester --name='receive default responses with --skip-default' --stdout=$'b\nc' \
		-- env COLOR=no choose 'q' 'd' --multi --skip-default --default=b --default=c -- a b c

	eval-tester --name='receive default --index responses with --skip-default' --stdout=$'1\n2' \
		-- env COLOR=no choose 'q' 'd' --multi --index --skip-default --default=b --default=c -- a b c

	# timeout optional
	eval-tester --name='receive no response by timeout with no input and optional' --stderr="q $timeout_optional" \
		-- env COLOR=no choose 'q' 'd' --timeout=5 -- a b c

	eval-tester --name='receive no --index response by timeout with no input and optional' --stderr="q $timeout_optional" \
		-- env COLOR=no choose 'q' 'd' --index --timeout=5 -- a b c

	# timeout required
	eval-tester --name='receive timeout response by timeout with no input and reqyured' --status='60' --stderr="q $timeout_required" \
		-- env COLOR=no choose 'q' 'd' --required --timeout=5 -- a b c

	eval-tester --name='receive timeout --index response by timeout with no input and reqyured' --status='60' --stderr="q $timeout_required" \
		-- env COLOR=no choose 'q' 'd' --index --required --timeout=5 -- a b c

	# single mode, single defalut
	eval-tester --name='receive default response by timeout with no input and optional' --stdout=b --stderr="q $timeout_defaults" \
		-- env COLOR=no choose 'q' 'd' --timeout=5 --default=b -- a b c

	eval-tester --name='receive default --index response by timeout with no input and optional' --stdout=1 --stderr="q $timeout_defaults" \
		-- env COLOR=no choose 'q' 'd' --index --timeout=5 --default=b -- a b c

	eval-tester --name='receive default response by timeout with no input and required' --stdout=b --stderr="q $timeout_defaults" \
		-- env COLOR=no choose 'q' 'd' --timeout=5 --default=b --required -- a b c

	eval-tester --name='receive default --index response by timeout with no input and required' --stdout=1 --stderr="q $timeout_defaults" \
		-- env COLOR=no choose 'q' 'd' --index --timeout=5 --default=b --required -- a b c

	# single mode, so only the first match is selected
	eval-tester --name='receive default first response by timeout with no input and optional' --stdout=b --stderr="q $timeout_defaults" \
		-- env COLOR=no choose 'q' 'd' --timeout=5 --default-fuzzy=b -- a b bb c

	eval-tester --name='receive default first --index response by timeout with no input and optional' --stdout=1 --stderr="q $timeout_defaults" \
		-- env COLOR=no choose 'q' 'd' --index --timeout=5 --default-fuzzy=b -- a b bb c

	eval-tester --name='receive default first response by timeout with no input and required' --stdout=b --stderr="q $timeout_defaults" \
		-- env COLOR=no choose 'q' 'd' --timeout=5 --default-fuzzy=b --required -- a b bb c

	eval-tester --name='receive default first --index response by timeout with no input and required' --stdout=1 --stderr="q $timeout_defaults" \
		-- env COLOR=no choose 'q' 'd' --index --timeout=5 --default-fuzzy=b --required -- a b bb c

	# multi mode
	eval-tester --name='receive default responses by timeout with no input and multi and optional' --stdout=$'b\nbb' --stderr="q $timeout_defaults" \
		-- env COLOR=no choose --multi 'q' 'd' --timeout=5 --default-fuzzy=b -- a b bb c

	eval-tester --name='receive default --index responses by timeout with no input and multi and optional' --stdout=$'1\n2' --stderr="q $timeout_defaults" \
		-- env COLOR=no choose --multi 'q' 'd' --index --timeout=5 --default-fuzzy=b -- a b bb c

	eval-tester --name='receive default responses by timeout with no input and multi and required' --stdout=$'b\nbb' --stderr="q $timeout_defaults" \
		-- env COLOR=no choose --multi 'q' 'd' --timeout=5 --default-fuzzy=b --required -- a b bb c

	eval-tester --name='receive default --index responses by timeout with no input and multi and required' --stdout=$'1\n2' --stderr="q $timeout_defaults" \
		-- env COLOR=no choose --multi 'q' 'd' --index --timeout=5 --default-fuzzy=b --required -- a b bb c

	# multiline defaults
	eval-tester --name='receive multi-line default first response by timeout with no input' --stdout=$'b\nB' --stderr="q $timeout_defaults" \
		-- env COLOR=no choose 'q' 'd' --timeout=2 --default=$'b\nB' --defaults=$'c\nd' -- a $'b\nB' c d
	eval-tester --name='receive multi-line default first --index response by timeout with no input' --stdout=1 --stderr="q $timeout_defaults" \
		-- env COLOR=no choose 'q' 'd' --index --timeout=2 --default=$'b\nB' --defaults=$'c\nd' -- a $'b\nB' c d
	eval-tester --name='receive multi-line default responses by timeout with no input' --stdout=$'b\nB\nc\nd' --stderr="q $timeout_defaults" \
		-- env COLOR=no choose 'q' 'd' --multi --timeout=2 --default=$'b\nB' --defaults=$'c\nd' -- a $'b\nB' c d
	eval-tester --name='receive multi-line default responses by timeout with no input' --stdout=$'1\n2\n3' --stderr="q $timeout_defaults" \
		-- env COLOR=no choose 'q' 'd' --multi --index --timeout=2 --default=$'b\nB' --defaults=$'c\nd' -- a $'b\nB' c d

	# TESTS WITH INTERACTION

	# enter key with no defaults causes first selection in single mode
	{
		sleep "$delay"
		__print_line
	} | eval-tester --name='receive first item by enter key' --stdout='a' \
		-- choose 'q' 'd' --timeout=5 -- a b c

	{
		sleep "$delay"
		__print_line
	} | eval-tester --name='receive first --index item by enter key' --stdout='0' \
		-- choose 'q' 'd' --index --timeout=5 -- a b c

	# enter key with no defaults causes no selection in multi mode
	{
		sleep "$delay"
		__print_line
	} | eval-tester --name='receive no response by enter key with --multi' \
		-- choose 'q' 'd' --multi --timeout=5 -- a b c

	{
		sleep "$delay"
		__print_line
	} | eval-tester --name='receive no --index response by enter key with --multi' \
		-- choose 'q' 'd' --multi --index --timeout=5 -- a b c

	# --confirm: enter key with no defaults causes first selection in single mode
	{
		sleep "$delay"
		__print_line
		sleep "$delay"
		__print_line
	} | eval-tester --name='receive first item by enter key after confirm' --stdout='a' \
		-- choose 'q' 'd' --confirm --timeout=10 -- a b c

	{
		sleep "$delay"
		__print_line
		sleep "$delay"
		__print_line
	} | eval-tester --name='receive first --index item by enter key after confirm' --stdout='0' \
		-- choose 'q' 'd' --confirm --index --timeout=10 -- a b c

	# --confirm: enter key after confirm with no defaults causes no selection in multi mode
	{
		sleep "$delay"
		__print_line
		sleep "$delay"
		__print_line
	} | eval-tester --name='receive no response by enter key after confirm with --multi' \
		-- choose 'q' 'd' --confirm --multi --timeout=10 -- a b c

	{
		sleep "$delay"
		__print_line
		sleep "$delay"
		__print_line
	} | eval-tester --name='receive no --index response by enter key after confirm with --multi' \
		-- choose 'q' 'd' --confirm --multi --index --timeout=10 -- a b c

	# enter key to select the defaults
	{
		sleep "$delay"
		__print_line
	} | eval-tester --name='receive default first response by enter key' --stdout='b' \
		-- choose 'q' 'd' --timeout=5 --default=b --default=c -- a b c

	{
		sleep "$delay"
		__print_line
	} | eval-tester --name='receive default first --index response by enter key' --stdout='1' \
		-- choose 'q' 'd' --index --timeout=5 --default=b --default=c -- a b c

	{
		sleep "$delay"
		__print_line
	} | eval-tester --name='receive default responses by enter key' --stdout=$'b\nc' \
		-- choose 'q' 'd' --multi --timeout=5 --default=b --default=c -- a b c

	{
		sleep "$delay"
		__print_line
	} | eval-tester --name='receive default --index responses by enter key' --stdout=$'1\n2' \
		-- choose 'q' 'd' --multi --index --timeout=5 --default=b --default=c -- a b c

	# at this point, we know --index works as expected, so no need to test it further

	# test navigation keys
	{
		sleep "$delay"
		__print_string "$down"
		sleep "$delay"
		__print_line
	} | eval-tester --name='down key' --stdout='b' \
		-- choose 'q' 'd' -- a b c

	{
		sleep "$delay"
		__print_string "$up"
		sleep "$delay"
		__print_line
	} | eval-tester --name='up key' --stdout='c' \
		-- choose 'q' 'd' -- a b c

	{
		sleep "$delay"
		__print_string "$right"
		sleep "$delay"
		__print_line
	} | eval-tester --name='right key' --stdout='c' \
		-- choose 'q' 'd' -- a b c

	{
		sleep "$delay"
		__print_string "$right"
		sleep "$delay"
		__print_string "$left"
		sleep "$delay"
		__print_line
	} | eval-tester --name='right, left key' --stdout='a' \
		-- choose 'q' 'd' -- a b c

	{
		sleep "$delay"
		__print_string "$end"
		sleep "$delay"
		__print_line
	} | eval-tester --name='end key' --stdout='c' \
		-- choose 'q' 'd' -- a b c

	{
		sleep "$delay"
		__print_string "$end"
		sleep "$delay"
		__print_string "$home"
		sleep "$delay"
		__print_line
	} | eval-tester --name='end, home key' --stdout='a' \
		-- choose 'q' 'd' -- a b c

	{
		sleep "$delay"
		__print_string "$page_down"
		sleep "$delay"
		__print_line
	} | eval-tester --name='page down key' --stdout='c' \
		-- choose 'q' 'd' -- a b c

	{
		sleep "$delay"
		__print_string "$page_down"
		sleep "$delay"
		__print_string "$page_up"
		sleep "$delay"
		__print_line
	} | eval-tester --name='page down, page up key' --stdout='a' \
		-- choose 'q' 'd' -- a b c

	{
		sleep "$delay"
		__print_string "$insert"
		sleep "$delay"
		__print_string '+'
		sleep "$delay"
		__print_string '-'
		sleep "$delay"
		__print_string "$delete"
		sleep "$delay"
		__print_string "$backspace"
		sleep "$delay"
		__print_string "$all"
		sleep "$delay"
		__print_string '2' # move to second index
		sleep "$delay"
		__print_string 't'
		sleep "$delay"
		__print_string ' '
		sleep "$delay"
	} | eval-tester --name='test multi modifiers are noops in single mode' --stdout='b' \
		-- env COLOR=no choose 'q' 'd' -- a b c

	{
		sleep "$delay"
		__print_string "$insert" # select and next
		sleep "$delay"
		__print_string '+' # select and next
		sleep "$delay"
		__print_line
	} | eval-tester --name='insert key --multi' --stdout=$'a\nb' \
		-- choose 'q' 'd' --multi -- a b c

	{
		sleep "$delay"
		__print_string ' ' # select
		sleep "$delay"
		__print_string "$delete" # unselect and next
		sleep "$delay"
		__print_string ' ' # select
		sleep "$delay"
		__print_line
	} | eval-tester --name='select, delete, select --multi' --stdout='b' \
		-- choose 'q' 'd' --multi -- a b c

	{
		sleep "$delay"
		__print_string "$all"
		sleep "$delay"
		__print_line
	} | eval-tester --name='all key --multi' --stdout=$'a\nb\nc' \
		-- choose 'q' 'd' --multi -- a b c

	{
		sleep "$delay"
		__print_string 't'
		sleep "$delay"
		__print_line
	} | eval-tester --name='toggle key --multi' --stdout=$'a\nb\nc' \
		-- choose 'q' 'd' --multi -- a b c

	{
		sleep "$delay"
		__print_string 't'
		sleep "$delay"
		__print_string 't'
		sleep "$delay"
		__print_line
	} | eval-tester --name='toggle key x2 --multi' \
		-- choose 'q' 'd' --multi -- a b c

	# abort response via escape
	{
		sleep "$delay"
		__print_string "$escape"
	} | eval-tester --name='abort response via escape' \
		-- choose 'q' 'd' -- a b c

	# test escape key with required
	{
		sleep "$delay"
		__print_string "$escape"
		sleep "$delay"
		__print_string "$down"
		sleep "$delay"
		__print_line
	} | eval-tester --name='escape key is disabled in single required mode with no default' --stdout='b' \
		-- choose 'q' 'd' --required -- a b c

	{
		sleep "$delay"
		__print_string "$escape"
		sleep "$delay"
		__print_string "$down"
		sleep "$delay"
		__print_string ' '
		sleep "$delay"
		__print_line
	} | eval-tester --name='escape key is disabled in multi required mode with no defaults' --stdout='b' \
		-- choose 'q' 'd' --required --multi -- a b c

	{
		sleep "$delay"
		__print_string "$escape"
	} | eval-tester --name='escape key is enabled in single required mode with default' --stdout='b' \
		-- choose 'q' 'd' --required --default=b -- a b c

	{
		sleep "$delay"
		__print_string "$escape"
	} | eval-tester --name='escape key is enabled in multi required mode with defaults' --stdout='b' \
		-- choose 'q' 'd' --required --multi --default=b -- a b c

	# test tab keys
	{
		# single starts on first preference, in this case b (index 1)
		sleep "$delay"
		__print_string "$tab"
		sleep "$delay"
		__print_line
	} | eval-tester --name='tab works in single mode' --stdout='c' \
		-- choose 'q' 'd' --default=b --default=c --default=d -- a b c d

	{
		# single starts on first preference, in this case b (index 1)
		sleep "$delay"
		__print_string "$backtab"
		sleep "$delay"
		__print_line
	} | eval-tester --name='backtab works in single mode' --stdout='d' \
		-- choose 'q' 'd' --default=b --default=c --default=d -- a b c d

	{
		# single starts on first preference, in this case b (index 1)
		sleep "$delay"
		__print_string "$backtab"
		sleep "$delay"
		__print_string "$tab"
		sleep "$delay"
		__print_line
	} | eval-tester --name='tabs works in single mode' --stdout='b' \
		-- choose 'q' 'd' --default=b --default=c --default=d -- a b c d

	{
		# multi starts on a (index 0), ignoring preference (even if it is on another page)
		sleep "$delay"
		__print_string "$tab"
		sleep "$delay"
		__print_string ' '
		sleep "$delay"
		__print_line
	} | eval-tester --name='tab works in multi mode' --stdout=$'c\nd' \
		-- choose 'q' 'd' --multi --default=b --default=c --default=d -- a b c d

	{
		# multi starts on a (index 0), ignoring preference (even if it is on another page)
		sleep "$delay"
		__print_string "$backtab"
		sleep "$delay"
		__print_string ' '
		sleep "$delay"
		__print_line
	} | eval-tester --name='backtab works in multi mode' --stdout=$'b\nc' \
		-- choose 'q' 'd' --multi --default=b --default=c --default=d -- a b c d

	{
		# multi starts on a (index 0), ignoring preference (even if it is on another page)
		sleep "$delay"
		__print_string "$backtab"
		sleep "$delay"
		__print_string "$tab"
		sleep "$delay"
		__print_string ' '
		sleep "$delay"
		__print_line
	} | eval-tester --name='tabs works in multi mode' --stdout=$'c\nd' \
		-- choose 'q' 'd' --multi --default=b --default=c --default=d -- a b c d

	# confirm and cancel screens
	{
		sleep "$delay"
		__print_string "$down"
		sleep "$delay"
		__print_line
		sleep "$delay"
		__print_line
		sleep "$delay"
	} | eval-tester --name='confirm item below first preference in single mode' --stdout='c' \
		-- choose 'q' 'd' --confirm --default=b --default=c --default=d -- a b c d

	{
		sleep "$delay"
		__print_string "$down"
		sleep "$delay"
		__print_line
		sleep "$delay"
		__print_string "$escape"
		sleep "$delay"
		__print_string "$escape"
		sleep "$delay"
		__print_line # confirm the cancel
		sleep "$delay"
	} | eval-tester --name='confirm a selection, but revert to first preference, in single mode' --stdout='b' \
		-- choose 'q' 'd' --confirm --default=b --default=c --default=d -- a b c d

	echo-style --g1="TEST: $0"
	return 0
)
function choose_() (
	source "$DOROTHY/sources/bash.bash"
	__require_array 'mapfile'

	# =====================================
	# Arguments

	function help {
		cat <<-EOF >/dev/stderr
			ABOUT:
			Prompt the user to select an item from the menu, in a clean and robust way.

			USAGE:
			choose [...options] -- ...<item>

			OPTIONS:
			<question> | --question=<question>
			    Display this question in the prompt. If specified multiple times, they will be joined by newline, and only the first will be lingered.

			--label -- ...[<value> <label>]
			    Pass values and labels.

			--label=first -- ...[<label> <value>]
			    Pass values and labels, with the label first.

			--visual='\$LABEL' -- ...[<value> <label>]
			    Customise what is displayed to the user. It is eval'd. E.g.
			    To show label and value, use: --visual='\$LABEL [\$VALUE]'
			    If empty LABEL, then will equal VALUE.

			--return='\$VALUE' -- ...[<value> <label>]
			    Customise how the value is returned to the program. It is eval'd. E.g.
			    To return the visual, use: --return='\$VISUAL'
			    Tto return the index, use: --return='\$INDEX' or --index

			--default-exact=<value>
			--defaults-exact=<newline separated values>
			    Pre-select <value>s by exact matching.

			--default-fuzzy=<value>
			--defaults-fuzzy=<newline separated values>
			    Pre-select <value>s by fuzzy matching.

			--[no-]skip-solo=[YES|no] | --[no-]confirm-solo=[NO|yes]
			    If a selection is required, and there is only a single item, the solo item will be selected. This option skips the prompt for the required solo item, sending it without doing the prompt. Defaults to disabled.

			--[no-]skip-default=[yes|NO] | --[no-]confirm-default=[YES|no]
			    If there are defaults, skip the prompt and send the defaults. Defaults to disabled.

			--[no-]confirm-input=[yes|NO]
			    Have the choose menu confirm the user's input (their selection or lack of selection). Defaults to disabled.

			--[no-]confirm=[yes|no]
			    HAve the prompt not skip any step, requiring solo values to be prompted, default values to be prompted, and selections or their lack of to be confirmed.

			--[no-]required=[yes|NO]
			    Do not continue until a selection is made. Disable aborting the prompt.

			--[no-]multi=[yes|NO]
			    Multiple items can be selected.

			--[no-]hints=[YES|no]
			    Display interaction hint line.

			--[no-]linger=[yes|NO]
			    Whether the prompt should persist afterwards.

			--timeout=<timeout>
			    Custom timeout value in seconds.

			QUIRKS:
			If you wish to return the index, which is desirable in the case of when multiple values can be identical, use --index or --return='\$INDEX'.
		EOF
		if test "$#" -ne 0; then
			echo-error "$@"
		fi
		return 22 # EINVAL 22 Invalid argument
	}

	# process
	local item='' inputs=() tmp=()
	local option_question=()
	local option_label='no' option_visual='' option_return='$VALUE'
	local defaults_exact=() defaults_fuzzy=() option_confirm_solo='yes' option_confirm_default='yes' option_confirm_input='no'
	local option_required='no' option_multi='no'
	local option_linger='no' option_timeout=''
	while test "$#" -ne 0; do
		item="$1"
		shift
		case "$item" in
		'--help' | '-h') help ;;
		'--question='*) option_question+=("${item#*=}") ;;
		'--no-label'* | '--label'*)
			# label can be 'yes', 'no', and 'first'
			option_label="$(get-flag-value --fallback="$option_label" -- "$item")"
			;;
		'--visual='*) option_visual="${item#*=}" ;;
		'--return='*) option_return="${item#*=}" ;;
		'--index') option_return='$INDEX' ;;
		'--default-exact='* | '--default='*) defaults_exact+=("${item#*=}") ;;
		'--defaults-exact='* | '--defaults='*)
			mapfile -t tmp <<<"${item#*=}"
			defaults_exact+=("${tmp[@]}")
			;;
		'--default-fuzzy='*) defaults_fuzzy+=("${item#*=}") ;;
		'--defaults-fuzzy='*)
			mapfile -t tmp <<<"${item#*=}"
			defaults_fuzzy+=("${tmp[@]}")
			;;
		'--no-skip-solo'* | '--skip-solo'*)
			option_confirm_solo="$(get-flag-value --non-affirmative --fallback="$option_confirm_solo" -- "$item")"
			;;
		'--no-confirm-solo'* | '--confirm-solo'*)
			option_confirm_solo="$(get-flag-value --affirmative --fallback="$option_confirm_solo" -- "$item")"
			;;
		'--no-skip-default'* | '--skip-default'*)
			option_confirm_default="$(get-flag-value --non-affirmative --fallback="$option_confirm_default" -- "$item")"
			;;
		'--no-confirm-default'* | '--confirm-default'*)
			option_confirm_default="$(get-flag-value --affirmative --fallback="$option_confirm_default" -- "$item")"
			;;
		'--no-confirm-input'* | '--confirm-input'*)
			option_confirm_input="$(get-flag-value --affirmative --fallback="$option_confirm_input" -- "$item")"
			;;
		'--no-confirm'* | '--confirm'*)
			option_confirm_solo="$(get-flag-value --affirmative --fallback="$option_confirm_solo" -- "$item")"
			option_confirm_default="$(get-flag-value --affirmative --fallback="$option_confirm_default" -- "$item")"
			option_confirm_input="$(get-flag-value --affirmative --fallback="$option_confirm_input" -- "$item")"
			;;
		'--no-required'* | '--required'*)
			option_required="$(get-flag-value --affirmative --fallback="$option_required" -- "$item")"
			;;
		'--no-multi'* | '--multi'*)
			option_multi="$(get-flag-value --affirmative --fallback="$option_multi" -- "$item")"
			;;
		'--no-linger'* | '--linger'*)
			option_linger="$(get-flag-value --affirmative --fallback="$option_linger" -- "$item")"
			;;
		'--timeout='*) option_timeout="${item#*=}" ;;
		'--')
			inputs+=("$@")
			shift $#
			break
			;;
		'--'*) help "An unrecognised flag was provided: $item" ;;
		*) option_question+=("$item") ;;
		esac
	done

	# ensure items were provided
	if test "${#inputs[@]}" -eq 0; then
		help 'No <item>s provided.'
	fi

	# question
	local question_title question_body
	if test "${#option_question[@]}" -ne 0; then # bash v3 compat
		if test -n "${option_question[0]}"; then
			question_title="${option_question[0]}"
			question_body="$(__print_lines "${option_question[@]:1}")"
		else
			question_title="$(__print_lines "${option_question[@]:1}")"
			question_body=''
		fi
	else
		question_title=''
		question_body=''
	fi

	# =====================================
	# Styles

	source "$DOROTHY/sources/config.sh"

	# styles.bash provides:
	# all style variables
	load_dorothy_config 'styles.bash'

	# refresh the styles
	refresh_style_cache -- 'question_title_prompt' 'question_title_result' 'question_body' 'input_warning' 'input_error' 'icon_prompt' 'error' 'notice' 'count_spacer' 'result_line' 'active_line' 'selected_line' 'default_line' 'empty_line' 'inactive_line' 'legend' 'key' 'count_more' 'count_selected' 'count_defaults' 'count_empty' 'bar_top' 'bar_middle' 'bar_bottom' 'icon_multi_selected' 'icon_multi_default' 'icon_multi_active' 'icon_multi_standard' 'icon_single_selected' 'icon_single_default' 'icon_single_active_required' 'icon_single_active_optional' 'icon_single_standard' 'icon_nothing_provided' 'icon_no_selection' 'commentary_nothing_selected' 'legend_legend_spacer' 'legend_key_spacer' 'key_key_spacer' 'indent_bar' 'indent_active' 'indent_inactive' 'indent_blockquote' 'bar_line' 'alternative_screen_buffer' 'default_screen_buffer' 'commentary_timeout_default' 'commentary_timeout_optional' 'commentary_timeout_required' 'commentary_input_failure' 'result_commentary_spacer'

	# select icons
	if test "$option_multi" = 'yes'; then
		style__icon_selected="$style__icon_multi_selected"
		style__icon_default="$style__icon_multi_default"
		style__icon_active="$style__icon_multi_active"
		style__icon_standard="$style__icon_multi_standard"
	else
		style__icon_selected="$style__icon_single_selected"
		style__icon_default="$style__icon_single_default"
		if test "$option_required" = 'yes'; then
			style__icon_active="$style__icon_single_active_required"
		else
			style__icon_active="$style__icon_single_active_optional"
		fi
		style__icon_standard="$style__icon_single_standard"
	fi

	# style the question
	local question_title_prompt='' question_title_result='' question_body_prompt=''
	if test -n "$question_title"; then
		question_title_prompt="${style__question_title_prompt}${question_title}${style__end__question_title_prompt}"
		question_title_result="${style__question_title_result}${question_title}${style__end__question_title_result}"
	fi
	if test -n "$question_body"; then
		question_body_prompt="${style__question_body}${question_body}${style__end__question_body}"
	fi

	# =====================================
	# Menu

	# enforce question if lingering
	if test "$option_linger" = 'yes' -a -z "$question_title"; then
		help 'A <question> is required when using --linger'
	fi

	# generic helpers
	function __string_has_case_insensitive_substring {
		local string="$1" substring="$2"
		[[ "$(__lowercase_string -- "$string")" == *"$(__lowercase_string -- "$substring")"* ]]
		return
	}

	# prepare label handling
	local inputs_step=1
	if test "$option_label" != 'no'; then
		# because of labels, we will iterate items two at a time
		inputs_step=2

		# verify we have a label for each value
		if is-odd -- "${#inputs[@]}"; then
			{
				__print_lines \
					"${style__error}The amount of <label>s must match the amount of <value>s. See [$0 --help] for usage.${style__end__error}" \
					"${style__notice}Provide an even amount of items to ensure there is a <label> for each <value>:${style__end__notice}"
				echo-verbose -- "${inputs[@]}"
			} >/dev/stderr
			return 22 # EINVAL 22 Invalid argument
		fi
	fi

	# generate the items
	# @todo add support for option_defaults_indexes if a user requests it
	local index item INDEX=-1 VALUE LABEL VISUAL RETURN items=() returns=() defaults=() items_count can_skip_prompt='no' defaults_indexes=() defaults_count=0 defaults_last=-1 fallbacks_indexes=() fallbacks_count=0 fallbacks_last=-1
	for ((index = 0; index < ${#inputs[@]}; index = index + inputs_step)); do
		# index considers inputs_step, INDEX is only each item (label/value combo)
		INDEX=$((INDEX + 1))

		# order of
		if test "$option_label" = 'no'; then
			VALUE="${inputs[index]}"
			LABEL="$VALUE"
			if test -z "$VALUE"; then
				__print_lines "${style__error}The $INDEX item at index $index was empty, all items must be non-empty.${style__end__error}" >/dev/stderr
				return 22 # EINVAL 22 Invalid argument
			fi
		else
			if test "$option_label" = 'yes'; then
				VALUE="${inputs[index]}"
				LABEL="${inputs[index + 1]}"
			elif test "$option_label" = 'first'; then
				VALUE="${inputs[index + 1]}"
				LABEL="${inputs[index]}"
			else
				__print_lines "${style__error}Invalid label option [$option_label], it must be no, yes, or first.${style__end__error}" >/dev/stderr
				return 22 # EINVAL 22 Invalid argument
			fi
			if test -z "$LABEL" -o -z "$VALUE"; then
				__print_lines "${style__error}Invalid label=[$LABEL] value=[$VALUE] combination, both must be non-empty.${style__end__error}" >/dev/stderr
				return 22 # EINVAL 22 Invalid argument
			fi
		fi

		# enable if default
		if test "${#defaults_exact[@]}" -ne 0; then # bash v3 compat
			for item in "${defaults_exact[@]}"; do
				if test "$VALUE" = "$item"; then
					defaults[INDEX]='yes'
				fi
			done
		fi
		if test "${#defaults_fuzzy[@]}" -ne 0; then # bash v3 compat
			for item in "${defaults_fuzzy[@]}"; do
				if __string_has_case_insensitive_substring "$VALUE" "$item"; then
					defaults[INDEX]='yes'
				fi
			done
		fi

		# generate what is used
		if test -n "$option_visual"; then
			eval "VISUAL=\"$option_visual\""
		else
			VISUAL="$LABEL"
		fi
		if test -z "$VISUAL"; then
			__print_lines "${style__error}Invalid visual=[$VISUAL] for label=[$LABEL] value=[$VALUE], all must be non-empty.${style__end__error}" >/dev/stderr
			return 22 # EINVAL 22 Invalid argument
		fi
		if test -n "$option_return"; then
			eval "RETURN=\"$option_return\""
		else
			RETURN="$VALUE"
		fi
		if test -z "$RETURN"; then
			__print_lines "${style__error}Invalid return=[$RETURN] for label=[$LABEL] value=[$VALUE], all must be non-empty.${style__end__error}" >/dev/stderr
			return 22 # EINVAL 22 Invalid argument
		fi
		items+=("$VISUAL")
		returns+=("$RETURN")
	done
	items_count="${#items[@]}"
	if test "$items_count" -eq 1 -a "$option_required" = 'yes'; then
		defaults[0]='yes'
		if test "$option_confirm_solo" = 'no'; then
			can_skip_prompt='yes'
		fi
	fi
	defaults_count="${#defaults[@]}"
	defaults_indexes=("${!defaults[@]}")

	# handle default options
	local can_revert_to_defaults can_cancel
	if test "$defaults_count" -ne 0; then
		defaults_last="$((defaults_count - 1))"
		can_revert_to_defaults='yes'
		can_cancel='yes'
		if test "$option_confirm_default" = 'no'; then
			can_skip_prompt='yes'
		fi
	else
		can_revert_to_defaults='no'
		if test "$option_required" = 'no'; then
			can_cancel='yes'
		else
			can_cancel='no'
		fi
	fi

	# adjust fallbacks for single vs multi mode
	# fallbacks=(...) not actually needed, as never used
	if test "$option_multi" = 'no' -a "$defaults_count" -gt 1; then
		fallbacks_count=1
		fallbacks_indexes=("${defaults_indexes[0]}")
		fallbacks_last=0
	else
		fallbacks_count="$defaults_count"
		fallbacks_indexes=("${defaults_indexes[@]}")
		fallbacks_last="$defaults_last"
	fi

	# prepare menu vars
	local \
		commentary='' \
		content_columns \
		items_last \
		items_renders \
		items_rows \
		legend_cancel_content legend_cancel_rows \
		legend_cancel_rows \
		legend_choose_content legend_choose_rows \
		legend_confirm_content legend_confirm_rows \
		legend_confirm_rows \
		menu_bottom_index_choose=0 \
		menu_bottom_index_confirm=0 \
		menu_cursor_choose=0 \
		menu_cursor_confirm_and_cancel=0 \
		menu_direction=1 \
		menu_header_rows \
		menu_header='' \
		menu_mode='choose' \
		menu_resized_to='' \
		menu_skip_render='no' \
		menu_status=0 \
		menu_top_index_choose=0 \
		menu_top_index_confirm=0 \
		paging_supported='yes' \
		paging_used \
		text__pick_nothing_cancel \
		text__pick_nothing_choose \
		text__pick_nothing_confirm \
		text__pick_cancel \
		text__pick_choose \
		text__pick_confirm \
		terminal_columns_prior=-1 \
		terminal_columns \
		terminal_device_file \
		terminal_margin=0 \
		terminal_lines_prior=-1 \
		terminal_lines \
		terminal_too_short='no' \
		title_supported='yes'
	items_last="$((items_count - 1))"

	# pick language
	text__pick_nothing_cancel='cancel with nothing'
	text__pick_nothing_choose='choose from nothing'
	text__pick_nothing_confirm='confirm with nothing'
	if test "$items_count" -eq 1 -a "$option_required" = 'yes'; then
		text__pick_cancel='cancel to the'
		text__pick_choose='choose the'
		text__pick_confirm='confirm the'
	elif test "$option_multi" = 'yes'; then
		text__pick_cancel='cancel to the'
		text__pick_choose='choose any of'
		text__pick_confirm='confirm the'
	else
		text__pick_cancel='cancel to the'
		text__pick_choose='choose one of the'
		text__pick_confirm='confirm the'
	fi

	# prepare paging
	terminal_device_file="$(get-terminal-device-file)"
	if ! get-terminal-size-support --quiet; then
		# fix [tput: No value for $TERM and no -T specified] errors when fetching columns and rows on CI
		paging_supported='no'
	fi
	if ! get-terminal-title-support --quiet; then
		# [ssh -T ...] passes [test ! -t 0] [test "$terminal_device_file" = '/dev/stderr'] [__command_exists tput]
		title_supported='no'
	fi

	# prepare hints
	if test -n "$question_title_prompt"; then
		menu_header+="$question_title_prompt"$'\n'
	fi
	if test -n "$question_body_prompt"; then
		menu_header+="$question_body_prompt"$'\n'
	fi
	function add_legend_keys {
		# extract the current state
		local name="$1" legend="$2" keys=("${@:3}") var content rows inject='' total last index key # shrunk lines
		var="${name}_content"
		content="${!var}"
		var="${name}_rows"
		rows="${!var}"
		total="${#keys[@]}"
		last="$((total - 1))"

		# render the legend keys
		# this could be cached, but no need, this operation is rare enough it doesn't matter
		inject+="${style__legend}${legend}${style__end__legend}${style__legend_key_spacer}"
		for ((index = 0; index < total; index++)); do
			key="${keys[index]}"
			inject+="${style__key}${key}${style__end__key}"
			if test "$index" -ne "$last"; then
				inject+="${style__key_key_spacer}"
			fi
		done

		# apply the change performantly
		if test -n "$content" && [[ $content != *$'\n' ]]; then # the trailing newline check is for [SEND LINE BUFFER] edge case
			content+="${style__legend_legend_spacer}${inject}"
		else
			content+="$inject"
		fi
		eval "${name}_content=\"\$content\""

		# append the content, not splitting legend keys across lines - this is disabled because it is not performant and in practice is not ideal
		# if test "$rows" -eq 0; then
		# 	content+="$inject"
		# 	eval "${name}_content=\"\$content\""
		# 	lines="$(echo-count-lines -- "$content")"
		# 	eval "${name}_rows=\"\$lines\""
		# elif test "$paging_supported" = 'yes'; then
		# 	shrunk="$(echo-wrap --width="$content_columns" -- "${content}${style__legend_legend_spacer}${inject}")"
		# 	lines="$(echo-count-lines -- "$shrunk")"
		# 	# if same rows as before, then append on same line, otherwise, append on new line
		# 	if test "$rows" -eq "$lines"; then
		# 		content+="${style__legend_legend_spacer}${inject}"
		# 	else
		# 		content+=$'\n'"$inject"
		# 	fi
		# 	eval "${name}_content=\"\$content\""
		# 	eval "${name}_rows=\"\$lines\""
		# else
		# 	content+="${style__legend_legend_spacer}${inject}"
		# 	eval "${name}_content=\"\$content\""
		# fi
	}
	function legends_rows {
		local name="$1" var content rows
		var="${name}_content"
		content="${!var}"
		rows="$(echo-wrap --width="$content_columns" -- "$content" | echo-count-lines --stdin)"
		eval "${name}_rows=\"$rows\""
	}
	function render_lengends {
		# reset legends
		legend_cancel_content=''
		legend_cancel_rows=0
		legend_choose_content=''
		legend_choose_rows=0
		legend_confirm_content=''
		legend_confirm_rows=0

		# prefer key names if possible, as people don't know the symbols
		if test "$option_multi" = 'yes'; then
			add_legend_keys 'legend_cancel' 'CONFIRM CANCELATION' 'ENTER' 'E'
			add_legend_keys 'legend_choose' 'SELECT' 'SPACE'
			add_legend_keys 'legend_choose' 'CONFIRM' 'ENTER' 'E'
			add_legend_keys 'legend_confirm' 'CONFIRM SELECTION' 'ENTER' 'E'
		else
			add_legend_keys 'legend_cancel' 'CONFIRM CANCELATION' 'SPACE' 'ENTER' 'E'
			add_legend_keys 'legend_choose' 'SELECT' 'SPACE' 'ENTER' 'E'
			add_legend_keys 'legend_confirm' 'CONFIRM SELECTION' 'SPACE' 'ENTER' 'E'
		fi
		add_legend_keys 'legend_cancel' 'ABORT CANCELATION' 'ESC' 'Q'
		add_legend_keys 'legend_confirm' 'CHANGE SELECTION' 'ESC' 'Q'
		add_legend_keys 'legend_cancel' 'ABORT' 'CTRL C'
		add_legend_keys 'legend_confirm' 'ABORT' 'CTRL C'
		if test "$can_cancel" = 'yes'; then
			# cancel restores defaults (if multi) or selects none (if non-multi) and leaves
			add_legend_keys 'legend_choose' 'CANCEL' 'ESC' 'Q'
		fi
		if test "$items_count" -ne 1; then
			# [⬆⬇⇧] have alignment issues, use [↑↓]
			add_legend_keys 'legend_choose' 'UP' '↑' 'W' 'K'
			add_legend_keys 'legend_choose' 'DOWN' '↓' 'S' 'J'
			if test "$can_revert_to_defaults" = 'yes'; then
				add_legend_keys 'legend_choose' 'NEXT PREF' 'TAB'   # next preference
				add_legend_keys 'legend_choose' 'PREV PREF' '⇧ TAB' # prior preference
				add_legend_keys 'legend_choose' 'RESET' 'Z'         # reset preferences
				if test "$option_multi" = 'yes'; then
					add_legend_keys 'legend_choose' 'ALL/NONE' 'T'
				fi
			fi
			if test "$paging_supported" = 'no'; then
				add_legend_keys 'legend_choose' 'FIRST' '←' 'A' 'H' 'HOME' 'fn ⇧ ←'
				add_legend_keys 'legend_choose' 'LAST' '→' 'D' 'L' 'END' 'fn ⇧ →'
			else
				add_legend_keys 'legend_choose' 'PAGE UP' '←' 'A' 'H'   # 'fn ⇧ ↑'
				add_legend_keys 'legend_choose' 'PAGE DOWN' '→' 'D' 'L' # 'fn ⇧ ↓'
				add_legend_keys 'legend_choose' 'FIRST' 'HOME' 'fn ⇧ ←'
				add_legend_keys 'legend_choose' 'LAST' 'END' 'fn ⇧ →'
			fi
			if test "$option_multi" = 'yes'; then
				add_legend_keys 'legend_choose' 'SELECT & NEXT' '+' 'INSERT'
				add_legend_keys 'legend_choose' 'SELECT & PREV' '-'
				add_legend_keys 'legend_choose' 'UNSELECT & NEXT' 'DELETE'
				add_legend_keys 'legend_choose' 'UNSELECT & PREV' 'BACKSPACE'
			fi
		fi
		if test "$paging_supported" = 'yes'; then
			legends_rows 'legend_cancel'
			legends_rows 'legend_choose'
			legends_rows 'legend_confirm'
		else
			legend_cancel_content+=$'\n'
			legend_choose_content+=$'\n'
			legend_confirm_content+=$'\n'
			add_legend_keys 'legend_cancel' 'SEND LINE BUFFER OF KEYPRESSES' 'ENTER'
			add_legend_keys 'legend_choose' 'SEND LINE BUFFER OF KEYPRESSES' 'ENTER'
			add_legend_keys 'legend_confirm' 'SEND LINE BUFFER OF KEYPRESSES' 'ENTER'
			legend_cancel_content+=': '
			legend_choose_content+=': '
			legend_confirm_content+=': '
		fi
	}
	if test "$paging_supported" = 'no'; then
		# no need for paging
		paging_used='no'
		# no need for row and column sizes
		terminal_lines=0
		terminal_columns=0
		content_columns=0
		menu_header_rows=0
		terminal_too_short='no'
		# set the legends. and disable cursors on line-buffering no-TTY mode as it is useful to see where the keys are being buffered
		render_lengends
		style__hide_cursor=''
		style__show_cursor=''
		# set rendering
		mapfile -t items_renders < <(get-array "$items_count")
		mapfile -t items_rows < <(get-array "$items_count")
		# paging support is eternal, so no need for future updates if disabled
		function show_cursor {
			:
		}
		function show_cursor_on_exit {
			:
		}
		function refresh_terminal_size {
			:
		}
	else
		function show_cursor {
			__print_string "$style__show_cursor" >"$terminal_device_file"
			trap - EXIT
		}
		function show_cursor_on_exit {
			trap show_cursor EXIT
		}
		# paging support is eternal, so we need to refresh if enabled
		function refresh_terminal_size {
			# refresh
			local terminal_size=()
			mapfile -t terminal_size < <(get-terminal-lines-and-columns)
			terminal_lines="${terminal_size[0]}"
			terminal_columns="${terminal_size[1]}"

			# only recalculate everything if the size actually changed from last time
			if test "$terminal_lines" -ne "$terminal_lines_prior" -o "$terminal_columns" -ne "$terminal_columns_prior"; then
				content_columns="$((terminal_columns - terminal_margin))"
				# refresh header to column size
				menu_header_rows="$(echo-wrap --width="$content_columns" -- "$menu_header" | echo-count-lines --stdin)"
				# refresh the legends
				render_lengends
				# move start index to current item, as otherwise it could be out of range
				if test "$terminal_lines" -lt "$terminal_lines_prior" -o "$terminal_columns" -lt "$terminal_columns_prior"; then
					# @todo we should detect if showing everything is possible before resorting to this
					menu_top_index_choose="$menu_cursor_choose"
					menu_bottom_index_choose="$menu_cursor_choose"
					menu_top_index_confirm="$menu_cursor_confirm_and_cancel"
					menu_bottom_index_confirm="$menu_cursor_confirm_and_cancel"
				fi
				# reset paging for new size
				paging_used='maybe'
				mapfile -t items_renders < <(get-array "$items_count")
				mapfile -t items_rows < <(get-array "$items_count")
				# update priors
				terminal_lines_prior="$terminal_lines"
				terminal_columns_prior="$terminal_columns"
			fi
			if test -n "$menu_resized_to" && test "$menu_resized_to" -gt "$terminal_lines"; then
				terminal_too_short='yes'
			else
				terminal_too_short='no'
			fi
		}
	fi

	# actions and selection modifications
	local selected=() selected_indexes=() selected_count=0 selected_last=-1
	function select_none {
		selected=()
		selected_indexes=()
		selected_count=0
		selected_last=-1
	}
	if test "$option_multi" = 'yes'; then
		function unselect_index {
			local index
			for index in "$@"; do
				if test "${selected[index]-}" = 'yes'; then
					unset 'selected[index]'
				fi
			done
			selected_indexes=("${!selected[@]}")
			selected_count="${#selected[@]}"
			selected_last="$((selected_count - 1))"
		}
		function select_index {
			local index
			for index in "$@"; do
				if test "${selected[index]-}" != 'yes'; then
					selected[index]='yes'
				fi
			done
			selected_indexes=("${!selected[@]}")
			selected_count="${#selected[@]}"
			selected_last="$((selected_count - 1))"
		}
		function toggle_index {
			local index
			for index in "$@"; do
				if test "${selected[index]-}" = 'yes'; then
					unset 'selected[index]'
				else
					selected[index]='yes'
				fi
			done
			selected_indexes=("${!selected[@]}")
			selected_count="${#selected[@]}"
			selected_last="$((selected_count - 1))"
		}
		function select_all {
			select_index "${!items[@]}"
		}
		function select_defaults {
			if test "$defaults_count" -ne 0; then # bash v3 compat
				select_index "${defaults_indexes[@]}"
			fi
		}
		function action_toggle_cursor {
			if test "$menu_mode" = 'choose'; then
				toggle_index "$menu_cursor_choose"
				if test "$menu_cursor_choose" -eq "$menu_bottom_index_choose"; then
					# don't cause a new page, instead keep rendering it as the bottom item
					menu_direction=-1
				fi
			else
				toggle_index "$menu_cursor_confirm_and_cancel"
				if test "$menu_cursor_confirm_and_cancel" -eq "$menu_bottom_index_confirm"; then
					# don't cause a new page, instead keep rendering it as the bottom item
					menu_direction=-1
				fi
			fi
		}
		function action_select_and_next {
			if test "$menu_mode" = 'choose'; then
				select_index "$menu_cursor_choose"
			else
				select_index "$menu_cursor_confirm_and_cancel"
			fi
			action_down
		}
		function action_unselect_and_next {
			if test "$menu_mode" = 'choose'; then
				unselect_index "$menu_cursor_choose"
			else
				unselect_index "$menu_cursor_confirm_and_cancel"
			fi
			action_down
		}
		function action_select_and_prior {
			if test "$menu_mode" = 'choose'; then
				select_index "$menu_cursor_choose"
			else
				select_index "$menu_cursor_confirm_and_cancel"
			fi
			action_up
		}
		function action_unselect_and_prior {
			if test "$menu_mode" = 'choose'; then
				unselect_index "$menu_cursor_choose"
			else
				unselect_index "$menu_cursor_confirm_and_cancel"
			fi
			action_up
		}
		function action_all {
			select_all
		}
	else
		function select_only_index {
			if test "$#" -ne 0; then
				selected=()
				selected["$1"]='yes'
				selected_indexes=("${!selected[@]}")
				selected_count=1
				selected_last=0
				menu_cursor_choose="$1"
				menu_cursor_confirm_and_cancel=0
			fi
		}
		function select_defaults {
			# select only first preference
			if test "$defaults_count" -ne 0; then
				select_only_index "${defaults_indexes[0]}"
			fi
		}
		function action_select_cursor {
			if test "$menu_mode" = 'choose'; then
				select_only_index "$menu_cursor_choose"
			else
				select_only_index "$menu_cursor_confirm_and_cancel"
			fi
		}
	fi
	function select_only_defaults {
		select_none # needed in case there are no defaults, we still want to erase selection
		select_defaults
	}
	function action_none {
		select_none
	}
	function action_revert {
		# if no defaults, removes selection
		select_none
		select_defaults
	}
	function action_jump {
		local index="$1"
		# jump to number
		if test "$menu_mode" = 'choose'; then
			if test "$index" -le 1; then
				menu_cursor_choose=0
			elif test "$index" -ge "$items_count"; then
				menu_cursor_choose="$items_last"
			else
				menu_cursor_choose="$((index - 1))"
			fi
		else
			if test "$index" -le 1; then
				menu_cursor_confirm_and_cancel=0
			elif test "$index" -ge "$selected_count"; then
				menu_cursor_confirm_and_cancel="$selected_last"
			else
				menu_cursor_confirm_and_cancel="$((index - 1))"
			fi
		fi

	}
	function action_up {
		if test "$menu_mode" = 'choose'; then
			if test "$menu_cursor_choose" -le 0; then
				menu_cursor_choose="$items_last"
			else
				menu_cursor_choose="$((menu_cursor_choose - 1))"
			fi
		else
			if test "$menu_cursor_confirm_and_cancel" -le 0; then
				menu_cursor_confirm_and_cancel="$selected_last"
			else
				menu_cursor_confirm_and_cancel="$((menu_cursor_confirm_and_cancel - 1))"
			fi
		fi
	}
	function action_down {
		if test "$menu_mode" = 'choose'; then
			if test "$menu_cursor_choose" -ge "$items_last"; then
				menu_cursor_choose=0
			else
				menu_cursor_choose="$((menu_cursor_choose + 1))"
				if test "$menu_cursor_choose" -ge "$menu_bottom_index_choose"; then
					# scroll down by one, rather than render whole new page
					menu_direction=-1
				fi
			fi
		else
			if test "$menu_cursor_confirm_and_cancel" -ge "$selected_last"; then
				menu_cursor_confirm_and_cancel=0
			else
				menu_cursor_confirm_and_cancel="$((menu_cursor_confirm_and_cancel + 1))"
				if test "$menu_cursor_confirm_and_cancel" -ge "$menu_bottom_index_confirm"; then
					# scroll down by one, rather than render whole new page
					menu_direction=-1
				fi
			fi
		fi
	}
	if test "$paging_supported" = 'yes'; then
		function action_page_up {
			if test "$menu_mode" = 'choose'; then
				if test "$menu_cursor_choose" -le "$menu_top_index_choose"; then
					menu_direction=-1
				else
					menu_cursor_choose="$menu_top_index_choose"
				fi
			else
				if test "$menu_cursor_confirm_and_cancel" -le "$menu_top_index_confirm"; then
					menu_direction=-1
				else
					menu_cursor_confirm_and_cancel="$menu_top_index_confirm"
				fi
			fi
		}
		function action_page_down {
			if test "$menu_mode" = 'choose'; then
				if test "$menu_cursor_choose" -ge "$menu_bottom_index_choose"; then
					menu_direction=1
				else
					menu_cursor_choose="$menu_bottom_index_choose"
					menu_direction=-1
				fi
			else
				if test "$menu_cursor_confirm_and_cancel" -ge "$menu_bottom_index_confirm"; then
					menu_direction=1
				else
					menu_cursor_confirm_and_cancel="$menu_bottom_index_confirm"
					menu_direction=-1
				fi
			fi
		}
	fi
	function action_first {
		if test "$menu_mode" = 'choose'; then
			menu_cursor_choose=0
		else
			menu_cursor_confirm_and_cancel=0
		fi
	}
	function action_last {
		if test "$menu_mode" = 'choose'; then
			menu_cursor_choose="$items_last"
		else
			menu_cursor_confirm_and_cancel="$selected_last"
		fi
	}
	function __is_preference {
		local index="$1"
		test "${selected[index]-}" = 'yes' -o "${defaults[index]-}" = 'yes'
	}
	function action_next_preference {
		if test "$menu_mode" != 'choose'; then
			action_down
			return
		fi
		local index
		# next selection
		for ((index = menu_cursor_choose + 1; index <= items_last; index++)); do
			if __is_preference "$index"; then
				menu_cursor_choose="$index"
				return 0
			fi
		done
		# earlier selection
		for ((index = 0; index < menu_cursor_choose; index++)); do
			if __is_preference "$index"; then
				menu_cursor_choose="$index"
				return 0
			fi
		done
		# no selection
		return 0
	}
	function action_prior_preference {
		if test "$menu_mode" != 'choose'; then
			action_up
			return
		fi
		local index
		# go backwards to the start
		for ((index = menu_cursor_choose - 1; index >= 0; index--)); do
			if __is_preference "$index"; then
				menu_cursor_choose="$index"
				return 0
			fi
		done
		# go backwards from the end
		for ((index = items_last; index > menu_cursor_choose; index--)); do
			if __is_preference "$index"; then
				menu_cursor_choose="$index"
				return 0
			fi
		done
		# no selection
		return 0
	}
	function set_menu_mode {
		local new="$1"
		# sanity check if new menu is appropriate
		if test "$option_required" = 'yes'; then
			# if required, and trying to do proceed without items, then go back to choose and send a bell
			if
				test "$selected_count" -eq 0 && test "$new" = 'confirm' -o "$new" = 'confirmed' ||
					test "$fallbacks_count" -eq 0 -a "$new" = 'cancel'
			then
				menu_skip_render='yes'
				menu_mode='choose'
				__print_string "$style__bell" >"$terminal_device_file"
				return 0
			fi
		fi
		# check if we need to recalculate paging and update the mode
		if test "$new" != "$menu_mode"; then
			if test "$paging_supported" = 'yes'; then
				paging_used='maybe'
			fi
			menu_mode="$new"
			if test "$new" != 'choose'; then
				# reset cursor
				menu_cursor_confirm_and_cancel=0
			fi
		fi
		# all done
		return 0
	}
	local debug_counter=0
	function render_menu {
		local \
			bar_bottom_content='' \
			bar_bottom_selected_count=0 \
			bar_bottom_unselected_defaults_count=0 \
			bar_middle_content='' \
			bar_middle_selected_count=0 \
			bar_middle_unselected_defaults_count=0 \
			bar_top_content='' \
			bar_top_selected_count=0 \
			bar_top_unselected_defaults_count=0 \
			index \
			item_index=0 \
			item_line \
			item_original \
			item_rendered \
			item_rows \
			items_bundled_rows=0 \
			items_bundled='' \
			line_prefix \
			line_begin \
			line_end \
			menu_bottom_index \
			menu_cursor \
			menu_index="${1-}" \
			menu_last \
			menu_legend_content \
			menu_legend_rows \
			menu_rows=0 \
			menu_title='' \
			menu_top_index \
			menu_total \
			page_items_count \
			verb \
			verb_total
		# refresh the terminal size
		refresh_terminal_size
		# fetch the appropriate size, must be done after refresh_terminal_size
		if test "$menu_mode" = 'choose'; then
			verb='Selected'
			menu_bottom_index="$menu_bottom_index_choose"
			menu_cursor="$menu_cursor_choose"
			menu_legend_content="$legend_choose_content"
			menu_legend_rows="$legend_choose_rows"
			menu_total="$items_count"
			menu_last="$items_last"
			menu_top_index="$menu_top_index_choose"
		else
			if test "$menu_mode" = 'cancel'; then
				verb='Cancel to'
				menu_total="$fallbacks_count"
				menu_last="$fallbacks_last"
				menu_legend_content="$legend_cancel_content"
				menu_legend_rows="$legend_cancel_rows"
			else
				verb='Confirm'
				menu_total="$selected_count"
				menu_last="$selected_last"
				menu_legend_content="$legend_confirm_content"
				menu_legend_rows="$legend_confirm_rows"
			fi
			# @todo, consider having these and cursors for cancel as well, instead of sharing with confirm
			menu_bottom_index="$menu_bottom_index_confirm"
			menu_cursor="$menu_cursor_confirm_and_cancel"
			menu_top_index="$menu_top_index_confirm"
		fi
		# adjust page direction
		if test -z "$menu_index"; then
			if test "$menu_cursor" -le 0; then
				menu_cursor=0
				menu_index="$menu_cursor"
				menu_direction=1
			elif test "$menu_cursor" -ge "$menu_last"; then
				menu_cursor="$menu_last"
				menu_index="$menu_cursor"
				menu_direction=-1
			elif test "$menu_cursor" -le "$menu_top_index"; then
				menu_index="$menu_cursor"
			elif test "$menu_cursor" -ge "$menu_bottom_index"; then
				menu_index="$menu_cursor"
			elif test "$menu_direction" -eq 1; then
				# maintain the same page, as the cursor is within it
				menu_index="$menu_top_index"
			else
				# maintain the same page, as the cursor is within it
				menu_index="$menu_bottom_index"
			fi
		fi
		# @TODO HANDLE NO SELECTED OPTIONS BETTER, PERHAPS AN IF HERE
		if test "$paging_supported" = 'no'; then
			menu_index=0
			menu_direction=1
		fi
		menu_top_index="$menu_index"
		menu_bottom_index="$menu_index"
		menu_resized_to=''
		# debug
		function debug {
			printf '%s' $'\e]0;'"c=$menu_cursor,mi=$menu_index,ii=$item_index,d=$menu_direction,t=$menu_top_index,b=$menu_bottom_index,l=$menu_last,u=$paging_used,r=$menu_rows,mr=$menu_resized_to,tr=$terminal_lines,tts=$terminal_too_short,c=$debug_counter"$'\a' >"$terminal_device_file"
			debug_counter="$((debug_counter + 1))"
		}
		# e.g. go to second page, navigate half way, go page up
		for (( ; menu_index >= 0 && menu_index <= menu_last; menu_index += menu_direction)); do
			if test "$menu_mode" = 'choose'; then
				item_index="$menu_index"
			elif test "$menu_mode" = 'cancel'; then
				item_index="${fallbacks_indexes[menu_index]}"
			else
				item_index="${selected_indexes[menu_index]}"
			fi
			# determine prefix
			if test "$menu_index" -eq "$menu_cursor"; then
				line_begin="$style__active_line"
				line_prefix="$style__indent_active"
				line_end="$style__end__active_line"
			else
				line_begin="$style__inactive_line"
				line_prefix="$style__indent_inactive"
				line_end="$style__end__inactive_line"
			fi
			if test "${selected[item_index]-}" = 'yes' -a "$menu_mode" != 'cancel'; then
				line_begin+="$style__selected_line"
				line_prefix+="${style__icon_selected}"
				line_end+="$style__end__selected_line"
				bar_middle_selected_count="$((bar_middle_selected_count + 1))"
			elif test "${defaults[item_index]-}" = 'yes'; then
				line_begin+="$style__default_line"
				line_prefix+="${style__icon_default}"
				line_end+="$style__end__default_line"
				bar_middle_unselected_defaults_count="$((bar_middle_unselected_defaults_count + 1))"
			elif test "$menu_index" -eq "$menu_cursor"; then
				line_prefix+="${style__icon_active}"
			else
				line_prefix+="${style__icon_standard}"
			fi
			line_prefix="${line_begin}${line_prefix}"

			# determine paging
			if test "$paging_used" = 'no'; then
				# paging is no longer needed, now row calculations needed, only need to blockquote the multiline item
				if test -n "${items_renders[item_index]}"; then
					item_rendered="${items_renders[item_index]}"
				else
					item_original="${items[item_index]}"
					item_rendered="$item_original"
					item_rendered="${item_rendered//$'\n'/$'\n'"${style__indent_bar}${style__bar_line}"}" # re-add the necessary indentation
					items_renders[item_index]="$item_rendered"
				fi
				# use rendered item
				item_line="${line_prefix}${item_rendered}${line_end}"$'\n'
			else
				# paging is needed, so we must recalculate bundled size
				if test -n "${items_rows[item_index]}"; then
					item_rendered="${items_renders[item_index]}"
					item_rows="${items_rows[item_index]}"
				else
					item_original="${items[item_index]}"
					if test "${#item_original}" -lt "$content_columns" && [[ $item_original != *$'\n'* && $item_original != *$'\t'* ]]; then
						# no need to format item, as it is small enough
						item_rendered="$item_original"
						item_rows=1
						items_renders[item_index]="$item_rendered"
						items_rows[item_index]="$item_rows"
					else
						# need to format item, as it is too big
						item_rendered="$item_original"
						item_rendered="${item_rendered//$'\n'/$'\n'"${style__indent_bar}${style__bar_line}"}" # re-add the necessary indentation
						item_rendered="$(echo-wrap --width="$content_columns" -- "$item_rendered")"
						item_rows="$(echo-count-lines -- "$item_rendered")"
						items_renders[item_index]="$item_rendered"
						items_rows[item_index]="$item_rows"
					fi
				fi
				# calculate total menu size
				menu_rows="$((menu_header_rows + items_bundled_rows + item_rows + menu_legend_rows + 3))"
				item_line="${line_prefix}${item_rendered}${line_end}"$'\n'
				items_bundled_rows="$((items_bundled_rows + item_rows))"
				if test "$menu_rows" -gt "$terminal_lines"; then
					if test -z "$items_bundled"; then
						# we need to reszie the terminal
						menu_resized_to="$menu_rows"
					else
						# we already have content rendered, so exit with what we have
						break
					fi
				fi
			fi
			# append or prepend the line to the bundle
			# item line will always be defined, no need for test -n
			if test "$menu_direction" -eq 1; then
				items_bundled+="$item_line"
				menu_bottom_index="$menu_index"
			else
				items_bundled="$item_line$items_bundled"
				menu_top_index="$menu_index"
			fi
			if test -n "$menu_resized_to"; then
				break
			fi
		done

		# save paging changes
		if test "$menu_mode" = 'choose'; then
			menu_top_index_choose="$menu_top_index"
			menu_bottom_index_choose="$menu_bottom_index"
		else
			menu_top_index_confirm="$menu_top_index"
			menu_bottom_index_confirm="$menu_bottom_index"
		fi

		# calculate paging needed
		if test "$paging_supported" = 'yes'; then
			if test "$menu_top_index" -eq 0 -a "$menu_bottom_index" -eq "$menu_last"; then
				paging_used='no'
			else
				paging_used='yes'
			fi
		fi

		# if paging was used, and we could support more rows, then re-render in the other direction
		# @todo update menu_index instead of cursor, so that cursor remains sensible (optional, may not be a good idea)
		if test "$paging_used" = 'yes' -a "$menu_rows" -lt "$terminal_lines"; then
			if test "$menu_direction" -eq -1 -a "$menu_top_index" -eq 0; then
				menu_direction=1
				render_menu 0
				return
			elif test "$menu_direction" -eq 1 -a "$menu_bottom_index" -eq "$menu_last"; then
				menu_direction=-1
				render_menu "$menu_last"
				return
			fi
		fi

		# reset direction
		if test "$menu_direction" -eq -1; then
			menu_direction=1
		fi

		# resize the terminal if it is too short?
		if test -n "$menu_resized_to"; then
			menu_title+=$'\e[8;'"$menu_resized_to"';t'
		fi

		# calculate page top, middle, bottom
		if test -z "$items_bundled"; then
			# no items, no need to count
			page_items_count=0
			if test "$menu_mode" = 'choose'; then
				bar_top_content+="${style__indent_bar}${style__bar_top}${style__count_empty}${text__pick_nothing_choose} below${style__end__count_empty}"
				items_bundled="${style__active_line}${style__empty_line}${style__indent_active}${style__icon_nothing_provided}${style__end__empty_line}${style__end__active_line}"$'\n'
				bar_bottom_content+="${style__indent_bar}${style__bar_bottom}${style__count_empty}${text__pick_nothing_choose} above${style__end__count_empty}"
			elif test "$menu_mode" = 'cancel'; then
				bar_top_content+="${style__indent_bar}${style__bar_top}${style__count_defaults}${text__pick_nothing_cancel} selected${style__end__count_empty}"
				items_bundled="${style__active_line}${style__empty_line}${style__indent_active}${style__icon_no_selection}${style__end__empty_line}${style__end__active_line}"$'\n'
				bar_bottom_content+="${style__indent_bar}${style__bar_bottom}${style__count_defaults}${text__pick_nothing_cancel} selected${style__end__count_empty}"
			else
				bar_top_content+="${style__indent_bar}${style__bar_top}${style__count_selected}${text__pick_nothing_confirm} selected${style__end__count_empty}"
				items_bundled="${style__active_line}${style__empty_line}${style__indent_active}${style__icon_no_selection}${style__end__empty_line}${style__end__active_line}"$'\n'
				bar_bottom_content+="${style__indent_bar}${style__bar_bottom}${style__count_selected}${text__pick_nothing_confirm} selected${style__end__count_empty}"
			fi
		else
			# has items, do counts
			page_items_count="$((menu_bottom_index - menu_top_index + 1))"

			# calculate header counts
			if test "$menu_top_index" -eq 0; then
				if test "$menu_mode" = 'choose'; then
					# choose
					bar_top_content+="${style__indent_bar}${style__bar_top}${style__count_more}${text__pick_choose} ${menu_total} below${style__end__count_more}"
					bar_top_selected_count="$selected_count"
					for index in "${defaults_indexes[@]}"; do
						if test "${selected[index]-}" = 'yes'; then
							continue
						fi
						bar_top_unselected_defaults_count="$((bar_top_unselected_defaults_count + 1))"
					done
				elif test "$menu_mode" = 'cancel'; then
					# cancel
					if test "$defaults_count" -ne "$fallbacks_count" -a "$fallbacks_count" -eq 1; then
						bar_top_content+="${style__indent_bar}${style__bar_top}${style__count_defaults}${text__pick_cancel} first default below${style__end__count_defaults}"
					else
						bar_top_content+="${style__indent_bar}${style__bar_top}${style__count_defaults}${text__pick_cancel} ${menu_total} defaults below${style__end__count_defaults}"
					fi
				else
					# confirm
					bar_top_content+="${style__indent_bar}${style__bar_top}${style__count_selected}${text__pick_confirm} ${menu_total} selected below${style__end__count_selected}"
				fi
			else
				if test "$menu_mode" = 'choose'; then
					# choose
					bar_top_content+="${style__indent_bar}${style__bar_middle}${style__count_more}${menu_top_index} more above${style__end__count_more}"
					for index in "${selected_indexes[@]}"; do
						if test "$index" -ge "$menu_top_index"; then
							break
						fi
						bar_top_selected_count="$((bar_top_selected_count + 1))"
					done
					for index in "${defaults_indexes[@]}"; do
						if test "$index" -ge "$menu_top_index"; then
							break
						fi
						if test "${selected[index]-}" = 'yes'; then
							continue
						fi
						bar_top_unselected_defaults_count="$((bar_top_unselected_defaults_count + 1))"
					done
				elif test "$menu_mode" = 'cancel'; then
					# cancel
					bar_top_content+="${style__indent_bar}${style__bar_middle}${style__count_defaults}${menu_top_index} more defaults above${style__end__count_defaults}"
				else
					# confirm
					bar_top_content+="${style__indent_bar}${style__bar_middle}${style__count_selected}${menu_top_index} more selected above${style__end__count_selected}"
				fi
			fi

			# calculate bottom counts
			if test "$menu_bottom_index" -eq "$menu_last"; then
				if test "$menu_mode" = 'choose'; then
					# choose
					bar_bottom_content+="${style__indent_bar}${style__bar_bottom}${style__count_more}${text__pick_choose} ${menu_total} above${style__end__count_more}"
					bar_bottom_selected_count="$selected_count"
					for index in "${defaults_indexes[@]}"; do
						if test "${selected[index]-}" = 'yes'; then
							continue
						fi
						bar_bottom_unselected_defaults_count="$((bar_bottom_unselected_defaults_count + 1))"
					done
				elif test "$menu_mode" = 'cancel'; then
					# cancel
					if test "$defaults_count" -ne "$fallbacks_count" -a "$fallbacks_count" -eq 1; then
						bar_bottom_content+="${style__indent_bar}${style__bar_bottom}${style__count_defaults}${text__pick_cancel} first default above${style__end__count_defaults}"
					else
						bar_bottom_content+="${style__indent_bar}${style__bar_bottom}${style__count_defaults}${text__pick_cancel} ${menu_total} defaults above${style__end__count_defaults}"
					fi
				else
					# confirm
					bar_bottom_content+="${style__indent_bar}${style__bar_bottom}${style__count_selected}${text__pick_confirm} ${menu_total} selected above${style__end__count_selected}"
				fi
			else
				index="$((menu_last - menu_bottom_index))"
				if test "$menu_mode" = 'choose'; then
					# choose
					bar_bottom_content+="${style__indent_bar}${style__bar_middle}${style__count_more}${index} more below"
					for index in "${selected_indexes[@]}"; do
						if test "$index" -le "$menu_bottom_index"; then
							continue
						fi
						bar_bottom_selected_count="$((bar_bottom_selected_count + 1))"
					done
					for index in "${defaults_indexes[@]}"; do
						if test "$index" -le "$menu_bottom_index" -o "${selected[index]-}" = 'yes'; then
							continue
						fi
						bar_bottom_unselected_defaults_count="$((bar_bottom_unselected_defaults_count + 1))"
					done
				elif test "$menu_mode" = 'cancel'; then
					# cancel
					bar_bottom_content+="${style__indent_bar}${style__bar_middle}${style__count_defaults}cancel to ${index} more defaults below${style__end__count_defaults}"
				else
					# confirm
					bar_bottom_content+="${style__indent_bar}${style__bar_middle}${style__count_selected}confirm ${index} more selected below${style__end__count_selected}"
				fi
			fi

			# add selected and unslected defaults counts
			if test "$menu_mode" = 'choose'; then
				# choose: top bar
				if test "$bar_top_selected_count" -ne 0; then
					bar_top_content+="${style__count_spacer}${style__count_selected}${bar_top_selected_count} selected${style__end__count_selected}"
				fi
				if test "$bar_top_unselected_defaults_count" -ne 0; then
					bar_top_content+="${style__count_spacer}${style__count_defaults}${bar_top_unselected_defaults_count} unselected defaults${style__end__count_defaults}"
				fi
				# choose: middle bar
				if test "$paging_used" = 'yes'; then
					bar_middle_content+="${style__indent_bar}${style__bar_middle}${style__count_more}${page_items_count} visible${style__end__count_more}"
					if test "$bar_middle_selected_count" -ne 0; then
						bar_middle_content+="${style__count_spacer}${style__count_selected}${bar_middle_selected_count} selected${style__end__count_selected}"
					fi
					if test "$bar_middle_unselected_defaults_count" -ne 0; then
						bar_middle_content+="${style__count_spacer}${style__count_defaults}${bar_middle_unselected_defaults_count} unselected defaults${style__end__count_defaults}"
					fi
				fi
				# choose: bottom bar
				if test "$bar_bottom_selected_count" -ne 0; then
					bar_bottom_content+="${style__count_spacer}${style__count_selected}${bar_bottom_selected_count} selected${style__end__count_selected}"
				fi
				if test "$bar_bottom_unselected_defaults_count" -ne 0; then
					bar_bottom_content+="${style__count_spacer}${style__count_defaults}${bar_bottom_unselected_defaults_count} unselected defaults${style__end__count_defaults}"
				fi
			elif test "$menu_mode" = 'cancel'; then
				# cancel
				bar_middle_content+="${style__indent_bar}${style__bar_middle}${style__count_defaults}${page_items_count} visible${style__end__count_defaults}"
			else
				# confirm
				bar_middle_content+="${style__indent_bar}${style__bar_middle}${style__count_selected}${page_items_count} visible${style__end__count_selected}"
			fi
		fi
		bar_top_content+="${style__end__bar_top}"$'\n'
		if test -n "$bar_middle_content"; then
			bar_middle_content+="${style__end__bar_middle}"$'\n'
		fi
		bar_bottom_content+="${style__end__bar_bottom}"$'\n'

		# output menu
		if test "$menu_mode" = 'choose'; then
			verb_total="$selected_count"
		else
			verb_total="$menu_total"
		fi
		if test "$title_supported" = 'no'; then
			menu_title=''
		elif test "$paging_used" = 'yes'; then
			menu_title+=$'\e]0;'"👉 ${verb} ${verb_total} of ${items_count} items 💁‍♀️ Viewing ${page_items_count} of ${items_count} items [$((menu_top_index + 1))…$((menu_cursor + 1))…$((menu_bottom_index + 1))] 👈"$'\a'
		else
			menu_title+=$'\e]0;'"👉 ${verb} ${verb_total} of ${items_count} items 👈"$'\a'
		fi
		printf '%s' "${style__clear_screen}${style__hide_cursor}${menu_title}${menu_header}${bar_top_content}${bar_middle_content}${items_bundled}${bar_bottom_content}${menu_legend_content}" >"$terminal_device_file"
		if test -n "$menu_resized_to"; then
			refresh_terminal_size
			if test "$terminal_too_short" = 'yes'; then
				menu_title=$'\e]0;'"‼️ TERMINAL TOO SHORT ‼️"$'\a'
				local additional_rows="$((menu_resized_to - terminal_lines))"
				printf '%s' "${style__clear_screen}${style__hide_cursor}${menu_title}${style__error}You have been prompted to make a menu selection, however the terminal does not have enough vertical height to make that selection.${style__end__error}"$'\n'"${style__notice}Increase the terminal height or reduce font size to proceed, then press any key.${style__end__notice}"$'\n'"Terminal rows = ${terminal_lines}, Needed rows = ${menu_resized_to}, Additional rows = ${additional_rows}"$'\n' >"$terminal_device_file"
			fi
		fi
	}
	function render_result {
		local render="${question_title_result}${commentary}" index item item_rendered
		if test -n "$render"; then
			render+=$'\n'
		fi
		if test "$menu_status" -eq 0; then
			# render linger or temp
			if test "$option_linger" = 'yes'; then
				# add results only if lingering, as there may be more than terminal height, so clearing wouldn't support such
				if test "$selected_count" -eq 0; then
					render+="${style__commentary_nothing_selected}"$'\n'
				else
					for index in "${selected_indexes[@]}"; do
						if test "${selected[index]}" = 'yes'; then
							item="${items[index]}"
							item_rendered="${item//$'\n'/$'\n'"$style__indent_blockquote"}" # re-add the necessary indentation
							render+="${style__result_line}${style__icon_selected}${item_rendered}${style__end__result_line}"$'\n'
						fi
					done
				fi
				# inform
				__print_string "$render" >"$terminal_device_file"
			elif test -n "$commentary"; then
				# inform to stderr, consistent with ask, choose, confirm
				__print_string "$render" >/dev/stderr
			fi
			# stdout
			for index in "${selected_indexes[@]}"; do
				if test "${selected[index]}" = 'yes'; then
					__print_lines "${returns[index]}"
				fi
			done
		else
			# inform
			if test -n "$commentary"; then
				if test "$option_linger" = 'yes'; then
					__print_string "$render" >"$terminal_device_file"
				else
					__print_string "$render" >/dev/stderr
				fi
			fi
			return "$menu_status"
		fi
	}
	function handle_menu {
		local input read_status keys skips
		# action
		show_cursor_on_exit
		__print_string "$style__alternative_screen_buffer" >"$terminal_device_file"
		while true; do
			# (re-)render the menu?
			if test "$menu_skip_render" = 'no'; then
				render_menu
			fi
			menu_skip_render='no'

			# handle the response
			eval_capture --statusvar=read_status --stdoutvar=input -- read-key --timeout="$option_timeout"
			if test "$read_status" -eq 60; then
				if test "$selected_count" -ne 0; then
					# default
					commentary="${style__result_commentary_spacer}${style__commentary_timeout_default}"
					action_revert
					set_menu_mode 'exit'
					break
				elif test "$option_required" = 'no'; then
					# optional
					commentary="${style__result_commentary_spacer}${style__commentary_timeout_optional}"
					action_none
					set_menu_mode 'exit'
					break
				else
					# required
					commentary="${style__result_commentary_spacer}${style__commentary_timeout_required}"
					menu_status="$read_status"
					set_menu_mode 'exit'
					break
				fi
			elif test "$read_status" -eq 94; then
				# unknown character, send bell and continue
				menu_skip_render='yes'
				__print_string "$style__bell" >"$terminal_device_file"
				continue
			elif test "$read_status" -ne 0; then
				# failure
				commentary="${style__result_commentary_spacer}$(printf "$style__commentary_input_failure" "read status: $read_status")"
				menu_status="$read_status" # error causes no selection
				set_menu_mode 'exit'
				break
			elif test "$terminal_too_short" = 'yes'; then
				continue
			elif test -z "$input"; then
				menu_skip_render='yes'
				continue
			fi

			# input => keys => key
			keys=()
			skips=()
			mapfile -t keys <<<"$input"
			for key in "${keys[@]}"; do
				if is-digit -- "$key"; then
					action_jump "$key"
					# it may be tempting to make these (this action and below) non-multi selections, however that is not desired for timeouts, as timeouts should be empty if non-required, or the default if required, rather than whatever the user had their menu on, as timeout = escape/cancel
				elif test "$key" = 'up' -o "$key" = 'w' -o "$key" = 'k'; then
					action_up
				elif test "$key" = 'down' -o "$key" = 's' -o "$key" = 'j'; then
					action_down
				elif test "$key" = 'left' -o "$key" = 'a' -o "$key" = 'h' -o "$key" = 'page-up'; then
					if test "$paging_supported" = 'yes'; then
						action_page_up
					else
						action_first
					fi
				elif test "$key" = 'right' -o "$key" = 'd' -o "$key" = 'l' -o "$key" = 'page-down'; then
					if test "$paging_supported" = 'yes'; then
						action_page_down
					else
						action_last
					fi
				elif test "$key" = 'home'; then
					action_first
				elif test "$key" = 'end'; then
					action_last
				elif test "$key" = 'tab'; then
					action_next_preference
				elif test "$key" = 'backtab'; then
					action_prior_preference
				elif test "$menu_mode" = 'cancel'; then
					# CANCEL MENU
					if test "$key" = 'enter' -o "$key" = 'e' || test "$key" = 'space' -a "$option_multi" = 'no'; then
						action_revert
						set_menu_mode 'confirmed'
						break
					elif test "$key" = 'escape' -o "$key" = 'q'; then
						set_menu_mode 'choose'
					fi
				elif test "$menu_mode" = 'confirm'; then
					# CONFIRM MENU
					if test "$key" = 'enter' -o "$key" = 'e' || test "$key" = 'space' -a "$option_multi" = 'no'; then
						set_menu_mode 'confirmed'
						break
					elif test "$key" = 'escape' -o "$key" = 'q'; then
						set_menu_mode 'choose'
					fi
				elif test "$key" = 'space'; then
					if test "$option_multi" = 'yes'; then
						action_toggle_cursor
					else
						action_select_cursor
						if test "$option_confirm_input" = 'yes'; then
							set_menu_mode 'confirm'
						else
							set_menu_mode 'confirmed'
							break
						fi
					fi
				elif test "$can_cancel" = 'yes' && test "$key" = 'escape' -o "$key" = 'q'; then
					if test "$option_confirm_input" = 'yes'; then
						set_menu_mode 'cancel'
					else
						action_revert
						set_menu_mode 'confirmed'
						break
					fi
				elif test "$key" = 'enter' -o "$key" = 'e'; then
					if test "$option_multi" = 'no'; then
						action_select_cursor
					fi
					if test "$option_confirm_input" = 'yes'; then
						set_menu_mode 'confirm'
					else
						set_menu_mode 'confirmed'
						break
					fi
				elif test "$key" = 'z'; then
					action_revert
				elif test "$option_multi" = 'yes'; then
					if test "$key" = 't'; then
						if test "$selected_count" -eq "$items_count"; then
							action_none
						else
							action_all
						fi
					elif test "$key" = 'insert' -o "$key" = '+'; then
						action_select_and_next
					elif test "$key" = '-'; then
						action_select_and_prior
					elif test "$key" = 'backspace'; then
						action_unselect_and_prior
					elif test "$key" = 'delete'; then
						action_unselect_and_next
					elif test "$key" = 'all'; then
						action_all
					else
						# nothing done, no need to repeat, just need to read again
						skips+=("$key")
						continue
					fi
				else
					# nothing done, no need to repeat, just need to read again
					skips+=("$key")
					continue
				fi
			done
			if test "${#skips[@]}" -eq "${#keys[@]}"; then
				# all were unknown characters, send bell and continue
				menu_skip_render='yes'
				__print_string "$style__bell" >"$terminal_device_file"
				continue
			fi

			# finish if finished
			if test "$menu_mode" = 'confirmed' -o "$menu_mode" = 'exit'; then
				break
			fi
		done
		show_cursor
		__print_string "$style__default_screen_buffer" >"$terminal_device_file"
	}

	# select the defaults
	select_defaults

	# render if not skipping
	if test "$can_skip_prompt" = 'yes'; then
		: # we have defaults, and want to skip defaults
	else
		handle_menu
	fi

	# render result
	render_result
	return
)

# fire if invoked standalone
if test "$0" = "${BASH_SOURCE[0]}"; then
	if test "$*" = '--test'; then
		choose_test
	else
		choose_ "$@"
	fi
fi
