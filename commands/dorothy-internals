#!/usr/bin/env bash
# trunk-ignore-all(shellcheck/SC2034)
# trunk-ignore-all(shellcheck/SC2178)
source "$DOROTHY/sources/bash.bash"

# =====================================
# SPECIAL NOTES ON IMPLEMENTATIONS

# Initial prototypes are found here:
# https://gist.github.com/balupton/21ded5cefc26dc20833e6ed606209e1b

# Within the trap, one must use `|| return $?` instead of `|| return` due to this bug in versions prior to v4.4:
# > f.  Fixed a bug that caused `return' executed from a trap handler to use the wrong return status when one was not supplied as an argument.
# Which caused these failures:
# https://github.com/bevry/dorothy/actions/runs/13102792036

# Within the wrapper, care must be taken to ensure any function calls do throw another ERR trap
# For instance, if `__is_subshell_function` uses `test` instead of `[[`
# Or if, `[[ ... ]]` is used but without `|| return`
# Then an ERR trap will be thrown, causing unintended logic paths

# Bash versions prior to 4.4, have a bug where `return <non-zero>` becomes `return 0` within traps
# > _run_trap_internal: make sure to catch and use return values supplied as arguments to return; instead of just catching return, make sure we use return_catch_value as well. Affects RETURN, DEBUG, ERROR traps.
# > https://stackoverflow.com/q/79495360/130638
# There are some ways to work around this, such as leveraging difference between bash 4.2 and 4.3; however nothing is perfect, as such detection, prevention, and crashing for consistency and safety is essential
# This is likely what actually caused this bug report:
# https://github.com/bevry/dorothy/issues/203#issuecomment-2628393491

# Bash v4.4 also introduces `inherit_errexit`, however this has no effect on our tests so far, as only `se -Ee` are relevant.

# For interesting outputs of historical tests, see:
# https://gist.github.com/balupton/029d30458b6f31dddb8091496c7f8b3e

# =====================================
# Parse Arguments

all_implementations=(core 1 2 3 4 4b 5 5b 5c 6)

function help {
	cat <<-EOF >&2
		dorothy-internals

		USAGE:
		dorothy-internals [...options]

		OPTIONS:
		--i=<implementation> | --implementation=<implementation> | -- ...<implementation>
		    Use this specific __try implementation, available are: ${all_implementations[*]}.
		--ai | --all-implementations | --all-try-implementations
		    Use all available __try implementations.

		--v=<version> | --version=<version>
		    Use this specific bash <version> or binary.
		--av | --all-versions | --all-bash-versions | --test
		    Use all available bash versions.

		--skip=<test>
		    Skip this specific test.
		--only=<test>
		    Only run this specific test. This is used to capture results of tests that crash.

		DEFAULTS:
		Defaults to [core] for the implementation. Defaults to current bash version.
	EOF
	if [[ $# -ne 0 ]]; then
		echo-error "$@"
	fi
	return 22 # EINVAL 22 Invalid argument
}
item=''
option_implementations=()
option_binaries=()
option_csv_file=''
option_skip=()
option_only=()
option_csv='yes'
while [[ $# -ne 0 ]]; do
	item="$1"
	shift
	case "$item" in
	--test)
		__split --target={option_binaries} --no-zero-length --append --invoke -- \
			debug-bash --all-bash-binaries --only-print-binaries
		;;
	--ab | --all-binaries | --all-bash-binaries | --av | --all-versions | --all-bash-versions | --bash=* | --b=* | --binary=* | --binaries=* | --bash-binary=* | --bash-binaries=* | --v=* | --version=* | --versions=* | --bash-version=* | --bash-versions=*)
		__split --target={option_binaries} --no-zero-length --append --invoke -- \
			debug-bash "$item" --only-print-binaries
		;;
	--i=* | --implementation=*) option_implementations+=("${item#*=}") ;;
	--ai | --all-implementations | --all-try-implementations) option_implementations=("${all_implementations[@]}") ;;
	--skip=*)
		__split --target={option_skip} --append --no-zero-length -- "${item#*=}"
		;;
	--only=*)
		__split --target={option_only} --append --no-zero-length -- "${item#*=}"
		;;
	--csv=no | --no-csv) option_csv=no ;;
	--csv=yes | --csv) option_csv=yes ;;
	--csv=*) option_csv_file="${item#*=}" ;;
	--)
		option_implementations+=("$@")
		shift $#
		break
		;;
	*) help "$0: An unrecognised flag was provided: $item" ;;
	esac
done

# create a csv file
render_csv='yes'
if [[ $option_csv == 'yes' && -z $option_csv_file ]]; then
	option_csv_file="$(mktemp)"
else
	render_csv='no'
fi

# default to core as the implementation
if [[ ${#option_implementations[@]} -eq 0 ]]; then
	option_implementations=('core')
fi

# =====================================
# Handle Arguments

function render_csv {
	if [[ $render_csv == 'no' ]]; then
		return 0
	fi

	local c_fail=$'\e[41m'   # background red
	local c_faulty=$'\e[43m' # background yellow
	local c_pass=$'\e[42m'   # background green
	local c_header=$'\e[44m' # background blue
	local c_end_field=''
	local c_end_line=$'\e[49m' # end background
	local implementations=() versions=() tests=() results=()
	local passed_implementations='' passed_versions=''
	local failed_implementations='' failed_versions=''
	local headers=(
		"${c_header}implementation${c_end_field}"
		"${c_header}version${c_end_field}"
		"${c_header}test${c_end_field}"
		"${c_header}result${c_end_field}"
	)
	local blank=('' '' '' '')
	local parts=("${headers[@]}" "${blank[@]}")
	local implementation_length=14
	local version_length=7
	local test_length=4
	local result_length=6

	# csv file handling
	echo-file --raw -- "$option_csv_file" | echo-write --atomic -- "$option_csv_file"

	# fetch details
	local implementation version test result
	while IFS=, read -r implementation version test result; do
		implementations+=("$implementation")
		versions+=("$version")
		tests+=("$test")
		results+=("$result")
		if [[ $result != *'ok'* ]]; then
			if [[ $failed_implementations != *"{$implementation}"* ]]; then
				failed_implementations+="{$implementation}"
			fi
			if [[ $failed_versions != *"{$implementation$version}"* ]]; then
				failed_versions+="{$implementation$version}"
			fi
		else
			if [[ $passed_implementations != *"{$implementation}"* ]]; then
				passed_implementations+="{$implementation}"
			fi
			if [[ $passed_versions != *"{$implementation$version}"* ]]; then
				passed_versions+="{$implementation$version}"
			fi
		fi
	done <"$option_csv_file"

	# calculate output
	for ((i = 0; i < ${#implementations[@]}; i++)); do
		implementation="${implementations[i]}"
		version="${versions[i]}"
		test="${tests[i]}"
		result="${results[i]}"
		if [[ ${#implementation} -gt $implementation_length ]]; then
			implementation_length=${#implementation}
		fi
		if [[ ${#version} -gt $version_length ]]; then
			version_length=${#version}
		fi
		if [[ ${#test} -gt $test_length ]]; then
			test_length=${#test}
		fi
		if [[ ${#result} -gt $result_length ]]; then
			result_length=${#result}
		fi
		if [[ $failed_implementations == *"{$implementation}"* && $passed_implementations == *"{$implementation}"* ]]; then
			rendered_implementation="${c_faulty}${implementation}${c_end_field}"
		elif [[ $failed_implementations == *"{$implementation}"* ]]; then
			rendered_implementation="${c_fail}${implementation}${c_end_field}"
		else
			rendered_implementation="${c_pass}${implementation}${c_end_field}"
		fi
		if [[ $failed_versions == *"{$implementation$version}"* && $passed_versions == *"{$implementation$version}"* ]]; then
			rendered_version="${c_faulty}${version}${c_end_field}"
		elif [[ $failed_versions == *"{$implementation$version}"* ]]; then
			rendered_version="${c_fail}${version}${c_end_field}"
		else
			rendered_version="${c_pass}${version}${c_end_field}"
		fi
		if [[ $result != *'ok'* ]]; then
			rendered_test="${c_fail}${test}${c_end_field}"
			rendered_result="${c_fail}${result}${c_end_field}"
		else
			rendered_test="${c_pass}${test}${c_end_field}"
			rendered_result="${c_pass}${result}${c_end_field}"
		fi
		if [[ i -gt 1 ]]; then
			if [[ ${implementations[i - 1]} != "${implementations[i]}" ]]; then
				parts+=("${blank[@]}")
			fi
			if [[ ${versions[i - 1]} != "${versions[i]}" ]]; then
				parts+=("${blank[@]}")
			fi
		fi
		parts+=("$rendered_implementation" "$rendered_version" "$rendered_test" "$rendered_result")
	done

	# add some padding
	implementation_length=$((implementation_length + 20))
	version_length=$((version_length + 20))
	test_length=$((test_length + 20))
	result_length=$((result_length + 20))

	# output result
	printf "%-${implementation_length}s%-${version_length}s%-${test_length}s%-${result_length}s${c_end_line}\n" "${parts[@]}"
}

# handle multiple bash versions
if [[ ${#option_binaries[@]} -ne 0 ]]; then
	__result_status=0

	# execute the tests
	debug-bash --binaries="$(__print_lines "${option_binaries[@]}")" --no-wrap --continue -- \
		dorothy-internals --skip="$(__print_lines "${option_skip[@]}")" --only="$(__print_lines "${option_only[@]}")" --csv="$option_csv" --csv="$option_csv_file" -- "${option_implementations[@]}" || __result_status=$?

	# ignore bash 4.1 complaint
	if [[ $__result_status -eq 75 ]]; then
		__result_status=0
	fi

	# finish
	render_csv
	exit "$__result_status"
fi
# we are now a single bash version

# then handle multiple implementations within the same bash version execution
if [[ ${#option_implementations[@]} -ne 1 ]]; then
	__result_status=0
	for option_implementation in "${option_implementations[@]}"; do
		dorothy-internals --skip="$(__print_lines "${option_skip[@]}")" --only="$(__print_lines "${option_only[@]}")" --csv="$option_csv" --csv="$option_csv_file" --implementation="$option_implementation" || __result_status=$?
	done
	exit "$__result_status"
fi

# we are now a single bash version and implementation
option_implementation="${option_implementations[0]}"

# =====================================
# Helpers for Tests

# prepare vars
BASH_VERSION_AND_BINARY="$BASH_VERSION_CURRENT:$BASH"
if [[ $BASH_VERSION_AND_BINARY == '3.2.57:/bin/bash' ]] && is-mac; then
	BASH_VERSION_AND_BINARY+=':macos'
fi
SUITE_NAME="[$option_implementation] [$BASH_VERSION_AND_BINARY]"
TEST_NAME=''
COUNT_TESTS=0
COUNT_OK=0
COUNT_FAIL=0
CSV_UPDATES=''

# parse skip and only into an easier format
skip_string=''
only_string=''
for item in "${option_skip[@]}"; do
	skip_string+="{$item}"
done
for item in "${option_only[@]}"; do
	only_string+="{$item}"
done

# start the suite
echo-style --stderr --h1="$SUITE_NAME" --tty+terminal-title="$SUITE_NAME"

# prepare
function __begin_test_block {
	# process arguments
	local item option_name option_crash_on=() option_crash_exit_status='' option_crash_stdout='' had_crash_stdout='no'
	while [[ $# -ne 0 ]]; do
		item="$1"
		shift
		case "$item" in
		--name=*) option_name="${item#*=}" ;;
		--crash-on=*) option_crash_on+=("${item#*=}") ;;
		--crash-exit-status=*) option_crash_exit_status="${item#*=}" ;;
		--crash-stdout=*)
			had_crash_stdout='yes'
			option_crash_stdout="${item#*=}"
			;;
		*)
			__print_lines "ERROR: __begin_test_block: An unrecognised flag was provided: $item" >&2 || return
			return 22
			;; # EINVAL 22 Invalid argument
		esac
	done

	# ensure we have a name
	if [[ -z $option_name ]]; then
		__print_lines "ERROR: __begin_test_block: A name was not provided" >&2 || return
		return 22
	fi

	# check the prior test is ok
	# @todo improve this
	# __dump {COUNT_TESTS} {COUNT_OK} {COUNT_FAIL} {TEST_NAME} >&2

	# apply and reset shared vars
	TEST_NAME="$option_name"

	# check if we are not only, if not only, then skip silently
	if [[ -n $only_string && $only_string != *"{$TEST_NAME}"* ]]; then
		return 1
	fi

	# check if we are a crash version
	local crashes=''
	for item in "${option_crash_on[@]}"; do
		if [[ $BASH_VERSION_AND_BINARY == "$item"* ]]; then
			crashes='yes'
			break
		fi
	done

	# if it crashes, then run again, invoking only this test, and capture its stdout and status
	if [[ $crashes == 'yes' && -z $only_string ]]; then
		local __crash_exit_status='' crash_stdout_file crash_stdout='' crash_result='ok' REPLY
		# log our test is starting via a custom route
		COUNT_TESTS=$((COUNT_TESTS + 1))
		# run only this text, capturing status and stdout
		crash_stdout_file="$(mktemp)"
		set +e
		dorothy-internals --only="$TEST_NAME" --csv=no --implementation="$option_implementation" --version="$BASH" >"$crash_stdout_file"
		__crash_exit_status=$?
		set -e
		# __read_whole <"$crash_stdout_file" || return
		# crash_stdout="$REPLY"
		crash_stdout="$(<"$crash_stdout_file")" || return # we want to trim trailing newlines for consistency with bash, __do, and eval-tester
		rm -f -- "$crash_stdout_file"
		# compare status
		if [[ -n $option_crash_exit_status && $__crash_exit_status -ne $option_crash_exit_status ]]; then
			crash_result='fail'
			echo-style --stderr --red --bold='Crashed Exit Status' ' ' --="$__crash_exit_status" ' ' --bold='Expected Exit Status:' ' ' --invert="$option_crash_exit_status" || return
		elif [[ $__crash_exit_status -eq 0 ]]; then
			crash_result='fail'
			echo-style --stderr --green --bold='Crashed Exit Status:' ' ' --invert="$__crash_exit_status" ' ' --bold='Expected Exit Status:' ' ' --invert="<non-zero>" || return
		else
			echo-style --stderr --green --bold='Crashed Exit Status:' ' ' --invert="$__crash_exit_status" ' ' --bold='Expected Exit Status:' ' ' --invert="<non-zero>" || return
		fi

		# compare stdout
		if [[ $had_crash_stdout == 'yes' ]]; then
			if [[ -z $crash_stdout ]]; then
				crash_stdout='<empty>'
			fi
			if [[ -z $option_crash_stdout ]]; then
				option_crash_stdout='<empty>'
			fi
			if [[ $crash_stdout != "$option_crash_stdout" ]]; then
				crash_result='fail'
				echo-style --stderr --red --bold='Crashed STDOUT:' ' ' --invert="$crash_stdout" --newline --bold='Expected STDOUT:' ' ' --invert="$option_crash_stdout" || return
			else
				echo-style --stderr --green --bold='Crashed STDOUT:' ' ' --invert="$crash_stdout" --newline --bold='Expected STDOUT:' ' ' --invert="$option_crash_stdout" || return
			fi
		fi

		# compare result
		if [[ $crash_result != 'ok' ]]; then
			COUNT_FAIL=$((COUNT_FAIL + 1))
			echo-style --stderr --error='CRASH DIVERGED' --newline || return
			CSV_UPDATES+="$option_implementation,$BASH_VERSION_AND_BINARY,$TEST_NAME,CRASH DIVERGED"$'\n'
		else
			COUNT_OK=$((COUNT_OK + 1))
			echo-style --stderr --success='crash ok' --newline || return
			CSV_UPDATES+="$option_implementation,$BASH_VERSION_AND_BINARY,$TEST_NAME,crash ok"$'\n'
		fi
		return 1
	fi

	# otherwise run this test if it isn't a skip
	if [[ $skip_string == *"{$TEST_NAME}"* ]]; then
		echo-style --stderr --h2="$TEST_NAME" --newline --warning='SKIPPED MANUAL' --newline --e2="$TEST_NAME" || return
		CSV_UPDATES+="$option_implementation,$BASH_VERSION_AND_BINARY,$TEST_NAME,SKIPPED"$'\n'
		return 1
	fi

	# run the test
	COUNT_TESTS=$((COUNT_TESTS + 1))
	echo-style --stderr --h2="$TEST_NAME" || return
}
function __end_test_block {
	local result='ok' actual_var actual expected actual_file expected_file
	while [[ $# -ne 0 ]]; do
		__dereference --origin="$1" --name={actual_var} || return
		actual="${!actual_var-}"
		shift
		expected="$1"
		shift
		if [[ $actual != "$expected" ]]; then
			__print_lines \
				$'\e[7m'"FAIL: [$actual_var]"$'\e[0m' \
				$'\e[7m'"== IT WAS == "$'\e[0m' \
				"$actual" \
				$'\e[7m''== IT SHOULD BE =='$'\e[0m' \
				"$expected" \
				$'\e[7m'"== END FAILURE =="$'\e[0m' || return
			actual_file="$(fs-temp --directory='dorothy-internals' --file)"
			expected_file="$actual_file.expected"
			actual_file="$actual_file.actual"
			__print_string "$actual" >"$actual_file"
			__print_string "$expected" >"$expected_file"
			fs-diff --unchanged --after="$expected_file" --before="$actual_file" || :
			result='fail'
		fi
	done
	if [[ $result != 'ok' ]]; then
		COUNT_FAIL=$((COUNT_FAIL + 1))
		echo-style --stderr --e2="$TEST_NAME" || return
		CSV_UPDATES+="$option_implementation,$BASH_VERSION_AND_BINARY,$TEST_NAME,FAIL"$'\n'
	else
		COUNT_OK=$((COUNT_OK + 1))
		echo-style --stderr --g2="$TEST_NAME" || return
		CSV_UPDATES+="$option_implementation,$BASH_VERSION_AND_BINARY,$TEST_NAME,ok"$'\n'
	fi
}
function on_exit {
	local -i exit_status=$? incomplete_count
	incomplete_count=$((COUNT_TESTS - COUNT_OK - COUNT_FAIL))

	# log the crash
	if [[ $incomplete_count -eq 1 && -n $TEST_NAME ]]; then
		echo-style --stderr --e2="$TEST_NAME" ' ' --status="$exit_status" ' ' --error='CRASHED'
		CSV_UPDATES+="$option_implementation,$BASH_VERSION_AND_BINARY,$TEST_NAME,CRASHED"$'\n'
	fi

	# log the suite
	if [[ $exit_status -ne 0 ]]; then
		echo-style --stderr --e1="$SUITE_NAME" ' ' --status="$exit_status"
	else
		echo-style --stderr --g1="$SUITE_NAME"
	fi

	# append all our results to the csv file
	if [[ -n $CSV_UPDATES ]]; then
		if [[ $COUNT_OK -ne $COUNT_TESTS ]]; then
			CSV_UPDATES+="$option_implementation,$BASH_VERSION_AND_BINARY,TESTS:$COUNT_TESTS  SUCCESSES:$COUNT_OK  FAILURES:$COUNT_FAIL  INCOMPLETE:$incomplete_count,FAIL"$'\n'
		else
			CSV_UPDATES+="$option_implementation,$BASH_VERSION_AND_BINARY,TESTS:$COUNT_TESTS  SUCCESSES:$COUNT_OK  FAILURES:$COUNT_FAIL  INCOMPLETE:$incomplete_count,ok"$'\n'
		fi
		if [[ -n $option_csv_file ]]; then
			__print_string "$CSV_UPDATES" >>"$option_csv_file"
		fi
	fi

	# finish
	render_csv
}

# write everything at once on exit, as writing as it happens causes corruption
trap on_exit EXIT

# =====================================
# Implementations

source "$DOROTHY/sources/bash-legacy.bash"

# =====================================
# Helpers for tests

newline=$'\n'
space=' '
temp_test_file="$(mktemp)"

if [[ $BASH_DECLARED_VARS_ARE_ALWAYS_DEFINED == 'yes' ]]; then
	dump_var_empty_or_undefined_placeholder='[ empty ]'
else
	dump_var_empty_or_undefined_placeholder='[ undefined ]'
fi

# enable debug for this testing command
#shopt -s extdebug 2>/dev/null || :
function __enable_strict {
	# no impact if this is [set -e] or the below
	set -Eeuo pipefail
	shopt -s inherit_errexit 2>/dev/null || : # has no effect on try_
	#shopt -s extdebug 2>/dev/null || :
}

function __ansi_trim_special_from_stdin {
	local REPLY
	__read_whole
	__ansi_trim "$REPLY" 'not-text'
}

# =====================================
# TESTS

# -------------------------------------
# Print Toolkit Dependencies

if __begin_test_block --name='__command_missing'; then
	function tests() (
		set +e
		__command_missing 2>&1
		__print_lines $?
		__command_missing -- 2>&1
		__print_lines $?
		__command_missing -- bash
		__print_lines $?
		__command_missing -- bash bash
		__print_lines $?
		__command_missing -- "$RANDOM"
		__print_lines $?
		__command_missing -- "$RANDOM" bash
		__print_lines $?
		__command_missing -- bash "$RANDOM"
		__print_lines $?
	)
	results="$(tests)"
	__end_test_block {results} "$(
		cat <<-EOF
			ERROR: __command_missing: At least one command must be provided, none were.
			22
			ERROR: __command_missing: At least one command must be provided, none were.
			22
			1
			1
			0
			0
			0
		EOF
	)"
fi

if __begin_test_block --name='__command_exists'; then
	function tests() (
		set +e
		__command_exists 2>&1
		__print_lines $?
		__command_exists -- 2>&1
		__print_lines $?
		__command_exists -- bash
		__print_lines $?
		__command_exists -- bash bash
		__print_lines $?
		__command_exists -- "$RANDOM"
		__print_lines $?
		__command_exists -- "$RANDOM" bash
		__print_lines $?
		__command_exists -- bash "$RANDOM"
		__print_lines $?
	)
	results="$(tests)"
	__end_test_block {results} "$(
		cat <<-EOF
			ERROR: __command_exists: At least one command must be provided, none were.
			22
			ERROR: __command_exists: At least one command must be provided, none were.
			22
			0
			0
			1
			1
			1
		EOF
	)"
fi

# -------------------------------------
# Print Toolkit

if __begin_test_block --name='__print_string'; then
	function tests() (
		__print_string
		__print_string ''
		__print_string a
		__print_string a b
	)
	results="$(tests)"
	__end_test_block {results} "$(
		cat <<-EOF
			aab
		EOF
	)"
fi
if __begin_test_block --name='__print_strings'; then
	function tests() (
		__print_strings
		__print_strings ''
		__print_strings a
		__print_strings a b
	)
	results="$(tests)"
	__end_test_block {results} "$(
		cat <<-EOF
			aab
		EOF
	)"
fi
if __begin_test_block --name='__print_strings_or_nothing'; then
	function tests() (
		__print_strings_or_nothing
		__print_strings_or_nothing ''
		__print_strings_or_nothing a
		__print_strings_or_nothing a b
	)
	results="$(tests)"
	__end_test_block {results} "$(
		cat <<-EOF
			aab
		EOF
	)"
fi

if __begin_test_block --name='__print_line'; then
	function tests() (
		__print_line
		__print_line ''
		__print_line a
		__print_line a b
	)
	tests >"$temp_test_file"
	__read_whole <"$temp_test_file"
	results="$REPLY"
	__end_test_block {results} "$newline$newline$newline$newline"
fi
if __begin_test_block --name='__print_lines_or_line'; then
	function tests() (
		__print_lines_or_line
		__print_lines_or_line ''
		__print_lines_or_line a
		__print_lines_or_line a b
	)
	results="$(tests)"
	__end_test_block {results} "$(
		cat <<-EOF


			a
			a
			b
		EOF
	)"
fi

if __begin_test_block --name='__print_lines'; then
	function tests() (
		__print_lines
		__print_lines ''
		__print_lines a
		__print_lines a b
	)
	results="$(tests)"
	__end_test_block {results} "$(
		cat <<-EOF

			a
			a
			b
		EOF
	)"
fi
if __begin_test_block --name='__print_lines_or_nothing'; then
	function tests() (
		__print_lines_or_nothing
		__print_lines_or_nothing ''
		__print_lines_or_nothing a
		__print_lines_or_nothing a b
	)
	results="$(tests)"
	__end_test_block {results} "$(
		cat <<-EOF

			a
			a
			b
		EOF
	)"
fi

if __begin_test_block --name='__print_value_strings_or_nothing'; then
	function tests() (
		__print_value_strings_or_nothing
		__print_value_strings_or_nothing ''
		__print_value_strings_or_nothing '' ''
		__print_value_strings_or_nothing a
		__print_value_strings_or_nothing a '' b
	)
	results="$(tests)"
	__end_test_block {results} "$(
		cat <<-EOF
			aab
		EOF
	)"
fi
if __begin_test_block --name='__print_value_lines_or_nothing'; then
	function tests() (
		__print_value_lines_or_nothing
		__print_value_lines_or_nothing ''
		__print_value_lines_or_nothing '' ''
		__print_value_lines_or_nothing a
		__print_value_lines_or_nothing a '' b
	)
	results="$(tests)"
	__end_test_block {results} "$(
		cat <<-EOF
			a
			a
			b
		EOF
	)"
fi
if __begin_test_block --name='__print_value_lines_or_line'; then
	function tests() (
		__print_value_lines_or_line
		__print_value_lines_or_line ''
		__print_value_lines_or_line '' ''
		__print_value_lines_or_line a
		__print_value_lines_or_line a '' b
	)
	results="$(tests)"
	__end_test_block {results} "$(
		cat <<-EOF



			a
			a
			b
		EOF
	)"
fi

if __begin_test_block --name='__print_without_styles'; then
	function tests() (
		__print_without_styles --no-trail
		__print_without_styles
		__print_without_styles --no-trail ''
		__print_without_styles ''
		__print_without_styles --no-trail --bold='a' b --='c' --newline d
		__print_without_styles --bold='a' b --='c' --newline d
	)
	results="$(tests)"
	__end_test_block {results} "$(
		cat <<-EOF


			abc
			dabc
			d
		EOF
	)"
fi

if __begin_test_block --name='__dump'; then
	function tests() (
		local undefined_var empty='' defined=value empty_array=() defined_array=('' value)
		local -a undefined_array
		__dump \
			{BASH_DECLARED_VARS_ARE_ALWAYS_DEFINED} BASH_DECLARED_ARRAYS_ARE_ALWAYS_DEFINED \
			--value= --value=value \
			undeclared_var \
			undefined_var \
			empty \
			defined \
			undefined_array \
			empty_array \
			defined_array
	)
	results="$(tests | __ansi_trim_special_from_stdin)"
	if [[ $BASH_DECLARED_VARS_ARE_ALWAYS_DEFINED == 'yes' ]]; then
		__end_test_block {results} "$(
			cat <<-EOF
				BASH_DECLARED_VARS_ARE_ALWAYS_DEFINED = yes
				BASH_DECLARED_ARRAYS_ARE_ALWAYS_DEFINED = yes
				[ empty ]
				value
				undeclared_var = [ undeclared ]
				undefined_var = [ empty ]
				empty = [ empty ]
				defined = value
				undefined_array[@] = [ empty ]
				empty_array[@] = [ empty ]
				defined_array[0] = [ empty ]
				defined_array[1] = value
			EOF
		)"
	elif [[ $BASH_DECLARED_ARRAYS_ARE_ALWAYS_DEFINED == 'yes' ]]; then
		__end_test_block {results} "$(
			cat <<-EOF
				BASH_DECLARED_VARS_ARE_ALWAYS_DEFINED = no
				BASH_DECLARED_ARRAYS_ARE_ALWAYS_DEFINED = yes
				[ empty ]
				value
				undeclared_var = [ undeclared ]
				undefined_var = [ undefined ]
				empty = [ empty ]
				defined = value
				undefined_array[@] = [ empty ]
				empty_array[@] = [ empty ]
				defined_array[0] = [ empty ]
				defined_array[1] = value
			EOF
		)"
	else
		__end_test_block {results} "$(
			cat <<-EOF
				BASH_DECLARED_VARS_ARE_ALWAYS_DEFINED = no
				BASH_DECLARED_ARRAYS_ARE_ALWAYS_DEFINED = no
				[ empty ]
				value
				undeclared_var = [ undeclared ]
				undefined_var = [ undefined ]
				empty = [ empty ]
				defined = value
				undefined_array[@] = [ undefined ]
				empty_array[@] = [ empty ]
				defined_array[0] = [ empty ]
				defined_array[1] = value
			EOF
		)"
	fi
fi

# can't test this otherwise
if [[ ${BASH_XTRACEFD:-"2"} -eq 2 ]]; then
	if __begin_test_block --name='__debug_lines'; then
		function tests() (
			DOROTHY_DEBUG=
			__debug_lines
			__debug_lines ''
			__debug_lines a
			__debug_lines a b
			DOROTHY_DEBUG=yes
			__debug_lines
			__debug_lines ''
			__debug_lines a
			__debug_lines a b
		)
		results="$(tests 2>&1)"
		__end_test_block {results} "$(
			cat <<-EOF

				a
				a
				b
			EOF
		)"
	fi
fi

# -------------------------------------
# Shims Toolkit

if __begin_test_block --name='__get_uppercase_first_letter'; then
	function tests() (
		__get_uppercase_first_letter
		__get_uppercase_first_letter --
		__get_uppercase_first_letter aa
		__get_uppercase_first_letter aa bb 'cc dd'
	)
	results="$(tests)"
	__end_test_block {results} "$(
		cat <<-EOF
			AaAaBbCc dd
		EOF
	)"
fi

if __begin_test_block --name='__get_uppercase_string'; then
	function tests() (
		__get_uppercase_string
		__get_uppercase_string --
		__get_uppercase_string aa
		__get_uppercase_string aa bb 'cc dd'
	)
	results="$(tests)"
	__end_test_block {results} "$(
		cat <<-EOF
			AAAABBCC DD
		EOF
	)"
fi

if __begin_test_block --name='__get_lowercase_string'; then
	function tests() (
		__get_lowercase_string
		__get_lowercase_string --
		__get_lowercase_string AA
		__get_lowercase_string AA BB 'CC DD'
	)
	results="$(tests)"
	__end_test_block {results} "$(
		cat <<-EOF
			aaaabbcc dd
		EOF
	)"
fi

# -------------------------------------
# Errors Toolkit

if __begin_test_block --name='__unrecognised_flag'; then
	function tests() (
		set +e
		__unrecognised_flag 'flag'
		__print_lines $?
		__unrecognised_flag 'flag' 'discarded'
		__print_lines $?
	)
	results="$(tests 2>&1)"
	__end_test_block {results} "$(
		cat <<-EOF
			ERROR: tests: An unrecognised flag was provided: flag
			22
			ERROR: tests: An unrecognised flag was provided: flag
			22
		EOF
	)"
fi

if __begin_test_block --name='__unrecognised_argument'; then
	function tests() (
		set +e
		__unrecognised_argument 'arg'
		__print_lines $?
		__unrecognised_argument 'arg' 'discarded'
		__print_lines $?
	)
	results="$(tests 2>&1)"
	__end_test_block {results} "$(
		cat <<-EOF
			ERROR: tests: An unrecognised argument was provided: arg
			22
			ERROR: tests: An unrecognised argument was provided: arg
			22
		EOF
	)"
fi

if __begin_test_block --name='__affirm_value_is_valid_write_mode'; then
	function tests() (
		set +e
		__affirm_value_is_valid_write_mode ''
		__print_lines $?
		__affirm_value_is_valid_write_mode '' 'discarded'
		__print_lines $?
		__affirm_value_is_valid_write_mode prepend
		__print_lines $?
		__affirm_value_is_valid_write_mode prepend discarded
		__print_lines $?
		__affirm_value_is_valid_write_mode append
		__print_lines $?
		__affirm_value_is_valid_write_mode append discarded
		__print_lines $?
		__affirm_value_is_valid_write_mode overwrite
		__print_lines $?
		__affirm_value_is_valid_write_mode overwrite discarded
		__print_lines $?
		__affirm_value_is_valid_write_mode other
		__print_lines $?
		__affirm_value_is_valid_write_mode other discarded
		__print_lines $?
	)
	results="$(tests 2>&1)"
	__end_test_block {results} "$(
		cat <<-EOF
			0
			0
			0
			0
			0
			0
			0
			0
			ERROR: tests: An invalid mode was provided: other
			22
			ERROR: tests: An invalid mode was provided: other
			22
		EOF
	)"
fi

if __begin_test_block --name='__affirm_value_is_defined'; then
	function tests() (
		set +e
		__affirm_value_is_defined ''
		__print_lines $?
		__affirm_value_is_defined '' 'thing'
		__print_lines $?
		__affirm_value_is_defined ' '
		__print_lines $?
		__affirm_value_is_defined ' ' 'thing'
		__print_lines $?
	)
	results="$(tests 2>&1)"
	__end_test_block {results} "$(
		cat <<-EOF
			ERROR: tests: A value must be provided.
			22
			ERROR: tests: A thing must be provided.
			22
			0
			0
		EOF
	)"
fi

if __begin_test_block --name='__affirm_value_is_undefined'; then
	function tests() (
		set +e
		__affirm_value_is_undefined ''
		__print_lines $?
		__affirm_value_is_undefined '' 'thing'
		__print_lines $?
		__affirm_value_is_undefined ' '
		__print_lines $?
		__affirm_value_is_undefined ' ' 'thing'
		__print_lines $?
	)
	results="$(tests 2>&1 | __ansi_trim_special_from_stdin)"
	__end_test_block {results} "$(
		cat <<-EOF
			0
			0
			ERROR: tests: A value must not be already defined, it was: $space
			22
			ERROR: tests: A thing must not be already defined, it was: $space
			22
		EOF
	)"
fi

if __begin_test_block --name='__affirm_value_is_positive_integer'; then
	function tests() (
		set +e
		__affirm_value_is_positive_integer ''
		__print_lines $?
		__affirm_value_is_positive_integer '' 'thing'
		__print_lines $?
		__affirm_value_is_positive_integer 1
		__print_lines $?
		__affirm_value_is_positive_integer 1 'thing'
		__print_lines $?
		__affirm_value_is_positive_integer 0
		__print_lines $?
		__affirm_value_is_positive_integer 0 'thing'
		__print_lines $?
		__affirm_value_is_positive_integer -0
		__print_lines $?
		__affirm_value_is_positive_integer -0 'thing'
		__print_lines $?
		__affirm_value_is_positive_integer -1
		__print_lines $?
		__affirm_value_is_positive_integer -1 'thing'
		__print_lines $?
		__affirm_value_is_positive_integer a
		__print_lines $?
		__affirm_value_is_positive_integer a 'thing'
		__print_lines $?
	)
	results="$(tests 2>&1 | __ansi_trim_special_from_stdin)"
	__end_test_block {results} "$(
		cat <<-EOF
			ERROR: tests: The value must be a positive integer, it was: [ empty ]
			22
			ERROR: tests: The thing must be a positive integer, it was: [ empty ]
			22
			0
			0
			0
			0
			ERROR: tests: The value must be a positive integer, it was: -0
			22
			ERROR: tests: The thing must be a positive integer, it was: -0
			22
			ERROR: tests: The value must be a positive integer, it was: -1
			22
			ERROR: tests: The thing must be a positive integer, it was: -1
			22
			ERROR: tests: The value must be a positive integer, it was: a
			22
			ERROR: tests: The thing must be a positive integer, it was: a
			22
		EOF
	)"
fi

if __begin_test_block --name='__affirm_length_defined'; then
	function tests() (
		set +e
		__affirm_length_defined ''
		__print_lines $?
		__affirm_length_defined '' 'thing'
		__print_lines $?
		__affirm_length_defined 0
		__print_lines $?
		__affirm_length_defined 0 'thing'
		__print_lines $?
		__affirm_length_defined 1
		__print_lines $?
		__affirm_length_defined 1 'thing'
		__print_lines $?
	)
	results="$(tests 2>&1 | __ansi_trim_special_from_stdin)"
	__end_test_block {results} "$(
		cat <<-EOF
			ERROR: tests: The length of value must be a positive integer, it was: [ empty ]
			22
			ERROR: tests: The length of thing must be a positive integer, it was: [ empty ]
			22
			ERROR: tests: At least one value must be provided, none were.
			22
			ERROR: tests: At least one thing must be provided, none were.
			22
			0
			0
		EOF
	)"
fi

if __begin_test_block --name='__affirm_variable_is_array'; then
	function tests() (
		set +e
		local str='' arr=()
		__affirm_variable_is_array str
		__print_lines $?
		__affirm_variable_is_array arr
		__print_lines $?
	)
	results="$(tests 2>&1)"
	__end_test_block {results} "$(
		cat <<-EOF
			ERROR: tests: The variable \$str must be an array.
			22
			0
		EOF
	)"
fi

if __begin_test_block --name='__return'; then
	function tests() (
		set +e
		__return 0
		__print_lines $?
		__return 123
		__print_lines $?
		__return 0 2 4
		__print_lines $?

		__return 0 -- __print_string 'invoked: '
		__print_lines $?
		__return 123 -- __print_string 'invoked: '
		__print_lines $?

		__return 0 --invoke-only-on-failure -- __print_string 'invoked: '
		__print_lines $?
		__return 123 --invoke-only-on-failure -- __print_string 'invoked: '
		__print_lines $?

		__return 0 2 4 -- __print_string 'invoked: '
		__print_lines $?
		__return 0 2 4 --invoke-only-on-failure -- __print_string 'invoked: '
		__print_lines $?
	)
	results="$(tests 2>&1)"
	__end_test_block {results} "$(
		cat <<-EOF
			0
			123
			2
			invoked: 0
			invoked: 123
			0
			invoked: 123
			invoked: 2
			invoked: 2
		EOF
	)"
fi

if __begin_test_block --name='__ignore_exit_status'; then
	function tests() (
		set +e
		__return 0 || __ignore_exit_status 2
		__print_lines $?
		__return 2 || __ignore_exit_status 2
		__print_lines $?
		__return 4 || __ignore_exit_status 2
		__print_lines $?
		__return 0 || __ignore_exit_status 1 2
		__print_lines $?
		__return 2 || __ignore_exit_status 1 2
		__print_lines $?
		__return 4 || __ignore_exit_status 1 2
		__print_lines $?
	)
	results="$(tests 2>&1)"
	__end_test_block {results} "$(
		cat <<-EOF
			0
			0
			4
			0
			0
			4
		EOF
	)"
fi

if __begin_test_block --name='__ignore_sigpipe'; then
	function tests() (
		set +e
		__return 0 || __ignore_sigpipe
		__print_lines $?
		__return 141 || __ignore_sigpipe
		__print_lines $?
		__return 4 || __ignore_exit_status
		__print_lines $?
	)
	results="$(tests 2>&1)"
	__end_test_block {results} "$(
		cat <<-EOF
			0
			0
			4
		EOF
	)"
fi

# @todo figure out a way to test `__exit_on_exit_status`

# -------------------------------------
# Value Toolkit

# @todo write tests for these

# -------------------------------------
# Reference Toolkit

if __begin_test_block --name='__is_reference'; then
	function tests() (
		set +e
		__is_reference
		__print_lines $?
		__is_reference ''
		__print_lines $?
		__is_reference '{}'
		__print_lines $?
		__is_reference '{a}'
		__print_lines $?
		__is_reference '{a}' ''
		__print_lines $?
		__is_reference '' ''
		__print_lines $?
		__is_reference '{a}' '{b}'
		__print_lines $?
	)
	results="$(tests 2>&1)"
	__end_test_block {results} "$(
		cat <<-EOF
			ERROR: __is_reference: At least one input must be provided, none were.
			22
			1
			1
			0
			1
			1
			0
		EOF
	)"
fi

if __begin_test_block --name='__dereference'; then
	function tests() (
		set +e
		local str='ab' arr=('a' 'b') name names=() value values=()

		__dereference --origin=str --name={name}
		__print_lines "$? $name"
		name=''
		__dereference --origin={str} --name={name}
		__print_lines "$? $name"
		__dereference --origin=str --name={names}
		__print_lines "$? ${names[*]}"
		__dereference --origin={str} --name={names}
		__print_lines "$? ${names[*]}"

		__dereference --origin=str --value={value}
		__print_lines "$? $value"
		__dereference --origin={str} --value={value}
		__print_lines "$? $value"
		__dereference --origin=str --value={values}
		__print_lines "$? ${values[*]}"
		__dereference --origin={str} --value={values}
		__print_lines "$? ${values[*]}"

		name=''
		value=''
		names=()
		values=()

		__dereference --origin=arr --name={name}
		__print_lines "$? $name"
		name=''
		__dereference --origin={arr} --name={name}
		__print_lines "$? $name"
		__dereference --origin=arr --name={names}
		__print_lines "$? ${names[*]}"
		__dereference --origin={arr} --name={names}
		__print_lines "$? ${names[*]}"

		__dereference --origin=arr --value={value}
		__print_lines "$? ${value[*]}"
		__dereference --origin={arr} --value={value}
		__print_lines "$? ${value[*]}"
		__dereference --origin=arr --value={values}
		__print_lines "$? ${values[*]}"
		__dereference --origin={arr} --value={values}
		__print_lines "$? ${values[*]}"
	)
	results="$(tests)"
	__end_test_block {results} "$(
		cat <<-EOF
			0 str
			0 str
			0 str
			0 str str
			0 ab
			0 ab
			0 ab
			0 ab ab
			0 arr
			0 arr
			0 arr
			0 arr arr
			0 a b
			0 a b a b
			0 a b
			0 a b a b
		EOF
	)"
fi

# -------------------------------------
# Function Toolkit

if __begin_test_block --name='__is_subshell_function'; then
	function tests() (
		set +e
		function fn_with_squigglies { :; }
		__is_subshell_function fn_with_squigglies
		__print_lines $?
		function fn_with_parens() (:)
		__is_subshell_function fn_with_parens
		__print_lines $?
		local str=''
		__is_subshell_function str
		__print_lines $?
		__is_subshell_function undef
		__print_lines $?
	)
	results="$(tests 2>&1)"
	__end_test_block {results} "$(
		cat <<-EOF
			1
			0
			1
			1
		EOF
	)"
fi

if __begin_test_block --name='inner of standard function'; then
	function standard_function {
		:
	}
	got_function_inner="$(__get_function_inner standard_function)"
	__end_test_block {got_function_inner} '    :'
fi
if __begin_test_block --name='inner of standard function with parens'; then
	function standard_function_with_parens() {
		:
	}
	got_function_inner="$(__get_function_inner standard_function_with_parens)"
	__end_test_block {got_function_inner} '    :'
fi
if __begin_test_block --name='inner of subshell function'; then
	function subshell_function() {
		:
	}
	got_function_inner="$(__get_function_inner subshell_function)"
	__end_test_block {got_function_inner} '    :'
fi

if __begin_test_block --name='__get_index_of_parent_function'; then
	function tests() (
		set +e
		__get_index_of_parent_function 'tests'
		function fn {
			__get_index_of_parent_function 'tests'
		}
		fn
		function fn {
			__get_index_of_parent_function 'undef' 'fn' 'tests'
		}
		fn
	)
	results="$(tests 2>&1)"
	__end_test_block {results} "$(
		cat <<-EOF
			010
		EOF
	)"
fi

if __begin_test_block --name='__get_first_parent_that_is_not'; then
	function tests() (
		set +e
		__get_first_parent_that_is_not 'tests' 'main'
		__print_lines "[status = $?]"
		__get_first_parent_that_is_not 'tests'
		__print_lines '' "[status = $?]"
		function fn {
			__get_first_parent_that_is_not 'tests'
			__print_lines '' "[status = $?]"
		}
		fn
		function fn {
			__get_first_parent_that_is_not 'undef' 'fn'
			__print_lines '' "[status = $?]"
		}
		fn
	)
	results="$(tests 2>&1)"
	__end_test_block {results} "$(
		cat <<-EOF
			[status = 1]
			main
			[status = 0]
			fn
			[status = 0]
			tests
			[status = 0]
		EOF
	)"
fi

# -------------------------------------
# Read Toolkit
# this is out of order in their appearance in bash.bash, but necessary for the rest of the tests

if __begin_test_block --name='__read_whole'; then
	function tests() (
		set +e
		local REPLY file
		file="$(mktemp)"
		printf 'before-null\0before-eot\004before-form-feed\fbefore-newline\nafter-newline' >"$file"
		__read_whole <"$file"
		printf '%q' "$REPLY"
	)
	results="$(tests 2>&1)"
	# trunk-ignore(cspell/error)
	__end_test_block {results} "$'before-nullbefore-eot\004before-form-feed\fbefore-newline\nafter-newline'"
fi

if __begin_test_block --name='__cat_pieces'; then
	function tests() (
		set +e
		local REPLY file1 file2
		file1="$(mktemp)"
		file2="$(mktemp)"
		printf 'before-null\0before-eot\004before-form-feed\fbefore-newline\nafter-newline' >"$file1"
		__cat_pieces <"$file1" >"$file2"
		cat -vbn "$file1"
		__print_line
		cat -vbn "$file2"
	)
	results="$(tests 2>&1)"
	__end_test_block {results} "$(
		cat <<EOF
     1	before-null^@before-eot^Dbefore-form-feed^Lbefore-newline
     2	after-newline
     1	before-null^@before-eot^Dbefore-form-feed^Lbefore-newline
     2	after-newline
EOF
	)"
fi

# =====================================
# Redirection & Error Handling Toolkit

# -------------------------------------
# __to

if __begin_test_block --name='__to'; then
	function tests() (
		set +e
		local REPLY target='' file inputs=($'content\n')
		file="$(mktemp)"

		__to -- "${inputs[@]}"
		__to --target={target} -- "${inputs[@]}"
		__to --target=STDOUT -- "${inputs[@]}"
		# trunk-ignore(shellcheck/SC2069)
		__to --target=STDERR -- "${inputs[@]}" 2>&1 >/dev/null
		__to --target=TTY -- $'content that is sent to TTY\n' # not tested

		__print_lines '---'
		__to --source={inputs} --target={target} --target=STDOUT --target=STDERR --target="$file" 2>&1
		__dump --no-style {target}
		__read_whole <"$file"
		__print_lines "file = $REPLY"

		__print_lines '---'
		local targets=({target} STDOUT STDERR 1 2 "$file")
		__to --source={inputs} --targets={targets} 2>&1
		__dump --no-style {target}
		__read_whole <"$file"
		__print_lines "file = $REPLY"

		# STDOUT/STDERR/1/2 etc will fail as they cannot be used with append/prepend
		targets=({target} "$file")

		__print_lines '---'
		input=$'appended\n'
		__to --source={input} --append --targets={targets} 2>&1
		__dump --no-style {target}
		__read_whole <"$file"
		__print_lines "file = $REPLY"

		__print_lines '---'
		input=$'prepended\n'
		__to --source={input} --prepend --targets={targets} 2>&1
		__dump --no-style {target}
		__read_whole <"$file"
		__print_lines "file = $REPLY"

		__print_lines '---'
		target=()
		inputs=('first' $'second\n')
		__to --target={target} -- "${inputs[@]}"
		__dump --no-style {target}
	)
	results="$(tests)"
	__end_test_block {results} "$(
		cat <<-EOF
			content
			content
			content
			---
			content
			content
			target = content

			file = content

			---
			content
			content
			content
			content
			target = content

			file = content

			---
			target = content
			appended

			file = content
			appended

			---
			target = prepended
			content
			appended

			file = prepended
			content
			appended

			---
			target[0] = first
			target[1] = second
		EOF
	)"
fi

# -------------------------------------
# __try and __do: test their exit status handling, which requires overrides to monitor complexities

function dorothy_try__context_lines {
	printf '%s\n' "CONTEXT: $DOROTHY_TRY__CONTEXT" "COMMAND: ${DOROTHY_TRY__COMMAND[*]}" >&2
	printf '         %s\n' "$@" >&2
}

function dorothy_try__dump_lines {
	__print_lines "$@" \
		"DOROTHY_TRY__COUNT    = ${DOROTHY_TRY__COUNT-}" \
		"DOROTHY_TRY__STATUS   = ${DOROTHY_TRY__STATUS-}" \
		"DOROTHY_TRY__CONTEXT  = ${DOROTHY_TRY__CONTEXT-}" \
		"DOROTHY_TRY__COMMAND  = ${DOROTHY_TRY__COMMAND:+"${DOROTHY_TRY__COMMAND[*]}"}" \
		"DOROTHY_TRY__SUBSHELL = ${DOROTHY_TRY__SUBSHELL-}" \
		"BASH_SOURCE           = ${BASH_SOURCE[*]}" \
		"BASH_LINENO           = ${BASH_LINENO[*]}" \
		"LINENO                = ${LINENO}" \
		"FUNCNAME              = ${FUNCNAME[*]}" \
		"CHILD_MAX             = ${CHILD_MAX-}" \
		"SHLVL                 = ${SHLVL-}" \
		"BASH_SUBSHELL         = ${BASH_SUBSHELL-}" \
		"BASH_COMMAND          = ${BASH_COMMAND-}" \
		"BASH_CMDS             = ${BASH_CMDS[*]}" \
		"BASH_ARGC             = ${BASH_ARGC[*]}" \
		"BASH_ARGV             = ${BASH_ARGV[*]}" \
		"BASH_VERSION          = ${BASH_VERSION}" \
		"-                     = $-" >&2
}

# -------------------------------------

if __begin_test_block --name='try __return 0'; then
	__try {caught_test_status} -- __return 0
	__end_test_block {caught_test_status} 0
fi

if __begin_test_block --name='try __return 123'; then
	__try {caught_test_status} -- __return 123
	__end_test_block {caught_test_status} 123
fi

if __begin_test_block --name='do __return 123 [--redirect-status]'; then
	__do --redirect-status={caught_test_status} -- __return 123
	__end_test_block {caught_test_status} 123
fi

# -------------------------------------

if __begin_test_block --name='try __return 0 [errexit disabled via conditional]'; then
	__conditional_test_status=0
	__try {caught_test_status} -- __return 0 || __conditional_test_status=$?
	__end_test_block {caught_test_status} 0 {__conditional_test_status} 0
fi

if __begin_test_block --name='try __return 123 [errexit disabled via conditional]'; then
	__conditional_test_status=0
	__try {caught_test_status} -- __return 123 || __conditional_test_status=$?
	__end_test_block {caught_test_status} 123 {__conditional_test_status} 0
fi

if __begin_test_block --name='do __return 0 [--copy-status]  [errexit disabled via conditional]'; then
	__conditional_test_status=0
	__do --copy-status={caught_test_status} -- __return 0 || __conditional_test_status=$?
	__end_test_block {caught_test_status} 0 {__conditional_test_status} 0
fi

if __begin_test_block --name='do __return 0 [--redirect-status] [errexit disabled via conditional]'; then
	__conditional_test_status=0
	__do --redirect-status={caught_test_status} -- __return 0 || __conditional_test_status=$?
	__end_test_block {caught_test_status} 0 {__conditional_test_status} 0
fi

if __begin_test_block --name='do __return 123 [--copy-status] [errexit disabled via conditional]'; then
	__conditional_test_status=0
	__do --copy-status={caught_test_status} -- __return 123 || __conditional_test_status=$?
	__end_test_block {caught_test_status} 123 {__conditional_test_status} 123
fi

if __begin_test_block --name='do __return 123 [--redirect-status] [errexit disabled via conditional]'; then
	__conditional_test_status=0
	__do --redirect-status={caught_test_status} -- __return 123 || __conditional_test_status=$?
	__end_test_block {caught_test_status} 123 {__conditional_test_status} 0
fi

# -------------------------------------

if __begin_test_block --name='try solo'; then
	function solo {
		__return 123
		__print_lines "FAIL: [$?] SHOULD NOT SEE THIS (1/3) AFTER (1/2) THROW"
		__return 124
		__print_lines "FAIL: [$?] SHOULD NOT SEE THIS (2/3) AFTER (2/2) THROW" # tests to make sure we clear status correctly
		__return 125 || return $?
		__print_lines "FAIL: [$?] SHOULD NOT SEE THIS (2/3) AFTER CONDITIONAL"
		return 126
	}
	__try {caught_test_status} -- solo
	__end_test_block {caught_test_status} 123
fi

if __begin_test_block --name='try solo[subshell]'; then
	function solo() (
		__return 123
		__print_lines "FAIL: [$?] SHOULD NOT SEE THIS (1/3) AFTER (1/2) THROW"
		__return 124
		__print_lines "FAIL: [$?] SHOULD NOT SEE THIS (2/3) AFTER (2/2) THROW" # tests to make sure we clear status correctly
		__return 125 || return $?
		__print_lines "FAIL: [$?] SHOULD NOT SEE THIS (2/3) AFTER CONDITIONAL"
		return 126
	)
	__try {caught_test_status} -- solo
	__end_test_block {caught_test_status} 123
fi

if __begin_test_block --name='try solo[subshell] [reinforced errexit]'; then
	function solo() (
		__enable_strict
		__return 123
		__print_lines "FAIL: [$?] SHOULD NOT SEE THIS (1/3) AFTER (1/2) THROW"
		__return 124
		__print_lines "FAIL: [$?] SHOULD NOT SEE THIS (2/3) AFTER (2/2) THROW" # tests to make sure we clear status correctly
		__return 125 || return $?
		__print_lines "FAIL: [$?] SHOULD NOT SEE THIS (2/3) AFTER CONDITIONAL"
		return 126
	)
	__try {caught_test_status} -- solo
	__end_test_block {caught_test_status} 123
fi

# -------------------------------------

# this isn't a real safety function, but we have to satisfy the linter
function __solo_with_side_effects {
	a=1
	__return 123
	a=2
	__return 124 || return $?
	a=3
	return 125
}

if __begin_test_block --name='try __solo_with_side_effects'; then
	a=0
	__try {caught_test_status} -- __solo_with_side_effects
	__end_test_block \
		{caught_test_status} 123 \
		{a} 1
fi

if __begin_test_block --name='try __solo_with_side_effects [errexit disabled via conditional]'; then
	a=0
	__conditional_test_status=0
	__try {caught_test_status} -- __solo_with_side_effects || __conditional_test_status=$?
	__end_test_block \
		{caught_test_status} 124 \
		{__conditional_test_status} 0 \
		{a} 2
fi

# -------------------------------------

if __begin_test_block --name='try __outer __inner'; then
	function __inner {
		__return 123 || return $?
		__print_lines "FAIL: [$?] SHOULD NOT SEE THIS (1/3)"
		return 124
	}
	function __outer {
		__inner || return $?
		__print_lines "FAIL: [$?] SHOULD NOT SEE THIS (2/3)"
		__return 125 || return $?
		__print_lines "FAIL: [$?] SHOULD NOT SEE THIS (3/3)"
		return 126
	}
	__try {caught_test_status} -- __outer
	__end_test_block {caught_test_status} 123
fi

if __begin_test_block --name='try __outer[subshell] __inner'; then
	function __inner {
		__return 123 || return $?
		__print_lines "FAIL: [$?] SHOULD NOT SEE THIS (1/3)"
		return 124
	}
	function __outer() (
		__inner || return $?
		__print_lines "FAIL: [$?] SHOULD NOT SEE THIS (2/3)"
		__return 125 || return $?
		__print_lines "FAIL: [$?] SHOULD NOT SEE THIS (3/3)"
		return 126
	)
	__try {caught_test_status} -- __outer
	__end_test_block {caught_test_status} 123
fi

if __begin_test_block --name='try __outer[subshell] __inner [reinforced errexit]'; then
	function __inner {
		__return 123 || return $?
		__print_lines "FAIL: [$?] SHOULD NOT SEE THIS (1/32)"
		return 124
	}
	function __outer() (
		__enable_strict
		__inner || return $?
		__print_lines "FAIL: [$?] SHOULD NOT SEE THIS (2/3)"
		__return 125 || return $?
		__print_lines "FAIL: [$?] SHOULD NOT SEE THIS (3/3)"
		return 126
	)
	__try {caught_test_status} -- __outer
	__end_test_block {caught_test_status} 123
fi

if __begin_test_block --name='try __outer[subshell] __inner[subshell]'; then
	function __inner() (
		__return 123 || return $?
		__print_lines "FAIL: [$?] SHOULD NOT SEE THIS (1/2)"
		return 124
	)
	function __outer() (
		__inner || return $?
		__print_lines "FAIL: [$?] SHOULD NOT SEE THIS (2/3)"
		__return 125 || return $?
		__print_lines "FAIL: [$?] SHOULD NOT SEE THIS (3/3)"
		return 126
	)
	__try {caught_test_status} -- __outer
	__end_test_block {caught_test_status} 123
fi

if __begin_test_block --name='try __outer[subshell] __inner[subshell] [reinforced errexit]'; then
	function __inner() (
		__enable_strict
		__return 123 || return $?
		__print_lines "FAIL: [$?] SHOULD NOT SEE THIS (1/3)"
		return 124
	)
	function __outer() (
		__enable_strict
		__inner || return $?
		__print_lines "FAIL: [$?] SHOULD NOT SEE THIS (2/3)"
		__return 125 || return $?
		__print_lines "FAIL: [$?] SHOULD NOT SEE THIS (3/3)"
		return 126
	)
	__try {caught_test_status} -- __outer
	__end_test_block {caught_test_status} 123
fi

# -------------------------------------

if __begin_test_block --name='try throws_solo'; then
	function throws_solo {
		__return 123
		__print_lines "FAIL: [$?] SHOULD NOT SEE THIS (1/2)"
		__return 124
		__print_lines "FAIL: [$?] SHOULD NOT SEE THIS (1/2)"
		return 125
	}
	__try {caught_test_status} -- throws_solo
	__end_test_block {caught_test_status} 123
fi

if __begin_test_block --name='try throws_solo[subshell]'; then
	function throws_solo() (
		__return 123
		__print_lines "FAIL: [$?] SHOULD NOT SEE THIS (1/2)"
		__return 124
		__print_lines "FAIL: [$?] SHOULD NOT SEE THIS (2/2)"
		return 125
	)
	__try {caught_test_status} -- throws_solo
	__end_test_block {caught_test_status} 123
fi

if __begin_test_block --name='try throws_solo[subshell] [reinforced errexit]'; then
	function throws_solo() (
		__enable_strict
		__return 123
		__print_lines "FAIL: [$?] SHOULD NOT SEE THIS (1/2)"
		__return 124
		__print_lines "FAIL: [$?] SHOULD NOT SEE THIS (2/2)"
		return 125
	)
	__try {caught_test_status} -- throws_solo
	__end_test_block {caught_test_status} 123
fi

# -------------------------------------

if __begin_test_block --name='try throws_solo[subshell] [errexit momentarily disabled within]'; then
	function throws_solo() (
		set +e # disable errexit
		__return 124
		__print_lines "OK: [$?] SHOULD SEE THIS (1/1)"
		set -e # re-enable errexit
		__return 125
		__print_lines "FAIL: [$?] SHOULD NOT NOT SEE THIS (1/1)"
		return 126
	)
	__try {caught_test_status} -- throws_solo
	__end_test_block {caught_test_status} 125
fi

# -------------------------------------

if __begin_test_block --name='try throws_outer __inner'; then
	function __inner {
		__return 123 || return $?
		__print_lines "FAIL: [$?] SHOULD NOT SEE THIS (1/3)"
		return 124
	}
	function throws_outer {
		__inner
		__print_lines "FAIL: [$?] SHOULD NOT SEE THIS (2/3)"
		__return 125
		__print_lines "FAIL: [$?] SHOULD NOT SEE THIS (3/3)"
		return 126
	}
	__try {caught_test_status} -- throws_outer
	__end_test_block {caught_test_status} 123
fi

if __begin_test_block --name='try throws_outer[subshell] __inner'; then
	function __inner {
		__return 123 || return $?
		__print_lines "FAIL: [$?] SHOULD NOT SEE THIS (1/3)"
		return 124
	}
	function throws_outer() (
		__inner
		__print_lines "FAIL: [$?] SHOULD NOT SEE THIS (2/3)"
		__return 125
		__print_lines "FAIL: [$?] SHOULD NOT SEE THIS (3/3)"
		return 126
	)
	__try {caught_test_status} -- throws_outer
	__end_test_block {caught_test_status} 123
fi

if __begin_test_block --name='try throws_outer[subshell] __inner [reinforced errexit]'; then
	function __inner {
		__return 123 || return $?
		__print_lines "FAIL: [$?] SHOULD NOT SEE THIS (1/32)"
		return 124
	}
	function throws_outer() (
		__enable_strict
		__inner
		__print_lines "FAIL: [$?] SHOULD NOT SEE THIS (2/3)"
		__return 125
		__print_lines "FAIL: [$?] SHOULD NOT SEE THIS (3/3)"
		return 126
	)
	__try {caught_test_status} -- throws_outer
	__end_test_block {caught_test_status} 123
fi

if __begin_test_block --name='try throws_outer[subshell] __inner[subshell]'; then
	function __inner() (
		__return 123 || return $?
		__print_lines "FAIL: [$?] SHOULD NOT SEE THIS (1/2)"
		return 124
	)
	function throws_outer() (
		__inner
		__print_lines "FAIL: [$?] SHOULD NOT SEE THIS (2/3)"
		__return 125
		__print_lines "FAIL: [$?] SHOULD NOT SEE THIS (3/3)"
		return 126
	)
	__try {caught_test_status} -- throws_outer
	__end_test_block {caught_test_status} 123
fi

if __begin_test_block --name='try throws_outer[subshell] __inner[subshell] [reinforced errexit]'; then
	function __inner() (
		__enable_strict
		__return 123 || return $?
		__print_lines "FAIL: [$?] SHOULD NOT SEE THIS (1/3)"
		return 124
	)
	function throws_outer() (
		__enable_strict
		__inner
		__print_lines "FAIL: [$?] SHOULD NOT SEE THIS (2/3)"
		__return 125
		__print_lines "FAIL: [$?] SHOULD NOT SEE THIS (3/3)"
		return 126
	)
	__try {caught_test_status} -- throws_outer
	__end_test_block {caught_test_status} 123
fi

# -------------------------------------

if __begin_test_block --name='try throws_outer throws_inner' \
	--crash-on=3.2 --crash-on=4.0 --crash-on=4.2 --crash-on=4.3 \
	--crash-exit-status=123 --crash-stdout=''; then
	function throws_inner {
		__return 123
		__print_lines "FAIL: [$?] SHOULD NOT SEE THIS (1/3)"
		return 124
	}
	function throws_outer {
		throws_inner
		__print_lines "FAIL: [$?] SHOULD NOT SEE THIS (2/3)"
		__return 125
		__print_lines "FAIL: [$?] SHOULD NOT SEE THIS (3/3)"
		return 126
	}
	__try {caught_test_status} -- throws_outer
	__end_test_block {caught_test_status} 123
fi

# this test is here to determine if it is the trap that is causing `FAIL: [0]` in the surrounding tests
if __begin_test_block --name='try throws_outer throws_inner [errexit disabled in root]'; then
	function throws_inner {
		__return 123
		__print_lines "OK: [$?] SHOULD SEE THIS (1/3)"
		return 124
	}
	function throws_outer {
		throws_inner
		__print_lines "OK: [$?] SHOULD SEE THIS (2/3)"
		__return 125
		__print_lines "OK: [$?] SHOULD SEE THIS (3/3)"
		return 126
	}
	set +e
	__try {caught_test_status} -- throws_outer
	set -e
	__end_test_block {caught_test_status} 126
fi

if __begin_test_block --name='try throws_outer[subshell] throws_inner'; then
	function throws_inner {
		__return 123
		__print_lines "FAIL: [$?] SHOULD NOT SEE THIS (1/3)"
		return 124
	}
	function throws_outer() (
		throws_inner
		__print_lines "FAIL: [$?] SHOULD NOT SEE THIS (2/3)"
		__return 125
		__print_lines "FAIL: [$?] SHOULD NOT SEE THIS (3/3)"
		return 126
	)
	__try {caught_test_status} -- throws_outer
	__end_test_block {caught_test_status} 123
fi

# this test is here to determine if it is the trap that is causing `FAIL: [0]` in the surrounding tests
if __begin_test_block --name='try throws_outer[subshell] throws_inner [errexit momentarily disabled within]'; then
	function throws_inner {
		__return 123
		__print_lines "OK: [$?] SHOULD SEE THIS (1/2)"
		return 124
	}
	function throws_outer() (
		set +e
		throws_inner
		__print_lines "OK: [$?] SHOULD SEE THIS (2/2)"
		set -e
		__return 125
		__print_lines "FAIL: [$?] SHOULD NOT SEE THIS (1/1)"
		return 126
	)
	__try {caught_test_status} -- throws_outer
	__end_test_block {caught_test_status} 125
fi

if __begin_test_block --name='try throws_outer[subshell] throws_inner [reinforced errexit]'; then
	function throws_inner {
		__return 123
		__print_lines "FAIL: [$?] SHOULD NOT SEE THIS (1/3)"
		return 124
	}
	function throws_outer() (
		__enable_strict
		throws_inner
		__print_lines "FAIL: [$?] SHOULD NOT SEE THIS (2/3)"
		__return 125
		__print_lines "FAIL: [$?] SHOULD NOT SEE THIS (3/3)"
		return 126
	)
	__try {caught_test_status} -- throws_outer
	__end_test_block {caught_test_status} 123
fi

if __begin_test_block --name='try throws_outer[subshell] throws_inner[subshell]'; then
	function throws_inner() (
		__return 123
		__print_lines "FAIL: [$?] SHOULD NOT SEE THIS (1/3)"
		return 124
	)
	function throws_outer() (
		throws_inner
		__print_lines "FAIL: [$?] SHOULD NOT SEE THIS (2/3)"
		__return 125
		__print_lines "FAIL: [$?] SHOULD NOT SEE THIS (3/3)"
		return 126
	)
	__try {caught_test_status} -- throws_outer
	__end_test_block {caught_test_status} 123
fi

if __begin_test_block --name='try throws_outer[subshell] throws_inner[subshell] [reinforced errexit]'; then
	function throws_inner() (
		__enable_strict
		__return 123
		__print_lines "FAIL: [$?] SHOULD NOT SEE THIS (1/3)"
		return 124
	)
	function throws_outer() (
		__enable_strict
		throws_inner
		__print_lines "FAIL: [$?] SHOULD NOT SEE THIS (2/3)"
		__return 125
		__print_lines "FAIL: [$?] SHOULD NOT SEE THIS (3/3)"
		return 126
	)
	__try {caught_test_status} -- throws_outer
	__end_test_block {caught_test_status} 123
fi

# -------------------------------------

function recursed_standard {
	caught_try_01=-1
	caught_try_02=-1
	caught_try_03=-1
	caught_try_04=-1
	caught_do_01=-1
	caught_do_02=-1
	caught_do_03=-1
	caught_do_04=-1
	caught_do_05=-1
	__try {caught_try_01} -- __return 0
	__print_lines "caught_try_01 = $caught_try_01 ?= $?"
	__try {caught_try_02} -- __return 102
	__print_lines "caught_try_02 = $caught_try_02 ?= $?"
	__try {caught_try_03} -- __return 103
	__print_lines "caught_try_03 = $caught_try_03 ?= $?"
	__try {caught_try_04} -- __return 0
	__print_lines "caught_try_04 = $caught_try_04 ?= $?"
	__do --copy-status={caught_do_01} -- __return 0
	__print_lines "caught_do_01 = $caught_do_01 ?= $?"
	__do --redirect-status={caught_do_02} -- __return 202
	__print_lines "caught_do_02 = $caught_do_02 ?= $?"
	__do --copy-status={caught_do_03} -- __return 0
	__print_lines "caught_do_03 = $caught_do_03 ?= $?"
	__do --copy-status={caught_do_04} -- __return 204
	__print_lines "caught_do_04 = $caught_do_04 ?= $?"
	__do --copy-status={caught_do_05} -- __return 205 || return
	__print_lines "caught_do_05 = $caught_do_05 ?= $?"
	return 99
}
function recursed_subshell() (
	__try {caught_try_01} -- __return 0
	__print_lines "caught_try_01 = $caught_try_01 ?= $?"
	__try {caught_try_02} -- __return 102
	__print_lines "caught_try_02 = $caught_try_02 ?= $?"
	__try {caught_try_03} -- __return 103
	__print_lines "caught_try_03 = $caught_try_03 ?= $?"
	__try {caught_try_04} -- __return 0
	__print_lines "caught_try_04 = $caught_try_04 ?= $?"
	__do --copy-status={caught_do_01} -- __return 0
	__print_lines "caught_do_01 = $caught_do_01 ?= $?"
	__do --redirect-status={caught_do_02} -- __return 202
	__print_lines "caught_do_02 = $caught_do_02 ?= $?"
	__do --copy-status={caught_do_03} -- __return 0
	__print_lines "caught_do_03 = $caught_do_03 ?= $?"
	__do --copy-status={caught_do_04} -- __return 204
	__print_lines "caught_do_04 = $caught_do_04 ?= $?"
	__do --copy-status={caught_do_05} -- __return 205 || return
	__print_lines "caught_do_05 = $caught_do_05 ?= $?"
	return 99
)
recursed_expected_errexit_stdout="$(
	cat <<-EOF
		caught_try_01 = 0 ?= 0
		caught_try_02 = 102 ?= 0
		caught_try_03 = 103 ?= 0
		caught_try_04 = 0 ?= 0
		caught_do_01 = 0 ?= 0
		caught_do_02 = 202 ?= 0
		caught_do_03 = 0 ?= 0
	EOF
)" # 204 is not output as it is returned before the output

# test
if __begin_test_block --name='try recursed' \
	--crash-on=3.2 --crash-on=4.0 --crash-on=4.2 --crash-on=4.3 \
	--crash-exit-status=204 --crash-stdout="$recursed_expected_errexit_stdout"; then
	__try {caught_test_status} -- recursed_standard
	__end_test_block \
		{caught_test_status} 204 \
		{caught_try_01} 0 \
		{caught_try_02} 102 \
		{caught_try_03} 103 \
		{caught_try_04} 0 \
		{caught_do_01} 0 \
		{caught_do_02} 202 \
		{caught_do_03} 0 \
		{caught_do_04} 204 \
		{caught_do_05} -1
fi

# test
if __begin_test_block --name='try recursed [errexit disabled via conditional]'; then
	__conditional_test_status=0
	__try {caught_test_status} -- recursed_standard || __conditional_test_status=$?
	__end_test_block \
		{caught_test_status} 205 \
		{__conditional_test_status} 0 \
		{caught_try_01} 0 \
		{caught_try_02} 102 \
		{caught_try_03} 103 \
		{caught_try_04} 0 \
		{caught_do_01} 0 \
		{caught_do_02} 202 \
		{caught_do_03} 0 \
		{caught_do_04} 204 \
		{caught_do_05} 205
fi

# can't test subshell directly as the subshell prevents the variables from being modified
# instead must use do and compare outputs

# test
if __begin_test_block --name='do recursed[subshell] [--redirect-status] [--copy-stdout]' \
	--crash-on='3.2.57:/bin/bash:macos' \
	--crash-exit-status=204 --crash-stdout="$recursed_expected_errexit_stdout"; then
	__do --redirect-status={caught_test_status} --copy-stdout={caught_test_stdout} -- recursed_subshell
	__end_test_block \
		{caught_test_status} 204 \
		{caught_test_stdout} "$recursed_expected_errexit_stdout"
fi

if __begin_test_block --name='do recursed[subshell] [--redirect-status] [--copy-stdout] [errexit disabled via conditional]'; then
	__conditional_test_status=0
	__do --redirect-status={caught_test_status} --copy-stdout={caught_test_stdout} -- recursed_subshell || __conditional_test_status=$?
	__end_test_block \
		{caught_test_status} 205 \
		{__conditional_test_status} 0 \
		{caught_test_stdout} "$(
			cat <<-EOF
				caught_try_01 = 0 ?= 0
				caught_try_02 = 102 ?= 0
				caught_try_03 = 103 ?= 0
				caught_try_04 = 0 ?= 0
				caught_do_01 = 0 ?= 0
				caught_do_02 = 202 ?= 0
				caught_do_03 = 0 ?= 0
				caught_do_04 = 204 ?= 204
			EOF
		)" # 205 is not output as it is returned before the output
fi

if __begin_test_block --name='do recursed[subshell] [--copy-status] [--copy-stdout] [errexit disabled via conditional]'; then
	__conditional_test_status=0
	__do --copy-status={caught_test_status} --copy-stdout={caught_test_stdout} -- recursed_subshell || __conditional_test_status=$?
	__end_test_block \
		{caught_test_status} 205 \
		{__conditional_test_status} 205 \
		{caught_test_stdout} '' # we do not have the stdout due to the failure not being ignored
fi

# -------------------------------------
# now that the testing of exit status is finished, undo the overrides
# and start testing content redirections instead

function dorothy_try__context_lines { :; }
function dorothy_try__dump_lines { :; }

function __write_stdout_stderr {
	printf '%s\n' 'stdout1' >&1
	printf '%s\n' 'stderr1' >&2
	printf '%s\n\n' 'stdout2' >&1
	printf '%s\n\n' 'stderr2' >&2
}

if __begin_test_block --name='do [--redirect-stdout] [--redirect-stderr]'; then
	__do \
		--redirect-status={caught_test_status} \
		--redirect-stdout={caught_test_stdout} \
		--redirect-stderr={caught_test_stderr} \
		-- \
		__write_stdout_stderr
	__end_test_block \
		{caught_test_status} 0 \
		{caught_test_stdout} $'stdout1\nstdout2' \
		{caught_test_stderr} $'stderr1\nstderr2'
fi
if __begin_test_block --name='do [--redirect-stdout] [--redirect-stderr] [--trailing-newlines]'; then
	__do --trailing-newlines \
		--redirect-status={caught_test_status} \
		--redirect-stdout={caught_test_stdout} \
		--redirect-stderr={caught_test_stderr} \
		-- \
		__write_stdout_stderr
	__end_test_block \
		{caught_test_status} 0 \
		{caught_test_stdout} $'stdout1\nstdout2\n\n' \
		{caught_test_stderr} $'stderr1\nstderr2\n\n'
fi
if __begin_test_block --name='do [--redirect-output]'; then
	__do \
		--redirect-status={caught_test_status} \
		--redirect-output={caught_test_output} \
		-- \
		__write_stdout_stderr
	__end_test_block \
		{caught_test_status} 0 \
		{caught_test_output} $'stdout1\nstderr1\nstdout2\n\nstderr2'
fi
if __begin_test_block --name='do [--redirect-output] [--trailing-newlines]'; then
	__do --trailing-newlines \
		--redirect-status={caught_test_status} \
		--redirect-output={caught_test_output} \
		-- \
		__write_stdout_stderr
	__end_test_block \
		{caught_test_status} 0 \
		{caught_test_output} $'stdout1\nstderr1\nstdout2\n\nstderr2\n\n'
fi

# @todo resolve copy-output and expectations on how the below does not behave as intuited
# if __begin_test_block --name='do stdout/stderr --trailing-newlines'; then
# 	__do --trailing-newlines \
# 		--redirect-status={caught_test_status} \
# 		--copy-stdout={caught_test_stdout} \
# 		--copy-stderr={caught_test_stderr_original} \
# 		--redirect-stderr='(echo-uppercase --stdin >&2)' \
# 		--copy-stderr={caught_test_stderr} \
# 		--redirect-stderr=STDOUT \
# 		--copy-stdout={caught_test_output} \
# 		-- \
# 		__write_stdout_stderr
# 	__end_test_block \
# 		{caught_test_status} 0 \
# 		{caught_test_stdout} $'my-stdout\n\n' \
# 		{caught_test_stderr_original} 'my-stderr' \
# 		{caught_test_stderr} 'MY-STDERR' \
# 		{caught_test_output} $'my-stdoutMY-STDERR\n\n'
# fi

# =============================================================================
# Extra Toolkit

# -------------------------------------
# User & Group Toolkit

# @todo do these tests later

# -------------------------------------
# Filesystem & Elevate Toolkit

# @todo do these tests later

# -------------------------------------
# ANSI Toolkit

# these are already tested indirectly via their respective commands

# -------------------------------------
# Read Toolkit
# consider moving in bash.bash to before the __to stuff

# already tested earlier

# -------------------------------------
# File Descriptor Toolkit
# consider moving in bash.bash to before the __to stuff

# if these are broken then eval-tester is broken, so no need to test them here, at least for now

# -------------------------------------
# Semaphore Toolkit
# consider moving in bash.bash to before the __to stuff

# -------------------------------------
# Strings & Arrays Toolkit

# this is stuff we still need to test

# need to ensure __flag uses --target as we want to eventually supported --source+target= etc

if __begin_test_block --name='__array'; then
	function tests() (
		set +e
		local defined_array=() declared_variable targets=({defined_array} {declared_variable})
		__dump defined_array declared_variable

		__print_lines '--'
		__array --target={defined_array} --target={declared_variable}
		__print_lines "[status = $?]"

		__print_lines '--'
		__array --target={defined_array} --target={declared_variable} --size=0
		__print_lines "[status = $?]"

		__print_lines '--'
		declared_variable=()
		__array --target={defined_array} --target={declared_variable} --size=0
		__dump defined_array declared_variable
		__print_lines "[status = $?]"

		__print_lines '--'
		__array --target={defined_array} --target={declared_variable} --size=1
		__dump defined_array declared_variable
		__print_lines "[status = $?]"

		__print_lines '--'
		__array --target={defined_array} --target={declared_variable} --size=2
		__dump defined_array declared_variable
		__print_lines "[status = $?]"

		__print_lines '--'
		__array --target={defined_array} --target={declared_variable} --size=3 --fill='.' --append
		__dump defined_array declared_variable
		__print_lines "[status = $?]"

		__print_lines '--'
		__array --targets={targets} --size=1 --fill='..' --prepend
		__dump defined_array declared_variable
		__print_lines "[status = $?]"
	)
	results="$(tests 2>&1 | __ansi_trim_special_from_stdin)"
	__end_test_block {results} "$(
		cat <<-EOF
			defined_array[@] = [ empty ]
			declared_variable = $dump_var_empty_or_undefined_placeholder
			--
			ERROR: __array: The array fill size must be a positive integer, it was: [ empty ]
			[status = 22]
			--
			ERROR: __to: If the source [ARRAY__results] is an array, then the target [declared_variable] must be as well:
			ARRAY__results[@] = [ empty ]
			declared_variable = $dump_var_empty_or_undefined_placeholder
			[status = 22]
			--
			defined_array[@] = [ empty ]
			declared_variable[@] = [ empty ]
			[status = 0]
			--
			defined_array[0] = [ empty ]
			declared_variable[0] = [ empty ]
			[status = 0]
			--
			defined_array[0] = [ empty ]
			defined_array[1] = [ empty ]
			declared_variable[0] = [ empty ]
			declared_variable[1] = [ empty ]
			[status = 0]
			--
			defined_array[0] = [ empty ]
			defined_array[1] = [ empty ]
			defined_array[2] = .
			defined_array[3] = .
			defined_array[4] = .
			declared_variable[0] = [ empty ]
			declared_variable[1] = [ empty ]
			declared_variable[2] = .
			declared_variable[3] = .
			declared_variable[4] = .
			[status = 0]
			--
			defined_array[0] = ..
			defined_array[1] = [ empty ]
			defined_array[2] = [ empty ]
			defined_array[3] = .
			defined_array[4] = .
			defined_array[5] = .
			declared_variable[0] = ..
			declared_variable[1] = [ empty ]
			declared_variable[2] = [ empty ]
			declared_variable[3] = .
			declared_variable[4] = .
			declared_variable[5] = .
			[status = 0]
		EOF
	)"
fi

if __begin_test_block --name='__at'; then
	function tests() (
		set +e
		local arr=(a b c d e f) str='abcdef' array_target=() str_target

		__at --source={arr} --index=0 # a
		__at --source={arr} 1         # b
		__at --source={arr} -1        # f
		__at --source={arr} -- -2     # e
		__print_line
		__at --source={arr} --index=0 1 -- -1 # failure
		__print_lines "[status = $?]"
		__at --source={arr} --target={array_target} --index=0 --index=1 --index=-1 -- -2
		__dump array_target

		__print_lines '---'

		__at --source={str} --index=0 # a
		__at --source={str} 1         # b
		__at --source={str} -1        # f
		__at --source={str} -- -2     # e
		__print_line
		__at --source={str} --index=0 1 -- -1 # failure
		__print_lines "[status = $?]"
		__at --source={str} --target={str_target} --index=0 --index=1 --index=-1 -- -2
		__print_lines "[status = $?]"

		__print_lines '---'

		__at --source={arr} --index=5
		__print_lines "[status = $?]"
		__at --source={arr} --index=6
		__print_lines "[status = $?]"
		__at --source={arr} --index=7
		__print_lines "[status = $?]"
		__at --source={arr} -5
		__print_lines "[status = $?]"
		__at --source={arr} --index=-6
		__print_lines "[status = $?]"
		__at --source={arr} --index=-7
		__print_lines "[status = $?]"

		__print_lines '---'

		__at --source={str} --index=5
		__print_lines "[status = $?]"
		__at --source={str} --index=6
		__print_lines "[status = $?]"
		__at --source={str} --index=7
		__print_lines "[status = $?]"
		__at --source={str} -5
		__print_lines "[status = $?]"
		__at --source={str} --index=-6
		__print_lines "[status = $?]"
		__at --source={str} --index=-7
		__print_lines "[status = $?]"

	)
	results="$(tests 2>&1 | __ansi_trim_special_from_stdin)"
	__end_test_block {results} "$(
		cat <<-EOF
			abfe
			ERROR: __to: If the source [AT__results] is an array, then the target [STDOUT] must be as well:
			AT__results[0] = a
			AT__results[1] = b
			AT__results[2] = f
			[status = 22]
			array_target[0] = a
			array_target[1] = b
			array_target[2] = f
			array_target[3] = e
			---
			abfe
			ERROR: __to: If the source [AT__results] is an array, then the target [STDOUT] must be as well:
			AT__results[0] = a
			AT__results[1] = b
			AT__results[2] = f
			[status = 22]
			ERROR: __to: If the source [AT__results] is an array, then the target [str_target] must be as well:
			AT__results[0] = a
			AT__results[1] = b
			AT__results[2] = f
			AT__results[3] = e
			str_target = $dump_var_empty_or_undefined_placeholder
			[status = 22]
			---
			f[status = 0]
			ERROR: __at: The index 6 was beyond the range of:
			arr[ 0 | -6 ] = a
			arr[ 1 | -5 ] = b
			arr[ 2 | -4 ] = c
			arr[ 3 | -3 ] = d
			arr[ 4 | -2 ] = e
			arr[ 5 | -1 ] = f
			[status = 33]
			ERROR: __at: The index 7 was beyond the range of:
			arr[ 0 | -6 ] = a
			arr[ 1 | -5 ] = b
			arr[ 2 | -4 ] = c
			arr[ 3 | -3 ] = d
			arr[ 4 | -2 ] = e
			arr[ 5 | -1 ] = f
			[status = 33]
			b[status = 0]
			a[status = 0]
			ERROR: __at: The index -7 was beyond the range of:
			arr[ 0 | -6 ] = a
			arr[ 1 | -5 ] = b
			arr[ 2 | -4 ] = c
			arr[ 3 | -3 ] = d
			arr[ 4 | -2 ] = e
			arr[ 5 | -1 ] = f
			[status = 33]
			---
			f[status = 0]
			ERROR: __at: The index 6 was beyond the range of:
			str = abcdef
			str[ 0 | -6 ] = a
			str[ 1 | -5 ] = b
			str[ 2 | -4 ] = c
			str[ 3 | -3 ] = d
			str[ 4 | -2 ] = e
			str[ 5 | -1 ] = f
			[status = 33]
			ERROR: __at: The index 7 was beyond the range of:
			str = abcdef
			str[ 0 | -6 ] = a
			str[ 1 | -5 ] = b
			str[ 2 | -4 ] = c
			str[ 3 | -3 ] = d
			str[ 4 | -2 ] = e
			str[ 5 | -1 ] = f
			[status = 33]
			b[status = 0]
			a[status = 0]
			ERROR: __at: The index -7 was beyond the range of:
			str = abcdef
			str[ 0 | -6 ] = a
			str[ 1 | -5 ] = b
			str[ 2 | -4 ] = c
			str[ 3 | -3 ] = d
			str[ 4 | -2 ] = e
			str[ 5 | -1 ] = f
			[status = 33]
		EOF
	)"
fi

if __begin_test_block --name='__slice'; then
	function tests() (
		set +e
		local arr=(a b c d e f) str='abcdef' array_target=() str_target

		__slice --source={arr} 0     # abcdef
		__slice --source={arr} 1     # bcdef
		__slice --source={arr} -1    # ff
		__slice --source={arr} -- -2 # ef
		__print_line
		__slice --source={arr} 0 2 -- -2 # failure
		__print_lines "[status = $?]"
		__slice --source={arr} --target={array_target} 0 2 -- -2 # ab ef
		__dump array_target

		__print_lines '---'

		__slice --source={str} 0     # abcdef
		__slice --source={str} 1     # bcdef
		__slice --source={str} -1    # f
		__slice --source={str} -- -2 # ef
		__print_line
		__slice --source={str} 0 2 -- -2 # failure
		__print_lines "[status = $?]"
		__slice --source={str} --target={str_target} 0 2 -- -2 # failure
		__print_lines "[status = $?]"

		__print_lines '---'

		__slice --source={arr} 5
		__print_lines "[status = $?]"
		__slice --source={arr} 6
		__print_lines "[status = $?]"
		__slice --source={arr} 7
		__print_lines "[status = $?]"
		__slice --source={arr} -5
		__print_lines "[status = $?]"
		__slice --source={arr} -6
		__print_lines "[status = $?]"
		__slice --source={arr} -7
		__print_lines "[status = $?]"

		__print_lines '---'

		__slice --source={str} 5
		__print_lines "[status = $?]"
		__slice --source={str} 6
		__print_lines "[status = $?]"
		__slice --source={str} 7
		__print_lines "[status = $?]"
		__slice --source={str} -5
		__print_lines "[status = $?]"
		__slice --source={str} -6
		__print_lines "[status = $?]"
		__slice --source={str} -7
		__print_lines "[status = $?]"

	)
	results="$(tests 2>&1 | __ansi_trim_special_from_stdin)"
	__end_test_block {results} "$(
		cat <<-EOF
			ERROR: __to: If the source [SLICE__results] is an array, then the target [STDOUT] must be as well:
			SLICE__results[0] = a
			SLICE__results[1] = b
			SLICE__results[2] = c
			SLICE__results[3] = d
			SLICE__results[4] = e
			SLICE__results[5] = f
			ERROR: __to: If the source [SLICE__results] is an array, then the target [STDOUT] must be as well:
			SLICE__results[0] = b
			SLICE__results[1] = c
			SLICE__results[2] = d
			SLICE__results[3] = e
			SLICE__results[4] = f
			fERROR: __to: If the source [SLICE__results] is an array, then the target [STDOUT] must be as well:
			SLICE__results[0] = e
			SLICE__results[1] = f

			ERROR: __to: If the source [SLICE__results] is an array, then the target [STDOUT] must be as well:
			SLICE__results[0] = a
			SLICE__results[1] = b
			SLICE__results[2] = e
			SLICE__results[3] = f
			[status = 22]
			array_target[0] = a
			array_target[1] = b
			array_target[2] = e
			array_target[3] = f
			---
			abcdefbcdeffef
			ERROR: __to: If the source [SLICE__results] is an array, then the target [STDOUT] must be as well:
			SLICE__results[0] = ab
			SLICE__results[1] = ef
			[status = 22]
			ERROR: __to: If the source [SLICE__results] is an array, then the target [str_target] must be as well:
			SLICE__results[0] = ab
			SLICE__results[1] = ef
			str_target = $dump_var_empty_or_undefined_placeholder
			[status = 22]
			---
			f[status = 0]
			ERROR: __slice: The index 6 was beyond the range of:
			arr[ 0 | -6 ] = a
			arr[ 1 | -5 ] = b
			arr[ 2 | -4 ] = c
			arr[ 3 | -3 ] = d
			arr[ 4 | -2 ] = e
			arr[ 5 | -1 ] = f
			[status = 33]
			ERROR: __slice: The index 7 was beyond the range of:
			arr[ 0 | -6 ] = a
			arr[ 1 | -5 ] = b
			arr[ 2 | -4 ] = c
			arr[ 3 | -3 ] = d
			arr[ 4 | -2 ] = e
			arr[ 5 | -1 ] = f
			[status = 33]
			ERROR: __to: If the source [SLICE__results] is an array, then the target [STDOUT] must be as well:
			SLICE__results[0] = b
			SLICE__results[1] = c
			SLICE__results[2] = d
			SLICE__results[3] = e
			SLICE__results[4] = f
			[status = 22]
			ERROR: __to: If the source [SLICE__results] is an array, then the target [STDOUT] must be as well:
			SLICE__results[0] = a
			SLICE__results[1] = b
			SLICE__results[2] = c
			SLICE__results[3] = d
			SLICE__results[4] = e
			SLICE__results[5] = f
			[status = 22]
			ERROR: __slice: The index -7 was beyond the range of:
			arr[ 0 | -6 ] = a
			arr[ 1 | -5 ] = b
			arr[ 2 | -4 ] = c
			arr[ 3 | -3 ] = d
			arr[ 4 | -2 ] = e
			arr[ 5 | -1 ] = f
			[status = 33]
			---
			f[status = 0]
			ERROR: __slice: The index 6 was beyond the range of:
			str = abcdef
			str[ 0 | -6 ] = a
			str[ 1 | -5 ] = b
			str[ 2 | -4 ] = c
			str[ 3 | -3 ] = d
			str[ 4 | -2 ] = e
			str[ 5 | -1 ] = f
			[status = 33]
			ERROR: __slice: The index 7 was beyond the range of:
			str = abcdef
			str[ 0 | -6 ] = a
			str[ 1 | -5 ] = b
			str[ 2 | -4 ] = c
			str[ 3 | -3 ] = d
			str[ 4 | -2 ] = e
			str[ 5 | -1 ] = f
			[status = 33]
			bcdef[status = 0]
			abcdef[status = 0]
			ERROR: __slice: The index -7 was beyond the range of:
			str = abcdef
			str[ 0 | -6 ] = a
			str[ 1 | -5 ] = b
			str[ 2 | -4 ] = c
			str[ 3 | -3 ] = d
			str[ 4 | -2 ] = e
			str[ 5 | -1 ] = f
			[status = 33]
		EOF
	)"
fi

# =====================================
# Conclusion

if [[ $COUNT_OK -ne $COUNT_TESTS ]]; then
	__return 2 # final test of ERR
fi

# proceed to EXIT
