#!/usr/bin/env bash

# NOTE THAT FOR HISTORICAL VIDEOS YOUTUBE REDUCES THE QUALITY
# https://www.reddit.com/r/DataHoarder/comments/ize8xs/is_youtube_reducing_the_quality_of_old_videos/
# I have many archived channels which started at say 1GB for 1 hour in 2017, but now are 200MB for 1 hour, the same codec, but lower resolution.

# FOR THUMBNAILS
# AVIF is successor to WebP and the closed-source HEIF, however lacks wide support.
# WebP is successor to the below, and offers wide support.
#   https://en.wikipedia.org/wiki/WebP
# JPEG patent expired in 2006
# JPEG-2000 is free to use
# PNG is an open-standard

# FOR CONTAINER
# https://en.wikipedia.org/wiki/Comparison_of_video_container_formats
# MKV is living, open-source and royalty free.
# WebM is VP9+Verbos only, it is royalty free, subset of MKV, wider support for ios, mac, and web browsers
# MP4 is royalty free with expired patents, supported by absolutely everything, but less featured than MKV and a bit outdated.
#   https://en.wikipedia.org/wiki/ISO/IEC_base_media_file_format

# FOR FORMAT
# AV1 is royalty free and successor to VP9 and HEVC/H265, but no widespread hardware support
# VP9 is royalty free and successor to VP8 and H264, with moderate hardware support
# MP4/M4A is an affordable format which patents are still valid until 2023, with ubiquitous hardware support
#    https://meta.wikimedia.org/wiki/Have_the_patents_for_MPEG-4_Visual_expired_yet%3F
#    https://video.stackexchange.com/a/14699
#
# AV1 playlist:
# https://www.youtube.com/playlist?list=PLyqf6gJt7KuHBmeVzZteZUlNUQAVLwrZS
#
# AV1 is not viable without widespread hardware support:
# https://en.wikipedia.org/wiki/AV1#Hardware
# Running `ytd-helper --av1 BCmB-otRDeo` which is a 1 minute video, takes DAYS on a 2017 MacBook Pro.
# Use `ytd-helper --vp9` instead until AV1 has widespread hardware support sometime in 2023-2025.

# youtube-dl --help
#  --no-overwrites                  Do not overwrite files
#  --continue                       Force resume of partially downloaded files. By default, youtube-dl will resume downloads if possible.
#  --all-formats                    Download all available video formats
#  --all-subs                       Download all the available subtitles of the video
#  --geo-bypass                     Bypass geographic restriction via faking X-Forwarded-For HTTP header
#  --write-all-thumbnails           Write all thumbnail image formats to disk
#  --write-annotations              Write video annotations to a .annotations.xml file
#  --write-auto-sub                 Write automatically generated subtitle file (YouTube only)
#  --write-description              Write video description to a .description file
#  --write-info-json                Write video metadata to a .info.json file
#  --write-sub                      Write subtitle file

function ytd_helper() (
	source "$DOROTHY/sources/bash.bash"
	local all_tools=(yt-dlp youtube-dl)

	# =====================================
	# Arguments

	function help {
		cat <<-EOF >&2
			ABOUT:
			Helper for interacting with [youtube-dl] and its clones. Wraps with custom flags for common tasks.

			USAGE:
			ytd-helper [...options] -- ...<url> [... tool options]

			OPTIONS:
			<url>
			    The URL to download the video from.

			--tool=<tool:$(__join --source={all_tools} --delimiter='|')|?>
			    The tool to use. Use [?] to prompt. Default is the first available tool.

			-- [... tool options]
			    Forward to the invoked <tool>. Refer to [youtube-dl --help].

			--best
			    Download the best video+audio combination.

			--embed
			    Embed as much as possible into the video+audio combination.

			--month
			    Restrict downloads to the past month.

			--archive
			    Download as much as possible, but do not use embed, as not all formats support embedding.

			--audio
			    Download only the best audio.

			--audio+video
			    Download the video+audio combination as usual, but also download the best audio.

			--mp4
			    Download the best video+audio combination, preferring MP4 for video and M4A for audio.

			--free
			    Download the best video+audio combination of royalty free codecs.

			--vp9
			    Download the best video+audio combination of VP9 for video, Opus for audio, and WebM for container.

			--av1
			    Download the best video+audio combination of AV1 for video, Opus for audio, and MKV for container.

			--channel
			    Download with each channel in its own folder.

			--playlist
			    Download with each playlist in its own folder, and each video in its own folder.
		EOF
		if [[ $# -ne 0 ]]; then
			__print_error "$@"
		fi
		return 22 # EINVAL 22 Invalid argument
	}

	# =====================================
	# Action

	# arguments
	local item option_args=(--geo-bypass --no-playlist) option_tool='' option_redo='' option_overwrite='' option_playlist_or_channel=''
	while [[ $# -ne 0 ]]; do
		item="$1"
		shift
		case "$item" in
		'--help' | '-h') help ;;
		'--tool='*) option_tool="${item#*=}" ;;
		'--overwrite') option_overwrite='yes' ;;
		'--redo') option_redo='.' ;;
		'--redo='*) option_redo="${item#*=}" ;;
		'--youtube-video-id='*) option_args+=("https://youtu.be/${item#*=}") ;;
		'--youtube-playlist-id='*)
			option_playlist_or_channel='yes'
			option_args+=("https://www.youtube.com/playlist?list=${item#*=}")
			;;
		'--embed')
			option_args+=(
				--sub-langs 'en,id'
				--embed-subs
				--embed-thumbnail
				--embed-metadata
				--embed-chapters
				--embed-info-json # <-- only works on mkv, which this does not enforce

				# Remux the video into another container if necessary (currently supported: avi, flv, gif, mkv, mov, mp4, webm, aac, aiff, alac, flac, m4a, mka, mp3, ogg, opus, vorbis, wav). If the target container does not support the video/audio codec, remuxing will fail. You can specify multiple rules; e.g. "aac>m4a/mov>mp4/mkv" will remux aac to m4a, mov to mp4 and anything else to mkv
				# --remux-video mkv

				# Re-encode the video into another format if necessary. The syntax and supported formats are the same as --remux-video
				# --recode-video mkv

				# Containers that may be used when merging formats, separated by "/", e.g. "mp4/mkv". Ignored if no merge is required. (currently supported: avi, flv, mkv, mov, mp4, webm)
				# --merge-output-format mkv
			)
			# --xattrs not supported on macos
			;;
		'--month')
			option_args+=(
				--no-overwrites
				--dateafter "$(date-helper --ytd --month-ago)"
			)
			;;
		'--archive')
			option_args+=(
				--all-formats
				--all-subs
				--continue
				--no-overwrites
				--write-all-thumbnails
				--write-annotations
				--write-auto-sub
				--write-auto-subs
				--write-description
				--write-info-json
				--write-subs
			)
			;;
		'--audio')
			option_args+=(
				--extract-audio
				--format 'bestaudio[ext=m4a]'
			)
			;;
		'--audio+video')
			ytd_helper --audio "${option_args[@]}" "$@"
			ytd_helper "${option_args[@]}" "$@"
			return 0
			;;
		'--best')
			# just using 'best' can download a 360p video
			# this combination will always download the best resolution and codec
			# consider bv*+ba/bv+na/b
			option_args+=(
				--format 'bestvideo+bestaudio/best'
			)
			;;
		'--mkv')
			option_args+=(
				#--recode-video mkv <-- this will always re-encode
				--remux-video mkv # <-- this will remux, but will fail if there is already a mp4 downloaded that has embedded data inside it, hence need for [--force-overwrites]
				--merge-output-format mkv
				--format 'bestvideo+bestaudio/best' # [ext=mkv] is not supported, silently ignored
			)
			;;
		'--mp4')
			option_args+=(
				--recode-video mp4
				--merge-output-format mp4
				--format 'bestvideo[ext=mp4]+bestaudio[ext=m4a]/best[ext=mp4]/best'
			)
			;;
		'--free')
			# `--prefer-free-formats` only prefers, it doesn't guarantee
			option_args+=(
				--format '(bestvideo[vcodec^=av01]/bestvideo[vcodec^=vp9])+bestaudio[acodec=opus]'
			)
			;;
		'--vp9')
			option_args+=(
				--recode-video webm
				--merge-output-format webm
				--format '(bestvideo[vcodec^=vp9]/bestvideo)+bestaudio[acodec=opus]'
				--postprocessor-args '-c:a libopus -c:v vp9 -strict experimental'
			)
			;;
		'--av1')
			option_args+=(
				--recode-video mkv
				--merge-output-format mkv
				--format '(bestvideo[vcodec^=av01]/bestvideo)+bestaudio[acodec=opus]'
				--postprocessor-args '-c:a libopus -c:v av1 -strict experimental'
			)
			;;
		'--channel' | '--playlist') option_playlist_or_channel='yes' ;;
		'--safari') option_args+=(--cookies-from-browser safari) ;;
		'--no-sponsors') option_args+=(--sponsorblock-remove default) ;;
		'--slim') option_args+=(--sponsorblock-remove all) ;;
		'--')
			option_args+=("$@")
			shift $#
			break
			;;
		'--'*) help "An unrecognised flag was provided: $item" ;;
		*) help "An unrecognised argument was provided: $item" ;;
		esac
	done

	# playlist or channel
	if [[ $option_playlist_or_channel == 'yes' ]]; then
		option_args+=(
			--playlist-reverse # when you are updating downloads from a playlist, you want to start with most recent first
			--ignore-errors
			--output '%(playlist_uploader)s [%(playlist_uploader_id)s]/%(playlist_title)s [%(playlist_id)s]/%(playlist_index)s - %(title)s [%(id)s].%(ext)s'
		)
	fi
	if [[ $option_overwrite == 'yes' ]]; then
		option_args+=(--force-overwrites)
	fi

	# ensure tool
	__tool --tool={option_tool} --tools={all_tools} --help={help} || return

	# =====================================
	# Action

	# if redo, re-add all local files
	if [[ -n $option_redo ]]; then
		local dirpath filepath filename video_id queue_dirpath='' queue=() removals=()
		function __process_queue {
			(
				__print_style --h1="$queue_dirpath" || return
				cd "$queue_dirpath" || return
				eval-helper --wrap --verbose -- "$option_tool" "${option_args[@]}" "${queue[@]}" || return
				__print_style --g1="$queue_dirpath" || return
			)
			queue=()
			if [[ ${#removals[@]} -ne 0 ]]; then
				fs-rm --no-confirm -- "${removals[@]}" || return
				removals=()
			fi
		}
		# for all nested files use: /**/*\]
		# local filepaths=("$option_redo"/*\].{mp4,mkv,webm,avi,flv,wmv,mov,mpg,mpeg,m4v,3gp,3g2,webp})
		# local filepaths=("$option_redo"/*\].webp)
		local filepaths=("$option_redo"/*\].{mp4,mkv,webm,avi,flv,wmv,mov,mpg,mpeg,m4v,3gp,3g2,webp})
		for filepath in "${filepaths[@]}"; do
			dirpath="$(fs-path --parents --absolute -- "$filepath")" || return
			if [[ -n $queue_dirpath && $dirpath != "$queue_dirpath" ]]; then
				__process_queue || return
			fi
			filename="$(fs-path --no-parents -- "$filepath")" || return
			# extract youtube video id
			video_id=''
			if [[ $filename =~ \[[^\]]+\] ]]; then
				__replace --source={filename} --target={video_id} --keep-after-last='[' --keep-before-first=']' || return
			fi
			if [[ -n $video_id ]]; then
				__print_style --code="$filepath" --bold=' => ' --code="$video_id" || return
				queue+=("https://youtu.be/$video_id")
				queue_dirpath="$dirpath"
			fi
		done
		if [[ ${#queue[@]} -ne 0 ]]; then
			__process_queue || return
		fi
	else
		eval-helper --wrap --verbose -- "$option_tool" "${option_args[@]}" || return
	fi
)

# fire if invoked standalone
if [[ $0 == "${BASH_SOURCE[0]}" ]]; then
	ytd_helper "$@"
fi
